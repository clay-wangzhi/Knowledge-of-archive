<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://clay-wangzhi.com/</id>
  <title>IT外卖小哥</title>
  <subtitle>当你发现自己的才华撑不起野心时，就请安静下来学习吧！</subtitle>
  <author>
    <name>Clay</name>
  </author>
  <updated>2021-05-11T09:25:42.224Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="https://clay-wangzhi.com/atom.xml"/>
  <link rel="alternate" href="https://clay-wangzhi.com/"/>
  <rights>Copyright by Clay</rights>
  <category term="自动化工具"/>
  <category term="常见服务的搭建"/>
  <category term="Python"/>
  <category term="Linux"/>
  <category term="MySQL"/>
  <category term="Redis"/>
  <category term="监控"/>
  <category term="web中间件"/>
  <contributor>
    <name>Clay</name>
  </contributor>
  <contributor>
    <name>LinuxStory</name>
  </contributor>
  <contributor>
    <name>Google</name>
  </contributor>
  <entry>
    <title type="html">Summary</title>
    <id>https://clay-wangzhi.com/SUMMARY/</id>
    <link href="https://clay-wangzhi.com/SUMMARY/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="summary"> Summary</h1>
<ul>
<li>
<p><a href="./">Introduction</a></p>
</li>
<li>
<p>[python subprocess模块的使用](3 python/python subprocess模块的使用.md)</p>
</li>
</ul>
<h2 id="_4-golang"> 4 Golang</h2>
<ul>
<li>
<p>[4.1 程序结构](4 golang/4.1 程序结构.md)</p>
</li>
<li>
<p>4.2 数据类型</p>
<ul>
<li>4.2.1 基础数据类型</li>
<li>4.2.2 复合数据类型</li>
</ul>
</li>
<li>
<p>4.3 函数</p>
</li>
<li>
<p>[12.1 keepalived和heartbeat对比](12 常见集群的搭建/12.1 keepalived和heartbeat对比.md)</p>
</li>
</ul>
<h2 id="_21-vim"> 21 vim</h2>
<ul>
<li>[vim设置参数以方便YAML语句录入](21 vim/vim设置参数以方便YAML语句录入.md)</li>
<li>[vim常用命令](21 vim/vim常用命令.md)</li>
</ul>
<h2 id="_22-网络"> 22 网络</h2>
<ul>
<li>[TCP协议三次握手四次挥手](22 网络/TCP协议三次握手四次挥手.md)</li>
<li>[ip地址](22 网络/ip地址.md)</li>
</ul>
<h2 id="_23-未分类"> 23 未分类</h2>
<ul>
<li>
<p>[调优](23 未分类/调优.md)</p>
</li>
<li>
<p>[curl方式执行shell脚本时如何传参](23 未分类/curl方式执行shell脚本时如何传参.md)</p>
</li>
<li>
<p>[PrometheusAlert](23 未分类/promethues-alerts.md)</p>
</li>
<li>
<p>[grafana问题](27 监控体系/grafana问题.md)</p>
</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">3 Ansible Ad-hoc命令集</title>
    <id>https://clay-wangzhi.com/automate/ansible/ad-hoc/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/ad-hoc/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_3-ansible-ad-hoc命令集"> 3 Ansible Ad-hoc命令集</h1>
<h2 id="_1-ad-hoc简介"> 1 Ad-hoc简介</h2>
<p>Ad-Hoc（点对点模式）是指ansible下临时执行的一条命令，并且不需要保存的命令，对于复杂的命令会使用playbook。Ad-hoc的执行依赖于模块，ansible官方提供了大量的模块。 如：command、raw、shell、file、cron等，具体可以通过ansible-doc -l 进行查看 。可以使用ansible-doc -s module来查看某个模块的参数，也可以使用ansible-doc module来查看该模块更详细的信息。</p>
<h3 id="_1-1-命令说明"> 1.1 命令说明</h3>
<p>一个ad-hoc命令的执行，需要按以下格式进行执行：</p>
<div><pre><code>ansible 主机或组 -m 模块名 -a <span>'模块参数'</span>  ansible参数
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>主机和组，是在/etc/ansible/hosts 里进行指定的部分，当然动态Inventory 使用的是脚本从外部应用里获取的主机；</li>
<li>模块名，可以通过ansible-doc -l 查看目前安装的模块，默认不指定时，使用的是command模块，具体可以查看/etc/ansible/ansible.cfg 的“#module_name = command ” 部分，默认模块可以在该配置文件中进行修改；</li>
<li>模块参数，可以通过 “ansible-doc -s 模块名” 查看具体的用法及后面的参数；</li>
<li>ansible参数，可以通过ansible命令的帮助信息里查看到，这里有很多参数可以供选择，如是否需要输入密码、是否sudo等。</li>
</ul>
<h3 id="_1-2-用户说明"> 1.2  用户说明</h3>
<p>ansible在执行ad-hoc的时候，需要使用远程管理机上的一个用户身份，默认这个用户是root，而在实际生产环境中，不建议直接使用root，而推荐使用一个普通用户，需要配置该普通用户可通过sudo提权。</p>
<p>下面是一个配置示例：</p>
<ol>
<li>在被管理机上创建一个普通用户ansible，并配置sudo提权：</li>
</ol>
<div><pre><code># 创建ansible用户
useradd ansible

# 设置ansible用户可免密提权
vim /etc/sudoers.d/ansible
ansible    ALL=(ALL)       NOPASSWD:ALL

chmod 400 /etc/sudoers.d/ansible

mkdir /home/ansible/.ssh
chown ansible.ansible /home/ansible/.ssh
chmod 700 /home/ansible/.ssh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ol>
<li>在管理端修改ansible.cfg配置文件如下：</li>
</ol>
<div><pre><code>[default]
remote_user = ansible
ask_pass = False

[privilege_escalation]
become=True
become_method=sudo
become_user=root
become_ask_pass=False
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol>
<li>将管理端用户的<code>id_rsa.pub</code>复制到被管理端的<code>/home/ansible/.ssh//home/ansible/.ssh/authorized_keys</code>文件中，并设置该文件的权限为400</li>
</ol>
<div><pre><code># 管理端执行：
ssh-copy-id -i .ssh/id_rsa.pub ansible@db1.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>需要说明的是，通过上面的操作，需要为ansible用户先创建密码，在实际生产当中，不建议为该用户设置密码。可在安装系统时，提前将管理端公钥直接写入到被管理节点的ansible用户下</p>
</blockquote>
<h3 id="_1-3-命令执行模块"> 1.3 命令执行模块</h3>
<p>命令执行模块包含如下 四个模块：</p>
<ul>
<li>command模块：该模块通过-a跟上要执行的命令可以直接执行，不过命令里如果有带有如下字符部分则执行不成功 “ &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;|&quot;, &quot;&amp;&quot;</li>
<li>shell 模块：用法基本和command一样，不和command相同，但是支持解析特殊shell符号</li>
<li>raw模块：执行底层shell命令。command和shell模块都是通过目标主机上的python代码启动/bin/sh来执行命令的，但目标主机上可能没有安装python，这时只能使用raw模块在远程主机上直接启动/bin/sh来执行命令，通常只有在目标主机上安装python时才使用raw模块，其它时候都不使用该模块</li>
<li>script模块：在远程主机上执行脚本文件，其原理是先将shell 复制到远程主机，再在远程主机上执行</li>
</ul>
<blockquote>
<p>raw模块和comand、shell 模块不同的是其没有chdir、creates、removes参数，chdir参数的作用就是先切到chdir指定的目录后，再执行后面的命令，这在后面很多模块里都会有该参数 。</p>
</blockquote>
<h2 id="_2-常用模块"> 2 常用模块</h2>
<p>根据官方的分类，将模块按功能分类为：云模块、命令模块、数据库模块、文件模块、资产模块、消息模块、监控模块、网络模块、通知模块、包管理模块、源码控制模块、系统模块、单元模块、web设施模块、windows模块 ，具体可以参看官方页面。</p>
<p>这里从官方分类的模块里选择最常用的一些模块进行介绍。</p>
<h3 id="_2-1-command模块"> 2.1 command模块</h3>
<p>command模块包含如下选项：</p>
<ul>
<li>creates：一个文件名，当该文件存在，则该命令不执行</li>
<li>free_form：要执行的linux指令</li>
<li>chdir：在执行指令之前，先切换到该指定的目录</li>
<li>removes：一个文件名，当该文件不存在，则该选项不执行</li>
<li>executable：切换shell来执行指令，该执行路径必须是一个绝对路径</li>
</ul>
<p>chdir示例：</p>
<div><pre><code><span># 三个命令都会返回执行成功的状态。不过实际上只有前两个文件会被创建成功。使用raw模块的执行的结果文件事实上也被正常创建了，不过不是在chdir指定的目录，而是在当前执行用户的家目录</span>
ansible <span>192.168</span>.1.1 -m <span>command</span> -a <span>'chdir=/tmp/test.txt touch test.file'</span>
ansible <span>192.168</span>.1.1 -m shell -a <span>'chdir=/tmp/test.txt touch test2.file'</span>
ansible <span>192.168</span>.1.1 -m raw -a <span>'chdir=/tmp/text.txt touch test3.file'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>creates与removes示例：</p>
<div><pre><code>ansible <span>192.168</span>.1.1 -a <span>'creates=/tmp/server.txt uptime'</span> <span>#当/tmp/server.txt文件存在时，则不执行uptime指令</span>
ansible <span>192.168</span>.1.1 -a <span>'removes=/tmp/server.txt uptime'</span> <span>#当/tmp/server.txt文件不存在时，则不执行uptime指令</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_2-2-script模块"> 2.2 script模块</h3>
<p>示例：</p>
<div><pre><code><span>#要执行的脚本文件script.sh内容如下： </span>

<span>#/bin/bash</span>
<span>ifconfig</span>
<span>df</span> -hT

<span># 执行ansible指令：</span>
ansible <span>10.212</span>.52.252 -m script -a <span>'script.sh'</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="_2-3-ping模块"> 2.3 ping模块</h3>
<p>测试主机是否是通的，用法很简单，不涉及参数：</p>
<div><pre><code> ansible <span>test</span> -m <span>ping</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="_2-4-file模块"> 2.4 file模块</h3>
<p>file模块主要用于远程主机上的文件操作，file模块包含如下选项：</p>
<ul>
<li>force：需要在两种情况下强制创建软链接，一种是源文件不存在但之后会建立的情况下；另一种是目标软链接已存在,需要先取消之前的软链，然后创建新的软链，有两个选项：yes|no</li>
<li>group：定义文件/目录的属组</li>
<li>mode：定义文件/目录的权限</li>
<li>owner：定义文件/目录的属主</li>
<li>path：必选项，定义文件/目录的路径</li>
<li>src：要被链接的源文件的路径，只应用于state=link的情况</li>
<li>dest：被链接到的路径，只应用于state=link的情况</li>
<li>state：
<ul>
<li>directory：如果目录不存在，创建目录</li>
<li>file：即使文件不存在，也不会被创建</li>
<li>link：创建软链接</li>
<li>hard：创建硬链接</li>
<li>touch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间</li>
<li>absent：删除目录、文件或者取消链接文件</li>
</ul>
</li>
</ul>
<p>使用示例：</p>
<div><pre><code>ansible <span>192.168</span>.8.120 -m <span>file</span> -a <span>'path=/tmp/test.txt state=touch owner=root group=root mode=644'</span>

ansible <span>192.168</span>.8.120 -m <span>file</span> -a <span>'src=/tmp/test.txt dest=/root/test.txt state=link'</span>

ansible <span>192.168</span>.8.120 -m <span>file</span> -a <span>'path=/tmp/test.txt state=file'</span>

ansible <span>192.168</span>.8.120 -m <span>file</span> -a <span>'path=/tmp/test state=directory owner=root group=root mode=755'</span>

ansible <span>192.168</span>.8.120 -m <span>file</span> -a <span>'path=/tmp/test2/test3/aaa/bbb state=directory owner=root group=root mode=755'</span>

ansible <span>192.168</span>.8.120 -m <span>file</span> -a <span>'path=/tmp/test2 state=absent'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="_2-5-copy模块"> 2.5 copy模块</h3>
<p>复制文件到远程主机，copy模块包含如下选项：</p>
<ul>
<li>backup：在覆盖之前将原文件备份，备份文件包含时间信息。有两个选项：yes|no</li>
<li>content：用于替代&quot;src&quot;,可以直接设定指定文件的值</li>
<li>dest：必选项。要将源文件复制到的远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录</li>
<li>force：如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes</li>
<li>others：所有的file模块里的相关文件属性选项都可以在这里使用</li>
<li>src：要复制到远程主机的文件在本地的地址，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用&quot;/&quot;来结尾，则只复制目录里的内容，如果没有使用&quot;/&quot;来结尾，则包含目录在内的整个内容全部复制，类似于rsync。</li>
</ul>
<p>示例如下：</p>
<div><pre><code>ansible 192.168.8.120 -m copy -a &#39;src=/etc/ansible/ansible.cfg dest=/usr/local/src/ owner=root group=root mode=644&#39;

ansible 192.168.8.120 -m copy -a &#39;backup=yes src=/etc/fstab dest=/usr/local/src/ansible.cfg owner=root group=root mode=644&#39;

ansible 192.168.8.120 -m copy -a &#39;content=&quot;just a test!&quot; dest=/usr/local/src/test.txt&#39;

ansible 192.168.8.120 -m copy -a &#39;src=/data dest=/usr/local/src/&#39;

ansible 192.168.8.120 -m copy -a &#39;src=/data/ dest=/usr/local/src/&#39;

ansible 192.168.8.120 -m copy -a &quot;src=/mine/sudoers dest=/etc/sudoers validate=&#39;visudo -cf %s&#39;&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="_2-6-yum模块"> 2.6 yum模块</h3>
<p>使用yum包管理器来管理软件包，其选项有：</p>
<ul>
<li><code>name</code>：要进行操作的软件包的名字，也可以传递一个url或者一个本地的rpm包的路径</li>
<li><code>state</code>：状态（present，absent，latest）</li>
</ul>
<p>示例如下：</p>
<div><pre><code>ansible test -m yum -a &#39;name=httpd state=latest&#39;
ansible test -m yum -a &#39;name=&quot;@Development tools&quot; state=present&#39;
ansible test -m yum -a &#39;name=http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm state=present&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_2-7-service模块"> 2.7 service模块</h3>
<p>用于管理服务
该模块包含如下选项：</p>
<ul>
<li>arguments：给命令行提供一些选项</li>
<li>enabled：是否开机启动 yes|no</li>
<li>name：必选项，服务名称</li>
<li>pattern：定义一个模式，如果通过status指令来查看服务的状态时，没有响应，就会通过ps指令在进程中根据该模式进行查找，如果匹配到，则认为该服务依然在运行</li>
<li>runlevel：运行级别</li>
<li>sleep：如果执行了restarted，在则stop和start之间沉睡几秒钟</li>
<li>state：对当前服务执行启动，停止、重启、重新加载等操作（started,stopped,restarted,reloaded）</li>
<li>daemon_reload：针对使用systemd的系统，重新加载systemd配置，yes/no</li>
</ul>
<p>使用示例：</p>
<div><pre><code>ansible test -m service -a &quot;name=httpd state=started enabled=yes&quot;
asnible test -m service -a &quot;name=foo pattern=/usr/bin/foo state=started&quot;
ansible test -m service -a &quot;name=network state=restarted args=eth0&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_2-8-cron模块"> 2.8 cron模块</h3>
<p>用于管理计划任务</p>
<p>包含如下选项：</p>
<ul>
<li>backup：对远程主机上的原任务计划内容修改之前做备份</li>
<li>cron_file：如果指定该选项，则用该文件替换远程主机上的cron.d目录下的用户的任务计划</li>
<li>day：日（1-31，<em>，</em>/2,……）</li>
<li>hour：小时（0-23，<em>，</em>/2，……）</li>
<li>minute：分钟（0-59，<em>，</em>/2，……）</li>
<li>month：月（1-12，<em>，</em>/2，……）</li>
<li>weekday：周（0-7，*，……）</li>
<li>job：要执行的任务，依赖于state=present</li>
<li>name：该任务的描述</li>
<li>special_time：指定什么时候执行，参数：reboot,yearly,annually,monthly,weekly,daily,hourly</li>
<li>state：确认该任务计划是创建还是删除</li>
<li>user：以哪个用户的身份执行</li>
</ul>
<p>示例：</p>
<div><pre><code>ansible <span>test</span> -m <span>cron</span> -a <span>'name="a job for reboot" special_time=reboot job="/some/job.sh"'</span>
ansible <span>test</span> -m <span>cron</span> -a <span>'name="yum autoupdate" weekday="2" minute=0 hour=12 user="root"'</span>
ansible <span>test</span> -m <span>cron</span>  -a <span>'backup="True" name="test" minute="0" hour="5,2" job="ls -alh > /dev/null"'</span>
ansilbe <span>test</span> -m <span>cron</span> -a <span>'cron_file=ansible_yum-autoupdate state=absent'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_2-9-user模块与group模块"> 2.9 user模块与group模块</h3>
<p>user模块是请求的是useradd, userdel, usermod三个指令，goup模块请求的是groupadd, groupdel, groupmod 三个指令。</p>
<h4 id="_2-9-1-user模块"> 2.9.1 user模块</h4>
<ul>
<li>home：指定用户的家目录，需要与createhome配合使用</li>
<li>groups：指定用户的属组</li>
<li>uid：指定用的uid</li>
<li>password：指定用户的密码</li>
<li>name：指定用户名</li>
<li>createhome：是否创建家目录 yes|no</li>
<li>system：是否为系统用户</li>
<li>remove：当state=absent时，remove=yes则表示连同家目录一起删除，等价于userdel -r</li>
<li>state：是创建还是删除</li>
<li>shell：指定用户的shell环境</li>
</ul>
<p>使用示例：</p>
<div><pre><code>user: <span>name</span><span>=</span>johnd <span>comment</span><span>=</span><span>"John Doe"</span> <span>uid</span><span>=</span><span>1040</span> <span>group</span><span>=</span>admin
user: <span>name</span><span>=</span>james <span>shell</span><span>=</span>/bin/bash <span>groups</span><span>=</span>admins,developers <span>append</span><span>=</span>yes user: <span>name</span><span>=</span>johnd <span>state</span><span>=</span>absent <span>remove</span><span>=</span>yes
user: <span>name</span><span>=</span>james18 <span>shell</span><span>=</span>/bin/zsh <span>groups</span><span>=</span>developers <span>expires</span><span>=</span><span>1422403387</span>
<span>#生成密钥时，只会生成公钥文件和私钥文件，和直接使用ssh-keygen指令效果相同，不会生成authorized_keys文件</span>
user: <span>name</span><span>=</span>test <span>generate_ssh_key</span><span>=</span>yes <span>ssh_key_bits</span><span>=</span><span>2048</span> <span>ssh_key_file</span><span>=</span>.ssh/id_rsa  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>需要说明的是，在指定password参数时，不能使用明文密码，因为后面这一串密码会被直接传送到被管理主机的/etc/shadow文件中，所以需要先将密码字符串进行加密处理。然后将得到的字符串放到password中即可。</p>
<div><pre><code>echo &quot;123456&quot; | openssl passwd -1 -salt $(&lt; /dev/urandom tr -dc &#39;[:alnum:]&#39; | head -c 32) -stdin
$1$4P4PlFuE$ur9ObJiT5iHNrb9QnjaIB0

#使用上面的密码创建用户
ansible all -m user -a &#39;name=foo password=&quot;$1$4P4PlFuE$ur9ObJiT5iHNrb9QnjaIB0&quot;&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>不同的发行版默认使用的加密方式可能会有区别，具体可以查看/etc/login.defs文件确认，centos 6.5版本使用的是SHA512加密算法。</p>
</blockquote>
<h4 id="_2-9-2-group示例"> 2.9.2 group示例</h4>
<div><pre><code>group: name=somegroup state=present
</code></pre>
<div><span>1</span><br></div></div><h3 id="_2-10-synchronize模块"> 2.10 synchronize模块</h3>
<p>使用rsync同步文件，其参数如下：</p>
<ul>
<li>archive: 归档，相当于同时开启recursive(递归)、links、perms、times、owner、group、-D选项都为yes ，默认该项为开启</li>
<li>checksum: 跳过检测sum值，默认关闭</li>
<li>compress:是否开启压缩</li>
<li>copy_links：复制链接文件，默认为no ，注意后面还有一个links参数</li>
<li>delete: 删除不存在的文件，默认no</li>
<li>dest：目录路径</li>
<li>dest_port：默认目录主机上的端口 ，默认是22，走的ssh协议</li>
<li>dirs：传输目录不进行递归，默认为no，即进行目录递归</li>
<li>rsync_opts：rsync参数部分</li>
<li>set_remote_user：主要用于/etc/ansible/hosts中定义或默认使用的用户与rsync使用的用户不同的情况</li>
<li>mode: push或pull 模块，push模的话，一般用于从本机向远程主机上传文件，pull 模式用于从远程主机上取文件</li>
</ul>
<p>使用示例：</p>
<div><pre><code>src=some/relative/path dest=/some/absolute/path rsync_path=&quot;sudo rsync&quot;
src=some/relative/path dest=/some/absolute/path archive=no links=yes
src=some/relative/path dest=/some/absolute/path checksum=yes times=no
src=/tmp/helloworld dest=/var/www/helloword rsync_opts=--no-motd,--exclude=.git mode=pull
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_2-11-filesystem模块"> 2.11 filesystem模块</h3>
<p>在块设备上创建文件系统
常用选项：</p>
<ul>
<li>dev：目标块设备</li>
<li>force：在一个已有文件系统 的设备上强制创建</li>
<li>fstype：文件系统的类型</li>
<li>opts：传递给mkfs命令的选项</li>
</ul>
<p>示例：</p>
<div><pre><code>ansible <span>test</span> -m filesystem -a <span>'fstype=ext2 dev=/dev/sdb1 force=yes'</span>
ansible <span>test</span> -m filesystem -a <span>'fstype=ext4 dev=/dev/sdb1 opts="-cc"'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_2-12-mount模块"> 2.12 mount模块</h3>
<p>配置挂载点
选项：</p>
<ul>
<li>dump</li>
<li>fstype：必选项，挂载文件的类型</li>
<li>name：必选项，挂载点</li>
<li>opts：传递给mount命令的参数</li>
<li>src：必选项，要挂载的文件</li>
<li>state：必选项
<ul>
<li>present：只处理fstab中的配置</li>
<li>absent：删除挂载点</li>
<li>mounted：自动创建挂载点并挂载之</li>
<li>umounted：卸载</li>
</ul>
</li>
</ul>
<p>示例：</p>
<div><pre><code>name=/mnt/dvd src=/dev/sr0 fstype=iso9660 opts=ro state=present
name=/srv/disk src=&#39;LABEL=SOME_LABEL&#39; state=present
name=/home src=&#39;UUID=b3e48f45-f933-4c8e-a700-22a159ec9077&#39; opts=noatime state=present

ansible test -a &#39;dd if=/dev/zero of=/disk.img bs=4k count=1024&#39;
ansible test -a &#39;losetup /dev/loop0 /disk.img&#39;
ansible test -m filesystem &#39;fstype=ext4 force=yes opts=-F dev=/dev/loop0&#39;
ansible test -m mount &#39;name=/mnt src=/dev/loop0 fstype=ext4 state=mounted opts=rw&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="_2-13-get-url-模块"> 2.13 get_url 模块</h3>
<p>该模块主要用于从http、ftp、https服务器上下载文件（类似于wget），主要有如下选项：</p>
<ul>
<li>sha256sum：下载完成后进行sha256 check；</li>
<li>timeout：下载超时时间，默认10s</li>
<li>url：下载的URL</li>
<li>url_password、url_username：主要用于需要用户名密码进行验证的情况</li>
<li>use_proxy：是事使用代理，代理需事先在环境变更中定义</li>
</ul>
<p>示例：</p>
<div><pre><code>get_url: url=http://example.com/path/file.conf dest=/etc/foo.conf mode=0440
get_url: url=http://example.com/path/file.conf dest=/etc/foo.conf sha256sum=b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_2-14-unarchive模块"> 2.14 unarchive模块</h3>
<p>用于解压文件，模块包含如下选项：</p>
<ul>
<li>copy：在解压文件之前，是否先将文件复制到远程主机，默认为yes。若为no，则要求目标主机上压缩包必须存在。</li>
<li>creates：指定一个文件名，当该文件存在时，则解压指令不执行</li>
<li>dest：远程主机上的一个路径，即文件解压的路径</li>
<li>group：解压后的目录或文件的属组</li>
<li>list_files：如果为yes，则会列出压缩包里的文件，默认为no，2.0版本新增的选项</li>
<li>mode：解决后文件的权限</li>
<li>src：如果copy为yes，则需要指定压缩文件的源路径</li>
<li>owner：解压后文件或目录的属主</li>
</ul>
<p>示例如下：</p>
<div><pre><code>- unarchive: src=foo.tgz dest=/var/lib/foo
- unarchive: src=/tmp/foo.zip dest=/usr/local/bin copy=no
- unarchive: src=https://example.com/example.zip dest=/usr/local/bin copy=no
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_2-15-debug"> 2.15 debug</h3>
<p>用于输出调试一些数据，模块包含如下选项：</p>
<ul>
<li>msg：可以输出字符串，可以输出变量的值，变量调用需加&quot;{{}}&quot;</li>
<li>var：只能输出变量的值，变量调用无需加任何东西，只需数据变量名称</li>
</ul>
<p>示例如下：</p>
<div><pre><code>$ ansible localhost -e <span>'str=world'</span> -m debug -a <span>'msg="hello {{str}}"'</span>
localhost <span>|</span> SUCCESS <span>=</span><span>></span> <span>{</span>
    <span>"msg"</span><span>:</span> <span>"hello world"</span>
<span>}</span>

$ ansible localhost -e <span>'str="hello world"'</span> -m debug -a <span>'var=str'</span>
localhost <span>|</span> SUCCESS <span>=</span><span>></span> <span>{</span>
    <span>"str"</span><span>:</span> <span>"hello world"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>参考链接：</p>
<p>https://www.cnblogs.com/breezey/p/8810414.html</p>
<p>https://www.cnblogs.com/breezey/p/8811187.html</p>
<p>https://blog.51cto.com/cloumn/blog/1544</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">4.4 Playbook高级用法</title>
    <id>https://clay-wangzhi.com/automate/ansible/advanced-playbook/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/advanced-playbook/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-4-playbook高级用法"> 4.4 Playbook高级用法</h1>
<h2 id="_1-本地执行"> 1 本地执行</h2>
<p>默认情况下，Ansible使用ssh去连接远程主机，但实际上它提供了多种插件来丰富连接方式：smart、ssh、paramiko、local、docker、winrm，默认为smart。</p>
<p>smart表示智能选择ssh和paramiko(paramiko是Python的一个ssh协议模块)，当Ansible端安装的ssh支持ControlPersist(即持久连接)时自动使用ssh，否则使用paramiko。local和docker是非基于ssh连接的方式，winrm是连接Windows的插件。</p>
<p>可以在命令行选项中使用-c或--connection选项来指定连接方式：</p>
<p>如果希望在控制主机本地运行一个特定的任务，可以使用local_action语句。</p>
<p>假设我们需要配置的远程主机刚刚启动，如果我们直接运行playbook，可能会因为sshd服务尚未开始监听而导致失败，我们可以在控制主机上使用如下示例来等待被控端sshd端口监听：</p>
<div><pre><code>- name: wait for ssh server to be running
  wait_for
      port: 22 
      host: &quot;{{ inventory_hostname }}&quot; 
      search_regex: OpenSSH
  connection: local
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>此外，inventory中也可以通过连接的行为变量ansible_connection指定连接类型：</p>
<div><pre><code>192.168.100.101 ansible_connection=&quot;smart&quot;
</code></pre>
<div><span>1</span><br></div></div><h2 id="_2-任务委托"> 2 任务委托</h2>
<p>在有些时候，我们希望运行与选定的主机或主机组相关联的task，但是这个task又不需要在选定的主机或主机组上执行，而需要在另一台服务器上执行。</p>
<p>这种特性适用于以下场景：</p>
<ul>
<li>在告警系统中启用基于主机的告警</li>
<li>向负载均衡器中添加或移除一台主机</li>
<li>在dns上添加或修改针对某个主机的解析</li>
<li>在存储节点上创建一个存储以用于主机挂载</li>
<li>使用一个外部程序来检测主机上的服务是否正常</li>
</ul>
<p>可以使用delegate_to语句来在另一台主机上运行task：</p>
<div><pre><code>- name: enable alerts for web servers
  hosts: webservers
  tasks:
    - name: enable alerts
      nagios: action=enable_alerts service=web host=&quot;{{ inventory_hostname }}&quot;
      delegate_to: nagios.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p>如果delegate_to: 127.0.0.1的时候，等价于connection: local</p>
<p>显然connection: local和delegate_to: localhost在功能上是等价的。当然，connection可以定义在play级别或task级别上，而delegate_to只能定义在task级别上。</p>
</blockquote>
<h2 id="_3-任务暂停"> 3 任务暂停</h2>
<p>有些情况下，一些任务的运行需要等待一些状态的恢复，比如某一台主机或者应用刚刚重启，我们需要需要等待它上面的某个端口开启，此时就需要将正在运行的任务暂停，直到其状态满足要求。</p>
<p>Ansible提供了wait_for模块以实现任务暂停的需求</p>
<p>wait_for模块常用参数：</p>
<ul>
<li>connect_timeout：在下一个任务执行之前等待连接的超时时间</li>
<li>delay：等待一个端口或者文件或者连接到指定的状态时，默认超时时间为300秒，在这等待的300s的时间里，wait_for模块会一直轮询指定的对象是否到达指定的状态，delay即为多长时间轮询一次状态。</li>
<li>host：wait_for模块等待的主机的地址，默认为127.0.0.1</li>
<li>port：wait_for模块待待的主机的端口</li>
<li>path：文件路径，只有当这个文件存在时，下一任务才开始执行，即等待该文件创建完成</li>
<li>state：等待的状态，即等待的文件或端口或者连接状态达到指定的状态时，下一个任务开始执行。当等的对象为端口时，状态有started，stoped，即端口已经监听或者端口已经关闭；当等待的对象为文件时，状态有present或者started，absent，即文件已创建或者删除；当等待的对象为一个连接时，状态有drained，即连接已建立。默认为started</li>
<li>timeout：wait_for的等待的超时时间,默认为300秒</li>
</ul>
<p>示例：</p>
<div><pre><code>#等待8080端口已正常监听，才开始下一个任务，直到超时
- wait_for: 
    port: 8080 
    state: started  
    
#等待8000端口正常监听，每隔10s检查一次，直至等待超时
- wait_for: 
    port: 8000 
    delay: 10 
    
#等待8000端口直至有连接建立
- wait_for: 
    host: 0.0.0.0 
    port: 8000 
    delay: 10 
    state: drained
    
#等待8000端口有连接建立，如果连接来自10.2.1.2或者10.2.1.3，则忽略。
- wait_for: 
    host: 0.0.0.0 
    port: 8000 
    state: drained 
    exclude_hosts: 10.2.1.2,10.2.1.3 
    
#等待/tmp/foo文件已创建    
- wait_for: 
    path: /tmp/foo 

#等待/tmp/foo文件已创建，而且该文件中需要包含completed字符串    
- wait_for: 
    path: /tmp/foo 
    search_regex: completed 

#等待/var/lock/file.lock被删除    
- wait_for: 
    path: /var/lock/file.lock 
    state: absent 
    
#等待指定的进程被销毁
- wait_for: 
    path: /proc/3466/status 
    state: absent 
    
#等待openssh启动，10s检查一次
- wait_for: 
    port: 22 
    host: &quot;{{ ansible_ssh_host | default(inventory_hostname) }}&quot; search_regex: OpenSSH 
    delay: 10 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h2 id="_4-滚动执行"> 4 滚动执行</h2>
<p>默认情况下，ansible会并行的在所有选定的主机或主机组上执行每一个task，但有的时候，我们会希望能够逐台运行。最典型的例子就是对负载均衡器后面的应用服务器进行更新时。通常来讲，我们会将应用服务器逐台从负载均衡器上摘除，更新，然后再添加回去。我们可以在play中使用serial语句来告诉ansible限制并行执行play的主机数量。</p>
<p>下面是一个在amazon EC2的负载均衡器中移除主机，更新软件包，再添加回负载均衡的配置示例：</p>
<div><pre><code>- name: upgrade pkgs on servers behind load balancer
  hosts: myhosts
  serial: 1
  tasks:
    - name: get the ec2 instance id and elastic load balancer id
      ec2_facts:

    - name: take the host out of the elastic load balancer id
      local_action: ec2_elb
      args:
        instance_id: &quot;{{ ansible_ec2_instance_id }}&quot;
        state: absent

    - name: upgrade pkgs
      apt: 
          update_cache: yes 
          upgrade: yes

    - name: put the host back n the elastic load balancer
      local_action: ec2_elb
      args:
        instance_id: &quot;{{ ansible_ec2_instance_id }}&quot;
        state: present
        ec2_elbs: &quot;{{ items }}&quot;
      with_items: ec2_elbs
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>在上述示例中，serial的值为1，即表示在某一个时间段内，play只在一台主机上执行。如果为2，则同时有2台主机运行play。</p>
<p>一般来讲，当task失败时，ansible会停止执行失败的那台主机上的任务，但是继续对其他 主机执行。在负载均衡的场景中，我们会更希望ansible在所有主机执行失败之前就让play停止，否则很可能会面临所有主机都从负载均衡器上摘除并且都执行失败导致服务不可用的场景。这个时候，我们可以使用serial语句配合max_fail_percentage语句使用。<code>max_fail_percentage</code>表示当最大失败主机的比例达到多少时，ansible就让整个play失败。示例如下：</p>
<div><pre><code>- name: upgrade pkgs on fservers behind load balancer
  hosts: myhosts
  serial: 1
  max_fail_percentage: 25
  tasks:
    ......
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>假如负载均衡后面有4台主机，并且有一台主机执行失败，这时ansible还会继续运行，要让Play停止运行，则必须超过25%，所以如果想一台失败就停止执行，我们可以将max_fail_percentage的值设为24。如果我们希望只要有执行失败，就放弃执行，我们可以将max_fail_percentage的值设为0。</p>
<h2 id="_5-只执行一次"> 5 只执行一次</h2>
<p>某些时候，我们希望某个task只执行一次，即使它被绑定到了多个主机上。例如在一个负载均衡器后面有多台应用服务器，我们希望执行一个数据库迁移，只需要在一个应用服务器上执行操作即可。</p>
<p>可以使用run_once语句来处理：</p>
<div><pre><code>- name: run the database migrateions
  command: /opt/run_migrateions
  run_once: true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>还可以与local_action配合使用，如下：</p>
<div><pre><code>- name: run the task locally, only once
  command: /opt/my-custom-command
  connection: local
  run_once: true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>还可以与delegate_to配合使用，让这个只执行一次的任务在指定的机器上运行：</p>
<div><pre><code>- name: run the task locally, only once
  command: /opt/my-custom-command
  run_once: true
  delegate_to: app.a1-61-105.dev.unp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="_6-设置环境变量"> 6 设置环境变量</h2>
<p>我们在命令行下执行某些命令的时候，这些命令可能会需要依赖环境变量。比如在安装某些包的时候，可能需要通过代理才能完成完装。或者某个脚本可能需要调用某个环境变量才能完成运行。</p>
<p>ansible 支持通过<code>environment</code>关键字来定义一些环境变量。</p>
<p>在如下场景中可能需要用到环境变量：</p>
<ul>
<li>运行shell的时候，需要设置path变量</li>
<li>需要加载一些库，这些库不在系统的标准库路径当中</li>
</ul>
<p>下面是一个简单示例：</p>
<div><pre><code>---
- name: upload a remote file to aws s3
  hosts: test
  tasks:
    - name: install pip
      yum:
        name: python-pip
        state: installed
    
    - name: install the aws tools
      pip:
        name: awscli
        state: present
    
    - name upload file to s3
      shell aws s3 put-object --bucket=my-test-bucket --key={{ ansible_hostname }}/fstab --body=/etc/fstab --region=eu-west-1
      environment:
        AWS_ACCESS_KEY_ID: xxxxxx
        AWS_SECRET_ACCESS_KEY: xxxxxx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>事实上，environment也可以存储在变量当中：</p>
<div><pre><code>- hosts: all
  remote_user: root
  vars:
    proxy_env:
      http_proxy: http://proxy.example.com:8080
      https_proxy: http://proxy.bos.example.com:8080
  tasks:
    - apt: name=cobbler state=installed
      environment: proxy_env
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="_7-交互式提示"> 7 交互式提示</h2>
<p>在少数情况下，ansible任务运行的过程中需要用户输入一些数据，这些数据要么比较秘密不方便，或者数据是动态的，不同的用户有不同的需求，比如输入用户自己的账户和密码或者输入不同的版本号会触发不同的后续操作等。ansible的vars_prompt关键字就是用来处理上述这种与用户交互的情况的。</p>
<div><pre><code> - hosts: all
   remote_user: root
   vars_prompt:
      - name: share_user
        prompt: &quot;what is your network username?&quot;
        private: yes
 
      - name: share_pass
        prompt: &quot;what is your network password&quot;
        private: yes
        
    tasks:
      - debug:
          var: share_user
      - debug:
          var: share_pass
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>vars_prompt常用选项说明：</p>
<ul>
<li>private: 默认为yes，表示用户输入的值在命令行不可见</li>
<li>default：定义默认值，当用户未输入时则使用默认值</li>
<li>confirm：如果设置为yes，则会要求用户输入两次，适合输入密码的情况</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">5.1 自定义变量</title>
    <id>https://clay-wangzhi.com/automate/ansible/custom/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/custom/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_5-1-自定义变量"> 5.1 自定义变量</h1>
<p><strong>简单说明</strong></p>
<p>ansible支持变量，用于存储会在整个项目中重复使用到的一些值。以简化项目的创建与维护，降低出错的机率。</p>
<p>变量的定义：</p>
<ul>
<li>变量名应该由字母、数字下划数组成</li>
<li>变量名必须以字母开头</li>
<li>ansible内置关键字不能作为变量名</li>
</ul>
<h1 id="_1-在inventory中定义变量"> 1. 在Inventory中定义变量</h1>
<h2 id="_1-1-定义主机变量"> 1.1. 定义主机变量</h2>
<h3 id="_1-1-1-内置主机变量"> 1.1.1. 内置主机变量</h3>
<p>所谓内置变量其实就是ansible.cfg配置文件中的选项，在其前加上<code>ansible_</code>即成为内置变量。当然内置变拥有比ansible.cfg中选项更高的优先级，而且针对不同的主机，可以定义不同的值。</p>
<p>官方链接：https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#connecting-to-hosts-behavioral-inventory-parameters</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20210309153531453.png" alt="image-20210309153531453" /></p>
<p>下面是一个简单的示例：</p>
<div><pre><code><span># 指定了三台主机，三台主机的用密码分别是P@ssw0rd、123456、45789，指定的ssh连接的用户名分别为root、breeze、bernie，ssh 端口分别为22、22、3055 ，这样在ansible命令执行的时候就不用再指令用户和密码等了</span>

<span>[</span>test<span>]</span>
<span>192.168</span>.1.1 <span>ansible_user</span><span>=</span>root <span>ansible_password</span><span>=</span><span>'P@ssw0rd'</span>
<span>192.168</span>.1.2 <span>ansible_user</span><span>=</span>breeze <span>ansible_password</span><span>=</span><span>'123456'</span>
<span>192.168</span>.1.3 <span>ansible_user</span><span>=</span>bernie <span>ansible_port</span><span>=</span><span>3055</span> <span>ansible_password</span><span>=</span><span>'456789'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="_1-2-定义主机组变量"> 1.2. 定义主机组变量</h2>
<p>变量也可以通过组名，应用到组内的所有成员：</p>
<div><pre><code><span># test组中包含两台主机，通过对test组指定vars变更，相应的host1和host2相当于相应的指定了ntp_server和proxy变量参数值</span>

<span>[</span>test<span>]</span>
host1
host2
<span>[</span>test:vars<span>]</span>
<span>ntp_server</span><span>=</span><span>192.168</span>.1.10
<span>proxy</span><span>=</span><span>192.168</span>.1.20
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>主机组变量示例：</p>
<div><pre><code># 下面是一个示例，指定了一个武汉组有web1、web2；随州组有web3、web4主机；又指定了一个湖北组，同时包含武汉和随州；同时为该组内的所有主机指定了2个vars变量。设定了一个组中国组，包含湖北、湖南。

[wuhan]
web1
web2

[suizhou]
web4
web3

[hubei:children]
wuhan
suizhou

[hubei:vars]
ntp_server=192.168.1.10
zabbix_server=192.168.1.10
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h1 id="_2-在playbook中定义变量"> 2. 在Playbook中定义变量</h1>
<h2 id="_2-1-变量的定义方式"> 2.1. 变量的定义方式</h2>
<h3 id="_2-1-1-通过vars关键字定义"> 2.1.1. 通过vars关键字定义</h3>
<p>下面是一个简单示例：</p>
<div><pre><code><span>-</span> name： use vars define invrionmemnt
  <span>hosts</span><span>:</span> test
  <span>user</span><span>:</span> ansible
  <span>vars</span><span>:</span> 
    <span>http_port</span><span>:</span> <span>80</span>
    <span>server_name</span><span>:</span> localhost
    <span>conf_file</span><span>:</span> /etc/nginx/conf/default.conf
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_2-1-2-通过vars-files关键字引入变量文件"> 2.1.2. 通过vars_files关键字引入变量文件</h3>
<p>下面是一个简单示例：</p>
<div><pre><code><span>-</span> <span>hosts</span><span>:</span> all
  <span>remote_user</span><span>:</span> root
  <span>vars</span><span>:</span>
    <span>favcolor</span><span>:</span> blue
  <span>vars_files</span><span>:</span>
    <span>-</span> vars/external_vars.yml
    <span>-</span> vars/user_vars.yml

<span># vars/user_vars.yml示例：</span>

<span>users</span><span>:</span>
  <span>bjones</span><span>:</span>
    <span>first_name</span><span>:</span> Bob
    <span>last_name</span><span>:</span> Jones
    <span>home_dirs</span><span>:</span> /users/bjones
  <span>acook</span><span>:</span>
    <span>first_name</span><span>:</span> Anne
    <span>last_name</span><span>:</span> Cook
    <span>home_dirs</span><span>:</span> /users/acook
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><blockquote>
<p>变量的定义格式是成键值对出现的，键值对之间可以嵌套，最终形成一个大字典</p>
</blockquote>
<p>和vars一样，只不过它是将变量以字典格式定义在独立的文件中，且<code>vars_files</code>不能定义在task层次，只能定义在play层次。</p>
<div><pre><code>---
    - hosts: localhost
      vars_files: 
        - /tmp/var_file1.yml
        - var_file2.yml
      tasks: 
         - debug: msg=&quot;{{var1}} {{var2}}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面var_file2.yml使用的是相对路径，基于playbook所在的路径。例如该playbook为/tmp/x.yml，则var_file2.yml也应该在/tmp下。当然，完全可以使用绝对路径。</p>
<h3 id="_2-1-3-在playbook中通过host-vars和group-vars目录定义变量"> 2.1.3. 在playbook中通过host_vars和group_vars目录定义变量</h3>
<p>下面这是一个项目的playbook目录结构。这个项目中，包含一个ansible.cfg文件，一个inventory文件，一个playbook.yml文件，一个<code>group_vars</code>目录和一个<code>host_vars</code>目录:</p>
<div><pre><code># tree /etc/ansible/playbooks/project
/etc/ansible/playbooks/project
├── ansible.cfg
├── group_vars
│   ├── datacenter1
│   ├── datacenter2
│   └── datacenters
├── host_vars
│   ├── demo1.example.com
│   ├── demo2.example.com
│   ├── demo3.example.com
│   └── demo4.example.com
├── inventory
└── playbook.yml
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>其中inventory文件的示例如下：</p>
<div><pre><code>[datacenter1]
demo1.example.com
demo2.example.com

[datacenter2]
demo3.example.com
demo4.example.com

[datacenters:children]
datacenter1
datacenter2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>可以看到group_vars目录中，定义了三个文件，分别以inventory文件中的三个主机组命名，所以这三个文件中定义的就分别是这三个组可以使用的变量。</p>
<div><pre><code># cat datacenter1
package: httpd

# cat datacenter2 
package: apache

# cat datacenters 
package: httpd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在host_vars目录中，定义了三个文件，分别以inventory文件中的四个主机命名，所以这四个文件中定义的就分别是这四个主机可以使用的变量。</p>
<div><pre><code># cat demo1.example.com 
package: httpd

# cat demo2.example.com 
package: apache

# cat demo3.example.com 
package: mariadb-server

# cat demo4.example.com 
package: mysql-server
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p>需要说明的是，如果主机组定义的变量与主机冲突，主机变量优先级最高</p>
</blockquote>
<h3 id="_2-1-4-注册变量"> 2.1.4. 注册变量</h3>
<p>在有些时候，可能需要将某一条任务执行的结果保存下来，以便在接下的任务中调用或者做些判断。可以通过register关键字来实现将某一任务结果保存为一个变量。</p>
<p>下面是个简单的例子，将whoami命令执行的结果注册到变量login：</p>
<div><pre><code>- name: register variables
  hosts: test
  tasks:
    - name: capture output of whoami command
      command: whoami
      register: login
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注册变量的应用场景：</p>
<ul>
<li>在一台远端的服务器获取一个目录下的一列表的文件,然后下载这些文件</li>
<li>在handler执行之前,发现前面一个task发生了changed,然后执行一个指定的task</li>
<li>获取远端服务器的ssh key的内容,构建出known_hosts文件</li>
</ul>
<h3 id="_2-1-5-通过命令行设置变量"> 2.1.5. 通过命令行设置变量</h3>
<p>示例如下：</p>
<div><pre><code>---
- hosts: &#39;{{ hosts }}&#39;
  remote_user: &#39;{{ user }}&#39;
  tasks:
     - ...
     
ansible-playbook release.yml --extra-vars &quot;hosts=vipers user=starbuck&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>也可以写成类似如下方式：</p>
<div><pre><code>--extra-vars &#39;{&quot;hosts&quot;:&quot;vipers&quot;,&quot;user&quot;:&quot;starbuck&quot;}&#39;
</code></pre>
<div><span>1</span><br></div></div><h2 id="_2-2-使用与调试变量"> 2.2 使用与调试变量</h2>
<p>我们通过以上5种方式在playbook中定义了各种变量。说到底，最终的目的，还是为了方便使用。下面我们就看一看具体如何使用这些变量。</p>
<h3 id="_2-2-1-变量的引用"> 2.2.1. 变量的引用</h3>
<p>下面是一个变量的基本使用示例，前面的变量定义部分，直接使用的2.1.1中的变量示例：</p>
<div><pre><code><span>-</span> <span>name</span><span>:</span> use vars define variables
  <span>hosts</span><span>:</span> test
  <span>vars</span><span>:</span> 
    <span>http_port</span><span>:</span> <span>80</span>
    <span>server_name</span><span>:</span> localhost
    <span>conf_file</span><span>:</span> /etc/nginx/conf/default.conf
    
  <span>tasks</span><span>:</span>
    <span>-</span> <span>name</span><span>:</span> print variables
      <span>shell</span><span>:</span> echo "<span>{</span><span>{</span> http_port <span>}</span><span>}</span> <span>{</span><span>{</span> server_name <span>}</span><span>}</span> <span>{</span><span>{</span> conf_file <span>}</span><span>}</span>"  <span>></span> /tmp/text.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>在2.1.2中，我们通过<code>vars_files</code>引用了一个文件<code>user_vars.yml</code>，在该文件中定义了一个稍微复杂的字典变量，现在我想要获取<code>users</code>中<code>bjones</code>用户的<code>first_name</code>和<code>acook</code>用户的<code>home_dirs</code>，可以使用如下方法：</p>
<div><pre><code>{{ users.bjones.first_name }}
{{ users.acook.home_dirs }}
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>或者如下写法：</p>
<div><pre><code>{{ users[&#39;bjones&#39;][&#39;first_name&#39;] }}
{{ users[&#39;acook&#39;][&#39;home_dirs&#39;] }}
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_2-2-2-变量的调试输出"> 2.2.2. 变量的调试输出</h3>
<p>有些时候，我们在引用变量的时候，可能需要知道变量中包含哪些信息，以方便在执行过程中，对变量做些处理。ansible提供一个debug模块用于调试变量输出：</p>
<div><pre><code>- name: register variables
  hosts: test
  tasks:
    - name: capture output of whoami command
      command: whoami
      register: login
    - debug: var=login
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行后输出如下：</p>
<div><pre><code># ansible-playbook register.yml 

PLAY [register variables] ***************************************************************************************************************************************************

TASK [Gathering Facts] ******************************************************************************************************************************************************
ok: [10.1.61.187]

TASK [capture output of whoami command] *************************************************************************************************************************************
changed: [10.1.61.187]

TASK [debug] ****************************************************************************************************************************************************************
ok: [10.1.61.187] =&gt; {
    &quot;login&quot;: {
        &quot;changed&quot;: true,
        &quot;cmd&quot;: [
            &quot;whoami&quot;
        ],
        &quot;delta&quot;: &quot;0:00:00.004279&quot;,
        &quot;end&quot;: &quot;2019-05-24 00:41:43.710398&quot;,
        &quot;failed&quot;: false,
        &quot;rc&quot;: 0,
        &quot;start&quot;: &quot;2019-05-24 00:41:43.706119&quot;,
        &quot;stderr&quot;: &quot;&quot;,
        &quot;stderr_lines&quot;: [],
        &quot;stdout&quot;: &quot;root&quot;,
        &quot;stdout_lines&quot;: [
            &quot;root&quot;
        ]
    }
}

PLAY RECAP ******************************************************************************************************************************************************************
10.1.61.187                : ok=3    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>关于输出的debug部分重点说明如下：</p>
<ul>
<li>login： 变量名，其值为一个字典</li>
<li>changed：ansible基于此来判断是否发生了状态改变</li>
<li>cmd：被调用的命令</li>
<li>failed：是否运行失败</li>
<li>rc：返回值，0代表正常，非0代表异常</li>
<li>stderr：如果出现异常，会在这里显示错误输出</li>
<li>stderr_lines：按行分割的错误输出</li>
<li>stdout：如果指令正常运行，则在这里输出返回结果</li>
<li>stdout：按行分割的返回结果</li>
</ul>
<blockquote>
<p>需要说明的是，通过register注册的变量的结果并不是一成不变的，在不确定返回值的情况下，尽量调试看看输出结果。</p>
</blockquote>
<p>关于debug的更多用法说明：</p>
<p>调试模块，用于在调试中输出信息
常用参数：</p>
<ul>
<li>msg：调试输出的消息</li>
<li>var：将某个变量传递给debug模块，debug会直接将其打印输出</li>
<li>verbosity：debug的级别</li>
</ul>
<p>示例：</p>
<div><pre><code><span># Example that prints the loopback address and gateway for each host</span>
<span>-</span> <span>debug</span><span>:</span> msg="System <span>{</span><span>{</span> inventory_hostname <span>}</span><span>}</span> has uuid <span>{</span><span>{</span> ansible_product_uuid <span>}</span><span>}</span>"

<span>-</span> <span>debug</span><span>:</span> msg="System <span>{</span><span>{</span> inventory_hostname <span>}</span><span>}</span> has gateway <span>{</span><span>{</span> ansible_default_ipv4.gateway <span>}</span><span>}</span>"
  <span>when</span><span>:</span> ansible_default_ipv4.gateway is defined

<span>-</span> <span>shell</span><span>:</span> /usr/bin/uptime
  <span>register</span><span>:</span> result

<span>-</span> <span>debug</span><span>:</span> var=result verbosity=2    <span>#直接将上一条指令的结果作为变量传递给var，由debug打印出result的值</span>

<span>-</span> <span>name</span><span>:</span> Display all variables/facts known for a host
  <span>debug</span><span>:</span> var=hostvars<span>[</span>inventory_hostname<span>]</span> verbosity=4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>
<p>注意格式，=号左右没有空格</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">4.1 Playbook的结构及handler用法</title>
    <id>https://clay-wangzhi.com/automate/ansible/dir-handler/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/dir-handler/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-1-playbook的结构及handler用法"> 4.1 Playbook的结构及handler用法</h1>
<h2 id="_1-playbook的结构说明"> 1 playbook的结构说明</h2>
<p>playbook是由一个或多个&quot;play&quot;组成的列表。play的主要功能就是对一组主机应用play中定义好的task。从根本上来讲一个task就是对ansible一个module的调用。而将多个play按照一定的顺序组织到一个playbook中，我们称之为编排。</p>
<p>playbook主要有以下四部分构成:</p>
<ul>
<li>Target section： 用于定义将要执行playbook的远程主机组及远程主机组上的用户，还包括定义通过什么样的方式连接远程主机（默认ssh）</li>
<li>Variable section： 定义playbook运行时需要使用的变量</li>
<li>Task section： 定义将要在远程主机上执行的任务列表</li>
<li>Handler section： 定义task执行完成以后需要调用的任务</li>
</ul>
<h2 id="_2-target-section"> 2 Target section</h2>
<p>playbook中的每一个play的目的都是为了让某个或某些主机以某个指定的用户身份执行任务。</p>
<h3 id="_2-1-playbook中的远程用户"> 2.1 Playbook中的远程用户</h3>
<p>playbook中的远程用户和ad-hoc中的使用没有区别，默认不定义，则直接使用ansible.cfg配置中的用户相关的配置。也可在playbook中定义如下：</p>
<div><pre><code>- name: /etc/hosts is up to date
  hosts: datacenter
  remote_user: automation
  become: yes
  become_mothod: sudo
  become_user: root
  
  tasks:
    - name: server.example.com in /etc/hosts
      lineinfile:
        path: /etc/hosts
        line: &#39;192.168.0.200 server.exmaple.com server&#39;
        state: present
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="_2-2-playbook中的hosts"> 2.2 Playbook中的hosts</h3>
<p>playbook中的hosts即inentory中的定义主机与主机组，在《Ansible Inventory》中我们讲到了如何选择主机与主机组，在这里也完全适用。</p>
<div><pre><code>- name: start mariadb
  hosts: db,&amp;london
  tasks:
    - name: start mariadb
      service:
        name: mariadb
        state: started
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="_3-variable-section"> 3 Variable section</h2>
<p>vars设置变量vars指令可用于设置变量，可以设置一个或多个变量。下面的设置方式都是合理的</p>
<div><pre><code># 设置单个变量
vars:
  var1: value1

vars:
  - var1: value1

# 设置多个变量：
vars:
  var1: value1
  var2: value2

vars:
  - var1: value1
  - var2: value2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>vars可以设置在play级别，也可以设置在task级别：</p>
<p>(1).设置在play级别，该play范围内的task能访问这些变量，其它play范围内则无法访问；</p>
<p>(2).设置在task级别，只有该task能访问这些变量，其它task和其它play则无法访问。</p>
<h2 id="_4-task-section"> 4 Task section</h2>
<p>play的主体部分是任务列表。</p>
<p>任务列表中的各任务按次序逐个在hosts中指定的所有主机上执行，在所有主机上完成第一个任务后再开始第二个。在自上而下运行某playbook时，如果中途发生错误，则整个playbook会停止执行，由于playbook的幂等性，playbook可以被反复执行，所以即使发生了错误，在修复错误后，再执行一次即可。</p>
<p>定义task可以使用<code>action: module options</code>或<code>module: options</code>的格式，推荐使用后者以实现向后兼容。</p>
<div><pre><code><span>tasks</span><span>:</span>
  <span>-</span> <span>name</span><span>:</span> make sure apache is running
    <span>service</span><span>:</span> 
      <span>name</span><span>:</span> httpd
      <span>state</span><span>:</span> started
      
  <span>-</span> <span>name</span><span>:</span> disable selinux
    <span>command</span><span>:</span> /sbin/setenforce 0  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>如果命令或脚本的退出码不为零可以使用如下方式替代：</p>
<div><pre><code><span>tasks</span><span>:</span>
  <span>-</span> <span>name</span><span>:</span> run this command and ignore the result
    <span>shell</span><span>:</span> /usr/bin/somecommand <span>|</span><span>|</span> /bin/true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以使用ignore_errors来忽略错误信息：</p>
<div><pre><code><span>tasks</span><span>:</span>
  <span>-</span> <span>name</span><span>:</span> run this command and ignore the result
    <span>shell</span><span>:</span> /usr/bin/somecommand
    <span>ignore_errors</span><span>:</span> <span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="_5-handler-section"> 5 Handler section</h2>
<ul>
<li>在Ansible Playbook中，handler事实上也是个task，只不过这个task默认并不执行，只有在被触发时才执行。</li>
<li>handler通过notify来监视某个或者某几个task，一旦task执行结果发生变化，则触发handler，执行相应操作。</li>
<li>handler会在所有的play都执行完毕之后才会执行，这样可以避免当handler监视的多个task执行结果都发生了变化之后而导致handler的重复执行（handler只需要在最后执行一次即可）。</li>
</ul>
<div><pre><code><span>tasks</span><span>:</span>
  <span>-</span> <span>name</span><span>:</span> template configuration file
    <span>template</span><span>:</span> 
      <span>src</span><span>:</span> template.j2 
      <span>dest</span><span>:</span> /etc/foo.conf
    <span>notify</span><span>:</span>
      <span>-</span> restart memcached
      <span>-</span> restart apache
  <span>-</span> <span>name</span><span>:</span> start memcached
    <span>service</span><span>:</span>
      <span>name</span><span>:</span> memcached
      <span>state</span><span>:</span> started
  <span>-</span> <span>name</span><span>:</span> start apache
    service
      <span>name</span><span>:</span> httpd
      <span>state</span><span>:</span> started
<span>handlers</span><span>:</span>
  <span>-</span> <span>name</span><span>:</span> restart memcached
    <span>service</span><span>:</span>
      <span>name</span><span>:</span> memcached
      <span>state</span><span>:</span> restarted
  <span>-</span> <span>name</span><span>:</span> restart apache
    <span>service</span><span>:</span>
      <span>name</span><span>:</span> httpd
      <span>state</span><span>:</span> restarted
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><blockquote>
<p>在notify中定义内容一定要和tasks中定义的 - name 内容一样，这样才能达到触发的效果，否则会不生效。</p>
</blockquote>
<p>默认情况下，在一个play中，只要有task执行失败，则play终止，即使是与handler关联的task在失败的task之前运行成功了，handler也不会被执行。如果希望在这种情况下handler仍然能够执行，则需要使用如下配置：</p>
<div><pre><code>- hosts: all
  force_handlers: yes
  tasks:
    - name: a task which always notifies its handler
      command: /bin/true
      notify: restart the database
    - name: a task which fails because the package doesn&#39;t exist
      yum:
        name: notapkg
        state: latest
      
  handlers:
    - name: restart the database
      service:
        name: mariadb
        state: restarted
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><blockquote>
<p>如果与handler关联的task还未执行，在其前的task已经失败，整个play终止，则handler未被触发，也不会执行。</p>
</blockquote>
<blockquote>
<p>参考链接：</p>
<p>https://www.cnblogs.com/breezey/p/8811473.html</p>
<p>https://blog.51cto.com/cloumn/blog/1544</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">5.2 Fact变量</title>
    <id>https://clay-wangzhi.com/automate/ansible/fact/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/fact/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_5-2-fact变量"> 5.2 Fact变量</h1>
<h2 id="_1-fact简介"> 1 fact简介</h2>
<p>为了让Ansible更了解目标节点，可以让它去收集目标节点的信息，比如获取对方的主机名、系统版本、IP地址或其它网卡信息、分区挂载信息等等。在Ansible中，收集到的这些节点信息称为Facts。</p>
<p>有了这些信息，用户可以更好的控制管理节点，比如当IP地址为xxx时就怎样怎样，当系统是CentOS 6时怎样怎样，是CentOS 7时怎样怎样，等等。</p>
<p>有这些信息当然好，但是收集这些信息是有代价的，而且代价很大：因为要收集的信息量很大，所以收集的过程非常慢。所以，如果在playbook中用不上这些信息时，应当禁用收集行为，这也是一个非常有效的效率优化手段。</p>
<p>ansible两个模块叫setup、gather_facts，用于获取远程主机的相关信息，并可以将这些信息作为变量在playbook里进行调用。而setup模块获取这些信息的方法就是依赖于fact。</p>
<div><pre><code>$ ansible localhost -m setup
$ ansible localhost -m gather_facts
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>简单说明一下setup模块和gather_facts模块的区别。setup模块是早就存在的模块，而gather_facts模块是Ansible 2.8才提供的，它是一个二次封装的模块，内部很可能就是调用setup模块，但为何还要提供gather_facts模块呢？也许原因就在于gather_facts模块相比setup模块多的一个功能：并行收集多个节点的信息，而且在探测到要收集多个节点信息时会自动并行。</p>
<p>既然setup和gather_facts是模块，那么它们也可以在playbook中当作任务来执行。但是playbook专门为此提供了一个play级别的指令：gather_facts。</p>
<div><pre><code># ansible test -m setup
10.1.61.187 | SUCCESS =&gt; {
    &quot;ansible_facts&quot;: {
        &quot;ansible_all_ipv4_addresses&quot;: [
            &quot;10.1.61.187&quot;
        ],
        &quot;ansible_all_ipv6_addresses&quot;: [
            &quot;fe80::f816:3eff:fe4f:6611&quot;
        ],
        &quot;ansible_apparmor&quot;: {
            &quot;status&quot;: &quot;disabled&quot;
        },
        &quot;ansible_architecture&quot;: &quot;x86_64&quot;,
        &quot;ansible_bios_date&quot;: &quot;04/01/2014&quot;,
        &quot;ansible_bios_version&quot;: &quot;Ubuntu-1.8.2-1ubuntu1~cloud0&quot;,
        
        ...output omitted...
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>setup获取的这些信息，都是可用于该主机的变量。</p>
<h2 id="_2-自定义fact-local-facts"> 2 自定义fact(Local Facts)</h2>
<h3 id="_2-1-手动设置fact"> 2.1 手动设置fact</h3>
<p>ansible除了能获取到预定义的fact的内容,还支持手动为某个主机定制fact。称之为本地fact。本地fact默认存放于被控端的<code>/etc/ansible/facts.d</code>目录下，如果文件为<code>ini</code>格式或者<code>json</code>格式，ansible会自动识别。以这种形式加载的fact是key为<code>ansible_local</code>的特殊变量。</p>
<p>下面是一个简单的示例，在ansibler主控端定义一个<code>ini</code>格式的custom.fact文件内容如下：</p>
<div><pre><code>[general]
package = httpd
service = httpd
state = started
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>然后我们编写一个playbook文件名为setup_facts.yml内容如下：</p>
<div><pre><code>---
- name: Install remote facts
  hosts: test
  vars: 
    remote_dir: /etc/ansible/facts.d
    facts_file: custom.fact
  tasks:
    - name: Create the remote directory
      file:
        state: directory
        recurse: yes
        path: &quot;{{ remote_dir }}&quot;
    - name: Install the new facts
      copy:
        src: &quot;{{ facts_file }}&quot;
        dest: &quot;{{ remote_dir }}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>执行该playbook，完成facts的推送：</p>
<div><pre><code>ansible-playbook setup_facts.yml
</code></pre>
<div><span>1</span><br></div></div><p>此时，我们可以在被控端看到新的facts已经生成：</p>
<div><pre><code># ansible test -m setup        
10.1.61.187 | SUCCESS =&gt; {
    &quot;ansible_facts&quot;: {
    
        ...output omitted...
        
        &quot;ansible_local&quot;: {
            &quot;custom&quot;: {
                &quot;general&quot;: {
                    &quot;package&quot;: &quot;httpd&quot;,
                    &quot;service&quot;: &quot;httpd&quot;,
                    &quot;state&quot;: &quot;started&quot;
                }
            }
        },

        ...output omitted...
  
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>我们可以写一个简单的playbook来使用这些facts：</p>
<div><pre><code>- name: Install Apache and starts the service
  hosts: test
  tasks:
    - name: Install the required package
      yum: 
        name: &quot;{{ ansible_facts.ansible_local.custom.general.package }}&quot;
        state: latest
    - name: Start the service
      service: 
        name: &quot;{{ ansible_facts.ansible_local.custom.general.service }}&quot;
        state: &quot;{{ ansible_facts.ansible_local.custom.general.state }}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="_2-2-使用set-fact模块定义新的变量"> 2.2 使用set_fact模块定义新的变量</h3>
<p><code>set_fact</code>模块可以自定义facts，这些自定义的facts可以通过template或者变量的方式在playbook中使用。如果你想要获取一个进程使用的内存的百分比，则必须通过set_fact来进行计算之后得出其值，并将其值在playbook中引用。</p>
<p>下面是一个set_fact模块的应用示例：</p>
<div><pre><code>- name: set_fact example
  hosts: test
  tasks:
    - name: Calculate InnoDB buffer pool size
      set_fact: innodb_buffer_pool_size_mb=&quot;{{ ansible_memtotal_mb / 2 |int }}&quot;
      
    - debug: var=innodb_buffer_pool_size_mb
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行playbook如下：</p>
<div><pre><code># ansible-playbook set_fact_ex.yaml 

PLAY [set_fact example] *****************************************************************************************************************************************************

TASK [Gathering Facts] ******************************************************************************************************************************************************
ok: [10.1.61.187]

TASK [Calculate InnoDB buffer pool size] ************************************************************************************************************************************
ok: [10.1.61.187]

TASK [debug] ****************************************************************************************************************************************************************
ok: [10.1.61.187] =&gt; {
    &quot;innodb_buffer_pool_size_mb&quot;: &quot;3911.0&quot;
}

PLAY RECAP ******************************************************************************************************************************************************************
10.1.61.187                : ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>
<p>这种设置方式只在当前playbook当中有效</p>
</blockquote>
<h2 id="_3-手动采集fact"> 3 手动采集fact</h2>
<p>收集到目标节点信息之后，各信息都保存在一个名为ansible_facts的变量中，所以可以直接debug去查看这个变量里保存了什么东西，也即收集了目标节点的哪些信息。</p>
<div><pre><code>- name: info in ansible_facts
  debug:
    var: ansible_facts
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>此外也可以直接使用下面的方式来查看Facts中收集了哪些信息：</p>
<div><pre><code>$ ansible localhost -m &#39;setup&#39;
</code></pre>
<div><span>1</span><br></div></div><p>下面是收集到的部分Facts信息：</p>
<div><pre><code>localhost | SUCCESS =&gt; {
    &quot;ansible_facts&quot;: {
        &quot;ansible_all_ipv4_addresses&quot;: [
            &quot;192.168.135.234&quot;
        ],
        &quot;ansible_all_ipv6_addresses&quot;: [
            &quot;fe80::c38:ea5:1598:8169&quot;
        ],
        &quot;ansible_apparmor&quot;: {
            &quot;status&quot;: &quot;disabled&quot;
        },
        &quot;ansible_architecture&quot;: &quot;x86_64&quot;,
        &quot;ansible_bios_date&quot;: &quot;04/01/2014&quot;,
        &quot;ansible_bios_version&quot;: &quot;1.11.0-2.el7&quot;,
        &quot;ansible_cmdline&quot;: {
            &quot;BOOT_IMAGE&quot;: &quot;/vmlinuz-3.10.0-957.el7.x86_64&quot;,
            &quot;biosdevname&quot;: &quot;0&quot;,
            &quot;crashkernel&quot;: &quot;auto&quot;,
            &quot;net.ifnames&quot;: &quot;0&quot;,
            &quot;quiet&quot;: true,
            &quot;rhgb&quot;: true,
            &quot;ro&quot;: true,
            &quot;root&quot;: &quot;UUID=120cca73-ddab-4aac-b751-7421263b55ad&quot;
        },
        &quot;ansible_date_time&quot;: {
            &quot;date&quot;: &quot;2021-03-16&quot;,
            &quot;day&quot;: &quot;16&quot;,
            &quot;epoch&quot;: &quot;1615886206&quot;,
            &quot;hour&quot;: &quot;17&quot;,
            &quot;iso8601&quot;: &quot;2021-03-16T09:16:46Z&quot;,
            &quot;iso8601_basic&quot;: &quot;20210316T171646952201&quot;,
            &quot;iso8601_basic_short&quot;: &quot;20210316T171646&quot;,
            &quot;iso8601_micro&quot;: &quot;2021-03-16T09:16:46.952201Z&quot;,
            &quot;minute&quot;: &quot;16&quot;,
            &quot;month&quot;: &quot;03&quot;,
            &quot;second&quot;: &quot;46&quot;,
            &quot;time&quot;: &quot;17:16:46&quot;,
            &quot;tz&quot;: &quot;CST&quot;,
            &quot;tz_offset&quot;: &quot;+0800&quot;,
            &quot;weekday&quot;: &quot;Tuesday&quot;,
            &quot;weekday_number&quot;: &quot;2&quot;,
            &quot;weeknumber&quot;: &quot;11&quot;,
            &quot;year&quot;: &quot;2021&quot;
        },
        &quot;ansible_default_ipv4&quot;: {
            &quot;address&quot;: &quot;192.168.135.234&quot;,
            &quot;alias&quot;: &quot;eth0&quot;,
            &quot;broadcast&quot;: &quot;192.168.135.255&quot;,
            &quot;gateway&quot;: &quot;192.168.135.254&quot;,
            &quot;interface&quot;: &quot;eth0&quot;,
            &quot;macaddress&quot;: &quot;fa:16:3e:7e:9b:47&quot;,
            &quot;mtu&quot;: 1500,
            &quot;netmask&quot;: &quot;255.255.255.0&quot;,
            &quot;network&quot;: &quot;192.168.135.0&quot;,
            &quot;type&quot;: &quot;ether&quot;
        },
        &quot;ansible_default_ipv6&quot;: {},
        &quot;ansible_device_links&quot;: {
            &quot;ids&quot;: {
                &quot;sr0&quot;: [
                    &quot;ata-QEMU_DVD-ROM_QM00002&quot;
                ],
                &quot;sr1&quot;: [
                    &quot;ata-QEMU_DVD-ROM_QM00004&quot;
                ],
                &quot;vda&quot;: [
                    &quot;virtio-c1672133-7ae6-4318-8&quot;
                ],
                &quot;vda1&quot;: [
                    &quot;virtio-c1672133-7ae6-4318-8-part1&quot;
                ],
                &quot;vda2&quot;: [
                    &quot;virtio-c1672133-7ae6-4318-8-part2&quot;
                ]
            },
            &quot;labels&quot;: {
                &quot;sr1&quot;: [
                    &quot;config-2&quot;
                ]
            },
            &quot;masters&quot;: {},
            &quot;uuids&quot;: {
                &quot;sr1&quot;: [
                    &quot;2021-03-08-14-55-38-00&quot;
                ],
                &quot;vda1&quot;: [
                    &quot;fef1f8c8-02fb-440c-b8aa-8fec6bfb4a88&quot;
                ],
                &quot;vda2&quot;: [
                    &quot;120cca73-ddab-4aac-b751-7421263b55ad&quot;
                ]
            }
        },
        &quot;ansible_devices&quot;: {
            &quot;sr0&quot;: {
                &quot;holders&quot;: [],
                &quot;host&quot;: &quot;&quot;,
                &quot;links&quot;: {
                    &quot;ids&quot;: [
                        &quot;ata-QEMU_DVD-ROM_QM00002&quot;
                    ],
                    &quot;labels&quot;: [],
                    &quot;masters&quot;: [],
                    &quot;uuids&quot;: []
                },
                &quot;model&quot;: &quot;QEMU DVD-ROM&quot;,
                &quot;partitions&quot;: {},
                &quot;removable&quot;: &quot;1&quot;,
                &quot;rotational&quot;: &quot;1&quot;,
                &quot;sas_address&quot;: null,
                &quot;sas_device_handle&quot;: null,
                &quot;scheduler_mode&quot;: &quot;deadline&quot;,
                &quot;sectors&quot;: &quot;2097151&quot;,
                &quot;sectorsize&quot;: &quot;512&quot;,
                &quot;size&quot;: &quot;1024.00 MB&quot;,
                &quot;support_discard&quot;: &quot;0&quot;,
                &quot;vendor&quot;: &quot;QEMU&quot;,
                &quot;virtual&quot;: 1
            },
            &quot;sr1&quot;: {
                &quot;holders&quot;: [],
                &quot;host&quot;: &quot;&quot;,
                &quot;links&quot;: {
                    &quot;ids&quot;: [
                        &quot;ata-QEMU_DVD-ROM_QM00004&quot;
                    ],
                    &quot;labels&quot;: [
                        &quot;config-2&quot;
                    ],
                    &quot;masters&quot;: [],
                    &quot;uuids&quot;: [
                        &quot;2021-03-08-14-55-38-00&quot;
                    ]
                },
                &quot;model&quot;: &quot;QEMU DVD-ROM&quot;,
                &quot;partitions&quot;: {},
                &quot;removable&quot;: &quot;1&quot;,
                &quot;rotational&quot;: &quot;1&quot;,
                &quot;sas_address&quot;: null,
                &quot;sas_device_handle&quot;: null,
                &quot;scheduler_mode&quot;: &quot;deadline&quot;,
                &quot;sectors&quot;: &quot;964&quot;,
                &quot;sectorsize&quot;: &quot;2048&quot;,
                &quot;size&quot;: &quot;482.00 KB&quot;,
                &quot;support_discard&quot;: &quot;0&quot;,
                &quot;vendor&quot;: &quot;QEMU&quot;,
                &quot;virtual&quot;: 1
            },
            &quot;vda&quot;: {
                &quot;holders&quot;: [],
                &quot;host&quot;: &quot;&quot;,
                &quot;links&quot;: {
                    &quot;ids&quot;: [
                        &quot;virtio-c1672133-7ae6-4318-8&quot;
                    ],
                    &quot;labels&quot;: [],
                    &quot;masters&quot;: [],
                    &quot;uuids&quot;: []
                },
                &quot;model&quot;: null,
                &quot;partitions&quot;: {
                    &quot;vda1&quot;: {
                        &quot;holders&quot;: [],
                        &quot;links&quot;: {
                            &quot;ids&quot;: [
                                &quot;virtio-c1672133-7ae6-4318-8-part1&quot;
                            ],
                            &quot;labels&quot;: [],
                            &quot;masters&quot;: [],
                            &quot;uuids&quot;: [
                                &quot;fef1f8c8-02fb-440c-b8aa-8fec6bfb4a88&quot;
                            ]
                        },
                        &quot;sectors&quot;: &quot;1024000&quot;,
                        &quot;sectorsize&quot;: 512,
                        &quot;size&quot;: &quot;500.00 MB&quot;,
                        &quot;start&quot;: &quot;2048&quot;,
                        &quot;uuid&quot;: &quot;fef1f8c8-02fb-440c-b8aa-8fec6bfb4a88&quot;
                    },
                    &quot;vda2&quot;: {
                        &quot;holders&quot;: [],
                        &quot;links&quot;: {
                            &quot;ids&quot;: [
                                &quot;virtio-c1672133-7ae6-4318-8-part2&quot;
                            ],
                            &quot;labels&quot;: [],
                            &quot;masters&quot;: [],
                            &quot;uuids&quot;: [
                                &quot;120cca73-ddab-4aac-b751-7421263b55ad&quot;
                            ]
                        },
                        &quot;sectors&quot;: &quot;208689152&quot;,
                        &quot;sectorsize&quot;: 512,
                        &quot;size&quot;: &quot;99.51 GB&quot;,
                        &quot;start&quot;: &quot;1026048&quot;,
                        &quot;uuid&quot;: &quot;120cca73-ddab-4aac-b751-7421263b55ad&quot;
                    }
                },
                &quot;removable&quot;: &quot;0&quot;,
                &quot;rotational&quot;: &quot;1&quot;,
                &quot;sas_address&quot;: null,
                &quot;sas_device_handle&quot;: null,
                &quot;scheduler_mode&quot;: &quot;mq-deadline&quot;,
                &quot;sectors&quot;: &quot;209715200&quot;,
                &quot;sectorsize&quot;: &quot;512&quot;,
                &quot;size&quot;: &quot;100.00 GB&quot;,
                &quot;support_discard&quot;: &quot;0&quot;,
                &quot;vendor&quot;: &quot;0x1af4&quot;,
                &quot;virtual&quot;: 1
            }
        },
        &quot;ansible_distribution&quot;: &quot;CentOS&quot;,
        &quot;ansible_distribution_file_parsed&quot;: true,
        &quot;ansible_distribution_file_path&quot;: &quot;/etc/redhat-release&quot;,
        &quot;ansible_distribution_file_variety&quot;: &quot;RedHat&quot;,
        &quot;ansible_distribution_major_version&quot;: &quot;7&quot;,
        &quot;ansible_distribution_release&quot;: &quot;Core&quot;,
        &quot;ansible_distribution_version&quot;: &quot;7.6&quot;,
        &quot;ansible_dns&quot;: {
            &quot;nameservers&quot;: [
                &quot;202.96.209.5&quot;,
                &quot;114.114.114.114&quot;
            ],
            &quot;search&quot;: [
                &quot;openstacklocal&quot;
            ]
        },
        &quot;ansible_domain&quot;: &quot;&quot;,
        &quot;ansible_effective_group_id&quot;: 0,
        &quot;ansible_effective_user_id&quot;: 0,
        &quot;ansible_env&quot;: {
            &quot;CLASSPATH&quot;: &quot;.::/opt/jdk1.8.0_144/lib:/opt/jdk1.8.0_144/jre/lib&quot;,
            &quot;HISTCONTROL&quot;: &quot;ignoredups&quot;,
            &quot;HISTSIZE&quot;: &quot;1000&quot;,
            &quot;HOME&quot;: &quot;/root&quot;,
            &quot;HOSTNAME&quot;: &quot;host-192-168-135-234&quot;,
            &quot;JAVA_HOME&quot;: &quot;/opt/jdk1.8.0_144&quot;,
            &quot;JRE_HOME&quot;: &quot;/opt/jdk1.8.0_144/jre&quot;,
            &quot;LANG&quot;: &quot;en_US.UTF-8&quot;,
            &quot;LESSOPEN&quot;: &quot;||/usr/bin/lesspipe.sh %s&quot;,
            &quot;LOGNAME&quot;: &quot;root&quot;,
            &quot;LS_COLORS&quot;: &quot;rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:&quot;,
            &quot;MAIL&quot;: &quot;/var/spool/mail/root&quot;,
            &quot;PATH&quot;: &quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/jdk1.8.0_144/bin:/opt/jdk1.8.0_144/jre/bin:/root/bin&quot;,
            &quot;PWD&quot;: &quot;/etc/ansible/playbooks&quot;,
            &quot;SHELL&quot;: &quot;/bin/bash&quot;,
            &quot;SHLVL&quot;: &quot;3&quot;,
            &quot;SSH_CLIENT&quot;: &quot;192.168.135.72 6220 22&quot;,
            &quot;SSH_CONNECTION&quot;: &quot;192.168.135.72 6220 192.168.135.234 22&quot;,
            &quot;SSH_TTY&quot;: &quot;/dev/pts/0&quot;,
            &quot;TERM&quot;: &quot;xterm&quot;,
            &quot;USER&quot;: &quot;root&quot;,
            &quot;XDG_RUNTIME_DIR&quot;: &quot;/run/user/0&quot;,
            &quot;XDG_SESSION_ID&quot;: &quot;5879&quot;,
            &quot;_&quot;: &quot;/usr/bin/python3&quot;
        },
        &quot;ansible_eth0&quot;: {
            &quot;active&quot;: true,
            &quot;device&quot;: &quot;eth0&quot;,
            &quot;features&quot;: {
                &quot;busy_poll&quot;: &quot;off [fixed]&quot;,
                &quot;fcoe_mtu&quot;: &quot;off [fixed]&quot;,
                &quot;generic_receive_offload&quot;: &quot;on&quot;,
                &quot;generic_segmentation_offload&quot;: &quot;on&quot;,
                &quot;highdma&quot;: &quot;on [fixed]&quot;,
                &quot;hw_tc_offload&quot;: &quot;off [fixed]&quot;,
                &quot;l2_fwd_offload&quot;: &quot;off [fixed]&quot;,
                &quot;large_receive_offload&quot;: &quot;off [fixed]&quot;,
                &quot;loopback&quot;: &quot;off [fixed]&quot;,
                &quot;netns_local&quot;: &quot;off [fixed]&quot;,
                &quot;ntuple_filters&quot;: &quot;off [fixed]&quot;,
                &quot;receive_hashing&quot;: &quot;off [fixed]&quot;,
                &quot;rx_all&quot;: &quot;off [fixed]&quot;,
                &quot;rx_checksumming&quot;: &quot;on [fixed]&quot;,
                &quot;rx_fcs&quot;: &quot;off [fixed]&quot;,
                &quot;rx_gro_hw&quot;: &quot;off [fixed]&quot;,
                &quot;rx_udp_tunnel_port_offload&quot;: &quot;off [fixed]&quot;,
                &quot;rx_vlan_filter&quot;: &quot;on [fixed]&quot;,
                &quot;rx_vlan_offload&quot;: &quot;off [fixed]&quot;,
                &quot;rx_vlan_stag_filter&quot;: &quot;off [fixed]&quot;,
                &quot;rx_vlan_stag_hw_parse&quot;: &quot;off [fixed]&quot;,
                &quot;scatter_gather&quot;: &quot;on&quot;,
                &quot;tcp_segmentation_offload&quot;: &quot;on&quot;,
                &quot;tx_checksum_fcoe_crc&quot;: &quot;off [fixed]&quot;,
                &quot;tx_checksum_ip_generic&quot;: &quot;on&quot;,
                &quot;tx_checksum_ipv4&quot;: &quot;off [fixed]&quot;,
                &quot;tx_checksum_ipv6&quot;: &quot;off [fixed]&quot;,
                &quot;tx_checksum_sctp&quot;: &quot;off [fixed]&quot;,
                &quot;tx_checksumming&quot;: &quot;on&quot;,
                &quot;tx_fcoe_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_gre_csum_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_gre_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_gso_partial&quot;: &quot;off [fixed]&quot;,
                &quot;tx_gso_robust&quot;: &quot;off [fixed]&quot;,
                &quot;tx_ipip_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_lockless&quot;: &quot;off [fixed]&quot;,
                &quot;tx_nocache_copy&quot;: &quot;off&quot;,
                &quot;tx_scatter_gather&quot;: &quot;on&quot;,
                &quot;tx_scatter_gather_fraglist&quot;: &quot;off [fixed]&quot;,
                &quot;tx_sctp_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_sit_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_tcp6_segmentation&quot;: &quot;on&quot;,
                &quot;tx_tcp_ecn_segmentation&quot;: &quot;on&quot;,
                &quot;tx_tcp_mangleid_segmentation&quot;: &quot;off&quot;,
                &quot;tx_tcp_segmentation&quot;: &quot;on&quot;,
                &quot;tx_udp_tnl_csum_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_udp_tnl_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_vlan_offload&quot;: &quot;off [fixed]&quot;,
                &quot;tx_vlan_stag_hw_insert&quot;: &quot;off [fixed]&quot;,
                &quot;udp_fragmentation_offload&quot;: &quot;on&quot;,
                &quot;vlan_challenged&quot;: &quot;off [fixed]&quot;
            },
            &quot;hw_timestamp_filters&quot;: [],
            &quot;ipv4&quot;: {
                &quot;address&quot;: &quot;192.168.135.234&quot;,
                &quot;broadcast&quot;: &quot;192.168.135.255&quot;,
                &quot;netmask&quot;: &quot;255.255.255.0&quot;,
                &quot;network&quot;: &quot;192.168.135.0&quot;
            },
            &quot;ipv6&quot;: [
                {
                    &quot;address&quot;: &quot;fe80::c38:ea5:1598:8169&quot;,
                    &quot;prefix&quot;: &quot;64&quot;,
                    &quot;scope&quot;: &quot;link&quot;
                }
            ],
            &quot;macaddress&quot;: &quot;fa:16:3e:7e:9b:47&quot;,
            &quot;module&quot;: &quot;virtio_net&quot;,
            &quot;mtu&quot;: 1500,
            &quot;pciid&quot;: &quot;virtio0&quot;,
            &quot;promisc&quot;: false,
            &quot;timestamping&quot;: [
                &quot;rx_software&quot;,
                &quot;software&quot;
            ],
            &quot;type&quot;: &quot;ether&quot;
        },
        &quot;ansible_fibre_channel_wwn&quot;: [],
        &quot;ansible_fips&quot;: false,
        &quot;ansible_form_factor&quot;: &quot;Other&quot;,
        &quot;ansible_fqdn&quot;: &quot;host-192-168-135-234&quot;,
        &quot;ansible_hostname&quot;: &quot;host-192-168-135-234&quot;,
        &quot;ansible_hostnqn&quot;: &quot;&quot;,
        &quot;ansible_interfaces&quot;: [
            &quot;lo&quot;,
            &quot;eth0&quot;
        ],
        &quot;ansible_is_chroot&quot;: false,
        &quot;ansible_iscsi_iqn&quot;: &quot;&quot;,
        &quot;ansible_kernel&quot;: &quot;3.10.0-957.el7.x86_64&quot;,
        &quot;ansible_kernel_version&quot;: &quot;#1 SMP Thu Nov 8 23:39:32 UTC 2018&quot;,
        &quot;ansible_lo&quot;: {
            &quot;active&quot;: true,
            &quot;device&quot;: &quot;lo&quot;,
            &quot;features&quot;: {
                &quot;busy_poll&quot;: &quot;off [fixed]&quot;,
                &quot;fcoe_mtu&quot;: &quot;off [fixed]&quot;,
                &quot;generic_receive_offload&quot;: &quot;on&quot;,
                &quot;generic_segmentation_offload&quot;: &quot;on&quot;,
                &quot;highdma&quot;: &quot;on [fixed]&quot;,
                &quot;hw_tc_offload&quot;: &quot;off [fixed]&quot;,
                &quot;l2_fwd_offload&quot;: &quot;off [fixed]&quot;,
                &quot;large_receive_offload&quot;: &quot;off [fixed]&quot;,
                &quot;loopback&quot;: &quot;on [fixed]&quot;,
                &quot;netns_local&quot;: &quot;on [fixed]&quot;,
                &quot;ntuple_filters&quot;: &quot;off [fixed]&quot;,
                &quot;receive_hashing&quot;: &quot;off [fixed]&quot;,
                &quot;rx_all&quot;: &quot;off [fixed]&quot;,
                &quot;rx_checksumming&quot;: &quot;on [fixed]&quot;,
                &quot;rx_fcs&quot;: &quot;off [fixed]&quot;,
                &quot;rx_gro_hw&quot;: &quot;off [fixed]&quot;,
                &quot;rx_udp_tunnel_port_offload&quot;: &quot;off [fixed]&quot;,
                &quot;rx_vlan_filter&quot;: &quot;off [fixed]&quot;,
                &quot;rx_vlan_offload&quot;: &quot;off [fixed]&quot;,
                &quot;rx_vlan_stag_filter&quot;: &quot;off [fixed]&quot;,
                &quot;rx_vlan_stag_hw_parse&quot;: &quot;off [fixed]&quot;,
                &quot;scatter_gather&quot;: &quot;on&quot;,
                &quot;tcp_segmentation_offload&quot;: &quot;on&quot;,
                &quot;tx_checksum_fcoe_crc&quot;: &quot;off [fixed]&quot;,
                &quot;tx_checksum_ip_generic&quot;: &quot;on [fixed]&quot;,
                &quot;tx_checksum_ipv4&quot;: &quot;off [fixed]&quot;,
                &quot;tx_checksum_ipv6&quot;: &quot;off [fixed]&quot;,
                &quot;tx_checksum_sctp&quot;: &quot;on [fixed]&quot;,
                &quot;tx_checksumming&quot;: &quot;on&quot;,
                &quot;tx_fcoe_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_gre_csum_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_gre_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_gso_partial&quot;: &quot;off [fixed]&quot;,
                &quot;tx_gso_robust&quot;: &quot;off [fixed]&quot;,
                &quot;tx_ipip_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_lockless&quot;: &quot;on [fixed]&quot;,
                &quot;tx_nocache_copy&quot;: &quot;off [fixed]&quot;,
                &quot;tx_scatter_gather&quot;: &quot;on [fixed]&quot;,
                &quot;tx_scatter_gather_fraglist&quot;: &quot;on [fixed]&quot;,
                &quot;tx_sctp_segmentation&quot;: &quot;on&quot;,
                &quot;tx_sit_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_tcp6_segmentation&quot;: &quot;on&quot;,
                &quot;tx_tcp_ecn_segmentation&quot;: &quot;on&quot;,
                &quot;tx_tcp_mangleid_segmentation&quot;: &quot;on&quot;,
                &quot;tx_tcp_segmentation&quot;: &quot;on&quot;,
                &quot;tx_udp_tnl_csum_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_udp_tnl_segmentation&quot;: &quot;off [fixed]&quot;,
                &quot;tx_vlan_offload&quot;: &quot;off [fixed]&quot;,
                &quot;tx_vlan_stag_hw_insert&quot;: &quot;off [fixed]&quot;,
                &quot;udp_fragmentation_offload&quot;: &quot;on&quot;,
                &quot;vlan_challenged&quot;: &quot;on [fixed]&quot;
            },
            &quot;hw_timestamp_filters&quot;: [],
            &quot;ipv4&quot;: {
                &quot;address&quot;: &quot;127.0.0.1&quot;,
                &quot;broadcast&quot;: &quot;&quot;,
                &quot;netmask&quot;: &quot;255.0.0.0&quot;,
                &quot;network&quot;: &quot;127.0.0.0&quot;
            },
            &quot;ipv6&quot;: [
                {
                    &quot;address&quot;: &quot;::1&quot;,
                    &quot;prefix&quot;: &quot;128&quot;,
                    &quot;scope&quot;: &quot;host&quot;
                }
            ],
            &quot;mtu&quot;: 65536,
            &quot;promisc&quot;: false,
            &quot;timestamping&quot;: [
                &quot;rx_software&quot;,
                &quot;software&quot;
            ],
            &quot;type&quot;: &quot;loopback&quot;
        },
        &quot;ansible_local&quot;: {},
        &quot;ansible_lsb&quot;: {},
        &quot;ansible_machine&quot;: &quot;x86_64&quot;,
        &quot;ansible_machine_id&quot;: &quot;5da37d186bbc4fab946458f383820cc2&quot;,
        &quot;ansible_memfree_mb&quot;: 5793,
        &quot;ansible_memory_mb&quot;: {
            &quot;nocache&quot;: {
                &quot;free&quot;: 6652,
                &quot;used&quot;: 1150
            },
            &quot;real&quot;: {
                &quot;free&quot;: 5793,
                &quot;total&quot;: 7802,
                &quot;used&quot;: 2009
            },
            &quot;swap&quot;: {
                &quot;cached&quot;: 0,
                &quot;free&quot;: 0,
                &quot;total&quot;: 0,
                &quot;used&quot;: 0
            }
        },
        &quot;ansible_memtotal_mb&quot;: 7802,
        &quot;ansible_mounts&quot;: [
            {
                &quot;block_available&quot;: 25154087,
                &quot;block_size&quot;: 4096,
                &quot;block_total&quot;: 26073407,
                &quot;block_used&quot;: 919320,
                &quot;device&quot;: &quot;/dev/vda2&quot;,
                &quot;fstype&quot;: &quot;xfs&quot;,
                &quot;inode_available&quot;: 52034972,
                &quot;inode_total&quot;: 52172288,
                &quot;inode_used&quot;: 137316,
                &quot;mount&quot;: &quot;/&quot;,
                &quot;options&quot;: &quot;rw,relatime,attr2,inode64,noquota&quot;,
                &quot;size_available&quot;: 103031140352,
                &quot;size_total&quot;: 106796675072,
                &quot;uuid&quot;: &quot;120cca73-ddab-4aac-b751-7421263b55ad&quot;
            },
            {
                &quot;block_available&quot;: 93950,
                &quot;block_size&quot;: 4096,
                &quot;block_total&quot;: 127145,
                &quot;block_used&quot;: 33195,
                &quot;device&quot;: &quot;/dev/vda1&quot;,
                &quot;fstype&quot;: &quot;xfs&quot;,
                &quot;inode_available&quot;: 255673,
                &quot;inode_total&quot;: 256000,
                &quot;inode_used&quot;: 327,
                &quot;mount&quot;: &quot;/boot&quot;,
                &quot;options&quot;: &quot;rw,relatime,attr2,inode64,noquota&quot;,
                &quot;size_available&quot;: 384819200,
                &quot;size_total&quot;: 520785920,
                &quot;uuid&quot;: &quot;fef1f8c8-02fb-440c-b8aa-8fec6bfb4a88&quot;
            }
        ],
        &quot;ansible_nodename&quot;: &quot;host-192-168-135-234&quot;,
        &quot;ansible_os_family&quot;: &quot;RedHat&quot;,
        &quot;ansible_pkg_mgr&quot;: &quot;yum&quot;,
        &quot;ansible_proc_cmdline&quot;: {
            &quot;BOOT_IMAGE&quot;: &quot;/vmlinuz-3.10.0-957.el7.x86_64&quot;,
            &quot;biosdevname&quot;: [
                &quot;0&quot;,
                &quot;0&quot;,
                &quot;0&quot;
            ],
            &quot;crashkernel&quot;: &quot;auto&quot;,
            &quot;net.ifnames&quot;: [
                &quot;0&quot;,
                &quot;0&quot;,
                &quot;0&quot;
            ],
            &quot;quiet&quot;: true,
            &quot;rhgb&quot;: true,
            &quot;ro&quot;: true,
            &quot;root&quot;: &quot;UUID=120cca73-ddab-4aac-b751-7421263b55ad&quot;
        },
        &quot;ansible_processor&quot;: [
            &quot;0&quot;,
            &quot;GenuineIntel&quot;,
            &quot;QEMU Virtual CPU version (cpu64-rhel6)&quot;,
            &quot;1&quot;,
            &quot;GenuineIntel&quot;,
            &quot;QEMU Virtual CPU version (cpu64-rhel6)&quot;,
            &quot;2&quot;,
            &quot;GenuineIntel&quot;,
            &quot;QEMU Virtual CPU version (cpu64-rhel6)&quot;,
            &quot;3&quot;,
            &quot;GenuineIntel&quot;,
            &quot;QEMU Virtual CPU version (cpu64-rhel6)&quot;
        ],
        &quot;ansible_processor_cores&quot;: 1,
        &quot;ansible_processor_count&quot;: 4,
        &quot;ansible_processor_threads_per_core&quot;: 1,
        &quot;ansible_processor_vcpus&quot;: 4,
        &quot;ansible_product_name&quot;: &quot;ArStack&quot;,
        &quot;ansible_product_serial&quot;: &quot;ed734a0c-5e92-45e4-8491-1f2882a28b98&quot;,
        &quot;ansible_product_uuid&quot;: &quot;E9D04AFD-381C-4EF2-8523-A5F2177334A9&quot;,
        &quot;ansible_product_version&quot;: &quot;2020.5.15-1.el7.centos&quot;,
        &quot;ansible_python&quot;: {
            &quot;executable&quot;: &quot;/usr/bin/python3&quot;,
            &quot;has_sslcontext&quot;: true,
            &quot;type&quot;: &quot;cpython&quot;,
            &quot;version&quot;: {
                &quot;major&quot;: 3,
                &quot;micro&quot;: 8,
                &quot;minor&quot;: 6,
                &quot;releaselevel&quot;: &quot;final&quot;,
                &quot;serial&quot;: 0
            },
            &quot;version_info&quot;: [
                3,
                6,
                8,
                &quot;final&quot;,
                0
            ]
        },
        &quot;ansible_python_version&quot;: &quot;3.6.8&quot;,
        &quot;ansible_real_group_id&quot;: 0,
        &quot;ansible_real_user_id&quot;: 0,
        &quot;ansible_selinux&quot;: {
            &quot;status&quot;: &quot;Missing selinux Python library&quot;
        },
        &quot;ansible_selinux_python_present&quot;: false,
        &quot;ansible_service_mgr&quot;: &quot;systemd&quot;,
        &quot;ansible_ssh_host_key_ecdsa_public&quot;: &quot;AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBNxkCyohIHmaY5FLaLU4NRenQ6QE9qcjzbs87lvJhhH7TpWKHw3/NOVLks1amivsFJ1CQsgzk+XkU/YLfDFGNRo=&quot;,
        &quot;ansible_ssh_host_key_ed25519_public&quot;: &quot;AAAAC3NzaC1lZDI1NTE5AAAAILGRRrB9EPLkKsnOkyTzCpIyfWuIPEh7Qy9l2H0O+k4U&quot;,
        &quot;ansible_ssh_host_key_rsa_public&quot;: &quot;AAAAB3NzaC1yc2EAAAADAQABAAABAQDXqv9l/aw5jmEeKMRIVCUSUCpAPSUYyiVzfe7MNGDJ/Wd/ZHBMScAKgPq31z5OXJBpzDzIULZ5Di3WwmIdRHU6f4+PQ7E2LHQN4SDQvk7Flz7ivUv/aGtwUft929llVyT7/jrVFzWeR3ABtc6Roux2UMwWZANDwGWLkv+R6qluFNZ4yGTmYr7i/WTa0IXqI0AgZbAjGcSxqwGpgC7+NW8UVn975sz2pBRgCz9PG0mTWLKjcpESPpeypX0D0liq3rkwCjmU3OutwrTOYX1Di5n9miufUvZeSauWfska++t8xSYcOvbkzWidCOWOYtmx6VqrbKSSQiEDAbWJipIGcX+T&quot;,
        &quot;ansible_swapfree_mb&quot;: 0,
        &quot;ansible_swaptotal_mb&quot;: 0,
        &quot;ansible_system&quot;: &quot;Linux&quot;,
        &quot;ansible_system_capabilities&quot;: [
            &quot;cap_chown&quot;,
            &quot;cap_dac_override&quot;,
            &quot;cap_dac_read_search&quot;,
            &quot;cap_fowner&quot;,
            &quot;cap_fsetid&quot;,
            &quot;cap_kill&quot;,
            &quot;cap_setgid&quot;,
            &quot;cap_setuid&quot;,
            &quot;cap_setpcap&quot;,
            &quot;cap_linux_immutable&quot;,
            &quot;cap_net_bind_service&quot;,
            &quot;cap_net_broadcast&quot;,
            &quot;cap_net_admin&quot;,
            &quot;cap_net_raw&quot;,
            &quot;cap_ipc_lock&quot;,
            &quot;cap_ipc_owner&quot;,
            &quot;cap_sys_module&quot;,
            &quot;cap_sys_rawio&quot;,
            &quot;cap_sys_chroot&quot;,
            &quot;cap_sys_ptrace&quot;,
            &quot;cap_sys_pacct&quot;,
            &quot;cap_sys_admin&quot;,
            &quot;cap_sys_boot&quot;,
            &quot;cap_sys_nice&quot;,
            &quot;cap_sys_resource&quot;,
            &quot;cap_sys_time&quot;,
            &quot;cap_sys_tty_config&quot;,
            &quot;cap_mknod&quot;,
            &quot;cap_lease&quot;,
            &quot;cap_audit_write&quot;,
            &quot;cap_audit_control&quot;,
            &quot;cap_setfcap&quot;,
            &quot;cap_mac_override&quot;,
            &quot;cap_mac_admin&quot;,
            &quot;cap_syslog&quot;,
            &quot;35&quot;,
            &quot;36+ep&quot;
        ],
        &quot;ansible_system_capabilities_enforced&quot;: &quot;True&quot;,
        &quot;ansible_system_vendor&quot;: &quot;Huayun&quot;,
        &quot;ansible_uptime_seconds&quot;: 571792,
        &quot;ansible_user_dir&quot;: &quot;/root&quot;,
        &quot;ansible_user_gecos&quot;: &quot;root&quot;,
        &quot;ansible_user_gid&quot;: 0,
        &quot;ansible_user_id&quot;: &quot;root&quot;,
        &quot;ansible_user_shell&quot;: &quot;/bin/bash&quot;,
        &quot;ansible_user_uid&quot;: 0,
        &quot;ansible_userspace_architecture&quot;: &quot;x86_64&quot;,
        &quot;ansible_userspace_bits&quot;: &quot;64&quot;,
        &quot;ansible_virtualization_role&quot;: &quot;guest&quot;,
        &quot;ansible_virtualization_type&quot;: &quot;kvm&quot;,
        &quot;gather_subset&quot;: [
            &quot;all&quot;
        ],
        &quot;module_setup&quot;: true
    },
    &quot;changed&quot;: false
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br><span>314</span><br><span>315</span><br><span>316</span><br><span>317</span><br><span>318</span><br><span>319</span><br><span>320</span><br><span>321</span><br><span>322</span><br><span>323</span><br><span>324</span><br><span>325</span><br><span>326</span><br><span>327</span><br><span>328</span><br><span>329</span><br><span>330</span><br><span>331</span><br><span>332</span><br><span>333</span><br><span>334</span><br><span>335</span><br><span>336</span><br><span>337</span><br><span>338</span><br><span>339</span><br><span>340</span><br><span>341</span><br><span>342</span><br><span>343</span><br><span>344</span><br><span>345</span><br><span>346</span><br><span>347</span><br><span>348</span><br><span>349</span><br><span>350</span><br><span>351</span><br><span>352</span><br><span>353</span><br><span>354</span><br><span>355</span><br><span>356</span><br><span>357</span><br><span>358</span><br><span>359</span><br><span>360</span><br><span>361</span><br><span>362</span><br><span>363</span><br><span>364</span><br><span>365</span><br><span>366</span><br><span>367</span><br><span>368</span><br><span>369</span><br><span>370</span><br><span>371</span><br><span>372</span><br><span>373</span><br><span>374</span><br><span>375</span><br><span>376</span><br><span>377</span><br><span>378</span><br><span>379</span><br><span>380</span><br><span>381</span><br><span>382</span><br><span>383</span><br><span>384</span><br><span>385</span><br><span>386</span><br><span>387</span><br><span>388</span><br><span>389</span><br><span>390</span><br><span>391</span><br><span>392</span><br><span>393</span><br><span>394</span><br><span>395</span><br><span>396</span><br><span>397</span><br><span>398</span><br><span>399</span><br><span>400</span><br><span>401</span><br><span>402</span><br><span>403</span><br><span>404</span><br><span>405</span><br><span>406</span><br><span>407</span><br><span>408</span><br><span>409</span><br><span>410</span><br><span>411</span><br><span>412</span><br><span>413</span><br><span>414</span><br><span>415</span><br><span>416</span><br><span>417</span><br><span>418</span><br><span>419</span><br><span>420</span><br><span>421</span><br><span>422</span><br><span>423</span><br><span>424</span><br><span>425</span><br><span>426</span><br><span>427</span><br><span>428</span><br><span>429</span><br><span>430</span><br><span>431</span><br><span>432</span><br><span>433</span><br><span>434</span><br><span>435</span><br><span>436</span><br><span>437</span><br><span>438</span><br><span>439</span><br><span>440</span><br><span>441</span><br><span>442</span><br><span>443</span><br><span>444</span><br><span>445</span><br><span>446</span><br><span>447</span><br><span>448</span><br><span>449</span><br><span>450</span><br><span>451</span><br><span>452</span><br><span>453</span><br><span>454</span><br><span>455</span><br><span>456</span><br><span>457</span><br><span>458</span><br><span>459</span><br><span>460</span><br><span>461</span><br><span>462</span><br><span>463</span><br><span>464</span><br><span>465</span><br><span>466</span><br><span>467</span><br><span>468</span><br><span>469</span><br><span>470</span><br><span>471</span><br><span>472</span><br><span>473</span><br><span>474</span><br><span>475</span><br><span>476</span><br><span>477</span><br><span>478</span><br><span>479</span><br><span>480</span><br><span>481</span><br><span>482</span><br><span>483</span><br><span>484</span><br><span>485</span><br><span>486</span><br><span>487</span><br><span>488</span><br><span>489</span><br><span>490</span><br><span>491</span><br><span>492</span><br><span>493</span><br><span>494</span><br><span>495</span><br><span>496</span><br><span>497</span><br><span>498</span><br><span>499</span><br><span>500</span><br><span>501</span><br><span>502</span><br><span>503</span><br><span>504</span><br><span>505</span><br><span>506</span><br><span>507</span><br><span>508</span><br><span>509</span><br><span>510</span><br><span>511</span><br><span>512</span><br><span>513</span><br><span>514</span><br><span>515</span><br><span>516</span><br><span>517</span><br><span>518</span><br><span>519</span><br><span>520</span><br><span>521</span><br><span>522</span><br><span>523</span><br><span>524</span><br><span>525</span><br><span>526</span><br><span>527</span><br><span>528</span><br><span>529</span><br><span>530</span><br><span>531</span><br><span>532</span><br><span>533</span><br><span>534</span><br><span>535</span><br><span>536</span><br><span>537</span><br><span>538</span><br><span>539</span><br><span>540</span><br><span>541</span><br><span>542</span><br><span>543</span><br><span>544</span><br><span>545</span><br><span>546</span><br><span>547</span><br><span>548</span><br><span>549</span><br><span>550</span><br><span>551</span><br><span>552</span><br><span>553</span><br><span>554</span><br><span>555</span><br><span>556</span><br><span>557</span><br><span>558</span><br><span>559</span><br><span>560</span><br><span>561</span><br><span>562</span><br><span>563</span><br><span>564</span><br><span>565</span><br><span>566</span><br><span>567</span><br><span>568</span><br><span>569</span><br><span>570</span><br><span>571</span><br><span>572</span><br><span>573</span><br><span>574</span><br><span>575</span><br><span>576</span><br><span>577</span><br><span>578</span><br><span>579</span><br><span>580</span><br><span>581</span><br><span>582</span><br><span>583</span><br><span>584</span><br><span>585</span><br><span>586</span><br><span>587</span><br><span>588</span><br><span>589</span><br><span>590</span><br><span>591</span><br><span>592</span><br><span>593</span><br><span>594</span><br><span>595</span><br><span>596</span><br><span>597</span><br><span>598</span><br><span>599</span><br><span>600</span><br><span>601</span><br><span>602</span><br><span>603</span><br><span>604</span><br><span>605</span><br><span>606</span><br><span>607</span><br><span>608</span><br><span>609</span><br><span>610</span><br><span>611</span><br><span>612</span><br><span>613</span><br><span>614</span><br><span>615</span><br><span>616</span><br><span>617</span><br><span>618</span><br><span>619</span><br><span>620</span><br><span>621</span><br></div></div><p>收集到的信息量非常大，但很幸运，只需关注其中常见的几项即可，比如系统版本号、主机名、IP地址、分区信息、挂载信息。</p>
<p>有了这些信息，就可以去访问这些信息。由于它们都存放在ansible_facts变量中，所以通过这个变量去访问即可。但需要注意的是，对于收集到的绝大多数Facts信息，都有两种访问方式：</p>
<p>(1).一种是debug查看ansible_facts变量得到的结果，这也是真正存储这些信息的方式</p>
<p>(2).一种是命令行执行setup模块输出的方式</p>
<p>直接使用debug模块去输出ansible_facts变量，即可知如何访问这些信息。例如：</p>
<p>要获取eth0的ipv4地址：</p>
<div><pre><code>debug:
  var: ansible_facts.eth0.ipv4.address
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>再看在ansible命令行中执行setup模块的输出信息，会发现原本ansible_facts内几乎所有顶级的key现在都以ansible_开头，例如：</p>
<div><pre><code>debug:
  var: ansible_all_ipv4_addresses
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>之所以可以这样直接访问，是因为Ansible将Facts中绝大多数的顶级key都注入到了Ansible自身维护的变量表(即hostvars)中，这样访问它们就方便的多。</p>
<p>至于采用何种方式访问，这无所谓，但是要知道的是，虽然绝大多数Facts信息都单独定义了变量，但并非所有(主要是那些可能产生歧义或冲突的变量)。</p>
<p>另外再多提醒一句，ansible_facts自身也是变量，它也保存在各自节点的hostvars变量中，所以也可以通过hostvars去访问Facts信息。例如：</p>
<div><pre><code>debug:
  var: hostvars[&#39;logstash2&#39;][&#39;ansible_facts&#39;].eth0.ipv4.address
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>通常情况下，我们在运行play的时候，ansible会先尝试ssh到被控端采集fact，如果此时，被控制端的ssh还没有完全启动，就会导致整个play执行失败。这个时候，我们可以先显示的关闭fact采集，然后在task中通过wait_for等待被控端ssh端口被正常监听，再在task中使用setup模块来手动采集fact：</p>
<div><pre><code>- name: Deploy apps
  hosts: webservers
  gather_facts: false
  tasks：
    - name: wait for ssh to be running
      local_action: wait_for port=22 host=&quot;{{ inventory_hostname }}&quot; search_regex=OpenSSH
    - name: gather facts
      setup:
    ......
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="_4-启用fact缓存"> 4 启用fact缓存</h2>
<p>如果在play中需要引入fact，则可以开启fact缓存。fact缓存目前支持三种存储方式，分别为JSON、memcached、redis。</p>
<p>redis：缓存在redis服务中，直到目前(Ansible 2.9)为止，Ansible还不支持指定连接redis的端口、密码等</p>
<p>1.gathering：控制Ansible是否自动收集Facts，它有三种值：</p>
<p>(1).implicit：这是默认值，表示执行play时会自动收集Facts，除非显式指定gather_facts: false禁止收集</p>
<p>(2).explicit：不自动收集Facts，除非显式指定gather_facts: true开启收集</p>
<p>(3).smart：自动收集Facts，但如果已存在(缓存)则不重复收集</p>
<h3 id="_4-1-json文件fact缓存后端"> 4.1 Json文件fact缓存后端</h3>
<p>使用JSON文件作为fact缓存后端的时候，ansible将会把采集的fact写入到控制主机的文件中。</p>
<p>ansible.cfg配置如下：</p>
<div><pre><code>[defaults]
gathering = smart
#缓存时间，单位为秒
fact_caching_timeout = 86400    
fact_caching = jsonfile
#指定ansible包含fact的json文件位置，如果目录不存在，会自动创建
fact_caching_connection = /tmp/ansible_fact_cache    
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_4-2-redis-fact缓存后端"> 4.2  Redis fact缓存后端</h3>
<p>使用redis作为fact缓存后端，需要在控制主机上安装redis服务并保持运行。需要安装python操作redis的软件包。</p>
<p>ansible.cfg配置如下：</p>
<div><pre><code>[defaults]
gathering = smart
fact_caching_timeout = 86400 
fact_caching = redis
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_4-3-memcached-fact缓存后端"> 4.3 Memcached fact缓存后端</h3>
<p>使用memcached作为fact缓存后端，需要在控制主机上安装Memcached服务并保持运行，需要安装python操作memcached的软件包。</p>
<p>ansible.cfg配置如下：</p>
<div><pre><code>[defaults]
gathering = smart
fact_caching_timeout = 86400 
fact_caching = memcached
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="_5-关闭fact"> 5 关闭fact</h2>
<p>如果不想从fact中获取变量，或者说整个playbook当中都没有使用到fact变量，可以通过如下方法关闭fact以提升执行效率：</p>
<div><pre><code>- hosts: test
  gather_facts: false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>也可以在ansible.cfg中添加如下配置：</p>
<div><pre><code>[defaults]
gathering = explicit
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="_6-委托facts"> 6 委托Facts</h2>
<p>略：我暂时还没有用到</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">1 初识Ansible</title>
    <id>https://clay-wangzhi.com/automate/ansible/first/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/first/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_1-初识ansible"> 1 初识Ansible</h1>
<h2 id="_1-ansible简介"> 1 Ansible简介</h2>
<p>Ansible官方文档： https://docs.ansible.com/</p>
<p>Ansible 是一个 IT 自动化工具。它能配置系统、部署软件、编排更复杂的 IT 任务，如连续部署或零停机时间滚动更新。</p>
<p>Ansible 用 python 编写，尽管市面上已经有很多可供选择的配置管理解决方案（例如 Salt，Puppet，Chef等），但它们各有优劣，而Ansible的特点在于它的简洁。让 Ansible 在主流的配置管理系统中与众不同的一点便是，它并不需要你在想要配置的每个节点上安装自己的组件。同时提供的一个优点在于，如果需要的话，你可以在不止一个地方控制你的整个基础架构。</p>
<h3 id="_1-1-ansible特性"> 1.1 Ansible特性</h3>
<ul>
<li>Agentless：不需要再被管理节点上安装客户端，只要有sshd即可</li>
<li>幂等性：多次操作或多次执行不影响结果。</li>
<li>Serverless：在服务端不需要启动任何服务，只需要执行命令就行</li>
<li>Modules in any language：基于模块工作，可以使用任意语言开发ansible模块</li>
<li>YAML, not code：使用yaml语言定制playbook</li>
<li>SSH by default：默认使用ssh控制各节点</li>
<li>Strong multi-tier solution：可实现多级控制</li>
</ul>
<blockquote>
<p>幂等性详细解释：比如算术运算时数值加0是幂等的，无论加多少次结果都不会改变，而数值加1是非幂等的，每次加1结果都会改变。再比如执行systemctl stop xxx命令来停止服务,当发现要停止的目标服务已经处于停止状态，它什么也不会做，所以多次停止的结果仍然是停止，不会改变结果，它是幂等的，而systemctl restart xxx是非幂等的。Ansible的很多 模块在执行时都会先判断目标节点是否要执行任务,所以，可以放心大胆地让Ansible去执行任务,重复执行某个任务绝大多数时候不会产生任何副作用。</p>
</blockquote>
<h3 id="_1-2-ansible的基本组件"> 1.2 Ansible的基本组件</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/ansible1-1585014469983.png" alt="ansible1" /></p>
<ul>
<li>核心：ansible</li>
<li>核心模块（Core Modules）：这些都是ansible自带的模块</li>
<li>扩展模块（Custom Modules）：如果核心模块不足以完成某种功能，可以添加扩展模块</li>
<li>插件（Plugins）：完成模块功能的补充</li>
<li>剧本（Playbooks）：把需要完成的多个任务定义在剧本中</li>
<li>连接插件（Connectior Plugins）：ansible基于连接插件连接到各个主机上，虽然ansible是使用ssh连接到各个主机的，但是它还支持其他的连接方法，所以需要有连接插件</li>
<li>主机群（Host Inventory）：ansible在管理多台主机时，可以选择只对其中的一部分执行某些操作</li>
</ul>
<h3 id="_1-3-ansible工作机制"> 1.3 Ansible工作机制</h3>
<p>Ansible 在管理节点将 Ansible 模块通过 SSH 协议（或者 Kerberos、LDAP）推送到被管理端执行，执行完之后自动删除，可以使用版本控制系统（git/svn）来管理自定义模块及playbooks。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/ansible2-1585014469997.png" alt="ansible2" /></p>
<h2 id="_2-ansible安装"> 2 Ansible安装</h2>
<h3 id="_2-1-yum-安装-推荐"> 2.1 yum 安装（推荐）</h3>
<div><pre><code><span># 配置epel源</span>
<span>cat</span> <span>></span> /etc/yum.repos.d/epel.repo <span>&lt;&lt;</span><span>'EOF'
[epel]
name=epel repo
baseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/7/$basearch
enabled=1
gpgcheck=0
EOF</span>
<span># 安装</span>
yum -y <span>install</span> ansible
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>'EOF'，EOF用单引号括起来，可使配置文件中变量<code>$basearch</code>不被转义</p>
</blockquote>
<h3 id="_2-2-源码安装-推荐"> 2.2 源码安装（推荐）</h3>
<div><pre><code><span># 解决依赖关系：</span>
yum <span>install</span> -y python36 python36-devel python36-setuptools gcc libffi-devel openssl-devel

<span># 配置pip 下载源</span>
<span>mkdir</span> ~/.pip
<span>cat</span> <span>></span> ~/.pip/pip.conf <span>&lt;&lt;</span> <span>'EOF'
[global] 
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
[install]
trusted-host = https://pypi.tuna.tsinghua.edu.cn
EOF</span>

 
<span># 下载ansible：</span>
<span>wget</span> https://github.com/ansible/ansible/archive/v2.9.17.tar.gz

<span>#解压安装</span>

<span>tar</span> xf v2.9.17.tar.gz
<span>cd</span> ansible-2.9.17/
python3 setup.py build
python3 setup.py <span>install</span> <span># install 过程安装module失败时，使用pip3手动安装</span>
<span>mkdir</span> /etc/ansible
<span>cp</span> -r examples/* /etc/ansible
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="_2-3-pip-安装"> 2.3  pip 安装</h3>
<p>Ansible每个版本释放出来之后，都首先提交到Pypi,所以任何操作系统，都可以使用pip工具来安装最新版的Ansible。</p>
<div><pre><code>pip3 <span>install</span> ansible
</code></pre>
<div><span>1</span><br></div></div><p>但要注意，使用各系统的包管理I具(如yum)安装Ansible时自动会提供-些配置文件，如/etc/ansible/ansible. cfg。而使用pip安装的Ansible默认不提供配置文件。</p>
<h2 id="_3-ansible-参数补全功能"> 3 Ansible 参数补全功能</h2>
<p>从Ansible 2.9版本开始，它支持命令的选项补全功能，它依赖于python的argcomplete插件</p>
<p>安装argcomplete:</p>
<div><pre><code>yum -y install python-argcomplete
pip3 install argcomplete
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>安装完成后，激活插件</p>
<div><pre><code>activate-global-python-argcomplete 
</code></pre>
<div><span>1</span><br></div></div><p>重新进去终端，即可使用tab参数补全功能</p>
<h2 id="_4-ansible配置文件管理"> 4 Ansible配置文件管理</h2>
<h3 id="_4-1-配置文件优先级"> 4.1 配置文件优先级</h3>
<p>ansible的配置文件名为ansible.cfg，它一般会存在于四个地方：</p>
<ul>
<li>ANSIBLE_CONFIG：首先，Ansible命令会检查该环境变量，及这个环境变量将指向的配置文件</li>
<li>./ansible.cfg：当前工作目录，即当前执行ansible指令的目录，如果ANSIBEL_CONFIG环境变量未定义，则优先使用该配置文件</li>
<li>~/.ansible.cfg：当前用户家目录下的一个隐藏文件，如果当前工作目录下不存在ansible.cfg配置文件，则会查找用户家目录下的该隐藏文件</li>
<li>/etc/ansible/ansible.cfg：默认配置文件，如果上面两个路径下的ansible.cfg都不存在，则使用该文件</li>
</ul>
<blockquote>
<p>需要说明的是，配置文件中所有的配置项都可以通过环境变量的方式来定义，而环境变量定义的配置项具有最高优先级，会覆盖掉所有配置文件中的配置项</p>
</blockquote>
<h3 id="_4-2-配置文件详解"> 4.2 配置文件详解</h3>
<p>Ansible 配置文件采用ini风格进行配置，每一项配置都使用<code>key=value</code>的方式进行配置</p>
<h4 id="_4-2-1-配置文件分段说明"> 4.2.1 配置文件分段说明</h4>
<p>ansible.cfg的配置默认分为十段：</p>
<ul>
<li>[defaults]：通用配置项</li>
<li>[inventory]：与主机清单相关的配置项</li>
<li>[privilege_escalation]：特权升级相关的配置项</li>
<li>[paramiko_connection]：使用paramiko连接的相关配置项，Paramiko在RHEL6以及更早的版本中默认使用的ssh连接方式</li>
<li>[ssh_connection]：使用OpenSSH连接的相关配置项，OpenSSH是Ansible在RHEL6之后默认使用的ssh连接方式</li>
<li>[persistent_connection]：持久连接的配置项</li>
<li>[accelerate]：加速模式配置项</li>
<li>[selinux]：selinux相关的配置项</li>
<li>[colors]：ansible命令输出的颜色相关的配置项</li>
<li>[diff]：定义是否在运行时打印diff（变更前与变更后的差异）</li>
</ul>
<h4 id="_4-2-2-配置参数说明"> 4.2.2 配置参数说明</h4>
<div><pre><code>[default]
inventory      = /etc/ansible/hosts
remote_user    = root
ask_pass       = false
log_path       = /var/log/ansible.log

[privilege_escalation]
become=True
become_method=sudo
become_user=root
become_ask_pass=False

[ssh_connection]
ssh_args = -C -o ControlMaster=auto -o ControlPersist=60s 
host_key_checking = False 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>配置项说明：</p>
<ul>
<li>inventory：定义默认使用的主机清单</li>
<li>remote_user： ansible在操作远程主机时，使用远程主机上的哪个用户身份，默认是root</li>
<li>ask_pass：ansible在操作远程主机时，获取远程主机上的用户身份，是否交互提示密码验证，默认为true。如果使用密钥认证的话，建议将其设置为false</li>
<li>log_path：默认ansible 执行的时候，并不会输出日志到文件，打开该配置项，所有的命令执行后，都会将日志输出到<code>/var/log/ansible.log</code>文件。</li>
<li>become：如果ansible在操作远程主机时，使用的是远程主机上的普通用户，该普通用户是否允许提权</li>
<li>become_method：如果允许提权，使用何种提权方式，默认是sudo</li>
<li>become_user：提权到哪个用户身份，默认是root</li>
<li>become_ask_pass：提权时，是否交互提示密码验证，默认为False</li>
<li>ssh_args：ansible通过ssh连接远程被管理机，这里用于定义一些ssh连接时的参数，如-C启用压缩传输，ControlPersist用于提升性能。</li>
<li>host_key_checking：通过ssh首次连接远程主机时，由于在本机的<code>~/.ssh/known_hosts</code>文件中并有<code>fingerprint key</code>串，ssh第一次连接的时候一般会提示输入yes/no进行确认将key字符串加入到<code>~/.ssh/known_hosts</code>文件中。将此项设置为False将跳过该确认过程。</li>
</ul>
<blockquote>
<p>参考链接：</p>
<p>https://www.cnblogs.com/breezey/p/8810263.html</p>
<p>https://blog.51cto.com/cloumn/blog/1540</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">2 Ansible Inventory配置详解</title>
    <id>https://clay-wangzhi.com/automate/ansible/inventory/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/inventory/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_2-ansible-inventory配置详解"> 2 Ansible Inventory配置详解</h1>
<p>在使用Ansible来批量管理主机的时候，通常我们需要先定义要管理哪些主机或者主机组，而这个用于管理主机与主机组的文件就叫做Inventory，也叫主机清单。</p>
<p>Ansible Inventory 是包含<code>静态 Inventory</code> 和<code>动态 Inventory</code> 两部分的，静态 Inventory 指的是在文件中指定的主机和组，动态 Inventory 指通过外部脚本获取主机列表，并按照 ansible 所要求的格式返回给 ansilbe 命令的。</p>
<h2 id="_1-inventory文件路径"> 1 inventory文件路径</h2>
<p>默认的inventory文件是<code>/etc/ansible/hosts</code>，可以通过Ansible配置文件的inventory配置指令去修改路径。</p>
<div><pre><code>$ grep &#39;/etc/ansible/hosts&#39; /etc/ansible/ansible.cfg
#inventory = /etc/ansible/hosts
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但通常我们不会去修改这个配置项，如果在其它地方定义了inventory文件，可以直接在ansible的命令行中使用-i选项去指定我们自定义的inventory文件。</p>
<p><strong>多个inventory文件</strong></p>
<p>当Ansible要管理的节点非常多时，仅靠分组的逻辑可能也不足够方便管理，这个时候可以定义多个inventory文件并放在一个目录下， 并按一定的命名规则为每 个inventory命名，以便见名知意。</p>
<p>现在要使用多个inventory的功能，需要将inventory指定为目录路径。</p>
<p>例如，Ansible配置文件将inventory指令设置为对应的目录:</p>
<div><pre><code>inventory <span>=</span> /etc/ansible/inventorys 
</code></pre>
<div><span>1</span><br></div></div><p>inventory指定为目:录时，inventory文件最好不要带有后缀， 就像示例中的a和b文件。因为Ansible当使用目录作为inventory时，默认将忽略一些后缀的文件不去解析。 需要修改配置:文件中的inventory_ ignore_ extensions 项来禁止忽略指定后缀(如ini后缀)的文件。</p>
<div><pre><code><span>#inventory_ ignore_ extensions=~, .orig, .bak, .in, .cfg, .retry, .pyc, .pyo</span>
inventory_ ignore_ extensions <span>=</span> ~, .orig, .bak, .cfg, .retry, .pyC, .pyo
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="_2-静态inventory"> 2 静态Inventory</h2>
<h3 id="_2-1-定义主机和组"> 2.1 定义主机和组</h3>
<blockquote>
<p>定义主机清单，有多种格式，常用的有<code>ini</code>格式和<code>YAML</code>（Ansible 2.4开始支持）格式，我倾向于使用<code>YAML</code>格式，下面的举例中，两种格式都会提到。</p>
<p><strong>Ansible 默认预定义了两个主机组：<code>all</code>分组（所有主机）和<code>ungrouped</code>分组（不在分组内的主机），两个组都不包括localhost这个特殊的节点</strong></p>
</blockquote>
<p>对于/etc/ansible/hosts最简单的定义格式像下面：</p>
<h4 id="_2-1-1-简单的主机和组"> 2.1.1 简单的主机和组</h4>
<p>In INI:</p>
<div><pre><code><span># 中括号中的名字代表组名，可以根据自己的需求将庞大的主机分成具有标识的组，如上面分了两个组webservers和dbservers组；  </span>
<span># 主机(hosts)部分可以使用域名、主机名、IP地址表示；当然使用前两者时，也需要主机能反解析到相应的IP地址，一般此类配置中多使用IP地址；</span>
mail.example.com

<span>[</span>webservers<span>]</span>
foo.example.com
bar.example.com

<span>[</span>dbservers<span>]</span>
one.example.com
two.example.com
three.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>In YAML:</p>
<div><pre><code>all:
  hosts:
    mail.example.com:
  children:
    webservers:
      hosts:
        foo.example.com:
        bar.example.com:
    dbservers:
      hosts:
        one.example.com:
        two.example.com:
        three.example.com:
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="_2-1-2-指定主机范围"> 2.1.2  指定主机范围</h4>
<p>In INI:</p>
<div><pre><code><span># 下面指定了从web01到web50，webservers组共计50台主机；databases组有db-a到db-f共6台主机</span>
<span>[</span>webservers<span>]</span>
www<span>[</span>01:50<span>]</span>.example.com
<span>[</span>databases<span>]</span>
db-<span>[</span>a:f<span>]</span>.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>In YAML:</p>
<div><pre><code>all:
  children:
  	webservers:
      hosts:
        www[01:50].example.com:
    databases:
      hosts:
        db-[a:f].example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="_2-1-3-定义主机组嵌套"> 2.1.3 定义主机组嵌套</h4>
<p>一个主机组可以包含若干个子主机组：</p>
<p>In INI:</p>
<div><pre><code><span># 如下示例中，production组包含两个子组，分别为webservers和dbservers，webservers和dbservers组分别包含若干主机</span>
<span>[</span>webservers<span>]</span>
foo.example.com
bar.example.com

<span>[</span>dbservers<span>]</span>
one.example.com
two.example.com
three.example.com

<span>[</span>production:children<span>]</span>
webservers
dbservers
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>In YAML:</p>
<div><pre><code>all:
  children:
    webservers:
      hosts:
        foo.example.com:
        bar.example.com:
    dbservers:
      hosts:
        one.example.com:
        two.example.com:
        three.example.com:
    production:
      children:
        webservers:
        dbservers:
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="_2-1-4-添加主机变量"> 2.1.4 添加主机变量</h4>
<p>不同ansible版本，行为控制变量名称可能不同，比如以前版本中端口号的行为变量是<code>ansible_ssh_port</code></p>
<p>下面是常见的行为变量：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20210309153531453.png" alt="image-20210309153531453" /></p>
<p>In INI:</p>
<div><pre><code>[atlanta]
host1 http_port=80 maxRequestsPerChild=808 ansible_port=5555 ansible_host=192.0.2.50
host2 http_port=303 maxRequestsPerChild=909
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>In YAML:</p>
<div><pre><code>atlanta:
  host1:
    http_port: 80
    maxRequestsPerChild: 808
    ansible_port: 5555
    ansible_host: 192.0.2.50
  host2:
    http_port: 303
    maxRequestsPerChild: 909
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="_2-1-5-添加组变量"> 2.1.5 添加组变量</h4>
<p>In INI:</p>
<div><pre><code>[atlanta]
host1
host2

[atlanta:vars]
ntp_server=ntp.atlanta.example.com
proxy=proxy.atlanta.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>In YAML:</p>
<div><pre><code>atlanta:
  hosts:
    host1:
    host2:
  vars:
    ntp_server: ntp.atlanta.example.com
    proxy: proxy.atlanta.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>集成变量值</strong></p>
<p>In INI:</p>
<div><pre><code>[atlanta]
host1
host2

[raleigh]
host2
host3

[southeast:children]
atlanta
raleigh

[southeast:vars]
some_server=foo.southeast.example.com
halon_system_timeout=30
self_destruct_countdown=60
escape_pods=2

[usa:children]
southeast
northeast
southwest
northwest
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>In YAML:</p>
<div><pre><code>all:
  children:
    usa:
      children:
        southeast:
          children:
            atlanta:
              hosts:
                host1:
                host2:
            raleigh:
              hosts:
                host2:
                host3:
          vars:
            some_server: foo.southeast.example.com
            halon_system_timeout: 30
            self_destruct_countdown: 60
            escape_pods: 2
        northeast:
        northwest:
        southwest:
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h4 id="_2-1-6-组织主机和组变量-配置单独变量文件host-vars和group-vars"> 2.1.6 组织主机和组变量(配置单独变量文件host_vars和group_vars)</h4>
<p>尽管可以将变量存储在主清单文件中，但是存储单独的主机变量和组变量文件可以帮助您更轻松地组织变量值。 主机和组变量文件必须使用YAML语法。 有效的文件扩展名包括“ .yml”，“。yaml”，“。json”或没有文件扩展名。</p>
<p>Ansible通过搜索相对于清单文件或剧本文件的路径来加载主机和组变量文件。 如果<code>/etc/ansible/hosts</code>上的清单文件包含名为“ foosball”的主机，该主机属于“ raleigh”和“ webservers”两个组，则该主机将在以下位置的YAML文件中使用变量：</p>
<div><pre><code>/etc/ansible/group_vars/raleigh # can optionally end in &#39;.yml&#39;, &#39;.yaml&#39;, or &#39;.json&#39;
/etc/ansible/group_vars/webservers
/etc/ansible/host_vars/foosball
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例如，如果按数据中心将清单中的主机分组，并且每个数据中心使用其自己的NTP服务器和数据库服务器，则可以创建一个名为<code>/etc/ansible/group_vars/raleigh</code>的文件来存储raleigh组的变量：</p>
<div><pre><code>---
ntp_server: acme.example.org
database_server: storage.example.org
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>再来总结一下group_vars/, host_vars/的存放位置：</p>
<p>(1).inventory文件的同目录</p>
<p>(2).playbook文件的同目录</p>
<h3 id="_2-2-选择主机与组-hosts指令"> 2.2 选择主机与组(hosts指令)</h3>
<p>在前面定义Inventory的时候，我们会把所有被管理主机通过主机组的方式定义到Inventory当中，但是当我们实际使用的时候，可能只需要对某一主机或主机组进行操作，这个时候就需要通过匹配的方式指定某一特定主机或主机组。</p>
<p>在此之间，我们先定义一个主机清单示例：</p>
<div><pre><code>srv1.example.com
srv2.example.com
s1.lab.example.com
s2.lab.example.com

<span>[</span>web<span>]</span>
jupiter.lab.example.com
saturn.example.com

<span>[</span>db<span>]</span>
db1.example.com
db2.example.com
db3.example.com

<span>[</span>lb<span>]</span>
lb1.lab.example.com
lb2.lab.example.com

<span>[</span>boston<span>]</span>
db1.example.com
jupiter.lab.example.com
lb2.lab.example.com

<span>[</span>london<span>]</span>
db2.example.com
db3.example.com
file1.lab.example.com
lb1.lab.example.com

<span>[</span>dev<span>]</span>
web1.lab.example.com
db3.example.com

<span>[</span>stage<span>]</span>
file2.example.com
db2.example.com

<span>[</span>prod<span>]</span>
lb2.lab.example.com
db1.example.com
jupiter.lab.example.com

<span>[</span>function:children<span>]</span>
web
db
lb
city

<span>[</span>city:children<span>]</span>
boston
london
environments

<span>[</span>environments:children<span>]</span>
dev
stage
prod
new

<span>[</span>new<span>]</span>
<span>172.25</span>.252.23
<span>172.25</span>.252.44
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><p>使用更为专业的<code>ansible-inventory</code>命令来查看主机组信息</p>
<div><pre><code> <span># 树状形式展开主机列表</span>
 ansible-inventory all --graph
 <span># 同时带上变量</span>
 ansible-inventory all --graph --vars
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="_2-2-1-匹配所有主机"> 2.2.1 匹配所有主机</h4>
<p>可以通过<code>all</code>或者<code>*</code>来指定匹配所有主机，通过如下指令查看<code>all</code>匹配到的主机：</p>
<div><pre><code><span># ansible all --list-hosts</span>
  hosts <span>(</span><span>16</span><span>)</span>:
    srv1.example.com
    srv2.example.com
    s1.lab.example.com
    s2.lab.example.com
    jupiter.lab.example.com
    saturn.example.com
    db1.example.com
    db2.example.com
    db3.example.com
    lb1.lab.example.com
    lb2.lab.example.com
    file1.lab.example.com
    web1.lab.example.com
    file2.example.com
    <span>172.25</span>.252.23
    <span>172.25</span>.252.44
    <span>172.25</span>.252.32
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h4 id="_2-2-2-匹配指定的主机或主机组"> 2.2.2 匹配指定的主机或主机组</h4>
<ol>
<li>匹配单个组</li>
</ol>
<div><pre><code><span># ansible prod --list-hosts</span>
  hosts <span>(</span><span>3</span><span>)</span>:
    lb2.lab.example.com
    db1.example.com
    jupiter.lab.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="2">
<li>匹配单个主机</li>
</ol>
<div><pre><code><span># ansible db2.example.com --list-hosts</span>
  hosts <span>(</span><span>1</span><span>)</span>:
    db2.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="3">
<li>匹配多个主机</li>
</ol>
<div><pre><code># ansible &#39;lb1.lab.example.com,s1.lab.example.com,db1.example.com&#39; --list-hosts  
  hosts (3):
    lb1.lab.example.com
    s1.lab.example.com
    db1.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="4">
<li>匹配多个组</li>
</ol>
<div><pre><code><span># ansible 'london,boston' --list-hosts</span>
  hosts <span>(</span><span>7</span><span>)</span>:
    db2.example.com
    db3.example.com
    file1.lab.example.com
    lb1.lab.example.com
    db1.example.com
    jupiter.lab.example.com
    lb2.lab.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol start="5">
<li>匹配不属于任何组的主机</li>
</ol>
<div><pre><code><span># ansible ungrouped --list-hosts</span>
  hosts <span>(</span><span>4</span><span>)</span>:
    srv1.example.com
    srv2.example.com
    s1.lab.example.com
    s2.lab.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="_2-2-4-通配符匹配"> 2.2.4 通配符匹配</h4>
<ol>
<li>匹配'*.example.com'：</li>
</ol>
<div><pre><code><span># ansible '*.example.com' --list-hosts</span>
  hosts <span>(</span><span>14</span><span>)</span>:
    srv1.example.com
    srv2.example.com
    s1.lab.example.com
    s2.lab.example.com
    jupiter.lab.example.com
    saturn.example.com
    db1.example.com
    db2.example.com
    db3.example.com
    lb1.lab.example.com
    lb2.lab.example.com
    file1.lab.example.com
    web1.lab.example.com
    file2.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ol start="2">
<li>匹配<code>172.25.*</code>的主机：</li>
</ol>
<div><pre><code># ansible &#39;172.25.*&#39; --list-hosts                         
  hosts (3):
    172.25.252.23
    172.25.252.44
    172.25.252.32
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="3">
<li>匹配以<code>s</code>开头的主机及主机组：</li>
</ol>
<div><pre><code># ansible &#39;s*&#39; --list-hosts
  hosts (7):
    file2.example.com
    db2.example.com
    srv1.example.com
    srv2.example.com
    s1.lab.example.com
    s2.lab.example.com
    saturn.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="_2-2-5-通配符组合匹配"> 2.2.5  通配符组合匹配</h4>
<ol>
<li>匹配包含<code>*.example.com</code>但不包含<code>*.lab.example.com</code>的主机：</li>
</ol>
<div><pre><code># ansible &#39;*.example.com,!*.lab.example.com&#39; --list-hosts  
  hosts (7):
    srv1.example.com
    srv2.example.com
    saturn.example.com
    db1.example.com
    db2.example.com
    db3.example.com
    file2.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol start="2">
<li>匹配包含prod以及172开头、包含lab关键字的主机或组</li>
</ol>
<div><pre><code># ansible &#39;prod,172*,*lab*&#39; --list-hosts
  hosts (11):
    lb2.lab.example.com
    db1.example.com
    jupiter.lab.example.com
    172.25.252.23
    172.25.252.44
    172.25.252.32
    s1.lab.example.com
    s2.lab.example.com
    lb1.lab.example.com
    file1.lab.example.com
    web1.lab.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ol start="3">
<li>匹配属于db组同时还属于london组的主机：</li>
</ol>
<div><pre><code># ansible &#39;db,&amp;london&#39; --list-hosts
  hosts (2):
    db2.example.com
    db3.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="4">
<li>匹配在london组或者boston组，还必须在prod组中且必须不在lb组中的主机：</li>
</ol>
<div><pre><code><span># ansible 'boston,london,&amp;prod,!lb' --list-hosts</span>
  hosts <span>(</span><span>2</span><span>)</span>:
    db1.example.com
    jupiter.lab.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>主机列表一定要用 单引号 ''</p>
</blockquote>
<h4 id="_2-2-6-正则表达式匹配"> 2.2.6 正则表达式匹配</h4>
<p>在开头的地方使用”~”，用来表示这是一个正则表达式:</p>
<div><pre><code><span># ansible '~(s|db).*example\.com' --list-hosts</span>
  hosts <span>(</span><span>8</span><span>)</span>:
    srv1.example.com
    srv2.example.com
    s1.lab.example.com
    s2.lab.example.com
    saturn.example.com
    db1.example.com
    db2.example.com
    db3.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="_2-2-7-通过-limit或-l明确指定主机或组"> 2.2.7 通过<code>--limit</code>或<code>-l</code>明确指定主机或组</h4>
<p>默认情况下，所有被ansible或ansible-playbook选中的主机都会执行任务，但是可以使用命令行的--limit pattern选项来筛选哪些主机执行任务哪些主机不执行任务。</p>
<p>这里需注意一点：即使使用了--limit选项，ansible或ansible-playbook命令也总是会解析Inventory中的所有主机，只不过这两个命令可以从解析的inventory结果中选择部分要执行任务的节点(比如通过hosts指令)。</p>
<p>所以，总结下这里涉及到的解析和筛选节点的过程：</p>
<div><pre><code>解析inventory --&gt; play的hosts指令 --&gt; limit选项
</code></pre>
<div><span>1</span><br></div></div><ol>
<li>通过<code>--limit</code>在选定的组中明确指定主机：</li>
</ol>
<div><pre><code># ansible ungrouped  --limit srv1.example.com --list-hosts
  hosts (1):
    srv1.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li>通过<code>--limit</code>参数，还可以指定一个文件，该文件中定义明确指定的主机的列表，定义一个retry_hosts.txt如下：</li>
</ol>
<div><pre><code>srv1.example.com
</code></pre>
<div><span>1</span><br></div></div><p>再次执行ansible指令如下：</p>
<div><pre><code><span># ansible ungrouped  --limit @retry_hosts.txt --list-hosts</span>
  hosts <span>(</span><span>1</span><span>)</span>:
    srv1.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="_3-动态inventory"> 3 动态Inventory</h2>
<p>这部分一般会结合 CMDB 资管系统、云计算平台等获取主机信息。由于主机资源一般会动态的进行增减，而这些系统一般会智能更新。我们可以通过这些工具提供的 API 或者接入库查询等方式返回主机列表。</p>
<p>比如为了结合资产管理系统（CMDB），所以要使用到动态获取 inventory 的方法，这样可以省去配置 ansible 服务端的 hosts，所有的客户端 IP、帐号、密码、端口都可以从 CMDB 中获取到。</p>
<p>只要你的脚本输出格式是满足要求的 JSON，这样就可以成为一个动态的资产生成器。</p>
<h3 id="_3-1-脚本规约"> 3.1 脚本规约</h3>
<p>用于生成 JSON 的脚本对实现语言没有要求，它可以是一个可执行脚本、二进制文件，或者其他任何可以运行文件，但是必须输出为 JSON 格式，同时必须支持两个参数：<code>--list</code> 和 <code>--host</code>。</p>
<ul>
<li>
<p><code>--list</code>：用于返回所有的主机组信息，每个组所包含的主机列表 <code>hosts</code>、所含子组列表 <code>children</code>、主机组变量列表 <code>vars</code> 都应该是字典形式的，<code>_meta</code> 用来存放主机变量。</p>
</li>
<li>
<p><code>--host</code>：返回指定主机的变量列表，或者返回一个空的字典脚本实现</p>
</li>
</ul>
<h3 id="_3-2-脚本实现"> 3.2 脚本实现</h3>
<p>一个参考实现框架如下：</p>
<div><pre><code><span>#!/usr/bin/env python3</span>
<span>#coding:utf8</span>
<span>import</span> json
<span>import</span> sys
 
<span>def</span> <span>all</span><span>(</span><span>)</span><span>:</span>
    info_dict <span>=</span> <span>{</span>
    <span>"all"</span><span>:</span><span>[</span>
        <span>"10.10.0.109"</span><span>,</span>
        <span>"10.10.0.112"</span><span>]</span>
    <span>}</span>
    <span>print</span><span>(</span>json<span>.</span>dumps<span>(</span>info_dict<span>,</span>indent<span>=</span><span>4</span><span>)</span><span>)</span>
 
<span>def</span> <span>group</span><span>(</span><span>)</span><span>:</span>
    host1 <span>=</span> <span>[</span><span>'10.10.0.112'</span><span>]</span>
    host2 <span>=</span> <span>[</span><span>'10.10.0.112'</span><span>,</span><span>'10.10.0.109'</span><span>]</span>
    group1 <span>=</span> <span>'test1'</span>
    group2 <span>=</span> <span>'test2'</span>
    hostdata <span>=</span> <span>{</span>
        group1<span>:</span><span>{</span><span>"hosts"</span><span>:</span>host1<span>}</span><span>,</span>
        group2<span>:</span><span>{</span><span>"hosts"</span><span>:</span>host2<span>}</span>
    <span>}</span>
    <span>print</span><span>(</span>json<span>.</span>dumps<span>(</span>hostdata<span>,</span>indent<span>=</span><span>4</span><span>)</span><span>)</span>
 
<span>def</span> <span>host</span><span>(</span>ip<span>)</span><span>:</span>
    info_dict <span>=</span> <span>{</span>
        <span>"10.10.0.112"</span><span>:</span> <span>{</span>
            <span>"ansible_ssh_host"</span><span>:</span><span>"10.10.0.112"</span><span>,</span>
            <span>"ansible_ssh_port"</span><span>:</span><span>22</span><span>,</span>
            <span>"ansible_ssh_user"</span><span>:</span><span>"root"</span><span>,</span>
            <span>"ansible_ssh_pass"</span><span>:</span><span>"123457"</span>
        <span>}</span><span>,</span>
        <span>"10.10.0.109"</span><span>:</span> <span>{</span>
            <span>"ansible_ssh_host"</span><span>:</span><span>"10.10.0.109"</span><span>,</span>
            <span>"ansible_ssh_port"</span><span>:</span><span>22</span><span>,</span>
            <span>"ansible_ssh_user"</span><span>:</span><span>"root"</span><span>,</span>
            <span>"ansible_ssh_pass"</span><span>:</span><span>"xxxx"</span>
        <span>}</span>
    <span>}</span>
    <span>print</span><span>(</span>json<span>.</span>dumps<span>(</span>info_dict<span>,</span>indent<span>=</span><span>4</span><span>)</span><span>)</span>
 
<span>if</span> <span>len</span><span>(</span>sys<span>.</span>argv<span>)</span> <span>==</span> <span>2</span> <span>and</span> <span>(</span>sys<span>.</span>argv<span>[</span><span>1</span><span>]</span> <span>==</span> <span>'--list'</span><span>)</span><span>:</span>
    group<span>(</span><span>)</span>
<span>elif</span> <span>len</span><span>(</span>sys<span>.</span>argv<span>)</span> <span>==</span> <span>3</span> <span>and</span> <span>(</span>sys<span>.</span>argv<span>[</span><span>1</span><span>]</span> <span>==</span> <span>'--host'</span><span>)</span><span>:</span>
    host<span>(</span>sys<span>.</span>argv<span>[</span><span>2</span><span>]</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>"Usage: %s --list or --host &lt;hostname>"</span> <span>%</span> sys<span>.</span>argv<span>[</span><span>0</span><span>]</span><span>)</span>
    sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h3 id="_3-3-结合cmdb动态获取"> 3.3 结合CMDB动态获取</h3>
<p>这个脚本主要是结合底层为<code>openstack</code>的私有云中的mysql实现的</p>
<div><pre><code><span>#!/usr/bin/env python3</span>
<span># coding:utf-8</span>

<span>import</span> pymysql
<span>import</span> json
<span>import</span> sys

conn <span>=</span> pymysql<span>.</span>connect<span>(</span>
    host<span>=</span><span>"192.168.*.*"</span><span>,</span>
    user<span>=</span><span>"root"</span><span>,</span>
    password<span>=</span><span>"****"</span><span>,</span>
    database<span>=</span><span>"***"</span><span>,</span>
    charset<span>=</span><span>"utf8"</span><span>)</span>


<span>def</span> <span>get_result</span><span>(</span>sql<span>)</span><span>:</span>
    <span>try</span><span>:</span>
        <span>with</span> conn<span>.</span>cursor<span>(</span><span>)</span> <span>as</span> cursor<span>:</span>
            cursor<span>.</span>execute<span>(</span>sql<span>)</span>
            result <span>=</span> cursor<span>.</span>fetchall<span>(</span><span>)</span>
            <span>return</span> result
    <span>except</span> Exception <span>as</span> e<span>:</span>
        <span>raise</span> e


<span>def</span> <span>get_all_group</span><span>(</span><span>)</span><span>:</span>
    sql <span>=</span> <span>"SELECT instances.user_id FROM nova.instances GROUP BY instances.user_id"</span>
    group_list <span>=</span> get_result<span>(</span>sql<span>)</span>
    <span>return</span> group_list


<span>def</span> <span>group_sql</span><span>(</span>group<span>)</span><span>:</span>
    <span>if</span> group <span>==</span> <span>"all"</span><span>:</span>
        sql <span>=</span> <span>"""SELECT ipallocations.`ip_address`
        FROM nova.instances JOIN  nova.`instance_system_metadata`  JOIN neutron.`ports` JOIN neutron.`ipallocations` 
        ON instances.uuid=instance_system_metadata.`instance_uuid` AND  instances.uuid=ports.device_id AND ports.id=ipallocations.port_id 
        WHERE  instances.vm_state = 'active' 
        GROUP BY ipallocations.`ip_address` 
        ORDER BY ipallocations.`ip_address`"""</span>
    <span>else</span><span>:</span>
        sql <span>=</span> <span>"""SELECT ipallocations.`ip_address`
        FROM nova.instances JOIN  nova.`instance_system_metadata`  JOIN neutron.`ports` JOIN neutron.`ipallocations` 
        ON instances.uuid=instance_system_metadata.`instance_uuid` AND  instances.uuid=ports.device_id AND ports.id=ipallocations.port_id 
        WHERE instances.user_id = "{}"
        AND instances.vm_state = 'active' 
        GROUP BY ipallocations.`ip_address` 
        ORDER BY ipallocations.`ip_address`
        """</span><span>.</span><span>format</span><span>(</span>group<span>)</span>
    <span>return</span> sql


<span>def</span> <span>group_list</span><span>(</span><span>)</span><span>:</span>
    big_dict <span>=</span> <span>{</span><span>}</span>
    groups <span>=</span> get_all_group<span>(</span><span>)</span>
    <span>for</span> group <span>in</span> groups<span>:</span>
        group_name <span>=</span> group<span>[</span><span>0</span><span>]</span>
        sql <span>=</span> group_sql<span>(</span>group_name<span>)</span>
        result <span>=</span> get_result<span>(</span>sql<span>)</span>
        host_list <span>=</span> <span>[</span><span>]</span>
        <span>for</span> host <span>in</span> result<span>:</span>
            host_list<span>.</span>append<span>(</span>host<span>[</span><span>0</span><span>]</span><span>)</span>
        <span>if</span> group_name <span>==</span> <span>"99de4a68d74748eeb17708ae0d17e386"</span><span>:</span>
            big_dict<span>[</span><span>"bes"</span><span>]</span> <span>=</span> <span>{</span><span>"hosts"</span><span>:</span> host_list<span>}</span>
        <span>elif</span> group_name <span>==</span> <span>"103e9393fc1d4b22abf7d15651409396"</span><span>:</span>
            big_dict<span>[</span><span>"csp"</span><span>]</span> <span>=</span> <span>{</span><span>"hosts"</span><span>:</span> host_list<span>}</span>
        <span>elif</span> group_name <span>==</span> <span>"364e0a4530f64b7b890856abd93426b6"</span><span>:</span>
            big_dict<span>[</span><span>"h5"</span><span>]</span> <span>=</span> <span>{</span><span>"hosts"</span><span>:</span> host_list<span>}</span>
        <span>else</span><span>:</span>
            big_dict<span>[</span><span>"unknown"</span><span>]</span> <span>=</span> <span>{</span><span>"hosts"</span><span>:</span> host_list<span>}</span>

    <span>print</span><span>(</span>json<span>.</span>dumps<span>(</span>big_dict<span>,</span> indent<span>=</span><span>4</span><span>)</span><span>)</span>


<span>def</span> <span>host_list</span><span>(</span>hostip<span>)</span><span>:</span>
    host_dict <span>=</span> <span>{</span><span>}</span>
    <span># sql = """SELECT ip,port,username from nova.instances where ip="{}";""".format(hostip)</span>
    <span># result = get_result(sql)</span>
    <span># for host in result:</span>
    <span>#     host_ip = host[0]</span>
    <span>#     ssh_port = host[1]</span>
    <span>#     ssh_user = host[2]</span>
    <span>#     host_dict[hostip] = {"ansible_ssh_host": host_ip,</span>
    <span>#                      "ansible_ssh_port": ssh_port, "ansible_ssh_user": ssh_user}</span>
    host_dict<span>[</span>hostip<span>]</span> <span>=</span> <span>{</span><span>"ansible_ssh_host"</span><span>:</span> hostip<span>,</span>
                         <span>"ansible_ssh_port"</span><span>:</span> <span>22</span><span>,</span> <span>"ansible_ssh_user"</span><span>:</span> <span>"root"</span><span>}</span>
    <span>print</span><span>(</span>json<span>.</span>dumps<span>(</span>host_dict<span>,</span> indent<span>=</span><span>4</span><span>)</span><span>)</span>


<span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>if</span> <span>len</span><span>(</span>sys<span>.</span>argv<span>)</span> <span>==</span> <span>2</span> <span>and</span> sys<span>.</span>argv<span>[</span><span>1</span><span>]</span> <span>==</span> <span>"--list"</span><span>:</span>
        group_list<span>(</span><span>)</span>
    <span>elif</span> <span>len</span><span>(</span>sys<span>.</span>argv<span>)</span> <span>==</span> <span>3</span> <span>and</span> sys<span>.</span>argv<span>[</span><span>1</span><span>]</span> <span>==</span> <span>"--host"</span><span>:</span>
        host_list<span>(</span>sys<span>.</span>argv<span>[</span><span>2</span><span>]</span><span>)</span>
    <span>else</span><span>:</span>
        <span>print</span><span>(</span><span>"Usage: %s --list or --host &lt;hostname>"</span> <span>%</span> sys<span>.</span>argv<span>[</span><span>0</span><span>]</span><span>)</span>
        sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>


<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    main<span>(</span><span>)</span>
    conn<span>.</span>close<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br></div></div><h3 id="_3-4-使用"> 3.4 使用</h3>
<p>使用方法和静态 inventory 类似：</p>
<div><pre><code><span># 可以指定组</span>
$ ansible -i dynamic_investory.py all --list-hosts
  hosts <span>(</span><span>3</span><span>)</span>:
    <span>127.0</span>.0.1
    <span>10.10</span>.0.112
    <span>10.10</span>.0.109

<span># 可以指定主机</span>
$ ansible -i dynamic_investory.py <span>127.0</span>.0.1 --list-hosts
  hosts <span>(</span><span>1</span><span>)</span>:
    <span>127.0</span>.0.1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="_4-临时添加节点-add-host模块"> 4 临时添加节点：add_host模块</h2>
<p>除了静态和动态inventory可以指定远程被控节点的信息，还有个比较特殊的模块add_host，它可以在任务执行时临时添加主机节点。</p>
<p>add_host用法非常简单，只有两个参数：name和groups，分别定义主机名和所在主机组，其中groups参数可以是一个列表，表示主机可以添加到多个组中。如果还有其它参数，则均被当作变量赋值。</p>
<div><pre><code>- name: add new host to nginx and apache
  add_host:
    name: 192.168.200.34
    groups:
      - nginx
      - apache
    ansible_port: 22
    my_var: &quot;hello world&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>add_host模块是一个比较特殊的模块，它在playbook运行时添加主机，有以下几个注意事项：</p>
<p>(1).新添加的主机在当前play中无效，只在之后的play中有效</p>
<p>(2).它添加的主机只存在于内存中，Ansible退出之后就消失</p>
<h2 id="_5-group-by运行时临时设置主机组"> 5 group_by运行时临时设置主机组</h2>
<p>group_by和add_host功能是类似的，group_by用于临时设置主机组。</p>
<p>group_by有两个参数：</p>
<p>(1).key：新设置的分组名</p>
<p>(2).parents：(可选参数)新增分组的父组</p>
<p>例如，当前的inventory如下：</p>
<div><pre><code>[nginx]
192.168.200.42

[php]
192.168.200.43

[mysql]
192.168.200.44

[dev:children]
nginx
php
mysql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>其中并没有&quot;CentOS 7&quot;和&quot;CentOS 6&quot;这两个主机组。现在想要在playbook运行的时候去设置这两个主机组。</p>
<div><pre><code>---
- name: set a new group
  hosts: all
  gather_facts: true
  tasks:
    - name: set new group
      group_by:
        key: &quot;{{ansible_distribution}}_{{ansible_distribution_major_version}}&quot;
        parents: &quot;CentOS&quot;

- name: use new group
  hosts: CentOS
  gather_facts: false
  tasks:
    - name: ping CentOS
      ping:
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>上面示例中gather_facts设置为true，因为group_by任务中使用了两个需要它收集来的变量：ansible_distribution和ansible_distribution_major_version。</p>
<p>ansible_distribution变量保存的是系统的发型名称，比如CentOS、RedHat等。ansible_distribution_major_version变量保存的是系统的主版本号，比如CentOS 7.2时返回主版本号7。关于gather_facts，会在稍后的进阶内容中详细介绍。</p>
<p>所以key参数渲染后的值(也即新增组的组名)应当类似于CentOS_6、CentOS_7，而且它们都是CentOS的子组。</p>
<blockquote>
<p>参考链接：</p>
<p>https://www.jianshu.com/p/71d6700fbe79</p>
<p>https://blog.csdn.net/qq_23191379/article/details/90416992</p>
<p>https://blog.51cto.com/cloumn/blog/1542</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">3.1 Ansible lineinfile模块详解</title>
    <id>https://clay-wangzhi.com/automate/ansible/lineinfile/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/lineinfile/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_3-1-ansible-lineinfile模块详解"> 3.1 Ansible lineinfile模块详解</h1>
<h2 id="_1-简介"> 1 简介</h2>
<p>之所以专门说一说这个模块，是因为lineinfile在实际使用中非常有用。</p>
<p>lineinfile模块用于在源文件中插入、删除、替换行，和sed命令的功能类似，也支持正则表达式匹配和替换。</p>
<p>实际上，在大多数时候，我们在linux上的操作，就是针对文件的操作，通过配置管理工具对配置文件作统一的配置修改是一个非常酷的功能。</p>
<p>下面是官方针对该模块的说明：</p>
<div><pre><code>lineinfile - Ensure a particular line is in a file, or replace an existing line using a back-referenced regular expression
</code></pre>
<div><span>1</span><br></div></div><p>简单讲，这个模块就是针对一个文件中行内容的操作。</p>
<p>下面我们详细说一说其具体可以做的事情。</p>
<h2 id="_2-修改匹配行"> 2 修改匹配行</h2>
<p>下面是一个简单的task示例：</p>
<div><pre><code><span># 将/etc/selinux/config中匹配到以'SELINUX='开头的行，将其替换为'SELINUX=disabled'</span>
<span>-</span> <span>name</span><span>:</span> modify selinux to disabled
  <span>lineinfile</span><span>:</span>
    <span>path</span><span>:</span> /etc/selinux/config
    <span>regex</span><span>:</span> <span>'^SELINUX='</span>
    <span>line</span><span>:</span> <span>'SELINUX=disabled'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="_3-在匹配行前或后添加内容"> 3 在匹配行前或后添加内容</h2>
<blockquote>
<p>insertbefore和insertafter指定的正则表达式如果匹配了多行，则默认选中最后一个匹配行，然后在被选中的行前、行后插入。如果明确要指定选中第一次匹配的行，则指定参数firstmatch=yes：</p>
</blockquote>
<p>示例文件如下：</p>
<div><pre><code># cat /etc/http.conf

Listen 127.0.0.1:80
Listen 80
Port
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_3-1-在匹配行前添加"> 3.1 在匹配行前添加</h3>
<p>在http.conf文件的<code>Listen 80</code>前面添加一行<code>Listen 8080</code>，task示例如下：</p>
<div><pre><code>- name: add line before Listen 80
  lineinfile:
    dest: /etc/http.conf
    insertbefore: &#39;^Listen 80&#39;
    line: &#39;Listen 8080&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_3-2-在匹配行后添加"> 3.2 在匹配行后添加</h3>
<p>在http.conf文件的<code>Port</code>后面添加一行<code>just a test</code>，task示例如下：</p>
<div><pre><code>- name: add line before Listen 80
  lineinfile:
    dest: /etc/http.conf
    insertafter: &#39;^Port&#39;
    line: &#39;just a test&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="_4-修改文件内容及权限"> 4 修改文件内容及权限</h2>
<p>示例文件：</p>
<div><pre><code><span>#cat /etc/hosts</span>

<span>127.0</span>.0.1       localhost.localdomain localhost ::1       localhost6.localdomain6 localhost6
<span>10.1</span>.61.130     hub.dz11.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>修改/etc/hosts，将以<code>127.0.0.1</code>开头的行替换为<code>127.0.0.1 localhost</code>，并将/etc/hosts的属主和属组都修改为root，权限改为644，如下：</p>
<div><pre><code>- name: modify hosts
  lineinfile:
    dest: /etc/hosts
    regex: &#39;^127\.0\.0\.1&#39;
    line: &#39;127.0.0.1 localhost&#39;
    owner: root
    group: root
    mode: 0644
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="_5-删除行内容"> 5 删除行内容</h2>
<p>regexp结合state=absent时，表示删除所有匹配的行。</p>
<p>示例原文件：</p>
<div><pre><code><span>#cat /etc/hosts</span>

<span>127.0</span>.0.1       localhost.localdomain localhost ::1       localhost6.localdomain6 localhost6
<span>10.1</span>.61.130     hub.dz11.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>删除以<code>10.1.61.130</code>开头的行：</p>
<div><pre><code>- name: delete a line
  lineinfile:
    dest: /etc/hosts
    regex: &#39;^10\.1\.61&#39;
    state: absent
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="_6-文件存在则添加一行内容"> 6 文件存在则添加一行内容</h2>
<p>往/etc/hosts里添加一行<code>10.1.61.131 test.dz11.com</code>（多次执行，不会重复添加），示例如下：</p>
<p>如果再次执行，则不会再次追加此行。因为lineinfile模块的state参数默认值为present，它能保证幂等性，当要插入的行已经存在时则不会再插入。</p>
<div><pre><code><span>-</span> <span>name</span><span>:</span> add a line
  <span>lineinfile</span><span>:</span>
    <span>dest</span><span>:</span> /etc/hosts
    <span>line</span><span>:</span> <span>'10.1.61.131 test.dz11.com'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="_7-如果有匹配的行则修改该行-如果不匹配则添加"> 7 如果有匹配的行则修改该行，如果不匹配则添加</h2>
<p>示例原文件/tmp/test.txt内容如下：</p>
<div><pre><code><span># %wheel   ALL=(ALL)   ALL</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面的示例task中，匹配以<code>%wheel</code>开头的行，匹配到，则执行替换，未匹配，则添加。因为原文件中，没有以<code>%wheel</code>开头的行，所以会添加一行：</p>
<div><pre><code><span>-</span> <span>name</span><span>:</span> add or modify a line
  <span>lineinfile</span><span>:</span> 
    <span>dest</span><span>:</span> /tmp/test.txt
    <span>regex</span><span>:</span> <span>'^%wheel'</span>
    <span>line</span><span>:</span> <span>'%wheel  ALL=(ALL)       NOPASSWD: ALL'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>修改后的文件如下：</p>
<div><pre><code><span>#cat /tmp/text.txt</span>

<span># %wheel   ALL=(ALL)   ALL</span>
%wheel  <span>ALL</span><span>=</span><span>(</span>ALL<span>)</span>       NOPASSWD: ALL
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="_8-参数backrefs-backup说明"> 8 参数backrefs，backup说明</h2>
<ul>
<li>backup： 是否备份原文件，默认为no</li>
<li>backrefs：
<ul>
<li>当backrefs为no时，如果regex没有匹配到行，则添加一行，如果Regx匹配到行，则修改该行</li>
<li>当backrefs为yes时，如果regex没有匹配到行，则保持原文件不变，如果regex匹配到行，则修改该行</li>
<li>backrefs默认为no，所以上面那个示例中，我们没有配置backrefs，而默认没有匹配，则修改。</li>
</ul>
</li>
</ul>
<p>下面我们看一看backrefs为yes时匹配到行的示例：</p>
<p>示例原文件：</p>
<div><pre><code><span># cat /tmp/testfile</span>

<span># %wheel   ALL=(ALL)   ALL</span>
%wheel  <span>ALL</span><span>=</span><span>(</span>ALL<span>)</span>       NOPASSWD: ALL
<span>#?bar</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>task示例：</p>
<div><pre><code> - name: test backrefs
  lineinfile:
      backup: yes
      state: present
      dest: /tmp/testfile
      regexp: &#39;^#\?bar&#39;
      backrefs: yes
      line: &#39;bar&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>修改后的文件：</p>
<div><pre><code><span># cat /tmp/testfile</span>

<span># %wheel   ALL=(ALL)   ALL</span>
%wheel  <span>ALL</span><span>=</span><span>(</span>ALL<span>)</span>       NOPASSWD: ALL
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="_9-使用validate验证文件是否正确修改"> 9 使用validate验证文件是否正确修改</h2>
<p>在一些场景下，我们修改完文件后，需要对文件做一下测试，用以检查文件修改之后，是否能正常运行。如http.conf、nginx.conf等，一旦改错，而不加以测试，可能会直接导致http服务挂掉。</p>
<p>可以使用validate关键字，在修改完成以后，对文件执行检测：</p>
<div><pre><code>- name: test validate
  lineinfile:
      dest: /etc/sudoers
      state: present
      regexp: &#39;^%ADMIN ALL=&#39;
      line: &#39;%ADMIN ALL=(ALL)&#39;
      validate: &#39;visudo -cf %s&#39;
  tags:
    - testsudo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="_10-regexp和insertxxx结合"> 10 regexp和insertXXX结合</h2>
<p>lineinfile最后一个比较常用的功能是regepx结合insertbefore或结合insertafter。这时候的行将根据insertXXX的位置来插入，而regexp参数则充当幂等性判断参数：只有regepx匹配失败时，insertXXX才会插入行。</p>
<p>例如：</p>
<div><pre><code>- lineinfile:
path: &quot;a.txt&quot;
line: &quot;hello line&quot;
regexp: &#39;^hello&#39;
insertbefore: &#39;^para.* 2&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这表示将&quot;hello line&quot;插入在paragraph 2行的前面，但如果再次执行，则不会再次插入，因为regexp参数指定的正则表达式已经能够已经存在的&quot;hello line&quot;行。所以，当regepx结合insertXXX使用时，regexp的参数通常都会设置为能够匹配插入之后的行的正则表达式，以便实现幂等性。</p>
<blockquote>
<p>参考链接：</p>
<p>https://www.cnblogs.com/breezey/p/9297252.html</p>
<p>https://blog.51cto.com/cloumn/blog/1544</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">5.4 使用lookup生成变量</title>
    <id>https://clay-wangzhi.com/automate/ansible/lookup/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/lookup/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_5-4-使用lookup生成变量"> 5.4 使用lookup生成变量</h1>
<h1 id="简单说明"> 简单说明</h1>
<p>在通常情况下，所有的配置信息都会被作为ansible的变量保存了，而且可以保存在ansible允许定义变量的各种地方，诸如vars区段，<code>vars_files</code>加载的文件中，以及host_vars和group_vars目录中。</p>
<p>但在有些时候，我们希望从诸如文本文件或者.csv文件中收集数据作为ansible的变量，或者直接获取某些命令的输出作为ansible的变量，甚至从redis或者etcd这样的键值存储中取得相应的值作为ansible的变量。这个时候，我们就需要通过ansible的lookup插件来从这些数据源中读取配置数据，传递给ansbile变量，并在playbook或者模板中使用这些数据。</p>
<p>lookup()是Ansible的一个插件，可用于从外部读取数据，这里的&quot;外部&quot;含义非常广泛，比如：</p>
<p>(1).从磁盘文件读取(file插件)</p>
<p>(2).从redis中读取(redis插件)</p>
<p>(3).从etcd中读取(etcd插件)</p>
<p>(4).从命令执行结果读取(pipe插件)</p>
<p>(5).从Ansible变量中读取(vars插件)</p>
<p>(6).从Ansible列表中读取(list插件)</p>
<p>(7).从Ansible字典中读取(dict插件)</p>
<p>(8)....</p>
<p>具体可以从哪些&quot;外部&quot;读取以及如何读取，取决于Ansible是否提供了相关的读取插件。官方手册：https://docs.ansible.com/ansible/latest/plugins/lookup.html#plugin-list 中列出了所有支持的插件</p>
<p><strong>lookup()语法</strong></p>
<div><pre><code>lookup(&#39;&lt;plugin_name&gt;&#39;, &#39;plugin_argument&#39;)
</code></pre>
<div><span>1</span><br></div></div><h1 id="_1-file-fileglob"> 1. file/fileglob</h1>
<p>使用file lookup可以从文本文件中获取数据，并在这些数据传递给ansible变量，在task或者jinja2模板中进行引用。下面是一个从文本文件中获取ssh公钥并复制到远程主机的示例：</p>
<div><pre><code>- name: copy authorized_host file
  template: 
    src: authorized_keys.j2 
    dest: /home/deploy/.ssh/authrized_keys 
    owner: deploy
    group: deploy
    mode: 0600
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>authorized_keys.j2模板文件示例如下：</p>
<div><pre><code><span>{</span><span>{</span> lookup('file'<span>,</span> '/users/breeze/.ssh/id_rsa.pub')<span>}</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>和file类似，支持通配符的fileglob插件，它使用通配符来通配Ansible本地端的文件名</p>
<div><pre><code>---
- name: play1
  hosts: new
  gather_facts: false
  tasks:
    - name: task1
  debug:
    msg: &quot;filenames: {{lookup(&#39;fileglob&#39;,&#39;/etc/*.conf&#39;)}}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>需注意的是，fileglob查询的是Ansible端文件，且只能通配文件而不能通配目录，且不会递归通配。如果想要查询目标主机上的文件，可以使用find模块。</p>
<blockquote>
<p>如果lookup()查询出来的结果包含多项，则默认以逗号分隔各项的字符串方式返回，如果想要以列表方式返回，则传递一个lookup的参数wantlist=True。例如，fileglob通配出来的文件如果有多个，加上wantlist=True：</p>
</blockquote>
<p>在Ansible 2.5中添加了一个新的功能query()或q()，后者是前者的等价缩写形式。query()在写法和功能上和lookup一致，其实它会自动调用lookup插件，并且总是以列表方式返回，而不需要手动加上wantlist=True参数。例如：</p>
<div><pre><code>- name: task1
  debug:
  msg: &quot;{{q(&#39;fileglob&#39;,&#39;/etc/*.conf&#39;)}}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h1 id="_2-pipe"> 2. pipe</h1>
<p>使用pipe lookup可以直接调用外部命令，并将命令执行的结果打印到标准输出，作为ansible变量。下面的例子通过pipe调用date指令拿到一个以时间数字组成的字串</p>
<div><pre><code>- name: Flamingo | Get release version
  set_fact:
    flamingo_release_version: &quot;{{ lookup(&#39;pipe&#39;, &#39;date +%Y%m%d%H%M%SZ&#39;) }}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h1 id="_3-env"> 3. env</h1>
<p>env lookup实际就是获取在控制主机上的某个环境变量的值。下面是一个读取控制机上<code>$JAVA_HOME</code>变量值的示例：</p>
<div><pre><code>- name: get JAVA_HOME
  debug: msg=&quot;{{ lookup(&#39;env&#39;, &#39;JAVA_HOME&#39;)}}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h1 id="_4-template"> 4. template</h1>
<p>template lookup可以指定一个jinja2模板，然后返回这个模板中的变量被替换以后的结果。</p>
<p>假设我们有一个message.j2模板，内容如下：</p>
<div><pre><code>This host runs {{ ansible_distribution }}
</code></pre>
<div><span>1</span><br></div></div><p>定义一个如下的task：</p>
<div><pre><code>- name: print message from template
  debug: msg=&quot;{{ lookup(&#39;template&#39;, &#39;message.j2&#39;)}}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>输出的msg的结果如下：</p>
<div><pre><code>This host runs CentOS
</code></pre>
<div><span>1</span><br></div></div><h1 id="_5-csvfile"> 5. csvfile</h1>
<p>csvfile可以从.csv文件中读取一个条目。假设我们有如下示例的名为users.csv的文件：</p>
<div><pre><code>username,email
lorin,lorin@test.com
john,john@example.com
sue,sue@exmaple.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>下面是一个使用csvfile lookkup提取sue的电子邮件地址的task示例：</p>
<div><pre><code><span>-</span> <span>name</span><span>:</span> get sue's email
  <span>debug</span><span>:</span> msg="<span>{</span><span>{</span> lookup('csvfile'<span>,</span>'sue file=users.csv delimiter=<span>,</span> col=1')<span>}</span><span>}</span>"
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以看到，一共向插件传递了四个参数：sue, file=users.csv, delimiter=,以及col=1。说明如下：</p>
<ul>
<li>第一个参数指定一个名字，该名字必须出现在其所在行的第0列，需要说明的是，如果指定的第一个参数名字在文件中出现多次，则匹配第一次出现的结果</li>
<li>第二个参数指定csv文件的文件名</li>
<li>第三个参数指定csv文件的中条目的分隔符，</li>
<li>第四个参数指定要取得哪一列的值，这一列正是第一个参数所在行的那一列的值</li>
</ul>
<p>如果我们想要查找的用户存储在名为username的变量中，则可以使用&quot;+&quot;符号来连接username字串和其他的参数字串，来构建完整的参数字符串：</p>
<div><pre><code>lookup(&#39;csvfile&#39;, username+&#39;file=users.csv&#39; delimiter=, col=1)
</code></pre>
<div><span>1</span><br></div></div><h1 id="_6-redis-kv"> 6. redis_kv</h1>
<p><code>redis_kv lookup</code>可以直接从redis存储中来获取一个key的value，key必须是一个字符串，如同Redis GET指令一样。需要注意的是，要使用<code>redis_kv lookup</code>，需要在主控端安装python的redis客户端，在centos上，软件包为python-redis。</p>
<p>下面是一个在playbook中调用redis lookup的task，从本地的redis中取中一个key为weather的值：</p>
<div><pre><code>- name: lookup value in redis
  debug: msg=&quot;{{ lookup(&#39;redis_kv&#39;, &#39;redis://localhost:6379,weather&#39;)}}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>其中URL部分如果不指定，该模块会默认连接到<code>redis://localhost:6379</code>，所以实际上在上面的实例中，调用可以直接写成如下：</p>
<div><pre><code>{{ lookup(&#39;redis_kv&#39;, &#39;weather&#39;)}}
</code></pre>
<div><span>1</span><br></div></div><h1 id="_7-etcd"> 7. etcd</h1>
<p>etcd是一个分布式的key-value存储，通常被用于保存配置信息或者被用于实现服务发现。可以使用etcd lookup来从etcd中获取指定key的value。</p>
<p>我们通过如下方法往一个etcd中写入一个key：</p>
<div><pre><code>curl -L http://127.0.0.1:4001/v2/keys/weather -XPUT -d value=sunny
</code></pre>
<div><span>1</span><br></div></div><p>定义一个调用etcd插件的task：</p>
<div><pre><code>- name: look up value in etcd
  debug: msg=&quot;{{ lookup(&#39;etcd&#39;,&#39;weather&#39;)}}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>默认情况下，etcd lookup会在http://127.0.0.1:4001上查找etcd服务器。但我们在执行playbook之前可以通过设置<code>ANSIBLE_ETCD_URL</code>环境变量来修改这个设置。</p>
<h1 id="_8-password"> 8. password</h1>
<p>password lookup会随机生成一个密码，并将这个密码写入到参数指定的文件中。如下示例，创建一个名为bob的mysql用户，并随机生成该用户的密码，并将密码写入到主控端的bob-password.txt中：</p>
<div><pre><code>- name: create deploy mysql user
  mysql_user: name=bob password={{ lookup(&#39;password&#39;, &#39;bob-password,txt&#39;)}} priv=*.*:ALL state=present
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h1 id="_9-dnstxt"> 9. dnstxt</h1>
<p>dnstxt lookup用于获取指定域名的TXT记录。需要在主控端安装python-dns。</p>
<p>使用方法如下：</p>
<div><pre><code>- name: lookup TXT record
  debug: msg=&quot;{{ lookup(&#39;dnstxt&#39;, &quot;aliyun.com&quot;) }}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果某一个主机有多个相关联的TXT记录，那么模块会把他们连在一起，并且每次调用时的连接顺序可能不同</p>
<blockquote>
<p>参考链接：</p>
<p>https://www.cnblogs.com/breezey/p/9275799.html</p>
<p>https://blog.51cto.com/cloumn/blog/1544</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">5.3 魔法变量</title>
    <id>https://clay-wangzhi.com/automate/ansible/magic/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/magic/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_5-3-魔法变量"> 5.3 魔法变量</h1>
<p><strong>魔法变量</strong></p>
<p>Ansible默认会提供一些内置的变量以实现一些特定的功能，我们称之为魔法变量。下面列举一些常用的魔法变量。</p>
<p>https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html#magic</p>
<h2 id="_1-hostvars"> 1. hostvars</h2>
<p>hostvars变量用于保存所有和主机相关的变量，通常包括inventory中定义的主机变量和gather_facts收集到的主机信息变量。hostvars是一个key/value格式的字典(即hash结构、对象)，key是每个节点的主机名，value是该主机对应的变量数据。</p>
<p>获取某台指定的主机的相关变量。如果有一台web服务器的配置文件中需要指定db服务器的ip地址，我们假定这台db服务器的hostname为db.exmaple.com,ip地址绑定在eth0网卡上，我们可以通过如下方法在web服务器上调用db服务器的ip地址：</p>
<div><pre><code>{{ hostvars[&#39;db.example.com&#39;].ansible_eth0.ipv4.address }}
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>需要注意的是db.example.com不能使用ip地址来取代，只能使用主机名或别名。</p>
</blockquote>
<h2 id="_2-inventory-hostname"> 2. inventory_hostname</h2>
<p>inventory_hostname是Ansible所识别的当前正在运行task的主机的主机名。如果在inventory里定义过别名，那么这里就是那个别名，如果inventory包含如下一行：</p>
<div><pre><code>server1 ansible_ssh_host=192.168.1.1
</code></pre>
<div><span>1</span><br></div></div><p>则<code>inventory_hostname</code>即为<code>server1</code>
利用<code>hostvars</code>和<code>inventory_hostname</code>变量，可以输出与当前主机相关联的所有变量：</p>
<div><pre><code>- debug: var=hostvars[inventory_hostname]
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>与inventory_hostname相近的还有一个inventory_hostname_short，如果一台主机的inventory_hostname为server1.exmaple.com，则inventory_hostname_short的值为server1</p>
</blockquote>
<h2 id="_3-group-names"> 3. group_names</h2>
<p>用于标识当前正在执行task的目标主机位于的主机组。假如我们有三台主机，用来配置成一主二从的mysql服务器。inventory配置如下：</p>
<div><pre><code>[mdb]
db1
[sdb]
db2
db3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>mysql配置文件my.conf.j2示例如下：</p>
<div><pre><code><span>#我们知道db1在mdb组，当db1与当前正在执行任务的主机位于同一组时，我们认为当前主机即在mdb组，所以对当前主机应用mysql master的配置</span>
<span>{</span>% if 'db1' in group_names %<span>}</span>
<span>[</span>mysqld<span>]</span>
server<span>-</span>id=1
log<span>-</span>bin=mysql<span>-</span>bin
log<span>-</span>bin<span>-</span>index=mysql<span>-</span>bin.index
sync<span>-</span>binlog=1
innodb_flush_log_at_trx_commit=1
<span>#当db1与当前主机不在同一组时，则认为当前主机不在mdb组，即应用my slave的配置</span>
<span>{</span>% else %<span>}</span>
<span>[</span>mysqld<span>]</span>
server<span>-</span>id=2
relay<span>-</span>log=relay<span>-</span>log
relay<span>-</span>log<span>-</span>index=relay<span>-</span>log.index
read<span>-</span>only = yes
sync_master_info = 1
sync_relay_log = 1
sync_relay_log_info = 1
relay_log_recovery = 1
skip_slave_start    
<span>{</span>% endif %<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>我们执行如下task:</p>
<div><pre><code>- name: copy config file to mysql master
  template: src=my.conf.j2 dest=/etc/my.cnf
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="_4-groups"> 4. groups</h2>
<p>groups是inventory中所有主机组的列表，可用于枚举主机组中的所有主机。</p>
<p>假如我们有一个inventory文件定义如下：</p>
<div><pre><code>[web]
server1
server2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在配置一台HAproxy的负载均衡器时，我们的配置文件肯定需要web主机组的所有服务器的IP，配置文件包含如下片段：</p>
<div><pre><code>backend web-backend
{% for host in groups.web%}
    server {{host.inventory_hostname}} {{ host.ansible_default_ipv4.address }}:80
{% endfor %}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>最终生成的文件如下：</p>
<div><pre><code>backend web-backend
    server server1 192.168.1.1:80
    server server2 192.168.1.2:80
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>再给一个例子，在所有的dbservers组的服务器上创建一个数据库用户kate：</p>
<div><pre><code>- name: Create a user for all db servers
  mysql_user: name=kate password=test host={{ hostvars.[item].ansible_eth0.ipv4.address }} state=present
  with_items: groups[&#39;dbservers&#39;] 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="_5-ansible-play-batch"> 5. ansible_play_batch</h2>
<p>play_hosts 已废弃，等价于ansible_play_batch</p>
<p>ansible_play_hosts等价于ansible_play_batch</p>
<p>它存储当前play所涉及的所有主机列表，但连接失败或执行任务失败的节点不会留在此变量中。</p>
<h2 id="_6-inventory-dir"> 6. inventory_dir</h2>
<p>主机清单所在目录</p>
<h2 id="_7-inventory-file"> 7. inventory_file</h2>
<p>主机清单文件</p>
<blockquote>
<p>参考链接：</p>
<p>https://www.cnblogs.com/breezey/p/9275763.html</p>
<p>https://blog.51cto.com/cloumn/blog/1544</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">6 Ansible使用优化</title>
    <id>https://clay-wangzhi.com/automate/ansible/optimize/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/optimize/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_6-ansible使用优化"> 6 Ansible使用优化</h1>
<h2 id="_1-加大forks的值"> 1 加大forks的值</h2>
<p>默认forks=5，即最多5个Ansible工作进程。即便是只有6个目标节点，对于&quot;效率&quot;常挂嘴边的21世纪IT人来说，这么一点数量的工作进程，也显然是杯水车薪。</p>
<p>对于Ansible来说，它的的大多数任务都是分派给目标节点去执行的，所以控制端通常比较闲暇。换句话说，控制端在浪费宝贵的资源。因此，如果没有其它资源的瓶颈(比如网络带宽瓶颈、磁盘IO瓶颈)，Ansible控制端可以尽可能开大马力，让足够多的节点同时开始运行。</p>
<p>加大forks的值，甚至尽情地加大forks的值，可以很大幅度地提升整个任务的执行效率。不用担心太多Ansible工作进程数量会影响Ansible控制端的性能，Ansible工作进程那缓慢的工作量对OS来说实在太轻松了(除非是一些会占用大量资源的特殊任务)。我想，对于一般任务来说，唯一需要考虑的是网络带宽是否足够支撑足够数量目标节点，偶尔可能还需要考虑磁盘瓶颈。</p>
<h2 id="_2-修改执行策略"> 2 修改执行策略</h2>
<p>默认情况下Ansible会让所有节点(或者serial指定的数量)执行完同一个任务后才让它们进入下一个任务，这体现了各节点的公平性和实时性：每个节点都能尽早执行到任务。这其实和操作系统的进程调度是类似的概念，只不过相对于操作系统的调度系统来说，Ansible的调度策略实在是太简陋了。</p>
<p>假设forks设置的比较大，可以一次性让足够多的节点并发执行任务，那么同时设置任务的执行策略为strategy=free便能让这些执行任务的节点彻底放飞自我。只是剩余的一部分节点可能会比较悲剧，它们处于调度不公平的一方。但是从整体来说，先让大部分节点快速完成任务是值得的。</p>
<p>但是要注意，有些场景下要小心使用free策略，特别是节点依赖时。比如，某些节点运行服务A，另一些节点运行服务B，而服务B是依赖于服务A的，那么必须不能让运行B服务的节点先执行，对于有节点依赖关系的任务，为了健壮性，一般会定义好等待条件，但是出现等待有可能就意味着浪费。</p>
<h2 id="_3-使ansible异步执行任务"> 3 使Ansible异步执行任务</h2>
<p>默认情况下，Ansible按照同步执行的方式执行每个任务。即对每个任务来说，都需要等待目标节点执行完该任务后回馈给Ansible端的报告，然后Ansible才认为该节点上的该任务已经执行完成，才会考虑下一步骤，比如free策略下该节点继续执行下一个任务，或者等待其它节点完成该任务，等等。</p>
<h3 id="_3-1-async和poll指令"> 3.1 async和poll指令</h3>
<p>Ansible允许在task级别(且只支持task级别)指定该task是否以异步模式(即放入后台)执行，即将该异步任务放入后台。例如：</p>
<div><pre><code>- name: it is an async task
  copy:
    src:
    dest:
  async: 200
  poll: 2
- name: a sync task
  copy:
    src:
    dest:
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>其中async指令表示该任务将以异步的模式执行。async指令的值200表示，如果该后台任务200秒还未完成，则认为该任务失败。poll指令表示该任务丢入后台后，Ansible每隔多久去检查一次异步任务是否已成功、是否报错等，只有检查到已完成后才认为该异步任务执行完成，才会进入下一个任务。</p>
<p>如此看来，似乎这个异步执行模式并非想象中那样真正的异步：将一个任务放入后台执行，立即进入下一个任务。而且这里的异步似乎会减慢任务的执行流程。比如后台任务在第3秒完成，也必须等到第4秒检查的时候才认为执行完成。</p>
<p>如果poll指令的值大于0，这确实不是真正的异步，每个工作进程必须等待放入后台的任务执行完成才会进入下一个任务，换句话说，尽管使用了async异步指令，也仍然会阻塞在该异步任务上。这会减慢任务的执行速度，但此时执行该异步任务的Ansible工作进程会放弃CPU，使得CPU可以执行其它进程(对于Ansible控制节点来说，这算哪门子优点？)。</p>
<p>但如果poll指令的值为0，将会以真正的异步模式执行任务，表示Ansible工作进程不检查后台任务的执行状况，而是直接执行下一个任务。</p>
<p>不管poll指令的值是否大于0，只要使用了异步，那么强烈建议将forks指令的值设置的足够大。比如能够一次性让所有节点都开始异步执行某任务，这样的话，无论poll的值是否大于0，都能提升效率。</p>
<p>此外，也可以在ansible命令中使用-B N选项指定async功能，N为超时时长，-P N选项指定poll功能，N为检查后台任务状况的时间间隔。</p>
<p>例如：</p>
<div><pre><code>ansible inventory_file -B200 -P 0 -m yum -a &#39;name=dos2unix&#39; -o -f 20
</code></pre>
<div><span>1</span><br></div></div><h3 id="_3-2-等待异步任务"> 3.2 等待异步任务</h3>
<p>略，后续补充</p>
<h3 id="_3-3-何时使用异步任务"> 3.3 何时使用异步任务</h3>
<p>有时候合理应用异步任务能大幅提升Ansible的执行效率，但也并非所有场景都能够使用异步任务。</p>
<p>总结来说，以下一些场景可能使用到Ansible的异步特性：</p>
<ul>
<li>某个task需要运行很长的时间，这个task很可能会达到ssh连接的timeout</li>
<li>没有任务是需要等待它才能完成的，即没有任务依赖此任务是否完成的状态</li>
<li>需要尽快返回当前shell执行其它命令，此时应将所有异步任务的poll设置为0，否则仍然会阻塞在异步任务上</li>
</ul>
<p>不适合使用异步特性的场景：</p>
<ul>
<li>需要执行完该任务后才能继续另外某个任务</li>
<li>申请排它锁的任务</li>
<li>从上到下几乎全是非常短的任务，异步与否影响不大，甚至可能会因为poll非0而降低效率</li>
</ul>
<h2 id="_4-controlpresist-持久化socket"> 4 controlpresist 持久化socket</h2>
<p><strong>controlpresist 持久化socket，一次验证，多次通信,被控主机的ssh版本需要时5.6以上</strong></p>
<p>安装在ansible被管理主机上</p>
<div><pre><code># cat ~/.ssh/config
Host * 
  Compression yes 
  ServerAliveInterval 60 
  ServerAliveCountMax 5
  ControlMaster auto
  ControlPath ~/.ssh/sockets/%r@%h-%p
  ControlPersist 4h
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>个人感觉效果不明显，不如下面ansible设置开启ssh长连接</p>
</blockquote>
<h2 id="_5-开启ssh长连接"> 5 开启SSH长连接</h2>
<p>开启ssh长连接为5天 ，要求ssh为5.6版本，查看版本ssh -v</p>
<div><pre><code># cat /etc/ansible/ansible.cfg
ssh_args = -C -o ControlMaster=auto -o ControlPersist=5d 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>设置之后，连接信息会被保留在~.ansible/cp下, netstat -nltpa | grep ESTABLISH | grep ssh 会看到长连接存在</p>
<h2 id="_6-关闭gather-facts"> 6 关闭gather_facts</h2>
<p>关闭获取被控主机信息：在playbook中关闭即可，在大量的主机下，其效果明显</p>
<div><pre><code>hosts: all
gather_facts: no
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="_7-开启pipeling"> 7 开启pipeling</h2>
<p>在不使用sudo的情况下开启pipeling，减少ansible没有传输时的连接数</p>
<div><pre><code>修改ansible.cfg中pipelining=False改为True
</code></pre>
<div><span>1</span><br></div></div><h2 id="_8-shell层次上的优化-将任务分开执行"> 8 Shell层次上的优化：将任务分开执行</h2>
<p>在LNMP的示例中，分别为nginx和php和MySQL都单独定义了自己的Role，它们分别在三批节点上执行。为了统筹这些Role，一般会定义一个汇聚了所有的Role的playbook文件，称为入口playbook，比如称为main.yml或site.yml。</p>
<p>但是，把这些Role聚集到单个playbook文件中后就必然会产生前后顺序关系。比如执行nginx Role的时候，PHP Role和MySQL Role对应的节点都在空闲。这是一种很低效的执行方式。</p>
<p>因此，可以为每个Role单独定义一个入口playbook文件，比如分别称之为nginx.yml、php.yml和mysql.yml，然后在Shell中使用多个ansible-playbook命令去分别执行这些入口文件。</p>
<p>这样一来，分别执行这三个Role的三批节点就可以同时开始执行任务了。</p>
<h2 id="_9-第三方策略插件-mitogen-for-ansible"> 9 第三方策略插件：Mitogen for Ansible</h2>
<p>略，后续补充</p>
<h2 id="_10-优化常规配置"> 10 优化常规配置</h2>
<div><pre><code>inventory      = /etc/ansible/hosts.yml   # 指定主机列表文件
roles_path    = /etc/ansible/roles # 指定roles下载位置
host_key_checking = False #关闭密码检查
remote_user = ane #指定连接到的ssh用户
deprecation_warnings = False #关闭一些告警
retry_files_enabled = False #关闭book产生的retry文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="_11-其他优化项"> 11 其他优化项</h2>
<ol>
<li>
<p>目录结构</p>
<p>如果只是一个简单的独立任务，使用playbook文件即可,方便我们在其他地方引用. 复杂建议采用role形式管理.</p>
</li>
<li>
<p>定义多环境</p>
<p>通过Inventory 方式去区分多环境下的主机或者主机组信息. 生成多个主机文件.
不同环境需要调用不同的playbook 或者task ，可以通过when 方式去判断当前的主机信息存在哪个环境中，然后进行引用.</p>
</li>
<li>
<p>检测
ansible-playbook 命令的–syntax-check 参数即可</p>
</li>
<li>
<p>灰度发布</p>
<p>挑选一台机器进行测试，只有进行测试之后我们才知道整个配置流程是否达到我们想要结果.
进行预运行时，我们只需要把一个或者多个task 使用delegate_to参数指定到一台设备上进行测试. 如果测试通过后，再进行接下来的工作.</p>
</li>
<li>
<p>统一管理</p>
<p>纳入git仓库管理</p>
</li>
<li>
<p><strong>Facts缓存优化</strong>，可以加入redis缓存（但会有一些问题，比如创建带有时间的文件夹）</p>
</li>
</ol>
<p>参考链接：</p>
<blockquote>
<p>https://blog.51cto.com/cloumn/blog/1544</p>
<p>https://blog.csdn.net/Jack_Yangyj/article/details/86503591</p>
<p>https://blog.csdn.net/goodlife111/article/details/94440672</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">4.2 Playbook循环语句</title>
    <id>https://clay-wangzhi.com/automate/ansible/playbook-for/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/playbook-for/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-2-playbook循环语句"> 4.2 Playbook循环语句</h1>
<h2 id="_1-简介"> 1 简介</h2>
<p>我们在编写playbook的时候，不可避免的要执行一些重复性操作，比如指安装软件包，批量创建用户，操作某个目录下的所有文件等。正如我们所说，ansible一门简单的自动化语言，所以流程控制、循环语句这些编程语言的基本元素它同样都具备。</p>
<p>loop循环，它是在Ansible 2.5版本中新添加的循环结构，等价于with_list。大多数时候，with_xxx的循环都可以通过一定的手段转换成loop循环，所以从Ansible 2.5版本之后，原来经常使用的with_items循环都可以尝试转换成loop。</p>
<p>下面我们简单的说一说Playbook中循环语句。</p>
<h2 id="_2-loop关键字说明"> 2 loop关键字说明</h2>
<p>在playbook中使用循环，直接使用loop关键字即可。</p>
<p>如下示例，启动httpd和postfilx服务：</p>
<div><pre><code>tasks:
  - name: postfix and httpd are running
    service:
      name: &quot;{{ item }}&quot;
      state: started
    loop:
      - postfix
      - httpd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>也可以将loop循环的列表提前赋值给一个变量，然后在循环语句中调用：</p>
<div><pre><code>#cat test_services.yml
test_services:
  - postfix
  - httpd

# cat install_pkgs.yml 
- name: start services
  hosts: test
  vars_files:
    - test_services.yml
  tasks:
    - name: postfix and httpd are running
      service:
        name: &quot;{{ item }}&quot;
        state: started
      loop: &quot;{{ test_services }}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>下面是一个循环更复杂类型数据的示例：</p>
<div><pre><code># cat test_loop.yml 
- name: test loop
  hosts: test
  tasks:
  - name: add www group
    group: 
      name: www
  - name: add several users
    user: 
      name: &quot;{{ item.name }}&quot;
      state: present 
      groups: &quot;{{ item.groups }}&quot;
    loop:
      - { name: &#39;testuser1&#39;, groups: &#39;wheel&#39; }
      - { name: &#39;testuser2&#39;, groups: &#39;www&#39; }
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="_3-循环的控制-loop-control"> 3 循环的控制：loop_control</h2>
<p>后续补充</p>
<h2 id="_3-在循环语句中注册变量"> 3 在循环语句中注册变量</h2>
<p>下面是一个register的变量在循环中使用的例子：</p>
<div><pre><code># cat register_loop.yml 
- name: registered variable usage as a loop list
  hosts: test
  tasks:
      - name: ensure /mnt/bkspool exists
        file:
          path: /mnt/bkspool
          state: directory
      - name: retrieve the list of home directories
        command: ls /home
        register: home_dirs
      - name: Show home_dirs results
        debug:
          var: home_dirs.stdout_lines
      - name: add home dirs to the backup spooler
        file: 
          path: /mnt/bkspool/{{ item }}
          src: /home/{{ item }}
          state: link
          force: yes
        loop: &quot;{{ home_dirs.stdout_lines }}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>在循环语句中注册变量：</p>
<div><pre><code>- name: Loop Register test
  gather_facts: no
  hosts: test
  tasks:
    - name: Looping Echo Task
      shell: &quot;echo this is my item: {{ item }}&quot;
      loop:
        - one
        - two
      register: echo_results
    - name: Show echo_results variable
      debug:
        var: echo_results
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>执行语句，可以看到变量的返回结果为一个字典列表：</p>
<div><pre><code>ok: [10.1.61.187] =&gt; {
    &quot;echo_results&quot;: {
        &quot;changed&quot;: true,
        &quot;msg&quot;: &quot;All items completed&quot;,
        &quot;results&quot;: [
            {
                &quot;ansible_loop_var&quot;: &quot;item&quot;,
                &quot;changed&quot;: true,
                &quot;cmd&quot;: &quot;echo this is my item: one&quot;,
                &quot;delta&quot;: &quot;0:00:00.004905&quot;,
                &quot;end&quot;: &quot;2019-06-10 00:23:51.814151&quot;,
                &quot;failed&quot;: false,
                &quot;invocation&quot;: {
                    &quot;module_args&quot;: {
                        &quot;_raw_params&quot;: &quot;echo this is my item: one&quot;,
                        &quot;_uses_shell&quot;: true,
                        &quot;argv&quot;: null,
                        &quot;chdir&quot;: null,
                        &quot;creates&quot;: null,
                        &quot;executable&quot;: null,
                        &quot;removes&quot;: null,
                        &quot;stdin&quot;: null,
                        &quot;stdin_add_newline&quot;: true,
                        &quot;strip_empty_ends&quot;: true,
                        &quot;warn&quot;: true
                    }
                },
                &quot;item&quot;: &quot;one&quot;,
                &quot;rc&quot;: 0,
                &quot;start&quot;: &quot;2019-06-10 00:23:51.809246&quot;,
                &quot;stderr&quot;: &quot;&quot;,
                &quot;stderr_lines&quot;: [],
                &quot;stdout&quot;: &quot;this is my item: one&quot;,
                &quot;stdout_lines&quot;: [
                    &quot;this is my item: one&quot;
                ]
            },
            {
                &quot;ansible_loop_var&quot;: &quot;item&quot;,
                &quot;changed&quot;: true,
                &quot;cmd&quot;: &quot;echo this is my item: two&quot;,
                &quot;delta&quot;: &quot;0:00:00.004736&quot;,
                &quot;end&quot;: &quot;2019-06-10 00:23:52.008981&quot;,
                &quot;failed&quot;: false,
                &quot;invocation&quot;: {
                    &quot;module_args&quot;: {
                        &quot;_raw_params&quot;: &quot;echo this is my item: two&quot;,
                        &quot;_uses_shell&quot;: true,
                        &quot;argv&quot;: null,
                        &quot;chdir&quot;: null,
                        &quot;creates&quot;: null,
                        &quot;executable&quot;: null,
                        &quot;removes&quot;: null,
                        &quot;stdin&quot;: null,
                        &quot;stdin_add_newline&quot;: true,
                        &quot;strip_empty_ends&quot;: true,
                        &quot;warn&quot;: true
                    }
                },
                &quot;item&quot;: &quot;two&quot;,
                &quot;rc&quot;: 0,
                &quot;start&quot;: &quot;2019-06-10 00:23:52.004245&quot;,
                &quot;stderr&quot;: &quot;&quot;,
                &quot;stderr_lines&quot;: [],
                &quot;stdout&quot;: &quot;this is my item: two&quot;,
                &quot;stdout_lines&quot;: [
                    &quot;this is my item: two&quot;
                ]
            }
        ]
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br></div></div><h2 id="_4-旧循环语句"> 4 旧循环语句</h2>
<p>在Ansible 2.5以前，playbook通过不同的循环语句以实现不同的循环，这些语句使用<code>with_</code>作为前缀。这些语法目前仍然兼容，但在未来的某个时间点，会逐步废弃。</p>
<table>
<thead>
<tr>
<th>循环语句关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>with_items</td>
<td>简单的列表循环</td>
</tr>
<tr>
<td>with_nested</td>
<td>嵌套循环</td>
</tr>
<tr>
<td>with_dict</td>
<td>循环字典</td>
</tr>
<tr>
<td>with_fileglob</td>
<td>循环指定目录中的所有文件</td>
</tr>
<tr>
<td>with_lines</td>
<td>循环一个文件中的所有行</td>
</tr>
<tr>
<td>with_sequence</td>
<td>生成一个自增的整数序列，可以指定起始值和结束值以及步长。参数以key=value的形式指定，format指定输出的格式。数字可以是十进制、十六进制、八进制</td>
</tr>
<tr>
<td>with_subelement</td>
<td>遍历子元素</td>
</tr>
<tr>
<td>with_together</td>
<td>遍历数据并行集合</td>
</tr>
</tbody>
</table>
<h3 id="_4-1-with-items"> 4.1 with_items</h3>
<div><pre><code>- hosts: test
  vars:
    data:
      - user0
      - user1
      - user2
  tasks:
    - name: &quot;with_items&quot;
      debug:
        msg: &quot;{{ item }}&quot;
      with_items: &quot;{{ data }}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="_4-2-with-nested"> 4.2 with_nested</h3>
<div><pre><code>tasks: 
  - name: debug loops
    debug: msg=&quot;name is {{ item[0] }}  vaule is {{ item[1] }} num is {{ item[2] }}&quot;
    with_nested:
      - [&#39;alice&#39;,&#39;bob&#39;]
      - [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]
      - [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>item[0]是循环的第一个列表的值['alice','bob']。item[1]是第二个列表的值；item[2]则是第三个列表的值，以上的执行输出如下：</p>
<div><pre><code># ansible-playbook with_nested_ex.yml 

PLAY [with_nested test] ******************************************************************************************

TASK [Gathering Facts] *******************************************************************************************
ok: [10.1.61.187]

TASK [debug loops] ***********************************************************************************************
ok: [10.1.61.187] =&gt; (item=[&#39;alice&#39;, &#39;a&#39;, &#39;1&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is alice  vaule is a num is 1&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;alice&#39;, &#39;a&#39;, &#39;2&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is alice  vaule is a num is 2&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;alice&#39;, &#39;a&#39;, &#39;3&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is alice  vaule is a num is 3&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;alice&#39;, &#39;b&#39;, &#39;1&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is alice  vaule is b num is 1&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;alice&#39;, &#39;b&#39;, &#39;2&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is alice  vaule is b num is 2&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;alice&#39;, &#39;b&#39;, &#39;3&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is alice  vaule is b num is 3&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;alice&#39;, &#39;c&#39;, &#39;1&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is alice  vaule is c num is 1&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;alice&#39;, &#39;c&#39;, &#39;2&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is alice  vaule is c num is 2&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;alice&#39;, &#39;c&#39;, &#39;3&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is alice  vaule is c num is 3&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;bob&#39;, &#39;a&#39;, &#39;1&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is bob  vaule is a num is 1&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;bob&#39;, &#39;a&#39;, &#39;2&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is bob  vaule is a num is 2&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;bob&#39;, &#39;a&#39;, &#39;3&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is bob  vaule is a num is 3&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;bob&#39;, &#39;b&#39;, &#39;1&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is bob  vaule is b num is 1&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;bob&#39;, &#39;b&#39;, &#39;2&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is bob  vaule is b num is 2&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;bob&#39;, &#39;b&#39;, &#39;3&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is bob  vaule is b num is 3&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;bob&#39;, &#39;c&#39;, &#39;1&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is bob  vaule is c num is 1&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;bob&#39;, &#39;c&#39;, &#39;2&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is bob  vaule is c num is 2&quot;
}
ok: [10.1.61.187] =&gt; (item=[&#39;bob&#39;, &#39;c&#39;, &#39;3&#39;]) =&gt; {
    &quot;msg&quot;: &quot;name is bob  vaule is c num is 3&quot;
}

PLAY RECAP *******************************************************************************************************
10.1.61.187 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><h3 id="_4-3-with-dict"> 4.3 with_dict</h3>
<div><pre><code><span># 假如有如下变量内容：</span>
<span>users</span><span>:</span>
  <span>alice</span><span>:</span>
    <span>name</span><span>:</span> Alice Appleworth
    <span>telephone</span><span>:</span> 123<span>-</span>456<span>-</span><span>7890</span>
  <span>bob</span><span>:</span>
    <span>name</span><span>:</span> Bob Bananarama
    <span>telephone</span><span>:</span> 987<span>-</span>654<span>-</span><span>3210</span>

<span># 现在需要输出每个用户的用户名和手机号：</span>
<span>tasks</span><span>:</span>
  <span>-</span> <span>name</span><span>:</span> Print phone records
    <span>debug</span><span>:</span> msg="User <span>{</span><span>{</span> item.key <span>}</span><span>}</span> is <span>{</span><span>{</span> item.value.name <span>}</span><span>}</span> (<span>{</span><span>{</span> item.value.telephone <span>}</span><span>}</span>)"
    <span>with_dict</span><span>:</span> <span>"{{ users }}"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="_4-4-with-fileglob"> 4.4 with_fileglob</h3>
<div><pre><code>- hosts: test
  tasks:
    - name: Make key directory     
      file: 
        path: /root/.sshkeys 
        state: directory 
        mode: 0700 
        owner: root 
        group: root 
        
    - name: Upload public keys     
      copy: 
        src: &quot;{{ item }}&quot;
        dest: /root/.sshkeys
        mode: 0600 
        owner: root 
        group: root  
      with_fileglob:
        - /root/.ssh/*.pub 
        
    - name: Assemble keys into authorized_keys file     
      assemble: 
        src: /root/.sshkeys 
        dest: /root/.ssh/authorized_keys
        mode: 0600 
        owner: root 
        group: root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="_4-5-with-lines"> 4.5 with_lines</h3>
<p>with_lines循环结构会让你在控制主机上执行任意命令，并对命令的输出进行逐行迭代。假设我们有一个 文件test.txt包含如下行：</p>
<div><pre><code>Breeze Yan
Bernie Yang
jerry Qing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们可以通过如下方法进行逐行输出：</p>
<div><pre><code>- name: print all names
  debug: msg=&quot;{{ item }}&quot;
  with_lines:
    - cat test.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_4-6-with-subelement"> 4.6 with_subelement</h3>
<p>假如现在需要遍历一个用户列表，并创建每个用户，而且还需要为每个用户配置以特定的SSH key登录。变量文件内容如下：</p>
<div><pre><code>users:
  - name: alice
    authorized:
      - /tmp/alice/onekey.pub
      - /tmp/alice/twokey.pub
    mysql:
        password: mysql-password
        hosts:
          - &quot;%&quot;
          - &quot;127.0.0.1&quot;
          - &quot;::1&quot;
          - &quot;localhost&quot;
        privs:
          - &quot;*.*:SELECT&quot;
          - &quot;DB1.*:ALL&quot;
  - name: bob
    authorized:
      - /tmp/bob/id_rsa.pub
    mysql:
        password: other-mysql-password
        hosts:
          - &quot;db1&quot;
        privs:
          - &quot;*.*:SELECT&quot;
          - &quot;DB2.*:ALL&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>playbook中定义如下：</p>
<div><pre><code>tasks:
  - user: name={{ item.name }} state=present generate_ssh_key=yes
    with_items: &quot;{{users}}&quot;
  - authorized_key: &quot;user={{ item.0.name }} key=&#39;{{ lookup(&#39;file&#39;, item.1) }}&#39;&quot;
    with_subelements:
     - users
     - authorized
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>也可以遍历嵌套的子列表：</p>
<div><pre><code>- name: Setup MySQL users
  mysql_user: name={{ item.0.name }} password={{ item.0.mysql.password }} host={{ item.1 }} priv={{ item.0.mysql.privs | join(&#39;/&#39;) }}
  with_subelements:
    - users
    - mysql.hosts
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_4-7-with-sequence"> 4.7 with_sequence</h3>
<div><pre><code>- hosts: all
  tasks:
    # create groups
    - group: name=evens state=present
    - group: name=odds state=present
    # create some test users
    - user: name={{ item }} state=present groups=evens
      with_sequence: start=0 end=32 format=testuser%02d
    # create a series of directories with even numbers for some reason
    - file: dest=/var/stuff/{{ item }} state=directory
      with_sequence: start=4 end=16 stride=2    # stride用于指定步长
    # a simpler way to use the sequence plugin
    # create 4 groups
    - group: name=group{{ item }} state=present
      with_sequence: count=4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="_4-8-with-random-choice"> 4.8 with_random_choice</h3>
<p>从列表中随机取一个值：</p>
<div><pre><code>- debug: msg={{ item }}
  with_random_choice:
     - &quot;go through the door&quot;
     - &quot;drink from the goblet&quot;
     - &quot;press the red button&quot;
     - &quot;do nothing&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_4-9-do-util循环"> 4.9 do-Util循环</h3>
<div><pre><code>- action: shell /usr/bin/foo
  register: result
  until: result.stdout.find(&quot;all systems go&quot;) != -1
  retries: 5
  delay: 10
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>重复执行shell模块，当shell模块执行的命令输出内容包含&quot;all systems go&quot;的时候停止。重试5次，延迟时间10秒。retries默认值为3，delay默认值为5。任务的返回值为最后一次循环的返回结果。</p>
<h3 id="_4-10-with-together"> 4.10 with_together</h3>
<p>示例：</p>
<div><pre><code>- hosts: webservers
  remote_user: root
  vars:
    alpha: [ &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]
    numbers: [ 1,2,3,4 ]
  tasks:
    - debug: msg=&quot;{{ item.0 }} and {{ item.1 }}&quot;
      with_together:
         - &quot;{{ alpha }}&quot;
         - &quot;{{ numbers }}&quot;
# 输出的结果为：
ok: [192.168.1.65] =&gt; (item=[&#39;a&#39;, 1]) =&gt; {
    &quot;item&quot;: [
        &quot;a&quot;,
        1
    ],
    &quot;msg&quot;: &quot;a and 1&quot;
}
ok: [192.168.1.65] =&gt; (item=[&#39;b&#39;, 2]) =&gt; {
    &quot;item&quot;: [
        &quot;b&quot;,
        2
    ],
    &quot;msg&quot;: &quot;b and 2&quot;
}
ok: [192.168.1.65] =&gt; (item=[&#39;c&#39;, 3]) =&gt; {
    &quot;item&quot;: [
        &quot;c&quot;,
        3
    ],
    &quot;msg&quot;: &quot;c and 3&quot;
}
ok: [192.168.1.65] =&gt; (item=[&#39;d&#39;, 4]) =&gt; {
    &quot;item&quot;: [
        &quot;d&quot;,
        4
    ],
    &quot;msg&quot;: &quot;d and 4&quot;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><blockquote>
<p>参考链接：</p>
<p>https://www.cnblogs.com/breezey/p/10996629.html</p>
<p>https://blog.51cto.com/cloumn/blog/1544</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">4.3 Playbook条件语句</title>
    <id>https://clay-wangzhi.com/automate/ansible/playbook-if/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/playbook-if/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-3-playbook条件语句"> 4.3 Playbook条件语句</h1>
<h2 id="_1-简介"> 1 简介</h2>
<p>在有的时候play的结果依赖于变量、fact或者是前一个任务的执行结果，或者有的时候，我们会基于上一个task执行返回的结果而决定如何执行后续的task。这个时候就需要用到条件判断。</p>
<p>条件语句在Ansible中的使用场景：</p>
<ul>
<li>在目标主机上定义了一个硬限制，比如目标主机的最小内存必须达到多少，才能执行该task</li>
<li>捕获一个命令的输出，根据命令输出结果的不同以触发不同的task</li>
<li>根据不同目标主机的facts，以定义不同的task</li>
<li>根据目标机的cpu的大小，以调优相关应用性能</li>
<li>用于判断某个服务的配置文件是否发生变更，以确定是否需要重启服务</li>
</ul>
<h2 id="_2-when关键字"> 2 when关键字</h2>
<h3 id="_2-1-when基本使用"> 2.1 when基本使用</h3>
<p>在ansible中，使用条件判断的关键字就是when。</p>
<p>如在安装包的时候，需要指定主机的操作系统类型，或者是当操作系统的硬盘满了之后，需要清空文件等,可以使用when语句来做判断 。when关键字后面跟着的是python的表达式,在表达式中你能够使用任何的变量或者fact,当表达式的结果返回的是false,便会跳过本次的任务</p>
<p>下面是一个基本的用法示例：</p>
<div><pre><code>---
- name: Install vim
  hosts: all
  tasks:
    - name:Install VIM via yum
      yum: 
        name: vim-enhanced 
        state: installed
      when: ansible_os_family ==&quot;RedHat&quot;
      
    - name:Install VIM via apt
      apt: 
        name: vim 
        state: installed
      when: ansible_os_family ==&quot;Debian&quot;
      
    - name: Unexpected OS family
      debug: msg=&quot;OS Family {{ ansible_os_family }} is not supported&quot; fail=yes
      when: not ansible_os_family ==&quot;RedHat&quot; or ansible_os_family ==&quot;Debian&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="_2-2-比较运算符"> 2.2  比较运算符</h3>
<p>在上面的示例当中，我们使用了&quot;==&quot;的比较运算符，在ansible中，还支持如下比较运算符：</p>
<ul>
<li><code>==</code>：比较两个对象是否相等，相等则返回真。可用于比较字符串和数字</li>
<li><code>!=</code>：比较两个对象是否不等，不等则为真。</li>
<li><code>&gt;</code>：比较两个对象的大小，左边的值大于右边的值，则为真</li>
<li><code>&lt;</code>：比较两个对象的大小，左边的值小于右边的值，则为真</li>
<li><code>&gt;=</code>：比较两个对象的大小，左边的值大于等于右边的值，则为真</li>
<li><code>&lt;=</code>：比较两个对象的大小，左边的值小于等于右边的值，则为真</li>
</ul>
<p>下面是一些简单的示例：</p>
<div><pre><code>when: ansible_machine == &quot;x86_64&quot; 

when: max_memory &lt;= 512
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_2-3-逻辑运算符"> 2.3 逻辑运算符</h3>
<p>在Ansible中，除了比较运算符，还支持逻辑运算符：</p>
<ul>
<li>and：逻辑与，当左边和右边两个表达式同时为真，则返回真</li>
<li>or：逻辑或，当左右和右边两个表达式任意一个为真，则返回真</li>
<li>not：逻辑否，对表达式取反</li>
<li>()：当一组表达式组合在一起，形成一个更大的表达式，组合内的所有表达式都是逻辑与的关系</li>
</ul>
<p>示例：</p>
<div><pre><code># 逻辑或
when: ansible_distribution == &quot;RedHat&quot; or ansible_distribution == &quot;Fedora&quot;

# 逻辑与
when: ansible_distribution_version == &quot;7.5&quot; and ansible_kernel == &quot;3.10.0-327.el7.x86_64&quot;

when:
  - ansible_distribution_version == &quot;7.5&quot;
  - ansible_kernel == &quot;3.10.0-327.el7.x86_64&quot;
  
# 组合

when: =&gt; 
  ( ansible_distribution == &quot;RedHat&quot; and ansible_distribution_major_version == &quot;7&quot; )
  or
  ( ansible_distribution == &quot;Fedora&quot; and ansible_distribution_major_version == &quot;28&quot;)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>一个完整的例子：</p>
<div><pre><code># 判断register注册变量的返回结果
- name: restart httpd if postfix is running
  hosts: test
  tasks:
    - name: get postfix server status
      command: /usr/bin/systemctl is-active postfix
      ignore_errors: yes
      register: result
      
    - name: restart apache httpd based on postfix status
      service:
        name: httpd
        state: restarted
      when: result.rc == 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="_3-条件判断与tests"> 3 条件判断与tests</h2>
<p>在shell当中，我们可使用test命令来进行一些常用的判断操作，如下：</p>
<div><pre><code># 判断/test文件是否存在
test -e /test

# 判断/testdir是否存在且为一个目录
test -d /testdir
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>事实上，在ansible中也有类似的用法，只不过ansible没有使用linux的test命令，而是jinja2模板的tests。</p>
<p>下面是一个简单示例：</p>
<div><pre><code># 通过条件语句判断testpath的路径是否存在
- hosts: test
  vars:
    testpath: /testdir
  tasks:
    - debug:
        msg: &quot;file exist&quot;
      when: testpath is exists
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面的示例中，我们使用了<code>is exists</code>用于路径存在时返回真，也可以使用<code>is not exists</code>用于路径不存在时返回真。也可以在整个条件表达式的前面使用not以取反：</p>
<div><pre><code>- hosts: test
  vars:
    testpath: /testdir1
  tasks:
    - debug:
        msg: &quot;file not exist&quot;
      when: not testpath is exists
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在ansible中，除了能够使用exists这种tests之外，还有一些别的tests。接下来我们详细说一说。</p>
<h3 id="_3-1-判断变量"> 3.1 判断变量</h3>
<ul>
<li>defined：判断变量是否已定义，已定义则返回真</li>
<li>undefined：判断变量是否未定义，未定义则返回真</li>
<li>none：判断变量的值是否为空，如果变量已定义且值为空，则返回真</li>
</ul>
<p>示例：</p>
<div><pre><code>- hosts: test
  gather_facts: no
  vars:
    testvar: &quot;test&quot;
    testvar1:
  tasks:
    - debug:
        msg: &quot;testvar is defined&quot;
      when: testvar is defined
    - debug:
        msg: &quot;testvar2 is undefined&quot;
      when: testvar2 is undefined
    - debug:
        msg: &quot;testvar1 is none&quot;
      when: testvar1 is none
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="_3-2-判断执行结果"> 3.2 判断执行结果</h3>
<ul>
<li>sucess或succeeded：通过任务执行结果返回的信息判断任务的执行状态，任务执行成功则返回true</li>
<li>failure或failed：任务执行失败则返回true</li>
<li>change或changed：任务执行状态为changed则返回true</li>
<li>skip或skipped：任务被跳过则返回true</li>
</ul>
<p>示例：</p>
<div><pre><code>- hosts: test
  gather_facts: no
  vars:
    doshell: true
  tasks:
    - shell: &#39;cat /testdir/aaa&#39;
      when: doshell
      register: result
      ignore_errors: true
    - debug:
        msg: &quot;success&quot;
      when: result is success
      
    - debug:
        msg: &quot;failed&quot;
      when: result is failure
      
    - debug:
        msg: &quot;changed&quot;
      when: result is change
      
    - debug:
        msg: &quot;skip&quot;
      when: result is skip
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="_3-3-判断路径"> 3.3 判断路径</h3>
<ul>
<li>file：判断指定路径是否为一个文件，是则为真</li>
<li>directory：判断指定路径是否为一个目录，是则为真</li>
<li>link：判断指定路径是否为一个软链接，是则为真</li>
<li>mount：判断指定路径是否为一个挂载点，是则为真</li>
<li>exists：判断指定路径是否存在，存在则为真</li>
</ul>
<blockquote>
<p>特别注意：关于路径的所有判断均是判断主控端上的路径，而非被控端上的路径</p>
</blockquote>
<p>示例：</p>
<div><pre><code>- hosts: test
  gather_facts: no
  vars:
    testpath1: &quot;/testdir/test&quot;
    testpath2: &quot;/testdir&quot;
  tasks:
    - debug:
        msg: &quot;file&quot;
      when: testpath1 is file
    - debug:
        msg: &quot;directory&quot;
      when: testpath2 is directory
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_3-4-判断字符串"> 3.4 判断字符串</h3>
<ul>
<li>lower：判断字符串中的所有字母是否都是小写，是则为真</li>
<li>upper：判断字符串中的所有字母是否都是大写，是则为真</li>
</ul>
<div><pre><code>- hosts: test
  gather_facts: no
  vars: 
    str1: &quot;abc&quot;
    str2: &quot;ABC&quot;
  tasks:
    - debug:
        msg: &quot;str1 is all lowercase&quot;
      when: str1 is lower
    - debug:
        msg: &quot;str2 is all uppercase&quot;
      when: str2 is upper
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_3-5-判断整除"> 3.5 判断整除</h3>
<ul>
<li>even：判断数值是否为偶数，是则为真</li>
<li>odd：判断数值是否为奇数，是则为真</li>
<li>divisibleby(num)：判断是否可以整除指定的数值，是则为真</li>
</ul>
<p>示例：</p>
<div><pre><code>- hosts: test
  gather_facts: no
  vars: 
    num1: 6
    num2: 8 
    num3: 15
  tasks:
    - debug: 
        msg: &quot;num1 is an even number&quot;
      when: num1 is even
    - debug:
        msg: &quot;num2 is an odd number&quot;
      when: num2 is odd
    - debug:
        msg: &quot;num3 can be divided exactly by&quot;
      when: num3 is divisibleby(3)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_3-6-其他tests"> 3.6 其他tests</h3>
<ol>
<li>
<p>version</p>
<p>可用于对比两个版本号的大小，或者与指定的版本号进行对比，使用语法为version(&quot;版本号&quot;,&quot;比较操作符&quot;)</p>
<div><pre><code>- hosts: test
  vars:
    ver1: 1.2
    ver2: 1.3
  tasks:
    - debug:
        msg: &quot;ver1 is greater than ver2&quot;
      when: ver1 is version(ver2,&quot;&gt;&quot;)
    - debug:
        msg: &quot;system version {{ ansible_distribution_version }} greater than 7.3&quot;
      when: ansible_distribution_version is version(&quot;7.3&quot;,&quot;gt&quot;)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>version中使用的比较运算符说明：</p>
<ul>
<li>大于： &gt;, gt</li>
<li>大于等于： &gt;=, ge</li>
<li>小于： &lt;, lt</li>
<li>小于等于： &lt;=, le</li>
<li>等于： =, ==, eq</li>
<li>不等于： !=, &lt;&gt;, ne</li>
</ul>
</li>
<li>
<p>subset
判断一个list是不是另一个list的子集</p>
</li>
<li>
<p>superset
判断一个list是不是另一个list的父集&quot;</p>
<div><pre><code>- hosts: test
  gather_facts: no
  vars:
    a:
      - 2
      - 5
    b: [1,2,3,4,5]
  tasks:
    - debug:
        msg: &quot;A is a subset of B&quot;
      when: a is subset(b)
    - debug:
        msg: &quot;B is the parent set of A&quot;
      when: b is superset(a)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
<li>
<p>in
判断一个字符串是否存在于另一个字符串中，也可用于判断某个特定的值是否存在于列表中</p>
<div><pre><code>- hosts: test
  vars:
    supported_distros:
      - RedHat
      - CentOS
  tasks:
    - debug:
        msg: &quot;{{ ansible_distribution }} in supported_distros&quot;
      when: ansible_distribution in supported_distros
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p>string
判断对象是否为一个字符串，是则为真</p>
</li>
<li>
<p>number
判断对象是否为一个数字，是则为真</p>
</li>
</ol>
<div><pre><code>- hosts: test
  gather_facts: no
  vars:
    var1: 1
    var2: &quot;1&quot;
    var3: a
  tasks:
    - debug:
        msg: &quot;var1 is a number&quot;
      when: var1 is number
    - debug:
        msg: &quot;var2 is a string&quot;
      when: var2 is string
    - debug:
        msg: &quot;var3 is a string&quot;
      when: var3 is string
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="_4-条件判断与block"> 4 条件判断与block</h2>
<h3 id="_4-1-block"> 4.1 block</h3>
<p>我们在前面使用when做条件判断时，如果条件成立则执行对应的任务。但这就面临一个问题，当我们要使用同一个条件判断执行多个任务的时候，就意味着我们要在某一个任务下面都写一下when语句，而且判断条件完全一样。这种方式不仅麻烦而且显得low。Ansible提供了一种更好的方式来解决这个问题，即block。</p>
<p>在ansible中，使用block将多个任务进行组合，当作一个整体。我们可以对这一个整体做条件判断，当条件成立时，则执行块中的所有任务：</p>
<div><pre><code>- hosts: test
  tasks:
    - debug:
        msg: &quot;task1 not in block&quot;
    - block:
        - debug:
            msg: &quot;task2 in block1&quot;
        - debug:
            msg: &quot;task3 in block1&quot;
      when: 2 &gt; 1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>下面是一个稍微有用点儿的例子：</p>
<div><pre><code>- hosts: test
  tasks:
    - name: set /etc/resolv.conf
      template: 
        src: resolv.conf.j2 
        dest: /etc/resolv.conf 
        owner: root 
        group: root 
        mode: 0644
    - block:
        - name: ensure /etc/resolvconf/resolv.conf.d/base file for ubuntu 16.04
          template: 
            src: resolv.conf.j2
            dest: /etc/resolvconf/resolv.conf.d/base
       
        - name: config dns for ubuntu 16.04
          template: 
            src: resolv.conf.j2
            dest: /etc/resolv.conf
      when: ansible_distribution == &quot;Ubuntu&quot; and ansible_distribution_major_version == &quot;16&quot; 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>使用block注意事项：</p>
<ol>
<li>可以为block定义name（ansible 2.3增加的特性）</li>
<li>可以直接对block使用when，但不能直接对block使用loop</li>
</ol>
<h3 id="_4-2-rescue"> 4.2 rescue</h3>
<p>block除了能和when一起使用之外，还能作错误处理。这个时候就需要用到rescue关键字：</p>
<div><pre><code>- hosts: test
  tasks:
    - block:
        - shell: &#39;ls /testdir&#39;
      rescue:
        - debug:
            msg: &#39;/testdir is not exists&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在上面的例子中，当block中的任务执行失败时，则运行rescue中的任务。如果block中的任务正常执行，则rescue的任务就不会被执行。如果block中有多个任务，则任何一个任务执行失败，都会执行rescue。block中可以定义多个任务，同样rescue当中也可以定义多个任务。</p>
<h3 id="_4-3-always"> 4.3 always</h3>
<p>当block执行失败时，rescue中的任务才会被执行；而无论block执行成功还是失败，always中的任务都会被执行：</p>
<div><pre><code>- hosts: test
  tasks:
    - block:
        - shell: &#39;ls /testdir&#39;
      rescue:
        - debug:
            msg: &#39;/testdir is not exists&#39;
      always:
        - debug:
            msg: &#39;This task always executes&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="_5-条件判断与错误处理"> 5 条件判断与错误处理</h2>
<p>在上面讲block的使用方法的时候，我们说block除了可以将多个任务组合到一起，还有错误处理的功能。接下来我们继续说一说错误处理。</p>
<h3 id="_5-1-fail模块"> 5.1 fail模块</h3>
<p>在shell中，可能会有这样的需求：当脚本执行至某个阶段时，需要对某个条件进行判断，如果条件成立，则立即终止脚本的运行。在shell中，可以直接调用&quot;exit&quot;即可执行退出。事实上，在playbook中也有类似的模块可以做这件事。即fail模块。</p>
<p>fail模块用于终止当前playbook的执行，通常与条件语句组合使用，当满足条件时，终止当前play的运行。</p>
<p>选项只有一个：</p>
<ul>
<li>msg：终止前打印出信息</li>
</ul>
<p>示例：</p>
<div><pre><code><span># 使用fail模块中断playbook输出</span>
<span>-</span> <span>hosts</span><span>:</span> test
  <span>tasks</span><span>:</span>
    <span>-</span> <span>shell</span><span>:</span> echo "Just a test<span>-</span><span>-</span>error" 
      <span>register</span><span>:</span> result
    <span>-</span> <span>fail</span><span>:</span>
        <span>msg</span><span>:</span> <span>"Conditions established,Interrupt running playbook"</span>
      <span>when</span><span>:</span> <span>"'error' in result.stdout"</span>
    <span>-</span> <span>debug</span><span>:</span>
        <span>msg</span><span>:</span> <span>"Inever execute,Because the playbook has stopped"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="_5-2-failed-when"> 5.2 failed_when</h3>
<p>事实上，当fail和when组合使用的时候，还有一个更简单的写法，即<code>failed_when</code>，当满足某个条件时，ansible主动触发失败。</p>
<div><pre><code># 如果在command_result存在错误输出，且错误输出中，包含了`FAILED`字串，即返回失败状态：
- name: this command prints FAILED when it fails
  command: /usr/bin/example-command -x -y -z
  register: command_result
  failed_when: &quot;&#39;FAILED&#39; in command_result.stderr&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>也可以直接通过<code>fail</code>模块和<code>when</code>条件语句，写成如下：</p>
<div><pre><code>- name: this command prints FAILED when it fails
  command: /usr/bin/example-command -x -y -z
  register: command_result
  ignore_errors: True

- name: fail the play if the previous command did not succeed
  fail: msg=&quot;the command failed&quot;
  when: &quot; command_result.stderr and &#39;FAILED&#39; in command_result.stderr&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>ansible一旦执行返回失败，后续操作就会中止，所以failed_when通常可以用于满足某种条件时主动中止playbook运行的一种方式。</p>
</blockquote>
<blockquote>
<p>ansible默认处理错误的机制是遇到错误就停止执行。但有些时候，有些错误是计划之中的。我们希望忽略这些错误，以让playbook继续往下执行。这个时候就可以使用<code>ignore_errors</code>忽略错误，从而让playbook继续往下执行。</p>
</blockquote>
<h3 id="_5-3-changed-when"> 5.3 changed_when</h3>
<p>当我们控制一些远程主机执行某些任务时，当任务在远程主机上成功执行，状态发生更改时，会返回changed状态响应，状态未发生更改时，会返回OK状态响应，当任务被跳过时，会返回skipped状态响应。我们可以通过<code>changed_when</code>来手动更改<code>changed</code>响应状态。示例如下：</p>
<div><pre><code>- shell: /usr/bin/billybass --mode=&quot;take me to the river&quot;
register: bass_result
changed_when: &quot;bass_result.rc != 2&quot;    #只有该条task执行以后，bass_result.rc的值不为2时，才会返回changed状态

# this will never report &#39;changed&#39; status
- shell: wall &#39;beep&#39;
  changed_when: False    #当changed_when为false时，该条task在执行以后，永远不会返回changed状态
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_5-4-断言-assert模块"> 5.4 断言：assert模块</h3>
<p>对于当满足某某条件时就失败的逻辑，可以使用fail模块加when指令来实现，也可使用更为直接的assert模块进行断言。</p>
<p>例如：</p>
<div><pre><code>---
- hosts: localhost
  gather_facts: no
  tasks:
    - assert:
        that:
          - 100 &gt; 20
          - 200 &gt; 200
      fail_msg: &quot;oh, not me&quot;
      success_msg: &quot;oh, it&#39;s me&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>其中that参数接收一个列表，用于定义一个或多个条件，如果条件全为true，则任务成功，只要有一个条件为false，则任务失败。fail_msg(或其别名参数msg)定义任务失败时的信息，success_msg定义任务成功时的信息。</p>
<h3 id="_5-5-any-errors-fatal"> 5.5 any_errors_fatal</h3>
<p>如果想让某个失败的任务直接导致整个play的失败，可在play级别使用any_errors_fatal指令。</p>
<div><pre><code>---
- hosts: nginx
  gather_facts: no
  any_errors_fatal: true
  tasks:
    - fail:
        msg: &quot;oh, not me&quot;
      when: inventory_hostname == groups[&#39;nginx&#39;][0]
    - debug:
        msg: &quot;hello&quot;

- hosts: localhost
  gather_facts: no
  tasks:
    - debug:
        msg: &quot;HELLO WORLD&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>将any_errors_fatal设置为true后，nginx组第一个节点只要一开始执行fail任务，整个playbook中所有后续任务都将不再执行，就连其它play也一样不执行。</p>
<p>注意观察playbook的执行结果，它将提示&quot;NO MORE HOSTS LEFT&quot;：</p>
<div><pre><code>........
TASK [fail] *********************
fatal: [192.168.200.42]: FAILED! =&gt; {&quot;changed&quot;: false, &quot;msg&quot;: &quot;oh, not me&quot;}
skipping: [192.168.200.43]
skipping: [192.168.200.44]

NO MORE HOSTS LEFT **************

PLAY RECAP *************
.........
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="_5-6-max-fail-percentage"> 5.6 max_fail_percentage</h3>
<p>略</p>
<h2 id="_6-在循环语句中使用条件语句"> 6 在循环语句中使用条件语句</h2>
<div><pre><code># 只打印大于5的值
tasks:
    - command: echo {{ item }}
      loop: [ 0, 2, 4, 6, 8, 10 ]
      when: item &gt; 5
# 确保将mariadb-server安装到根分区且根分区的可用空间要大于300M
- name: install mariadb-server if enough space on root
  yum: 
    name: mariadb-server
    state；拉特st
  loop: &quot;{{ ansible_mounts }}&quot;
  when: item.mount == &quot;/&quot; and item.size_available &gt; 300000000
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>转载链接：https://www.cnblogs.com/breezey/p/10996632.html</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">4 Ansible Playbook</title>
    <id>https://clay-wangzhi.com/automate/ansible/playbook/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/playbook/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-ansible-playbook"> 4 Ansible Playbook</h1>
<h2 id="_1-ansible-playbook简介"> 1 Ansible Playbook简介</h2>
<p>Ansible 靠ansible命令是撑不起自动化管理这把大伞的，Ansible真正强大的是playbook，它才是Ansible撬动自动化管理的结实杠杆。</p>
<p>ansbile-playbook是一系列ansible命令的集合，利用yaml 语言编写。playbook命令根据自上而下的顺序依次执行。同时，playbook开创了很多特性,它可以允许你传输某个命令的状态到后面的指令,如你可以从一台机器的文件中抓取内容并附为变量,然后在另一台机器中使用,这使得你可以实现一些复杂的部署机制,这是ansible命令无法实现的。</p>
<p>playbook通过ansible-playbook命令使用,它的参数和ansible命令类似,如参数-k(–ask-pass) 和 -K (–ask-sudo) 来询问ssh密码和sudo密码,-u指定用户,这些指令也可以通过规定的单元写在playbook 。</p>
<p>ansible-playbook的简单使用方法: ansible-playbook example-play.yml 。</p>
<h3 id="playbook、play和task的关系"> playbook、play和task的关系</h3>
<ul>
<li>playbook中可以定义一个或多个play</li>
<li>每个play中可以定义一个或多个task</li>
<li>每个play都需要通过hosts指令指定要执行改play的目标主机</li>
<li>每个play都可以设置一些该play的环境控制行为，比如定义play级别的变量</li>
</ul>
<blockquote>
<p>其中还可以定义两类特殊的task：pre_tasks和post_tasks</p>
<ul>
<li>pre_tasks表示执行执行普通任务之前执行的任务列表</li>
<li>post_tasks表示普通任务执行完之后执行的任务列表</li>
</ul>
</blockquote>
<h2 id="_2-playbook基本语法"> 2 Playbook基本语法</h2>
<p>下面是一个简单的ansible-playbook示例，可以了解其构成:</p>
<div><pre><code><span># cat user.yml</span>
<span>-</span> <span>name</span><span>:</span> create user
  <span>hosts</span><span>:</span> all
  <span>remote_user</span><span>:</span> root
  <span>gather_facts</span><span>:</span> <span>false</span>
  <span>vars</span><span>:</span>
    user<span>:</span><span>"test"</span>
  <span>tasks</span><span>:</span>
    <span>-</span> <span>name</span><span>:</span> create  user
      <span>user</span><span>:</span> name="<span>{</span><span>{</span> user <span>}</span><span>}</span>"
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>配置项说明：</p>
<ul>
<li>
<p><code>name</code>：对该playbook实现的功能做一个概述，后面执行过程中，会打印 name变量的值</p>
</li>
<li>
<p><code>hosts</code>：指定对哪些被管理机进行操作；</p>
</li>
<li>
<p><code>remote_user</code>：指定在远程被管理机上执行操作时使用什么用户，如不指定，则使用ansible.cfg中配置的remote_user</p>
</li>
<li>
<p><code>gather_facts</code>：指定在执行任务之前，是否先执行setup模块获取主机相关信息，如未用到，可不指定</p>
</li>
<li>
<p><code>vars</code>：定义后续任务中会使用到的变量，如未用到，可不指定</p>
</li>
<li>
<div><pre><code>tasks
</code></pre>
<div><span>1</span><br></div></div><p>：定义具体需要执行的任务</p>
<ul>
<li>name：对任务的描述，在执行过程中会打印出来。</li>
<li>user：指定调用user模块；
<ul>
<li>name：user模块里的一个参数，用于指定创建的用户名称</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>同样，如果想实现把这个新增的用户删除，只需将该playbook文件的最后一行替换为如下行再执行相应的playbook即可：</p>
<div><pre><code>user: name=&quot;{{ user }}&quot; state=absent remove=yes
</code></pre>
<div><span>1</span><br></div></div><h2 id="_3-playbook简单示例"> 3 Playbook简单示例</h2>
<p>下面通过playbook管理一个httpd服务器来简单了解下playbook的应用：</p>
<ol>
<li>创建playbook</li>
</ol>
<div><pre><code><span># cat manage_apache.yml</span>
<span>-</span> <span>name</span><span>:</span> play to setup web server
  <span>hosts</span><span>:</span> all
  <span>tasks</span><span>:</span>
    <span>-</span> <span>name</span><span>:</span> latest httpd version installed
      <span>yum</span><span>:</span>
        <span>name</span><span>:</span> httpd
        <span>state</span><span>:</span> latest
        
    <span>-</span> <span>name</span><span>:</span> correct index.html is present
      <span>copy</span><span>:</span> 
        <span>src</span><span>:</span> files/index.html
        <span>dest</span><span>:</span> /var/www/html/index.html
        
    <span>-</span> <span>name</span><span>:</span> start httpd service
      <span>service</span><span>:</span>
        <span>name</span><span>:</span> httpd
        <span>state</span><span>:</span> started
        <span>enabled</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ol>
<li>执行playbook</li>
</ol>
<div><pre><code># ansible-playbook  manage_apache.yml 

PLAY [play to setup web server] *********************************************************************************************************************************************

TASK [Gathering Facts] ******************************************************************************************************************************************************
ok: [10.1.61.187]

TASK [latest httpd version installed] ***************************************************************************************************************************************
changed: [10.1.61.187]

TASK [correct index.html is present] ****************************************************************************************************************************************
changed: [10.1.61.187]

TASK [start httpd service] **************************************************************************************************************************************************
changed: [10.1.61.187]

PLAY RECAP ******************************************************************************************************************************************************************
10.1.61.187                : ok=4    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="_4-ansible-playbook常用选项"> 4 ansible-playbook常用选项</h2>
<h3 id="_4-1-打印详细信息"> 4.1 打印详细信息</h3>
<ul>
<li>-v：打印任务运行结果</li>
<li>-vv：打印任务运行结果以及任务的配置信息</li>
<li>-vvv：包含了远程连接的一些信息</li>
<li>-vvvv：Adds extra verbosity options to the connection plug-ins,including the users being used in the managed hosts to execute scripts, and what scripts have been executed</li>
</ul>
<div><pre><code># ansible-playbook  manage_apache.yml  -vv
</code></pre>
<div><span>1</span><br></div></div><h3 id="_4-2-校验playbook语法"> 4.2  校验playbook语法</h3>
<div><pre><code># ansible-playbook --syntax-check  manage_apache.yml   

playbook: manage_apache.yml
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_4-3-测试运行playbook"> 4.3 测试运行playbook</h3>
<p>通过-C选项可以测试playbook的执行情况，但不会真的执行：</p>
<div><pre><code># ansible-playbook -C  manage_apache.yml  

PLAY [play to setup web server] *********************************************************************************************************************************************

TASK [Gathering Facts] ******************************************************************************************************************************************************
ok: [10.1.61.187]

TASK [latest httpd version installed] ***************************************************************************************************************************************
ok: [10.1.61.187]

TASK [correct index.html is present] ****************************************************************************************************************************************
ok: [10.1.61.187]

TASK [start httpd service] **************************************************************************************************************************************************
ok: [10.1.61.187]

PLAY RECAP ******************************************************************************************************************************************************************
10.1.61.187                : ok=4    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="_4-4-playbook模块参数的传递方式"> 4.4 playbook模块参数的传递方式</h3>
<p>copy模块的参数传递方式如下</p>
<div><pre><code>tasks:
  - name: copy /etc/passwd to /tmp
    copy: src=/etc/passwd dest=/tmp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这是标准的yaml语法，参数部分src=/etc/passwd dest=/tmp是一个字符串，当作copy对应的值。根据4_8 yaml介绍的yaml语法，还可以换行书写。有以下几种方式：</p>
<div><pre><code>---
- name: first play
  hosts: nginx
  gather_facts: false
  tasks:
  - copy:
    src=/etc/passwd dest=/tmp

  - copy:
    src=/etc/passwd
    dest=/tmp

  - copy: &gt;
    src=/etc/passwd
    dest=/tmp

  - copy: |
    src=/etc/passwd
    dest=/tmp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>除此之外，Ansible还提供了另外两种传递参数的方式：</p>
<p>(1).将参数和参数值写成key: value的方式</p>
<p>(2).使用args参数声明接下来的是参数</p>
<p>通过示例便可对其用法一目了然：</p>
<div><pre><code>---
- name: first play
  hosts: nginx
  gather_facts: false
  tasks:
  - name: copy1
    copy:
      src: /etc/passwd
      dest: /tmp

  - name: copy2
    copy:
    args:
      src: /etc/passwd
      dest: /tmp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>大多数时候，使用何种方式传递参数并无关紧要，只要个人觉得可读性高、方便、美观即可。</p>
<h2 id="_5-multiple-plays"> 5 Multiple Plays</h2>
<div><pre><code># This is a simple playbook with two plays

- name: first play
  hosts: web.example.com
  tasks:
    - name: first task
      yum:
        name: httpd
        status: present
    - name: second task
      service:
        name: httpd
        state: started
    
- name: second play
  hosts: db.example.com
  tasks:
    - name: first task
      yum:
        name: mariadb-server
        status: present
    - name: second task
      service:
        name: mariadb
        state: started
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><blockquote>
<p>参考链接：</p>
<p>https://www.cnblogs.com/breezey/p/8811250.html</p>
<p>https://blog.51cto.com/cloumn/blog/1544</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">7 常见问题</title>
    <id>https://clay-wangzhi.com/automate/ansible/qa/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/qa/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_7-常见问题"> 7 常见问题</h1>
<h3 id="_4-3-关于ssh连接一些常见的错误说明"> 4.3 关于ssh连接一些常见的错误说明</h3>
<ol>
<li><code>ERROR! to use the 'ssh' connection type with passwords, you must install the sshpass program</code></li>
</ol>
<p>完整错误示例如下：</p>
<div><pre><code>root@ctnr:/etc/ansible# ansible &#39;*.a32-168-1.*&#39; -m ping
ctnr.a32-168-1.prod.yiz | FAILED! =&gt; {
    &quot;failed&quot;: true, 
    &quot;msg&quot;: &quot;ERROR! to use the &#39;ssh&#39; connection type with passwords, you must install the sshpass program&quot;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>一般出现这种错误，是在通过密码验证远程被管理机的时候，需要在server端安装sshpass：</p>
<div><pre><code>yum install sshpass -y 
</code></pre>
<div><span>1</span><br></div></div><ol>
<li><code>Using a SSH password instead of a key is not possible because Host Key checking is enabled and sshpass does not support this. Please add this host's fingerprint to your known_hosts file to manage this host</code></li>
</ol>
<p>完整错误如下：</p>
<div><pre><code>ansible test -a &#39;uptime&#39;

192.168.1.1| FAILED =&gt;Using a SSH password instead of a key is not possible because HostKey checking is enabled and sshpass does not support this.Please add this host&#39;s fingerprint to your known_hosts file to manage this host.
192.168.1.2 | FAILED =&gt; Using a SSH password instead of a key is not possible because Host Key checking is enabled and sshpass does not support this.  Please add this host&#39;s fingerprint to your known_hosts file to manage this host.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这种错误通常就出现在server端第一次连接被管理机的时候，就是上面说到的需要通过输入yes/no进行确认将key字符串加入到<code>~/.ssh/known_hosts</code>文件中。</p>
<p>解决办法有两个：</p>
<ul>
<li>通过修改上面提到的host_key_checking，将其设置为false</li>
<li>通过修改ssh_args参数，修改如下：</li>
</ul>
<div><pre><code>ssh_args = -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no 
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Ansible 学习笔记</title>
    <id>https://clay-wangzhi.com/automate/ansible/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ansible-学习笔记"> Ansible 学习笔记</h1>
<p>Hello Ansible~</p>
<h2 id="summary"> Summary</h2>
<ul>
<li>[1 初识Ansible](Ansible/1 初识Ansible.md)</li>
<li>[2 Ansible Inventory 配置详解](Ansible/2 Ansible Inventory配置详解.md)</li>
<li>[3 Ansible Ad-hoc 命令集](Ansible/3 Ansible Ad-hoc命令集.md)</li>
<li>[3.1 Ansible lineinfile 模块详解](Ansible/3_1_Ansible lineinfile模块详解.md)</li>
<li>[4 Ansible Playbook](Ansible/4 Ansible Playbook.md)
<ul>
<li>[4.1 Playbook的结构及handler用法](Ansible/4_1_ Playbook的结构及handler用法.md)</li>
<li><a href="./Ansible/4_2_Playbook循环语句.html">4.2 Playbook循环语句</a></li>
<li><a href="./Ansible/4_3_Playbook条件语句.html">4.3 Playbook条件语句</a></li>
<li><a href="./Ansible/4_4_Playbook高级用法.html">4.4 Playbook高级用法</a></li>
<li><a href="./Ansible/4_5_Playbook之tags.html">4.5 Playbook之tags</a></li>
<li><a href="./Ansible/4_6_巧用Roles.html">4.6 巧用Roles</a></li>
<li><a href="./Ansible/4_7_文件管理模块及Jinja2过滤器.html">4.7 文件管理模块及Jinja2过滤器</a></li>
<li><a href="./Ansible/4_8_yaml语法.html">4.8 yaml 语法</a></li>
</ul>
</li>
<li>[5 Ansible变量](Ansible/5 Ansible变量.md)
<ul>
<li><a href="./Ansible/5_1_自定义变量.html">5.1 自定义变量</a></li>
<li><a href="./Ansible/5_2_Fact变量.html">5.2 Fact变量</a></li>
<li><a href="./Ansible/5_3_魔法变量.html">5.3 魔法变量</a></li>
<li><a href="./Ansible/5_4_使用lookup生成变量.html">5.4 使用lookup生成变量</a></li>
<li><a href="./Ansible/5_5_使用vault配置加密.html">5.5 使用vault配置加密</a></li>
</ul>
</li>
<li>[6 Ansible使用优化](Ansible/6 Ansible使用优化.md)</li>
</ul>
<h2 id="核心知识点概览"> 核心知识点概览</h2>
<h3 id="目前生产中ansible-的使用场景"> 目前生产中ansible 的使用场景</h3>
<ul>
<li>
<p><a href="https://github.com/clay-wangzhi/ansible-role-sysinit" target="_blank" rel="noopener noreferrer">系统初始化</a></p>
</li>
<li>
<p><a href="https://wiki.clay-wangzhi.com/10-zabbix/10.2-zabbix-jie-zhu-ansible-an-zhuang" target="_blank" rel="noopener noreferrer">安装配置zabbix</a></p>
</li>
<li>
<p><a href="">安装配置elk</a></p>
</li>
<li>
<p><a href="https://github.com/clay-wangzhi/ansible-role-tomcat" target="_blank" rel="noopener noreferrer">安装配置tomcat</a></p>
</li>
<li>
<p><a href="https://github.com/clay-wangzhi/ansible-role-mysql" target="_blank" rel="noopener noreferrer">安装配置mysql</a></p>
</li>
<li>
<p><a href="https://github.com/clay-wangzhi/ansible-role-jenkins" target="_blank" rel="noopener noreferrer">安装配置jenkins</a></p>
</li>
<li>
<p><a href="https://github.com/clay-wangzhi/ansible-role-zookeeper" target="_blank" rel="noopener noreferrer">安装配置zookeeper集群</a></p>
</li>
<li>
<p><a href="">项目升级发布</a></p>
</li>
<li>
<p><a href="https://github.com/easzlab/kubeasz" target="_blank" rel="noopener noreferrer">安装配置二进制的kubernetes集群</a></p>
</li>
</ul>
<h3 id="ansible-有哪些特性"> Ansible 有哪些特性</h3>
<ul>
<li>Agentless，无客户端</li>
<li>Serverless，在服务端无需启动任何服务，只需执行命令即可</li>
<li>默认使用ssh控制各节点</li>
<li>基于模块工作，可以使用任何语言编写模块</li>
<li>使用yaml语言定制playbook</li>
<li>幂等性，多次操作或多次执行不影响结果</li>
</ul>
<h3 id="ansible-配置文件解析优先级-由高到低依次为"> Ansible 配置文件解析优先级，由高到低依次为</h3>
<ol>
<li>ANSIBLE_CONFIG 环境变量指定的配置文件</li>
<li>当前目录下的的ansible.cfg</li>
<li>家目录下的ansible.cfg</li>
<li>/etc/ansible/ansible.cfg</li>
</ol>
<h3 id="ansible-inventory-知识点"> Ansible inventory 知识点</h3>
<ul>
<li>inventory 主机清单，包含静态inventory和动态inventory</li>
<li>要使用多个inventory的功能，需将inventory指定为文件目录（默认为/etc/ansible/hosts文件）</li>
<li>inventory指定目录时，目录下文件最好不要带有后缀名</li>
<li>Ansible 默认预定义了两个主机组：<code>all</code>分组（所有主机）和<code>ungrouped</code>分组（不在分组内的主机）</li>
<li>inventory可以配置单独的变量文件（host_vars和group_vars）</li>
<li>hosts指令，匹配主机，匹配多个用''单引号括起来，用逗号分隔，通配符（*，&amp;, !）,正则匹配，以'~'开头</li>
<li>ansible-inventory命令
<ul>
<li>树状形式展开主机列表<code>ansible-inventory all --graph</code></li>
<li>同时带上变量<code>ansible-inventory all --graph --vars</code></li>
</ul>
</li>
<li>通过<code>--limit</code>或<code>-l</code>明确指定主机或组</li>
<li>临时添加节点<code>add_host</code>，临时设置主机组<code>group_by</code></li>
</ul>
<h3 id="ansible-hoc-点对点模式-知识点"> Ansible-hoc（点对点模式）知识点</h3>
<ul>
<li>
<p><code>ansible-doc -l</code>查看有哪些模块，<code>ansible-doc -s moudle</code>查看某个模块的参数，<code>ansible-doc module</code>查看该模块更详细的信息</p>
</li>
<li>
<p>命令格式<code>ansible 主机或组 -m 模块名 -a '模块参数' ansible参数</code></p>
</li>
<li>
<p>4个命令执行模块的区别：</p>
<ul>
<li>command模块：该模块通过-a跟上要执行的命令可以直接执行，不过命令里如果有带有如下字符部分则执行不成功 “ &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;|&quot;, &quot;&amp;&quot;</li>
<li>shell 模块：用法基本和command一样，不和command相同，但是支持解析特殊shell符号</li>
<li>raw模块：执行底层shell命令。command和shell模块都是通过目标主机上的python代码启动/bin/sh来执行命令的，raw模块在远程主机上直接启动/bin/sh来执行命令</li>
<li>script模块：在远程主机上执行脚本文件，其原理是先将shell 复制到远程主机，再在远程主机上执行</li>
</ul>
</li>
<li>
<p>常用模块</p>
<ul>
<li>command</li>
<li>shell</li>
<li>script</li>
<li>ping</li>
<li>file</li>
<li>copy</li>
<li>service</li>
<li>lineinfile</li>
<li>cron</li>
<li>debug</li>
<li>template</li>
</ul>
</li>
<li>
<p>debug 模块</p>
<p>用于输出调试一些数据，模块包含如下选项：</p>
<ul>
<li>msg：可以输出字符串，可以输出变量的值，变量调用需加&quot;{{}}&quot;</li>
<li>var：只能输出变量的值，变量调用无需加任何东西，只需数据变量名称</li>
</ul>
<blockquote>
<p>注意格式，=号左右没有空格</p>
</blockquote>
</li>
<li>
<p>lineinfile 模块</p>
<p>lineinfile模块用于在源文件中插入、删除、替换行，和sed命令的功能类似，也支持正则表达式匹配和替换。</p>
<ul>
<li>path 指定文件</li>
<li>line  行内容</li>
<li>regexp 正则匹配</li>
<li>insertbefore，insertafter 匹配的行前后插入</li>
<li>state 状态</li>
<li>validate 校验文件格式是否正确</li>
<li>regexp和insertXXX结合，regexp参数则充当幂等性判断参数：只有regepx匹配失败时，insertXXX才会插入行</li>
</ul>
</li>
</ul>
<h3 id="ansible-playbook-知识点"> Ansible playbook 知识点</h3>
<ul>
<li>
<p>playbook、play和task的关系</p>
<ul>
<li>playbook中可以定义一个或多个play</li>
<li>每个play中可以定义一个或多个task</li>
</ul>
</li>
<li>
<p>可以定义两类特殊的task：pre_tasks和post_tasks</p>
<ul>
<li>pre_tasks表示执行执行普通任务之前执行的任务列表</li>
<li>post_tasks表示普通任务执行完之后执行的任务列表</li>
</ul>
</li>
<li>
<p>playbook主要有以下四部分构成</p>
<ul>
<li>Target：用于定义将要执行playbook的远程主机组及远程主机组上的用户，还包括定义通过什么样的方式连接远程主机</li>
<li>Variable：定义playbook运行时需要使用的变量</li>
<li>Task：定义将要在远程主机上执行的任务列表</li>
<li>Handler：定义task执行完成以后需要调用的任务</li>
</ul>
</li>
<li>
<p>常用命令</p>
<ul>
<li>校验playbook语法 <code>ansible-playbook --syntax-check xxx.yml</code></li>
<li>测试运行playbook <code>ansible-playbook -C xxx.yml</code></li>
</ul>
</li>
<li>
<p>循环语句</p>
<ul>
<li>loop关键字，等价于<code>with_list</code>循环列表</li>
</ul>
</li>
<li>
<p>条件语句</p>
<ul>
<li>when关键字，block关键字，rescue关键字，always关键字</li>
<li>fail模块，filed_when，ignore_errors，change_when，assert断言模块</li>
<li>any_errors_fatal，max_fail_percentage</li>
</ul>
</li>
<li>
<p>高级用法</p>
<ul>
<li>本地执行 <code>connection: local</code></li>
<li>任务委托 <code>delegate_to</code></li>
<li>任务暂停 <code>wait_for</code></li>
<li>滚动执行 <code>serial</code></li>
<li>执行一次 <code>run_once</code></li>
<li>设置环境变量 <code>environment</code></li>
<li>交互式提示 <code>vars_prompt</code></li>
</ul>
</li>
<li>
<p>tag</p>
<ul>
<li>打tag <code>tags:</code></li>
<li>指定tag执行 <code>--tags &quot;xxx,xxx&quot;</code></li>
<li>排除指定的tag执行 <code>--skip-tags &quot;xxx,xxx&quot;</code></li>
<li>查看所有tag <code>--list-tags</code></li>
</ul>
</li>
<li>
<p>roles目录结构</p>
<div><pre><code>$ ansible-galaxy init first_role
$ tree first_role/
first_role/            \\ 角色名称
├── defaults           \\ 为当前角色设定默认变量时使用此目录，应当包含一个main.yml文件；
│   └── main.yml        
├── files              \\ 存放有copy或script等模块调用的文件
├── handlers           \\ 此目录应当包含一个main.yml文件，用于定义各角色用到的各handler
│   └── main.yml
├── meta               \\ 应当包含一个main.yml，用于定义角色的特殊设定及其依赖关系；1.3及以后版本支持
│   └── main.yml
├── README.md
├── tasks              \\ 至少包含一个名为main.yml的文件，定义了此角色的任务列表
│   └── main.yml
├── templates          \\ template模块会自动在此目录中寻找Jinja2模板文件
├── tests
│   ├── inventory
│   └── test.yml
└── vars              \\ 应当包含一个main.yml，用于定义此角色用到的变量
    └── main.yml
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
<li>
<p>playbook 调用格式 <code>ansible-playbook -i /etc/ansible/xxx.yml /etc/ansbile/playbooks/xx.yml --limit &quot;xxx&quot; -e &quot;key=xxx&quot;</code></p>
</li>
<li>
<p>roles 的任务执行顺序</p>
<ol>
<li>首先执行meta下的main.yml文件内容     可以设置该role和其它role之前的关联关系。 dependencies</li>
<li>gather_facts任务</li>
<li>pre_tasks指令中的任务</li>
<li>pre_tasks中触发的所有handler</li>
<li>roles指令加载的Role,执行tasks下的main.yml文件内容</li>
<li>tasks指令中的任务</li>
<li>roles和tasks中触发的所有handler, 使用了notify后，会调用 handlers 目录下的main.yml文件</li>
<li>post_tasks指令中的任务</li>
<li>post_tasks中触发的所有handler</li>
</ol>
</li>
<li>
<p>playbook 静态加载和动态加载</p>
<ul>
<li>roles、include、import_xxx同属一类，它们都是静态加载，都在playbook解析阶段加载文件</li>
<li>include_xxx属于另一类，是动态加载，遇到指令的时候临时去加载文件</li>
<li>要对包含的任务列表进行循环操作，则只能使用<code>include_tasks</code>关键字，不能使用<code>import_tasks</code>关键字，<code>import_tasks</code>并不支持循环操作</li>
<li>使用include_tasks时，这个指令自身占用一个任务，使用import_tasks的时候，这个指令自身没有任务，它所在的任务会在解析playbook的时候被其加载的子任务覆盖</li>
<li>无法使用--list-tags列出include_xxx中的tags，无法使用--list-tasks列出include_xxx中的任务，因为它们都是临时动态加载的</li>
</ul>
</li>
<li>
<p>jinja2</p>
</li>
</ul>
<h3 id="ansible-变量-知识点"> Ansible 变量 知识点</h3>
<ul>
<li>
<p>变量作用域</p>
<ul>
<li>全局作用域：Ansible配置文件、环境变量、命令行选项-e,--extra-vars设置的变量都是全局变量</li>
<li>Play作用域：整个Play中都有效的变量，vars_files、vars_prompt、play级别的vars以及Role的变量，它们都是play级别的变量</li>
<li>主机变量：绑定在各主机上的变量，各种方式定义的inventory变量、Facts信息变量(这个就划分在这吧)、set_fact、register、include_vars都是主机变量</li>
<li>任务变量：只在当前任务中生效的变量，task级别的vars定义的变量属于任务变量</li>
<li>block变量：只在当前block内生效，block级别的vars定义的变量属于block变量</li>
<li>预定义特殊变：这些变量由Ansible自身内部维护，有些是全局变量，有些是play变量，有些是主机变量，所以不方便对它们分类</li>
</ul>
</li>
<li>
<p>主机变量</p>
<ul>
<li>
<p>内置主机变量<code>ansible_host</code>、<code>ansible_port</code>、<code>ansible_user</code>、<code>ansible_password</code>、<code>ansible_connection</code>等</p>
</li>
<li>
<p>自定义主机变量，在主机清单中</p>
<ul>
<li>
<p>in INI <code>hosts1 http_port=80</code>，</p>
</li>
<li>
<p>in YAML</p>
<div><pre><code>host1:
  http_port: 80
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
</li>
<li>
<p>自定义组变量，在主机清单中</p>
<ul>
<li>
<p>in INI</p>
<div><pre><code>[atlanta]
host1
host2

[atlanta:vars]
ntp_server=ntp.aliyun.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>in YAML</p>
<div><pre><code>atlanta:
  hosts:
    host1:
    host2:
  vars:
    ntp_server: ntp.aliyun.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ul>
</li>
<li>
<p>通过<code>host_vars</code>和<code>group_vars</code>目录定义变量，需要说明的是，如果主机组定义的变量与主机冲突，主机变量优先级最高</p>
</li>
</ul>
</li>
<li>
<p>play 变量</p>
<ul>
<li>通过vars关键字定义</li>
<li>通过vars_files关键字引入变量文件</li>
</ul>
</li>
<li>
<p>注册变量 <code>register</code></p>
</li>
<li>
<p>Facts 变量</p>
</li>
<li>
<p>内置变量/魔法变量</p>
<ul>
<li>hostvars 所有和主机相关的变量</li>
<li>inventory_hostname 当前正在运行task的主机的主机名</li>
<li>group_names 组名</li>
<li>groups 主机组列表</li>
<li>ansible_play_batch（play_hosts/ansible_play_hosts）当前play所涉及的所有主机列表，但连接失败或执行任务失败的节点不会留在此变量中</li>
<li>inventory_dir 主机清单所在目录</li>
<li>inventory_file 主机清单文件</li>
</ul>
</li>
<li>
<p>lookup 生产变量</p>
<ul>
<li>语法 <code>lookup('&lt;plugin_name&gt;', 'plugin_argument')</code></li>
<li>从命令执行结果读取(pipe插件)</li>
<li>从磁盘文件读取(file/fileglob插件)</li>
</ul>
</li>
</ul>
<h3 id="ansible-使用优化"> Ansible 使用优化</h3>
<ul>
<li>
<p>加大forks的值</p>
</li>
<li>
<p>开启ssh长连接为5天 ，要求ssh为5.6版本，查看版本ssh -v</p>
<div><pre><code># cat /etc/ansible/ansible.cfg
ssh_args = -C -o ControlMaster=auto -o ControlPersist=5d 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>Shell层次上的优化：将任务分开执行</p>
</li>
</ul>
<p>以下优化，根据实际情况进行修改</p>
<ul>
<li>
<p>修改执行策略，改为free</p>
</li>
<li>
<p>开启pipeling，在不使用sudo的情况下开启pipeling，减少ansible没有传输时的连接数</p>
<div><pre><code>修改ansible.cfg中pipelining=False改为True
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>修改facts收集行为，<code>gather_facts: no</code> ，或者添加缓存，注意添加缓存后有坑，比如创建带有时间的文件夹</p>
</li>
<li>
<p>使Ansible异步执行任务，async和poll指令</p>
</li>
<li>
<p>第三方策略插件：Mitogen for Ansible</p>
</li>
</ul>
<h3 id="ansible-常见问题"> Ansible 常见问题</h3>
<ul>
<li>server端未安装 sshpass</li>
<li>将host_key_checking设为False，关闭密码检查</li>
</ul>
<h3 id="yaml-文件知识点"> YAML 文件知识点</h3>
<ul>
<li>
<p>YAML的基本语法规则如下：</p>
<p>(1).使用缩进表示层级关系</p>
<p>(2).缩进时不允许使用Tab键，只允许使用空格</p>
<p>(3).缩进的空格数目不重要，只要相同层级的元素左对齐即可</p>
<p>(4).yaml文件以&quot;---&quot;作为文档的开始，以表明这是一个yaml文件</p>
<p>(5).# 表示注释，从这个字符一直到行尾，都会被解析器忽略</p>
<p>(6).字符串不用加引号，但在可能产生歧义时，需加引号(单双引号皆可)，比如引用变量时</p>
<p>(7).布尔值非常灵活，不分区大小写的true/false、yes/no、on/off、y/n、0和1都允许</p>
</li>
<li>
<p>YAML支持三种数据结构：</p>
<p>(1).对象：key/value格式，也称为哈希结构、字典结构或关联数组</p>
<p>(2).数组：也称为列表</p>
<p>(3).标量(scalars)：单个值</p>
</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">4.6 巧用Roles</title>
    <id>https://clay-wangzhi.com/automate/ansible/roles/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/roles/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-6-巧用roles"> 4.6 巧用Roles</h1>
<h2 id="_1-如何重用playbook"> 1 如何重用Playbook</h2>
<p>不能站在巨人肩膀上的编程语言不是好语言，支持重用机制会节省重复的调研工作上浪费大量的时间，当然也会提高可维护性。</p>
<p>Playbook支持两种重用机制，一种是重用静态Playbook脚本，另外一种是类似于编程语言中函数的机制。</p>
<ul>
<li>include语句 - 重用静态的Playbook脚本，使用起来简单、直接。</li>
<li>role语言 - Playbook的“函数机制”，使用方法稍复杂、功能强大。是Playbook脚本的共享平台ansible galaxy主要的分享方式</li>
</ul>
<p>组织文件的方式均使用include指令，但随着版本的更迭，Ansible对这方面做了更为细致的区分。虽然目前仍然支持include，但早已纳入废弃的计划，所以现在不要再使用include指令。</p>
<ul>
<li>
<p>对于playbook(或play)或task，可以使用include_xxx或import_xxx指令：</p>
<p>(1).include_tasks和import_tasks用于引入外部任务文件；</p>
<p>(2).import_playbook用于引入playbook文件；</p>
<p>(3).include可用于引入几乎所有内容文件，但建议不要使用它；</p>
</li>
<li>
<p>对于handler，因为它本身也是task，所以它也能使用include_tasks、import_tasks来引入，但是这并不是想象中那么简单，后文再细说。</p>
</li>
<li>
<p>对于variable，使用include_vars(这是核心模块提供的功能)或其它组织方式(如vars_files)，没有对应的import_vars。</p>
</li>
</ul>
<p>后文要介绍的Role，使用include_role或import_role或roles指令。</p>
<p>既然某类内容文件既可以使用include_xxx引入，也可以使用import_xxx引入，对于我们来说，就有必要去搞清楚它们有什么区别。</p>
<p>本文最后我会详细解释它们，现在我先把结论写在这：</p>
<p>(1).include_xxx指令是在遇到它的时候才加载文件并解析执行，所以它是动态解析的；</p>
<p>(2).import_xxx是在解析playbook的时候解析的，也就是说在执行playbook之前就已经解析好了，所以它也称为静态加载。</p>
<h2 id="_2-roles目录结构"> 2 roles目录结构</h2>
<p>Role可以组织任务、变量、handler以及其它一些内容，所以一个完整的Role里包含的目录和文件可能较多，手动去创建所有这些目录和文件是一件比较烦人的事，好在可以使用ansible-galaxy init ROLE_NAME命令来快速创建一个符合Role文件组织规范的框架。</p>
<p>例如，下面创建了一个名为first_role的Role：</p>
<div><pre><code>$ ansible-galaxy init first_role
$ tree first_role/
first_role/            \\ 角色名称
├── defaults           \\ 为当前角色设定默认变量时使用此目录，应当包含一个main.yml文件；
│   └── main.yml        
├── files              \\ 存放有copy或script等模块调用的文件
├── handlers           \\ 此目录应当包含一个main.yml文件，用于定义各角色用到的各handler
│   └── main.yml
├── meta               \\ 应当包含一个main.yml，用于定义角色的特殊设定及其依赖关系；1.3及以后版本支持
│   └── main.yml
├── README.md
├── tasks              \\ 至少包含一个名为main.yml的文件，定义了此角色的任务列表
│   └── main.yml
├── templates          \\ template模块会自动在此目录中寻找Jinja2模板文件
├── tests
│   ├── inventory
│   └── test.yml
└── vars              \\ 应当包含一个main.yml，用于定义此角色用到的变量
    └── main.yml

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>Role中有两个地方可以定义变量：</p>
<p>(1).roles/xxx/vars/main.yml</p>
<p>(2).roles/xxx/defaults/main.yml</p>
<p>从目录名称中可以看出，defaults/main.yml中用于定义Role的默认变量，那么显然，vars/main.yml用于定义其它变量。这两个文件之间的区别在于，defaults/main.yml中定义的变量优先级低于vars/main.yml中定义的变量。事实上，defaults/main.yml中的变量优先级几乎是最低的，基本上其它任何地方定义的变量都可以覆盖它。</p>
<blockquote>
<p>通常会将每个Role放在一个称为roles的目录下。</p>
</blockquote>
<p>可以使用ansible-galaxy init --help查看更多选项。比如，使用--init-path选项指定创建的Role路径：</p>
<div><pre><code>ansible-galaxy init --init-path /etc/ansible/roles first_role
</code></pre>
<div><span>1</span><br></div></div><p>不难发现文件大多命名为main.yml，这是Role在使用到它们的时候默认加载的文件名，如果换成其它名称，则需要手动使用include_xxx或import_xxx去加载。另一方面，这些目录下可能还包含其它yml文件，比如tasks目录下有多个任务文件，那么需要在这些main.yml文件中使用include_xxx或import_xxx去加载其它外部文件。</p>
<p>有了Role之后，就可以将Role当作一个不可分割的任务整体来对待，一个Role相当于是一个完整的功能。但在此需要明确一个层次上的概念，Role只是用于组织一个或多个任务，原来在play级别中使用tasks指令来定义任务，现在使用roles指令来引入Role中定义的任务。当然，roles指令和tasks指令并不冲突，它们可以共存。通过下面的图，应能帮助理解Role的角色。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20210316113538941.png" alt="image-20210316113538941" /></p>
<p>既然Role是一个完整的任务体系，拥有Role之后就可以去使用它，或者也可以分发给别人使用，但是一个Role仅仅只是目录而已，如何去使用这个Role呢？</p>
<h2 id="_3-组织-task"> 3 组织 task</h2>
<p>在此前的所有示例中，一直都是将所有任务编写在单个playbook文件中。但Ansible允许我们将任务分离到不同的文件中，然后去引入外部任务文件。</p>
<p>用示例来解释会非常简单。</p>
<p>假设，两个playbook文件pb1.yml和pb2.yml。pb1.yml文件内容如下：</p>
<div><pre><code>---
- name: play1
  hosts: localhost
  gather_facts: false
  tasks:
    - name: task1 in play1
      debug:
        msg: &quot;task1 in play1&quot;

  # - include_tasks: pb2.yml
    - import_tasks: pb2.yml
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>pb2.yml文件内容如下：</p>
<div><pre><code>- name: task2 in play1
  debug:
    msg: &quot;task2 in play1&quot;

- name: task3 in play1
  debug:
    msg: &quot;task3 in play1&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面是在pb1.yml文件中通过import_tasks引入了额外的任务文件pb2.yml，对于此处来说，将import_tasks替换成include_tasks也能正确工作，不会有任何影响。</p>
<blockquote>
<p>执行结果有差别：import_tasks，相当于有三个task，include_tasks，相当于有四个task，多了一个included的任务</p>
</blockquote>
<p>但如果是在循环中(比如loop)，则只能使用include_tasks而不能再使用import_tasks。</p>
<p><strong>在循环中include文件</strong></p>
<p>修改pb1.yml和pb2.yml文件内容：</p>
<p>pb1.yml内容如下，注意该文件中的include_tasks指令：</p>
<div><pre><code>---
- name: play1
  hosts: localhost
  gather_facts: false
  tasks:
    - name: task1 in play1
      debug:
        msg: &quot;task1 in play1&quot;

    - name: include two times
      include_tasks: pb2.yml
      loop:
        - ONE
        - TWO
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>pb2.yml内容如下，注意该文件中的{{item}}变量引用：</p>
<div><pre><code>- name: task2 in play1
  debug:
    msg: &quot;task2 in {{item}}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>执行pb1.yml文件，观察执行结果：</p>
<div><pre><code>PLAY [play1] *****************************************************************************************************************************************************************************************************************************

TASK [task1 in play1] ********************************************************************************************************************************************************************************************************************
ok: [localhost] =&gt; {
    &quot;msg&quot;: &quot;task1 in play1&quot;
}

TASK [include two times] *****************************************************************************************************************************************************************************************************************
included: /etc/ansible/playbooks/pb2.yml for localhost
included: /etc/ansible/playbooks/pb2.yml for localhost

TASK [task2 in play1] ********************************************************************************************************************************************************************************************************************
ok: [localhost] =&gt; {
    &quot;msg&quot;: &quot;task2 in ONE&quot;
}

TASK [task2 in play1] ********************************************************************************************************************************************************************************************************************
ok: [localhost] =&gt; {
    &quot;msg&quot;: &quot;task2 in TWO&quot;
}

PLAY RECAP *******************************************************************************************************************************************************************************************************************************
localhost                  : ok=5    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>上面是在loop循环中加载两次pb2.yml文件，该文件中的任务被执行了两次，并且在pb2.yml中能够引用外部文件(pb1.yml)中定义的变量{{item}}。</p>
<p>分析一下上面的执行流程：</p>
<p>(1).解析playbook文件pb1.yml</p>
<p>(2).执行第一个play</p>
<p>(3).当执行到pb1.yml中的第二个任务时，该任务在循环中，且其作用是加载外部任务文件pb2.yml</p>
<p>(4).开始循环，每轮循环都加载、解析并执行pb2.yml文件中的所有任务</p>
<p>(5).退出正是因为include_tasks指令是在遇到它的时候才进行加载解析以及执行，所以在pb2.yml中才能使用变量{{item}}。</p>
<p>如果将上面loop循环中的include_tasks换成import_tasks呢？语法会报错，后面我会详细解释。</p>
<h2 id="_4-组织handler"> 4 组织handler</h2>
<p>handler其本质也是task，所以也可以使用include_tasks或import_tasks来加载外部任务文件。但是它们引入handler任务文件的方式有很大的差别。</p>
<p>先看include_tasks引入handler任务文件的示例：</p>
<p>pb1.yml的内容：</p>
<div><pre><code>---
- name: play1
  hosts: localhost
  gather_facts: false
  handlers:
    - name: h1
      include_tasks: handler1.yml

  tasks:
    - name: task1 in play1
      debug:
        msg: &quot;task1 in play1&quot;
      changed_when: true
      notify:
        - h1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>注意在tasks的任务中加了一个指令changed_when: true，它用来强制指定它所在任务的changed状态，如果条件为真，则changed=1，否则changed=0。使用这个指令是因为debug模块默认不会引起changed=1行为，所以只能使用该指令来强制其状态为changed=1。</p>
<p>当Ansible监控到了changed=1，notify指令会生效，它会去触发对应的handler，它触发的handler的名称是handler1，其作用是使用include_tasks指令引入handler1.yml文件。</p>
<p>下面是handler1.yml文件的内容：</p>
<div><pre><code>---
- name: h11
  debug:
    msg: &quot;task h11&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意两个名称，一个是notify触发handler的任务名称(&quot;h1&quot;)，一个是引入文件中任务的名称(&quot;h11&quot;)，它们是两个任务。再来看import_tasks引入handler文件的示例，注意观察名称的不同点。</p>
<div><pre><code>---
- name: play1
  hosts: localhost
  gather_facts: false
  handlers:
    - name: h2
      import_tasks: handler2.yml

  tasks:
    - name: task1 in play1
      debug:
        msg: &quot;task1 in play1&quot;
      changed_when: true
      notify:
        - h22
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>下面是使用import_tasks引入的handler2.yml文件的内容：</p>
<div><pre><code>---
- name: h22
  debug:
    msg: &quot;task h22&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在引入handler任务文件的时候，include_tasks和import_tasks的区别表现在：</p>
<p>(1).使用include_tasks时，notify指令触发的handler名称是include_tasks任务本身的名称</p>
<p>(2).使用import_tasks时，notify指令触发的handler名称是import_tasks所引入文件内的任务名称</p>
<p>其实分析一下就很容易理解为什么notify触发的名称要不同：</p>
<p>(1).include_tasks是在遇到这个指令的时候才引入文件的，所以notify不可能去触发外部handler文件里的名称(h11)，外部handler文件中的名称在其引入之前根本就不存在</p>
<p>(2).import_tasks是在解析playbook的时候引入的，换句话说，在执行play之前就已经把外部handler文件的内容引入并替换在handler的位置处，而原来的名称(h2)则被覆盖了</p>
<p>最后，不要忘了import_tasks或include_tasks自身也是任务，既然是任务，就能使用task层次的指令。</p>
<p>但这两个指令对task层次指令的处理方式不同，相关细节仍然保留到后文统一解释。</p>
<h2 id="_5-组织变量"> 5 组织变量</h2>
<p>在Ansible中有很多种定义变量的方式，想要搞清楚所有这些散布各个角落的知识，是一个很大的难点。好在，我们没必要去过多关注，只需要掌握几个常用的变量定义和应用的方式即可。此处我要介绍的是将变量定义在外部文件中，然后去引入这些外部文件中的变量。</p>
<p>引入保存了变量的文件有两种方式：include_vars和vars_files。此外，还可以在命令行中使用-e或--extra-vars选项来引入。</p>
<h3 id="_5-1-vars-files"> 5.1 vars_files</h3>
<p>先介绍vars_files，它是一个play级别的指令，可用于在解析playbook的阶段引入一个或多个保存了变量的外部文件。</p>
<p>例如，pb.yml文件如下：</p>
<div><pre><code>---
- name: play1
  hosts: localhost
  gather_facts: false
  vars_files:
    - varfile1.yml
    - varfile2.yml
  tasks:
    - debug:
        msg: &quot;var in varfile1: {{var1}}&quot;
    - debug:
        msg: &quot;var in varfile2: {{var2}}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>pb.yml文件通过vars_files引入了两个变量文件，变量文件的写法要求遵守YAML或JSON格式。下面是这两个文件的内容：</p>
<div><pre><code># 下面是varfile1.yml文件的内容
---
var1: &quot;value1&quot;
var11: &quot;value11&quot;

# 下面是varfile2.yml文件的内容
---
var2: &quot;value2&quot;
var22: &quot;value22&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>需要说明的是，vars_files指令是play级别的指令，且是在解析playbook的时候加载并解析的，所以所引入变量的变量是play范围内可用的，其它play不可使用这些变量。</p>
<h3 id="_5-2-include-vars"> 5.2 include_vars</h3>
<p>include_vars指令也可用于引入外部变量文件，它和vars_files不同。一方面，include_vars是模块提供的功能，它是一个实实在在的任务，所以在这个任务执行之后才会创建变量。另一方面，既然include_vars是一个任务，它就可以被一些task级别的指令控制，如when指令。</p>
<p>例如：</p>
<div><pre><code>---
- name: play1
  hosts: localhost
  gather_facts: false
  tasks:
    - name: include vars from files
      include_vars: varfile1.yml
      when: 3 &gt; 2
       
    - debug:
        msg: &quot;var in varfile1: {{var1}}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面示例中引入变量文件的方式是直接指定文件名include_vars: varfile1.yml，也可以明确使用file参数来指定路径。</p>
<div><pre><code>- name: include vars from files
  include_vars:
    file: varfile1.yml
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果想要引入多个文件，可以使用循环的方式。例如：</p>
<div><pre><code>- name: include two var files
  include_vars:
    file: &quot;{{item}}&quot;
  loop:
    - varfile1.yml
    - varfile2.yml
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>需要注意，include_vars在引入文件的时候要求文件已经存在，如果有多个可能的文件但不确定文件是否已经存在，可以使用with_first_found指令或lookup的first_found插件，它们作用相同，都用于从文件列表中找出存在的文件，找到后立即停止，之前就曾提到过with_xxx的本质是调用lookup对应的插件。</p>
<p>例如：</p>
<div><pre><code>tasks:
  - name: include vars from files
    include_vars:
      file: &quot;{{item}}&quot;
    with_first_found:
      - varfile1.yml
      - varfile2.yml
      - default.yml

# 等价于：
tasks:
  - name: include vars from files
    include_vars:
      file: &quot;{{ lookup(&#39;first_found&#39;,any_files) }}&quot;
    vars:
      any_files:
        - varfile1.yml
        - varfile2.yml
        - default.yml
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>此外，include_vars还能从目录中导入多个文件，默认会递归到子目录中。例如：</p>
<div><pre><code>- name: Include all files in vars/all
  include_vars:
    dir: vars/all
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_5-3-extra-vars选项"> 5.3 --extra-vars选项</h3>
<p>ansible-playbook命令的-e选项或--extra-vars选项也可以用来定义变量或引入变量文件。</p>
<div><pre><code># 定义单个变量
$ ansible-playbook -e &#39;var1=&quot;value1&quot;&#39; xxx.yml

# 定义多个变量
$ ansible-playbook -e &#39;var1=&quot;value1&quot; var2=&quot;value2&quot;&#39; xxx.yml

# 引入单个变量文件
$ ansible-playbook -e &#39;@varfile1.yml&#39; xxx.yml

# 引入多个变量文件
$ ansible-playbook -e &#39;@varfile1.yml&#39; -e &#39;@varfile2.yml&#39; xxx.yml
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>因为是通过选项的方式来定义变量的，所以它所定义的变量是全局的，对所有play都有效。</p>
<p>通常来说不建议使用-e选项，因为这对用户来说是不透明也不友好的，要求用户记住要定义哪些变量。</p>
<h2 id="_6-组织playbook文件"> 6 组织playbook文件</h2>
<p>当单个playbook文件中的任务过多时，或许就是将任务划分到多个文件中的时刻。</p>
<p>import_playbook指令可用于引入playbook文件，它是一个play级别的指令，其本质是引入外部文件中的一个或多个play。</p>
<p>例如，pb.yml是入口playbook文件，此文件中引入了其它playbook文件，其内容如下：</p>
<div><pre><code>---
# 引入其它playbook文件
- import_playbook: pb1.yml
- import_playbook: pb2.yml

# 文件本身的play
- name: play in self
  hosts: localhost
  gather_facts: false
  tasks:
    - debug: &#39;msg=&quot;file pb.yml&quot;&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>pb1.yml，pb2.yml文件都是一个完整的playbook，它可以包含一个或多个play</p>
<h2 id="_7-playbook-调用"> 7 playbook 调用</h2>
<div><pre><code>ansible-playbook -i /root/xxx.yml  /root/app/main.yml  --limit &quot;lala_xxx&quot; -e &quot;user=wawo&quot;
</code></pre>
<div><span>1</span><br></div></div><p>解析：
-i         指定要运行的主机清单
--limit    指定运行的ip地址
-e         指定运行的外部参数</p>
<p>运行的控制 YAML 文件为： <code>/root/app/main.yml</code></p>
<div><pre><code>---
- hosts: all
  roles:
    - xxx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>hosts指定所有(all)的主机，但是由于在外部已经指定了主机的配置，所以all由外部指定参数来进行</p>
<p>roles指定要执行的具体剧本</p>
<p>**roles	**</p>
<ol>
<li>
<p>首先执行meta下的main.yml文件内容     可以设置该role和其它role之前的关联关系。 dependencies</p>
</li>
<li>
<p>gather_facts任务</p>
</li>
<li>
<p>pre_tasks指令中的任务</p>
</li>
<li>
<p>pre_tasks中触发的所有handler</p>
</li>
<li>
<p>roles指令加载的Role,执行tasks下的main.yml文件内容</p>
</li>
<li>
<p>tasks指令中的任务</p>
</li>
<li>
<p>roles和tasks中触发的所有handler, 使用了notify后，会调用 handlers 目录下的main.yml文件</p>
</li>
<li>
<p>post_tasks指令中的任务</p>
</li>
<li>
<p>post_tasks中触发的所有handler</p>
</li>
</ol>
<blockquote>
<p>用到的变量，会直接加载defaults目录下的main.yml文件,或者vars目录下,</p>
<p>用到的需要拷贝到远程机器的文件，会放到files目录下,</p>
<p>用到模板文件，会放到 templates 目录下</p>
</blockquote>
<p><strong>写好Role之后就是使用Role，即在一个入口playbook文件中去加载Role。</strong></p>
<p>加载Role的方式有多种：</p>
<p>(1).roles指令：play级别的指令，在playbook解析阶段加载对应文件，这是传统的引入Role的方式</p>
<p>(2).import_role指令：task级别的指令，在playbook解析阶段加载对应文件</p>
<p>(3).include_role指令：task级别的指令，在遇到该指令的时候才加载Role对应文件</p>
<p>上面通过roles指令来定义要解析和执行的Role，可以同时指定多个Role，且也可以加上role:参数，例如：</p>
<div><pre><code>roles:
  - first_role
  - role: seconde_role
  - role: third_role
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>也可以使用include_role和import_role来引入Role，但需注意，这两个指令是tasks级别的，也正因为它们是task级别，使得它们可以和其它task共存。</p>
<p>例如：</p>
<div><pre><code>---
- hosts: localhost
  gather_facts: false
  tasks:
    - debug:
        msg: &quot;before first role&quot;
    - import_role:
         name: first_role
    - include_role:
      name: second_role
    - debug:
       msg: &quot;after second role&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这三种引入Role的方式都可以为对应的Role传递参数，例如：</p>
<div><pre><code>---
- hosts: localhost
  gather_facts: false
  roles:
    - role: first_role
      varvar: &quot;valuevalue&quot;
      vars:
        var1: value1

tasks:
- import_role:
    name: second_role
  vars:
    var1: value1
- include_role:
    name: third_role
  vars:
    var1: value1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>有时候需要让某个Role按需执行，比如对于目标节点是CentOS 7时执行Role7而不执行Role6，目标节点是CentOS 6时执行Role6而不是Role7，这可以使用when指令来控制。</p>
<p>例如：</p>
<div><pre><code>---
- hosts: localhost
  gather_facts: false
  roles:
  # 下面是等价的，分别采用YAML和Json语法书写
    - role: first_role
      when: xxx
    - {role: ffirst_role, when: xxx}
  tasks:
  - import_role:
      name: second_role
    when: xxx
  - include_role:
      name: third_role
    when: xxx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>注意，在roles、import_role和include_role三种方式中，when指令的层次。</p>
<p>通常来说，无论使用哪种方式来引入Role都可以，只是某些场景下需要小心一些陷阱。</p>
<h2 id="_8-playbook解析、动态加载和静态加载"> 8 playbook解析、动态加载和静态加载</h2>
<p>还是这个结论：</p>
<ol>
<li>
<p>import_xxx是在playbook的解析阶段加载文件</p>
</li>
<li>
<p>include_xxx是遇到指令的时候加载文件</p>
</li>
</ol>
<p>只要理解了这两个结论，所有相关的现象都能理解。</p>
<p>那么playbook的解析是什么意思，它做了什么事呢？</p>
<p>第一个要明确的是playbook解析处于哪个阶段执行：inventory解析完成后、play开始执行前的阶段。</p>
<p>第二个要明确的是playbook解析做了哪些哪些事。一个简单又直观的描述是，playbook解析过程中，会扫描playbook文件中的内容，然后检查语法并转换成Ansible认识的内部格式，以便让Ansible去执行。</p>
<p>更具体一点，在解析playbook期间：</p>
<p>1.当在playbook文件中遇到了roles、include、import_xxx指令，则会将它们指定的文件内容&quot;插入到&quot;指令位置处，也即原文替换，这个过程对我们来说是透明的。实际上并非真的会插入替换，稍后我会再补充，但这样理解会更容易些；</p>
<ul>
<li>
<p>(1).roles、include、import_xxx同属一类，它们都是静态加载，都在playbook解析阶段加载文件，而include_xxx属于另一类，是动态加载，遇到指令的时候临时去加载文件；</p>
</li>
<li>
<p>(2).之所以有这么多看似功能重复的指令，这和Ansible版本的发展有关，不同的版本可能会小有区别；</p>
</li>
<li>
<p>(3).早期版本只有include指令，所以它的行为有些混乱，建议不要对其做太多考究，也尽量不要使用该指令；</p>
</li>
</ul>
<div><pre><code>1、ansible中的include, include_tasks 和 import_tasks 的差别
include 被 deprecated（不建议使用）了. 建议使用 include_tasks 和 import_tasks

include_tasks
是动态的: 在运行时展开. when只应用一次. 被include的文件名可以使用变量.

import_tasks
是静态的: 在加载时展开. when在被import的文件里的每个task, 都会重新检查一次. 因为是加载时展开的, 文件名的变量不能是动态设定的.
请确保文件名中使用到的变量被定义在vars中、vars_files中、或者extra-vars中，静态的import不支持其他方式传入的变量。

When using static includes, ensure that any variables used in their names are defined in vars/vars_files or extra-vars passed in from the command line. Static includes cannot use variables from inventory sources like group or host vars.
除了上述不同之处，在使用&quot;循环操作&quot;和&quot;条件判断&quot;时，&quot;include_tasks&quot;和&quot;import_tasks&quot;也有很多不同点需要注意，注意点如下。
如果想要对包含的任务列表进行循环操作，则只能使用&quot;include_tasks&quot;关键字，不能使用&quot;import_tasks&quot;关键字，&quot;import_tasks&quot;并不支持循环操作，
也就是说，使用&quot;loop&quot;关键字或&quot;with_items&quot;关键字对include文件进行循环操作时，只能配合&quot;include_tasks&quot;才能正常运行。
when关键字对&quot;include_tasks&quot;和&quot;import_tasks&quot;的实际操作有着本质区别，区别如下：
当对&quot;include_tasks&quot;使用when进行条件判断时，when对应的条件只会应用于&quot;include_tasks&quot;任务本身，当执行被包含的任务时，不会对这些被包含的任务重新进行条件判断。
当对&quot;import_tasks&quot;使用when进行条件判断时，when对应的条件会应用于被include的文件中的每一个任务，当执行被包含的任务时，会对每一个被包含的任务进行同样的条件判断。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>我想各位已经意识到了，使用include_tasks时，这个指令自身占用一个任务，使用import_tasks的时候，这个指令自身没有任务，它所在的任务会在解析playbook的时候被其加载的子任务覆盖。</p>
<ul>
<li>无法使用--list-tags列出include_xxx中的tags，无法使用--list-tasks列出include_xxx中的任务，因为它们都是临时动态加载的。</li>
</ul>
<h2 id="_9-ansible-galaxy和collection"> 9 Ansible Galaxy和Collection</h2>
<p>很多时候我们想要实现的Ansible部署需求其实别人已经写好了，所以我们自己不用再动手写(甚至不应该自己写)，直接去网上找别人已经写好的轮子即可。</p>
<p>Ansible Galaxy(https://galaxy.ansible.com/ )是一个Ansible官方的Role仓库，世界各地的人都在里面分享自己写好的Role，我们可以直接去Galaxy上搜索是否有自己想要的Role，如果有符合自己心意的，直接安装便可。当然，我们也可以将写好的Role分享出去给别人使用。</p>
<p>Ansible提供了一个ansible-galaxy命令行工具，可以快速创建、安装、管理由该工具维护的Role。它常用的命令有：</p>
<div><pre><code># 安装Role:
ansible-galaxy install username.role_name

# 移除Role:
ansible-galaxy remove username.role_name

# 列出已安装的Role:
ansible-galaxy list

# 查看Role信息:
ansible-galaxy info username.role_name

# 搜索Role:
ansible-galaxy search role_name

# 创建Role
ansible-galaxy init role_name

# 此外还有：&#39;delete&#39;,&#39;import&#39;, &#39;setup&#39;, &#39;login&#39;
# 它们都用于管理galaxy.ansible.com个人账户或里面的Role
# 无视它们
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>虽然Ansible Galaxy中有大量的Role，但有时候我们也会在Github上搜索Role，而且Galaxy仓库上的Role大多也都在Github上。ansible-galaxy install也可以直接从git上下载安装Role。</p>
<div><pre><code>ansible-galaxy install -p roles/ git+https://github.com/chusiang/helloworld.ansible.role.git
</code></pre>
<div><span>1</span><br></div></div><p><strong>Ansible Collection</strong></p>
<p>对于文件组织结构，在Ansible 2.8以前只支持Role的概念，但Ansible 2.8中添加了一项目前仍处于实验性的功能Collection，它以包的管理模式来结构化管理Ansible playbook涉及到的各个文件。</p>
<p>比如，我们可以将整个写好的功能构建、打包，然后分发出去，别人就可以使用ansible-galaxy(要求Ansible 2.9)去安装这个打包好的文件，这为自动化构建和部署带来了很大的便利。</p>
<blockquote>
<p>参考链接：</p>
<p>https://blog.51cto.com/cloumn/blog/1567</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">5 Ansible变量</title>
    <id>https://clay-wangzhi.com/automate/ansible/var/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/var/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_5-ansible变量"> 5 Ansible变量</h1>
<h2 id="变量优先级"> 变量优先级</h2>
<p>这些变量定义的方法，它们的优先级如下：</p>
<ol>
<li>在命令行中定义的变量（即用<code>-e</code>或<code>--extra-vars</code>定义的变量）；</li>
<li>在Inventory中定义的连接变量（比如：ansible_ssh_user）;</li>
<li>大多数的其他变量（命令行转换、play中的变量、included的变量、role中的变量等）；</li>
<li>在Inventory中定义的其他变量；</li>
<li>Facts变量；</li>
<li>“Role”默认变量，这个是默认的值，很容易丧失优先权。</li>
</ol>
<h2 id="变量作用域"> 变量作用域</h2>
<p>Ansible中变量主要有五种作用域概念：</p>
<p>(1).全局作用域：Ansible配置文件、环境变量、命令行选项-e,--extra-vars设置的变量都是全局变量</p>
<p>(2).Play作用域：整个Play中都有效的变量，vars_files、vars_prompt、play级别的vars以及Role的变量，它们都是play级别的变量</p>
<p>(3).主机变量：绑定在各主机上的变量，各种方式定义的inventory变量、Facts信息变量(这个就划分在这吧)、set_fact、register、include_vars都是主机变量</p>
<p>(4).任务变量：只在当前任务中生效的变量，task级别的vars定义的变量属于任务变量</p>
<p>(5).block变量：只在当前block内生效，block级别的vars定义的变量属于block变量</p>
<p>最后还有预定义特殊变量未分类，这些变量由Ansible自身内部维护，有些是全局变量，有些是play变量，有些是主机变量，所以不方便对它们分类。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">5.5 使用vault配置加密</title>
    <id>https://clay-wangzhi.com/automate/ansible/vault/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/vault/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_5-5-使用vault配置加密"> 5.5 使用vault配置加密</h1>
<h2 id="_1-简介"> 1 简介</h2>
<p>在使用ansible的过程中，不可避免的会存储一些敏感信息，比如在变量文件中存储帐号密码信息等。</p>
<p>ansible通过ansible-vault命令行工具来提供对敏感文件的加密和解密。</p>
<p>ansible-vault可以创建、加密、解密和查看文件。其可以加密任何ansible使用的文件，包括inventory文件，playbook中调用的变量文件等。</p>
<h2 id="_2-ansible-vault常用操作"> 2 Ansible-vault常用操作</h2>
<ol>
<li>创建加密文件</li>
</ol>
<div><pre><code>ansible-vault create file
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>编辑加密文件</li>
</ol>
<div><pre><code>ansible-vault edit file
</code></pre>
<div><span>1</span><br></div></div><ol start="3">
<li>重置密码</li>
</ol>
<div><pre><code>ansible-vault rekey file
</code></pre>
<div><span>1</span><br></div></div><ol start="4">
<li>加密已有文件</li>
</ol>
<div><pre><code>ansible-vault encrypt file
</code></pre>
<div><span>1</span><br></div></div><ol start="5">
<li>解密文件</li>
</ol>
<div><pre><code>ansible-vault decrypt file
</code></pre>
<div><span>1</span><br></div></div><ol start="6">
<li>查看文件</li>
</ol>
<div><pre><code>ansible-vault view file
</code></pre>
<div><span>1</span><br></div></div><h2 id="_3-ansible-vault配置示例"> 3 Ansible-vault配置示例</h2>
<ol>
<li>创建一个user.yml的变量文件，内容如下:</li>
</ol>
<div><pre><code>username: &quot;user1&quot;
pwhash: &quot;$1$GkTPu7we$ZZtdsLPIHkS.fmoVcn3v51&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="2">
<li>加密上面创建的变量文件：</li>
</ol>
<div><pre><code># ansible-vault encrypt user.yml 
New Vault password: 
Confirm New Vault password: 
Encryption successful
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="3">
<li>编写playbook文件如下：</li>
</ol>
<div><pre><code>- name: create user accounts for all our servers
  hosts: test
  become: True
  remote_user: ansible
  vars_files:
    - user.yml
  tasks:
    - name: Creating user from user.yml
      user:
        name: &quot;{{ username }}&quot;
        password: &quot;{{ pwhash }}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ol start="4">
<li>执行playbook</li>
</ol>
<div><pre><code># ansible-playbook create_user.yml --ask-vault-pass
Vault password: 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>也可以通过如下操作执行playbook：</p>
<div><pre><code>echo redhat &gt; vault-pass
chmod 600 vault-pass

ansible-playbook create_user.yml --vault-password-file=vault-pass
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">4.8 yaml语法</title>
    <id>https://clay-wangzhi.com/automate/ansible/yaml/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/yaml/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-8-yaml语法"> 4.8 yaml语法</h1>
<h2 id="playbook的语法-yaml"> playbook的语法：YAML</h2>
<p>ansible的playbook采用yaml语法，它以非常简洁的方式实现了json格式的事件描述。</p>
<p>yaml之于json就像markdown之于html一样，极度简化了json的书写。</p>
<p>YAML文件后缀通常为.yaml或.yml。</p>
<p>YAML在不少工具里都使用，学习它是&quot;一次学习、终生受益&quot;的，所以很有必要把yaml的语法格式做个梳理，系统性地去学一学。</p>
<p><strong>YAML的基本语法规则如下：</strong></p>
<p>(1).使用缩进表示层级关系</p>
<p>(2).缩进时不允许使用Tab键，只允许使用空格</p>
<p>(3).缩进的空格数目不重要，只要相同层级的元素左对齐即可</p>
<p>(4).yaml文件以&quot;---&quot;作为文档的开始，以表明这是一个yaml文件</p>
<blockquote>
<p>即使没有使用<code>---</code>开头，也不会有什么影响</p>
</blockquote>
<p>(5).# 表示注释，从这个字符一直到行尾，都会被解析器忽略</p>
<p>(6).字符串不用加引号，但在可能产生歧义时，需加引号(单双引号皆可)，比如引用变量时</p>
<p>(7).布尔值非常灵活，不分区大小写的true/false、yes/no、on/off、y/n、0和1都允许</p>
<p><strong>YAML支持三种数据结构：</strong></p>
<p>(1).对象：key/value格式，也称为哈希结构、字典结构或关联数组</p>
<p>(2).数组：也称为列表</p>
<p>(3).标量(scalars)：单个值</p>
<p>可以去找一些在线YAML转换JSON网站，比如 <a href="http://yaml-online-parser.appspot.com/" target="_blank" rel="noopener noreferrer">http://yaml-online-parser.appspot.com</a> 通过在线转换可以验证或查看自己所写的YAML是否出错以及哪里出错。</p>
<h3 id="对象"> 对象</h3>
<p>一组键值对，使用冒号隔开key和value。注意，冒号后必须至少一个空格。</p>
<div><pre><code>name: clay
</code></pre>
<div><span>1</span><br></div></div><p>等价于json：</p>
<div><pre><code>{
	&quot;name&quot;: &quot;clay&quot;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="数组"> 数组</h3>
<div><pre><code>---
- Shell
- Perl
- Python
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>等价于json：</p>
<div><pre><code>[&quot;Shell&quot;,&quot;Perl&quot;,&quot;Python&quot;]
</code></pre>
<div><span>1</span><br></div></div><p>也可以使用行内数组(内联语法)的写法：</p>
<div><pre><code>---
[&quot;Shell&quot;,&quot;Perl&quot;,&quot;Python&quot;]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>再例如：</p>
<div><pre><code>---
- lang1: Shell
- lang2: Perl
- lang3: Python
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>等价于json：</p>
<div><pre><code>[
    {&quot;lang1&quot;: &quot;Shell&quot;},
    {&quot;lang2&quot;: &quot;Perl&quot;},
    {&quot;lang3&quot;: &quot;Python&quot;}
]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>将对象和数组混合：</p>
<div><pre><code>---
languages:
  - Shell
  - Perl
  - Python
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>等价于json：</p>
<div><pre><code>{
	&quot;languages&quot;: [&quot;Shell&quot;,&quot;Perl&quot;,&quot;Python&quot;]
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="字典"> 字典</h3>
<div><pre><code>---
person1:
  name: clay
  age: 18
  gender: male

person2:
  name: wangchi
  age: 19
  gender: female
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>等价于json：</p>
<div><pre><code>{
  &quot;person2&quot;: {
    &quot;gender&quot;: &quot;female&quot;,
    &quot;age&quot;: 19,
    &quot;name&quot;: &quot;clay&quot;
  },
  &quot;person1&quot;: {
    &quot;gender&quot;: &quot;male&quot;,
    &quot;age&quot;: 18,
    &quot;name&quot;: &quot;wangchi&quot;
  }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>也可以使用行内对象的写法：</p>
<div><pre><code>---
person1: {name: clay, age: 18, gender: male}
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="复合结构"> 复合结构</h3>
<div><pre><code>---
- person1:
  name: clay
  age: 18
  langs:
    - Perl
    - Ruby
    - Shell

- person2:
  name: xiaofanggao
  age: 19
  langs:
    - Python
    - Javascript
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>等价于json：</p>
<div><pre><code>[
    {
        &quot;langs&quot;: [
        &quot;Perl&quot;,
        &quot;Ruby&quot;,
        &quot;Shell&quot;
        ],
        &quot;person1&quot;: null,
        &quot;age&quot;: 18,
        &quot;name&quot;: &quot;clay&quot;
    },
    {
        &quot;person2&quot;: null,
        &quot;age&quot;: 19,
        &quot;langs&quot;: [
        &quot;Python&quot;,
        &quot;Javascript&quot;
        ],
        &quot;name&quot;: &quot;xiaofanggao&quot;
    }
]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="字符串续行"> 字符串续行</h3>
<p>字符串可以写成多行，从第二行开始，必须至少有一个单空格缩进。换行符会被转为空格。</p>
<div><pre><code>str: hello
  world
  hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>等价于json：</p>
<div><pre><code>{
  &quot;str&quot;: &quot;hello world hello world&quot;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>也可以使用 &gt; 换行，它类似于上面的多层缩进写法。此外，还可以使用|在换行时保留换行符。</p>
<div><pre><code>that: &gt;
  Foo
  Bar
this: |
  Foo
  Bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>等价于json：</p>
<div><pre><code>{&#39;that&#39;: &#39;Foo Bar&#39;, &#39;this&#39;: &#39;Foo\nBar\n&#39;}
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>参考链接：</p>
<p>https://blog.51cto.com/cloumn/blog/1543</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">gitlab备份迁移升级&amp;集成openldap</title>
    <id>https://clay-wangzhi.com/automate/gitlab/</id>
    <link href="https://clay-wangzhi.com/automate/gitlab/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="gitlab备份迁移升级-集成openldap"> gitlab备份迁移升级&amp;集成openldap</h1>
<h2 id="gitlab安装"> gitlab安装</h2>
<h3 id="安装相关依赖"> 安装相关依赖</h3>
<div><pre><code>yum <span>install</span> -y <span>curl</span> policycoreutils-python openssh-server
yum <span>install</span> postfix
systemctl <span>enable</span> postfix
systemctl start postfix
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="镜像切换"> 镜像切换</h3>
<p>切换为国内的清华源</p>
<div><pre><code><span># cat gitlab_gitlab-ce.repo </span>
<span>[</span>gitlab_gitlab-ce<span>]</span>
<span>name</span><span>=</span>gitlab_gitlab-ce
<span>baseurl</span><span>=</span>https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/
<span>repo_gpgcheck</span><span>=</span><span>0</span>
<span>gpgcheck</span><span>=</span><span>0</span>
<span>enabled</span><span>=</span><span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>由于不同版本号的备份文件不能相互使用，下载旧gitlab中的对应的版本</p>
<div><pre><code>yum -y <span>install</span> gitlab-ce-11.5.1
</code></pre>
<div><span>1</span><br></div></div><h3 id="配置使用"> 配置使用</h3>
<p>安装完成之后，可以在<code>/etc/gitblab/gitlab.rb</code>中按照需求修改配置，
主要需要修改<code>external_url</code>，改成自己使用的 url 地址。
执行命令配置生效：</p>
<div><pre><code>gitlab-ctl reconfigure
gitlab-ctl restart
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="gitlab备份-恢复"> gitlab备份&amp;恢复</h2>
<p>Gitlab 成功运行起来之后，最终的事情就是定期的备份，遇到问题后的还原。</p>
<h3 id="备份配置"> 备份配置</h3>
<p>默认 Gitlab 的备份文件会创建在<code>/var/opt/gitlab/backups</code>文件夹中，格式为<code>时间戳_日期_版本号_gitlab_backup.tar</code>，例如：<code>1515031353_2018_01_04_10.3.2_gitlab_backup.tar</code>。
修改备份文件夹，需要修改配置文件<code>/etc/gitlab/gitlab.rb</code>中的：</p>
<div><pre><code>gitlab_rails<span>[</span><span>'backup_path'</span><span>]</span> <span>=</span> <span>'/your_wish/backups'</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后<code>gitlabctl-reconfigure</code>生效。</p>
<h3 id="手动备份"> 手动备份</h3>
<p>命令：<code>gitlab-backup create</code></p>
<p>For GitLab 12.1 and earlier, use <code>gitlab-rake gitlab:backup:create</code>.
会在命令执行的时间点，在你配置的文件夹或者默认文件夹创建一个备份文件。</p>
<h3 id="自动备份"> 自动备份</h3>
<div><pre><code><span>0</span> <span>2</span> * * * /opt/gitlab/bin/gitlab-backup create <span>CRON</span><span>=</span><span>1</span>
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p><strong>Note</strong> For GitLab 12.1 and earlier, use <code>gitlab-rake gitlab:backup:create</code>.</p>
</blockquote>
<h3 id="备份恢复"> 备份恢复</h3>
<p>First make sure your backup tar file is in the backup directory described in the <code>gitlab.rb</code> configuration <code>gitlab_rails['backup_path']</code>. The default is <code>/var/opt/gitlab/backups</code>. It needs to be owned by the <code>git</code> user.</p>
<div><pre><code>cp 11493107454_2018_04_25_10.6.4-ce_gitlab_backup.tar /var/opt/gitlab/backups/
chown git.git /var/opt/gitlab/backups/11493107454_2018_04_25_10.6.4-ce_gitlab_backup.tar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Stop the processes that are connected to the database. Leave the rest of GitLab running:</p>
<div><pre><code>gitlab-ctl stop unicorn
gitlab-ctl stop sidekiq
<span># Verify</span>
gitlab-ctl status
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Next, restore the backup, specifying the timestamp of the backup you wish to restore:</p>
<div><pre><code><span># This command will overwrite the contents of your GitLab database!</span>
gitlab-backup restore <span>BACKUP</span><span>=</span>1493107454_2018_04_25_10.6.4-ce
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p><strong>Note</strong> For GitLab 12.1 and earlier, use <code>gitlab-rake gitlab:backup:restore</code>.</p>
</blockquote>
<blockquote>
<p><strong>Warning:</strong> <code>gitlab-rake gitlab:backup:restore</code> does not set the right file system permissions on your Registry directory. This is a <a href="https://gitlab.com/gitlab-org/gitlab-foss/issues/62759" target="_blank" rel="noopener noreferrer">known issue</a>. On GitLab 12.2 or newer, you can use <code>gitlab-backup restore</code> to avoid this issue.</p>
</blockquote>
<p>Next, restore <code>/etc/gitlab/gitlab-secrets.json</code> if necessary as mentioned above.</p>
<p>Reconfigure, restart and check GitLab:</p>
<div><pre><code>gitlab-ctl reconfigure
gitlab-ctl restart
gitlab-rake gitlab:check <span>SANITIZE</span><span>=</span>true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>If there is a GitLab version mismatch between your backup tar file and the installed version of GitLab, the restore command will abort with an error. Install the <a href="https://packages.gitlab.com/gitlab/" target="_blank" rel="noopener noreferrer">correct GitLab version</a> and try again.</p>
<h2 id="gitlab升级"> gitlab升级</h2>
<p>It is considered safe to jump between patch versions and minor versions within one major version. For example, it is safe to:</p>
<ul>
<li>Upgrade the patch version:
<ul>
<li><code>8.9.0</code> -&gt; <code>8.9.7</code></li>
<li><code>8.9.0</code> -&gt; <code>8.9.1</code></li>
<li><code>8.9.2</code> -&gt; <code>8.9.6</code></li>
<li><code>9.5.5</code> -&gt; <code>9.5.9</code></li>
<li><code>10.6.3</code> -&gt; <code>10.6.6</code></li>
<li><code>11.11.1</code> -&gt; <code>11.11.8</code></li>
<li><code>12.0.4</code> -&gt; <code>12.0.9</code></li>
</ul>
</li>
<li>Upgrade the minor version:
<ul>
<li><code>8.9.4</code> -&gt; <code>8.12.3</code></li>
<li><code>9.2.3</code> -&gt; <code>9.5.5</code></li>
<li><code>10.6.6</code> -&gt; <code>10.8.7</code></li>
<li><code>11.3.4</code> -&gt; <code>11.11.8</code></li>
</ul>
</li>
</ul>
<p>Upgrading the major version requires more attention. We cannot guarantee that upgrading between major versions will be seamless. As previously mentioned, major versions are reserved for backwards incompatible changes. We recommend that you first upgrade to the latest available minor version within your major version. By doing this, you can address any deprecation messages that could change behavior in the next major release. To ensure background migrations are successful, increment by one minor version during the version jump before installing newer releases.</p>
<p>For example: <code>11.11.x</code> -&gt; <code>12.0.x</code> Please see the table below for some examples:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Latest stable version</th>
<th style="text-align:left">Your version</th>
<th style="text-align:left">Recommended upgrade path</th>
<th style="text-align:left">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">9.4.5</td>
<td style="text-align:left">8.13.4</td>
<td style="text-align:left"><code>8.13.4</code> -&gt; <code>8.17.7</code> -&gt; <code>9.4.5</code></td>
<td style="text-align:left"><code>8.17.7</code> is the last version in version <code>8</code></td>
</tr>
<tr>
<td style="text-align:left">10.1.4</td>
<td style="text-align:left">8.13.4</td>
<td style="text-align:left"><code>8.13.4 -&gt; 8.17.7 -&gt; 9.5.10 -&gt; 10.1.4</code></td>
<td style="text-align:left"><code>8.17.7</code> is the last version in version <code>8</code>, <code>9.5.10</code> is the last version in version <code>9</code></td>
</tr>
<tr>
<td style="text-align:left">11.3.4</td>
<td style="text-align:left">8.13.4</td>
<td style="text-align:left"><code>8.13.4</code> -&gt; <code>8.17.7</code> -&gt; <code>9.5.10</code> -&gt; <code>10.8.7</code> -&gt; <code>11.3.4</code></td>
<td style="text-align:left"><code>8.17.7</code> is the last version in version <code>8</code>, <code>9.5.10</code> is the last version in version <code>9</code>, <code>10.8.7</code> is the last version in version <code>10</code></td>
</tr>
<tr>
<td style="text-align:left">12.5.8</td>
<td style="text-align:left">11.3.4</td>
<td style="text-align:left"><code>11.3.4</code> -&gt; <code>11.11.8</code> -&gt; <code>12.0.9</code> -&gt; <code>12.5.8</code></td>
<td style="text-align:left"><code>11.11.8</code> is the last version in version <code>11</code></td>
</tr>
</tbody>
</table>
<p>我的升级路线为：表格中最后一个</p>
<p>每次升级直接<code>yum -y install gitlab-ce-版本号</code>就可以了</p>
<p>例如</p>
<div><pre><code>yum -y <span>install</span> gitlab-ce-11.11.8
</code></pre>
<div><span>1</span><br></div></div><p>每升级一次，重载一下配置，重启一下gitlab</p>
<div><pre><code>gitlab-ctl reconfigure
gitlab-ctl restart
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="gitlab集成openldap"> gitlab集成openldap</h2>
<h3 id="setting-up-ldap-sign-in"> Setting up LDAP sign-in</h3>
<p>If you have an LDAP directory service such as Active Directory, you can configure GitLab so that your users can sign in with their LDAP credentials. Add the following to <code>/etc/gitlab/gitlab.rb</code>, edited for your server.</p>
<p>For GitLab Community Edition:</p>
<p>以下是我ldap的配置</p>
<div><pre><code><span>### LDAP Settings</span>
<span>###! Docs: https://docs.gitlab.com/omnibus/settings/ldap.html</span>
<span>###! **Be careful not to break the indentation in the ldap_servers block. It is</span>
<span>###!   in yaml format and the spaces must be retained. Using tabs will not work.**</span>

gitlab_rails<span>[</span><span>'ldap_enabled'</span><span>]</span> <span>=</span> <span>true</span>
gitlab_rails<span>[</span><span>'prevent_ldap_sign_in'</span><span>]</span> <span>=</span> <span>false</span>
gitlab_rails<span>[</span><span>'ldap_servers'</span><span>]</span> <span>=</span> YAML.load <span>&lt;&lt;-</span><span>EOS
main:
  label: 'LDAP'
  host: '192.168.x.x'
  port: 389
  uid: 'cn'
  encryption: 'plain'
  bind_dn: 'cn=admin,dc=xxx,dc=com'
  password: 'xxx'
  smartcard_auth: false
  active_directory: true
  allow_username_or_email_login: true
  lowercase_usernames: false
  base: 'ou=People,dc=xxx,dc=com'
  user_filter: ''
EOS</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code>gitlab-ctl reconfigure
gitlab-ctl restart
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>参考文章：</p>
<p>https://www.jianshu.com/p/d29c332bcf53</p>
<p>https://docs.gitlab.com/ee/raketasks/backup_restore.html#restore-for-omnibus-gitlab-installations</p>
<p>https://www.jianshu.com/p/6361cba123a8</p>
<p>https://docs.gitlab.com/ee/policy/maintenance.html#upgrade-recommendations</p>
<p>https://docs.gitlab.com/omnibus/settings/ldap.html</p>
<p>https://www.jianshu.com/p/083cf462fed4</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2019-12-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">使用Jenkins扩展共享库进行钉钉消息推送</title>
    <id>https://clay-wangzhi.com/automate/jenkins/dingding-plugin/</id>
    <link href="https://clay-wangzhi.com/automate/jenkins/dingding-plugin/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用jenkins扩展共享库进行钉钉消息推送"> 使用Jenkins扩展共享库进行钉钉消息推送</h1>
<p>起因：执行完流水线后进行一定程度的消息推送，所以选择钉钉进行<code>jenkins</code>构建结构的消息推送</p>
<h2 id="下载配置相关依赖插件"> 下载配置相关依赖插件</h2>
<p>相关环境：</p>
<ul>
<li><code>Jenkins</code> 2.277.3，安装文档见上篇</li>
<li><code>DingTalk</code> 插件 2.4.3</li>
<li><code>build user vars plugin</code> 插件 1.7</li>
</ul>
<ol>
<li>
<p>在Jenkins中安装钉钉插件<a href="https://plugins.jenkins.io/dingding-notifications" target="_blank" rel="noopener noreferrer">DingTalk</a></p>
<blockquote>
<p>⚠️ 请确保你的 Jenkins 版本 &gt;= 2.176.4</p>
</blockquote>
</li>
<li>
<p>钉钉机器人配置，<a href="https://jenkinsci.github.io/dingtalk-plugin/" target="_blank" rel="noopener noreferrer">说明文档</a></p>
<p>找到 Jenkins 首页 &gt;&gt; 系统管理 &gt;&gt; 钉钉，我的配置如下图</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20210426164341273.png" alt="image-20210426164341273" /></p>
<blockquote>
<p>⚠️ ​注意手动输入机器人的id，不要自动生成，否则重启后，robot的id将发生变化</p>
</blockquote>
</li>
<li>
<p>安装<a href="https://plugins.jenkins.io/build-user-vars-plugin" target="_blank" rel="noopener noreferrer">build user vars plugin</a>插件，插件可能有相关版本依赖，需要重启一下 Jenkins 才能继续安装</p>
<p>在流水线中，使用wrap，获取BUILD_USER变量</p>
<div><pre><code><span>wrap</span><span>(</span><span>[</span><span>$</span><span>class</span><span>:</span> <span>'BuildUser'</span><span>]</span><span>)</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ol>
<h2 id="创建配置共享库"> 创建配置共享库</h2>
<h3 id="编写groovy脚本"> 编写Groovy脚本</h3>
<p>项目目录结构如下：</p>
<div><pre><code>$ tree jenkinslibrary
jenkinslibrary
├── README.md
└── src
    └── org
        └── devops
            └── dingmes.groovy

<span>3</span> directories, <span>2</span> files
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>dingme.groovy</code>文件内容如下</p>
<div><pre><code><span>package</span> org<span>.</span>devops

<span>def</span> <span>GetChangeString</span><span>(</span><span>)</span> <span>{</span>
    MAX_MSG_LEN <span>=</span> <span>100</span>
    <span>def</span> changeString <span>=</span> <span>""</span>
    <span>def</span> changeLogSets <span>=</span> currentBuild<span>.</span>changeSets
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> changeLogSets<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>def</span> entries <span>=</span> changeLogSets<span>[</span>i<span>]</span><span>.</span>items
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> entries<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>def</span> entry <span>=</span> entries<span>[</span>j<span>]</span>
            truncated_msg <span>=</span> entry<span>.</span>msg<span>.</span><span>take</span><span>(</span>MAX_MSG_LEN<span>)</span>
            commitTime <span>=</span> <span>new</span> <span>Date</span><span>(</span>entry<span>.</span>timestamp<span>)</span><span>.</span><span>format</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span>
            changeString <span>+=</span> <span>"> - <span><span>$</span><span>{</span>truncated_msg<span>}</span></span> [<span><span>$</span><span>{</span>entry<span>.</span>author<span>}</span></span> <span><span>$</span><span>{</span>commitTime<span>}</span></span>]\n"</span>
        <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>!</span>changeString<span>)</span> <span>{</span>
        changeString <span>=</span> <span>"> - No new changes"</span>
    <span>}</span>
    <span>return</span> changeString
<span>}</span>

<span>def</span> <span>DingdingReq</span><span>(</span>RobotID<span>,</span> Status<span>)</span> <span>{</span>
    <span>wrap</span><span>(</span><span>[</span><span>$</span><span>class</span><span>:</span> <span>'BuildUser'</span><span>]</span><span>)</span> <span>{</span>
        <span>def</span> changeString <span>=</span> <span>GetChangeString</span><span>(</span><span>)</span>
        dingtalk <span>(</span>
            robot<span>:</span> RobotID<span>,</span>
            type<span>:</span> <span>'MARKDOWN'</span><span>,</span>
            title<span>:</span> <span>'你有新的消息，请注意查收'</span><span>,</span>
            text<span>:</span> <span>[</span>
                <span>"### 构建信息"</span><span>,</span>
                <span>"> - 应用名称：**<span><span>$</span><span>{</span>env<span>.</span>JOB_NAME<span>}</span></span>**"</span><span>,</span>
                <span>"> - 构建结果：**<span><span>$</span><span>{</span>Status<span>}</span></span>**"</span><span>,</span>
                <span>"> - 当前版本：**<span><span>$</span><span>{</span>env<span>.</span>BUILD_NUMBER<span>}</span></span>**"</span><span>,</span>
                <span>"> - 构建发起：**<span><span>$</span><span>{</span>env<span>.</span>BUILD_USER<span>}</span></span>**"</span><span>,</span>
                <span>"> - 持续时间：**<span><span>$</span><span>{</span>currentBuild<span>.</span>durationString<span>}</span></span>**"</span><span>,</span>
                <span>"> - 构建日志：[点击查看详情](<span><span>$</span><span>{</span>env<span>.</span>BUILD_URL<span>}</span></span>console)"</span><span>,</span>
                <span>"### 更新记录:"</span><span>,</span>
                <span>"<span><span>$</span><span>{</span>changeString<span>}</span></span>"</span>
            <span>]</span><span>,</span>
            at<span>:</span> <span>[</span>
                <span>'xxxxxxxxxxx'</span>
            <span>]</span>
        <span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><blockquote>
<p>文本中<code>xxxxxxxxxxx</code>请根据实际情况更换为钉钉群组里面，具体人的手机号，可以添加多个</p>
</blockquote>
<h3 id="在-jenkins-中配置将共享库"> 在 Jenkins 中配置将共享库</h3>
<p>找到 Jenkins 首页 &gt;&gt; 系统管理 &gt;&gt; Global Pipeline Libraries，我的配置如下图</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20210426171913350.png" alt="image-20210426171913350" /></p>
<h3 id="在流水线中导入共享库"> 在流水线中导入共享库</h3>
<p>导入方法<code>@Library('pipeline-library-demo')_</code>，这样就可以使用共享库中的代码了</p>
<p>具体的 pipeline 脚本如下：</p>
<div><pre><code><span>#!groovy</span>

<span>@Library</span><span>(</span><span>'pipeline-library-demo'</span><span>)</span><span>_</span>

<span>//func from shareibrary</span>
<span>def</span> dingmes <span>=</span> <span>new</span> <span>org<span>.</span>devops<span>.</span>dingmes</span><span>(</span><span>)</span>

<span>//env</span>
String branchName <span>=</span> <span>"master"</span>
String gitlabCredentialsId <span>=</span> <span>"xxx"</span>
String gitUrl <span>=</span> <span>"http://xxx/xxx/jenkinslibrary.git"</span>
String robotId <span>=</span> <span>"2e0e11c4-2211-4687-b317-cacf58197288"</span>

pipeline <span>{</span>
    agent any
    
    stages <span>{</span>
        <span>stage</span><span>(</span><span>'Git Clone'</span><span>)</span> <span>{</span>
            steps <span>{</span>
                git branch<span>:</span> <span>"<span><span>$</span><span>{</span>branchName<span>}</span></span>"</span><span>,</span>
                credentialsId<span>:</span> <span>"<span><span>$</span><span>{</span>gitlabCredentialsId<span>}</span></span>"</span><span>,</span>
                url<span>:</span> <span>"<span><span>$</span><span>{</span>gitUrl<span>}</span></span>"</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    post <span>{</span>
        success <span>{</span>
            script <span>{</span>
                dingmes<span>.</span><span>DingdingReq</span><span>(</span>robotId<span>,</span> <span>"构建成功 ✅"</span><span>)</span>
            <span>}</span>
        <span>}</span>
        failure <span>{</span>
            script <span>{</span>
                dingmes<span>.</span><span>DingdingReq</span><span>(</span>robotId<span>,</span> <span>"构建失败 ❌"</span><span>)</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>至此完成，构建效果如下图：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20210426172713667.png" alt="image-20210426172713667" /></p>
<h2 id="遇到的问题"> 遇到的问题</h2>
<ol>
<li>
<p><code>currentBuild.durationString</code>的值传递不进去，一开始先用<code>withEnv</code>包裹一下</p>
<p>后来找到原因 Groovy 在单引号的字符串里面是不支持插值的，所以要用双引号</p>
<p>单引号中的<code>env.JOB_NAME</code>会引用失败，双引号则引用成功</p>
<p>单、双引号引用<code>JOB_NAME</code>都引用成功</p>
<blockquote>
<p>推荐所有变量都用&quot;&quot;双引号</p>
<p>三引号也是一样，''' 三单引号不支持插值，&quot;&quot;&quot;三双引号支持插值</p>
</blockquote>
</li>
</ol>
<p>参考链接：https://www.ssgeek.com/post/jenkinssharelibrary-shi-jian-zhi-zi-ding-yi-tong-zhi-qi/</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Jenkins Job迁移</title>
    <id>https://clay-wangzhi.com/automate/jenkins/migrate-job/</id>
    <link href="https://clay-wangzhi.com/automate/jenkins/migrate-job/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jenkins-job迁移"> Jenkins Job迁移</h1>
<p>在工作中可能会遇到这样的场景，即需要把一个Jenkins Master上的job迁移到另外一台Jenkins Master上，那怎么做比较好呢？</p>
<p>如果只是单独的一个job且这个job的设置很简单，这种情况下当然可以直接在新的Jenkins Master上直接创建job然后从旧的job拷贝下配置即可。但如果job很多，或者job的配置项较多那手动复制配置肯定是比较傻的行为。那我们现在来介绍下这种配置项较多、job比较多的情况下怎么来迁移这些job。</p>
<p>现在我搭建了两台Jenkins来进行说明。IP分别为192.168.9.9和192.168.9.8，现在我在.10上创建一个job，如test，然后进行如下配置</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/g62phjjstk.jpeg" alt="img" /></p>
<p>现在具体来看下如何将上面的配置的job从192.168.9.10的Jenkins上迁移到192.168.9.8的机器上。</p>
<h2 id="job-import-plugin导入"> <strong>Job Import Plugin导入</strong></h2>
<p>现在先介绍第一种方式，通过Job Import Plugin方式来进行job的迁移，这种方式比较方便，首先到新的Jenkins上，也就是192.168.9.8上，在192.168.9.8上插件管理里先安装下Job Import Plugin，如下所示：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/jf3clczyv2.jpeg" alt="img" /></p>
<p>安装完后进入“Manage Jenkins” -&gt; &quot;Configure System&quot;下，找到Job Import Pluguin配置的地方，进行如下设置：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/eug932owyp.jpeg" alt="img" /></p>
<p><strong>name</strong>: 这个可以任意命名，这里我命名成要拷贝的Jenkins的IP</p>
<p><strong>Url</strong>: 指要从哪里拷贝的Jenkins的URL，现在我们要从192.168.9.10拷贝job，因此这里要设置成192.168.9.10的Jenkins的URL</p>
<p><strong>Credentials</strong>：需要添加一个旧Jenkins的账号（也就是192.168.9.10的账号），没有添加的时候点击Add手动添加下，就可以像上面的截图一样下拉选择到这个账号了</p>
<p>设置完后点击保存下，回到Jenkins首页点击Job Import Plugin就可以进行Job的迁移了，如下所示：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/uov6bpo6hk.jpeg" alt="img" /></p>
<p>在Job Import Plugin界面，下拉选择刚才添加的配置，然后点击Query按钮就可以搜索出配置的Jenkins下的job了，然后选择需要的job进行迁移导入即可：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/v71i68ivlj.jpeg" alt="img" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/o6jxwkuuba.jpeg" alt="img" /></p>
<p>因为有时候旧的Jenkins上的插件新Jenkins上未必有，因此可以根据实际情况勾选是否需要安装必要的插件，如上面的截图所示，需不需要覆盖已有的job也根据实际情况勾选下。导入成功会有如下的提示：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/sqfvrcd932.jpeg" alt="img" /></p>
<p>有了上面的提示后就可以会到新的Jenkins的首页，查看Job有没有成功进入，并进入导入的job查看设置有没有成功的复制过来，如下所示：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/7j29p9rg9g.jpeg" alt="img" /></p>
<p>可以看到job及其设置成功的被导入到新的job了。</p>
<p>Job Import Pugin也支持多个job同时拷贝，如果旧的Job里有多个job，如上面的步骤里所示，query出来就有很多job可供选择，只需要勾选多个即可同时进行多个job的导入了。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/dg1ouhsl9j.jpeg" alt="img" /></p>
<h2 id="jenkins-cli方式导入"> <strong>Jenkins CLI方式导入</strong></h2>
<p>有时候在公司内部Jenkins部署到不同的网段里，不同网段间可能会限制无法相互访问，这种情况下通过Job Import Plugin进行job导入的方式就行不通了，这时候可以通过Jenkins CLI方式进行job配置导出，然后新Jenkins在根据导出的配置进行再导入操作，完成job的配置迁移 。下面我们来具体讲解下。</p>
<p>现到旧Jenkins下的Jenkins管理页面找到Jenkins CLI，如下所示：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/2yywfzeqrj.jpeg" alt="img" /></p>
<p>点击进入Jenkins CLI，可以看到Jenkins命令行接口提供很多命令可以用来进行Jenkins的相关操作，可以看到有提供了get-job这样一个命令，这个命令可以将job的定义导出到xml的格式到输出流，这样我们可以通过这个命令将旧Jenkins上的job导出到外部文件，然后还可以看到有另外一个命令create-job，这个命令可以根据已有的xml配置文件进行job创建，那我们可以根据从旧job导出的job配置文件做为输入进行job的创建了。</p>
<p>首先在旧的Jenkins上的cli页面点击jenkins-cli.jar就可以下载这个jar到本地，如下所示：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/g1ltwl2a3o.jpeg" alt="img" /></p>
<p>接着点击下Jenkins右上角的账号，选择Configure，然后点击Show API Token，拷贝token，这个token可以用来进行配置导出的时候做为认证使用</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/u30td2vuwj.jpeg" alt="img" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/yrwhwenjqe.jpeg" alt="img" /></p>
<p>在jenkins-cli.jar下载的根目录下执行如下命令进行job导出，这里我新建了个job，命名为test4，现在执行下如下命令进行test4这个job配置的导出：</p>
<div><pre><code> java <span>-</span>jar jenkins<span>-</span>cli<span>.</span>jar <span>-</span>s http<span>:</span><span>/</span><span>/</span><span>192.168</span><span>.9</span><span>.10</span><span>:</span><span>8080</span><span>/</span>jenkins <span>-</span>auth admin<span>:</span><span>493375</span>c06bc0006a455005804796c989 get<span>-</span>job <span>"test4"</span> <span>></span> test4<span>.</span>xml
</code></pre>
<div><span>1</span><br></div></div><p><strong>http://192.168.9.10:8080/jenkins:</strong> 就Job的Jenkins地址</p>
<p><strong>admin：</strong> 上面截图获取Show API Token下的User ID</p>
<p>**493375c06bc0006a455005804796c989：**上面截图获取API Token的值</p>
<p><strong>test4:</strong> 需要导出配置的job名</p>
<p><strong>test4.xml:</strong> 导出的文件的名称，可任意</p>
<p>根据实际情况替换下上面的四个值即可</p>
<p>执行完上面的命令就可以看到test4.xml文件生成了</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/xf64g5cl00.jpeg" alt="img" /></p>
<p>接着在新的Jenkins下同样先下载下jenkins-cli.jar，然后将上面生成的test4.xml拷贝到新的Jenkins机器下，同样获取下新Jenkins登录账号的API Token和User ID，执行下如下命令就可以进行job导入了</p>
<div><pre><code>java <span>-</span>jar jenkins<span>-</span>cli<span>.</span>jar <span>-</span>s http<span>:</span><span>/</span><span>/</span><span>192.168</span><span>.9</span><span>.8</span><span>:</span><span>8080</span><span>/</span>jenkins <span>-</span>auth admin<span>:</span><span>51964e7</span>b89a427be5dd2a28f38c86eff create<span>-</span>job test4 <span>&lt;</span>  test4<span>.</span>xml
</code></pre>
<div><span>1</span><br></div></div><p>记得将URL替换成新Jenkins的URL，User ID和token也替换下</p>
<p>上面的命令执行完后，就可以看到在新的Jenkins下新job被成功导入了</p>
<blockquote>
<p>转载链接：https://cloud.tencent.com/developer/article/1470433</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-01-16T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">pipeline配置java项目</title>
    <id>https://clay-wangzhi.com/automate/jenkins/pipeline-java/</id>
    <link href="https://clay-wangzhi.com/automate/jenkins/pipeline-java/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pipeline配置java项目"> pipeline配置java项目</h1>
<div><pre><code>pipeline <span>{</span>
    agent <span>{</span> label <span>'slave'</span> <span>}</span>
    options <span>{</span>
        <span>timestamps</span><span>(</span><span>)</span>
        <span>disableConcurrentBuilds</span><span>(</span><span>)</span>
        <span>buildDiscarder</span><span>(</span>
            <span>logRotator</span><span>(</span>
                numToKeepStr<span>:</span> <span>'20'</span><span>,</span>
                daysToKeepStr<span>:</span> <span>'30'</span><span>,</span>
            <span>)</span>
        <span>)</span>
    <span>}</span>
    parameters <span>{</span>
        <span>choice</span><span>(</span>
           name<span>:</span> <span>"DEPLOY_FLAG"</span><span>,</span>
           choices<span>:</span> <span>[</span><span>'deploy'</span><span>,</span> <span>'rollback'</span><span>]</span><span>,</span>
           description<span>:</span> <span>"发布/回滚"</span>
        <span>)</span>
    <span>}</span>
    <span>/*=======================================常修改变量-start=======================================*/</span>
    environment <span>{</span>
        gitUrl <span>=</span> <span>"git地址"</span>
        branchName <span>=</span> <span>"分支名称"</span>
        gitlabCredentialsId <span>=</span> <span>"认证凭证"</span>
        projectRunDir <span>=</span> <span>"项目运行目录"</span>
        jobName <span>=</span> <span>"<span><span>$</span><span>{</span>env<span>.</span>JOB_NAME<span>}</span></span>"</span>
        serviceName <span>=</span> <span>"服务名称"</span>
        serviceType <span>=</span> <span>"jar"</span>
        runHosts <span>=</span> <span>"192.168.167.xx,192.168.167.xx"</span>
        rollbackVersion <span>=</span> <span>""</span>
    <span>}</span>
    stages <span>{</span>
        <span>stage</span><span>(</span><span>'Deploy'</span><span>)</span><span>{</span>
            when <span>{</span>
                expression <span>{</span> <span>return</span> params<span>.</span>DEPLOY_FLAG <span>==</span> <span>'deploy'</span> <span>}</span>
            <span>}</span>
            stages <span>{</span>
                <span>stage</span><span>(</span><span>'Pre Env'</span><span>)</span> <span>{</span>
                    steps <span>{</span>
                        echo <span>"======================================项目名称 = <span><span>$</span><span>{</span>env<span>.</span>JOB_NAME<span>}</span></span>"</span>
                        echo <span>"======================================项目 URL = <span><span>$</span><span>{</span>gitUrl<span>}</span></span>"</span>
                        echo <span>"======================================项目分支 = <span><span>$</span><span>{</span>branchName<span>}</span></span>"</span>
                        echo <span>"======================================当前编译版本号 = <span><span>$</span><span>{</span>env<span>.</span>BUILD_NUMBER<span>}</span></span>"</span>
                    <span>}</span>
                <span>}</span>
                <span>stage</span><span>(</span><span>'Git Clone'</span><span>)</span> <span>{</span>
                    steps <span>{</span>
                        git branch<span>:</span> <span>"<span><span>$</span><span>{</span>branchName<span>}</span></span>"</span><span>,</span>
                        credentialsId<span>:</span> <span>"<span><span>$</span><span>{</span>gitlabCredentialsId<span>}</span></span>"</span><span>,</span>
                        url<span>:</span> <span>"<span><span>$</span><span>{</span>gitUrl<span>}</span></span>"</span>
                    <span>}</span>
                <span>}</span>
                <span>stage</span><span>(</span><span>'Mvn Build'</span><span>)</span> <span>{</span>
                    steps <span>{</span>
                        <span>withMaven</span><span>(</span>jdk<span>:</span> <span>'jdk1.8'</span><span>,</span> maven<span>:</span> <span>'maven'</span><span>)</span> <span>{</span>
                            sh <span>"mvn clean package -Dmaven.test.skip=true -U -f <span><span>$</span><span>{</span>serviceName<span>}</span></span>/pom.xml"</span>
                        <span>}</span>
                    <span>}</span>
                <span>}</span>
                <span>stage</span><span>(</span><span>'Ansible Deploy'</span><span>)</span> <span>{</span>
                    steps<span>{</span>
                        script <span>{</span>
                            sleep <span>5</span>
                            <span>ansiColor</span><span>(</span><span>'xterm'</span><span>)</span> <span>{</span>
                                ansiblePlaybook colorized<span>:</span> <span>true</span><span>,</span> extras<span>:</span> <span>'-e "directory=${projectRunDir}" -e "job=${jobName}" -e "service=${serviceName}" -e "type=${serviceType}"'</span><span>,</span> installation<span>:</span> <span>'ansible'</span><span>,</span> inventory<span>:</span> <span>'/etc/ansible/hosts.yml'</span><span>,</span> limit<span>:</span> <span>"<span><span>$</span><span>{</span>runHosts<span>}</span></span>"</span><span>,</span> playbook<span>:</span> <span>'/etc/ansible/playbook/deploy-jenkins.yml'</span>                            
                            <span>}</span>
                        <span>}</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>   
        <span>}</span>
        <span>stage</span><span>(</span><span>'Rollback'</span><span>)</span> <span>{</span>
            when <span>{</span>
                expression <span>{</span> <span>return</span> params<span>.</span>DEPLOY_FLAG <span>==</span> <span>'rollback'</span> <span>}</span>
            <span>}</span>
            steps<span>{</span>
                script <span>{</span>
                    rollbackVersion <span>=</span> <span>input</span><span>(</span>
                        message<span>:</span> <span>"请填写要回滚的版本"</span><span>,</span>
                        parameters<span>:</span> <span>[</span>
                            <span>string</span><span>(</span>name<span>:</span><span>'last_number'</span><span>)</span>
                        <span>]</span>
                    <span>)</span>
                    sh <span>"""
                        echo "正在回滚至就近第<span><span>$</span><span>{</span>rollbackVersion<span>}</span></span>个版本"
                        ansible <span><span>$</span><span>{</span>runHosts<span>}</span></span> -m shell -a "sh <span><span>$</span><span>{</span>projectRunDir<span>}</span></span>/rollback.sh <span><span>$</span><span>{</span>rollbackVersion<span>}</span></span> <span><span>$</span><span>{</span>serviceName<span>}</span></span>"
                    """</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    post <span>{</span>
        always <span>{</span>
            <span>deleteDir</span><span>(</span><span>)</span>
        <span>}</span>
        success <span>{</span>
            echo <span>'This task is successful!'</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">使用Jenkins Pipeline自动化构建发布</title>
    <id>https://clay-wangzhi.com/automate/jenkins/pipeline/</id>
    <link href="https://clay-wangzhi.com/automate/jenkins/pipeline/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用jenkins-pipeline自动化构建发布"> 使用Jenkins Pipeline自动化构建发布</h1>
<h2 id="一、jenkins介绍"> 一、Jenkins介绍</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/2399048-91830c936e5fa651.webp" alt="img" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/2399048-0fa91d8b2c207c35.webp" alt="img" /></p>
<h2 id="二、jenkins-pipeline介绍"> 二、Jenkins Pipeline介绍</h2>
<h3 id="jenkins-pipeline总体介绍"> Jenkins Pipeline总体介绍</h3>
<blockquote>
<p>1.Pipeline 是Jenkins 2.X核心特性，帮助Jenkins实现从CI到CD与DevOps的转变
2.Pipeline 简而言之，就是一套运行于Jenkins上的工作流框架，将原本独立
运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流
程编排与可视化。</p>
</blockquote>
<h3 id="什么是jenkins-pipeline"> 什么是Jenkins Pipeline</h3>
<blockquote>
<p>1.Jenkins Pipeline是一组插件，让Jenkins可以实现持续交付管道的落地和实施。
2.持续交付管道(CD Pipeline)是将软件从版本控制阶段到交付给用户或客户的完
整过程的自动化表现。
3.软件的每一次更改（提交到源代码管理系统）都要经过一个复杂的过程才能被发布。</p>
</blockquote>
<ol>
<li>Pipeline提供了一组可扩展的工具，通过Pipeline Domain Specific Language
(DSL) syntax可以达到Pipeline as Code的目的</li>
<li>Pipeline as Code：Jenkinsfile 存储在项目的源代码库</li>
</ol>
<h3 id="why-pipeline"> Why Pipeline?</h3>
<p>本质上，Jenkins 是一个自动化引擎，它支持许多自动模式。 Pipeline向Jenkins中添加了一组强大的工具, 支持用例 简单的CI到全面的CD pipeline。通过对一系列的相关任务进行建模, 用户可以利用pipeline的很多特性:</p>
<p>• 代码：Pipeline以代码的形式实现，通常被检入源代码控制，使团队能够编辑，
审查和迭代其CD流程。
• 可持续性：Jenkins重启或者中断后都不会影响Pipeline Job。
• 停顿：Pipeline可以选择停止并等待人工输入或批准，然后再继续Pipeline运行。
• 多功能：Pipeline支持现实世界的复杂CD要求，包括fork/join子进程，循环和
并行执行工作的能力。
• 可扩展：Pipeline插件支持其DSL的自定义扩展以及与其他插件集成的多个选项。</p>
<h3 id="pipeline与freestyle区别"> Pipeline与freestyle区别</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/2399048-40a98c55b7188ba8.webp" alt="img" /></p>
<p>1.Job调度方式
pipeline：通过结构化pipeline 语法进行调度，易于理解与阅读
freestyle：通过jenkins api或者cli进行调度</p>
<p>2.Job显示形式
pipline:提供上帝视角（全局视图）
freestyle：没有视图</p>
<h2 id="jenkins-pipeline-基础语法"> Jenkins Pipeline 基础语法</h2>
<blockquote>
<p>官网链接：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjenkins.io%2Fdoc%2F" target="_blank" rel="noopener noreferrer">https://jenkins.io/doc/</a></p>
</blockquote>
<h3 id="pipeline-支持两种语法"> Pipeline 支持两种语法</h3>
<p>1.声明式（jenkins2.x新加入的语法）</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/2399048-4e99cf386cd7bd51.webp" alt="img" /></p>
<blockquote>
<p>特点：</p>
<p>1.最外层必须由pipline{ //do something }来进行包裹</p>
<p>2.不需要分号作为分隔符，每个语句必须在一行内</p>
<p>3.不能直接使用groovy语句（例如循环判断等），需要被script {}包裹</p>
</blockquote>
<p>2.脚本式</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/2399048-0976ca380ccc0097.webp" alt="img" /></p>
<blockquote>
<p>特点：</p>
<p>1.最外层有node{}包裹</p>
<p>2.可直接使用groovy语句</p>
</blockquote>
<h3 id="declarative-pipeline-声明式-核心概念"> Declarative Pipeline（声明式）核心概念</h3>
<p>核心概念用来组织pipeline的运行流程</p>
<blockquote>
<p>1.pipeline :声明其内容为一个声明式的pipeline脚本</p>
<p>2.agent:执行节点（job运行的slave或者master节点）</p>
<p>3.stages:阶段集合，包裹所有的阶段（例如：打包，部署等各个阶段）</p>
<p>4.stage:阶段，被stages包裹，一个stages可以有多个stage</p>
<p>5.steps:步骤,为每个阶段的最小执行单元,被stage包裹</p>
<p>6.post:执行构建后的操作，根据构建结果来执行对应的操作</p>
</blockquote>
<p>根据上面几个概念就能够轻易的创建一个简单的pipeline</p>
<div><pre><code>pipeline<span>{</span>
    agent any
    stages<span>{</span>
        stage<span>(</span><span>"first stage"</span><span>)</span><span>{</span>
            steps<span>(</span><span>"first steps"</span><span>)</span><span>{</span>
                <span>echo</span> <span>"this is first step"</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    post<span>{</span>
        always<span>{</span>
            <span>echo</span> <span>"this is ending..."</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>下面针对几个核心概念，逐一进行说明</p>
<h4 id="_1-pipeline"> 1.pipeline</h4>
<blockquote>
<p>作用域：应用于全局最外层，表明该脚本为声明式pipeline
是否必须：必须
参数：无</p>
</blockquote>
<h4 id="_2-agent"> 2.agent</h4>
<blockquote>
<p>作用域：可用在全局与stage内
是否必须：是，
参数：any,none, label, node,docker,dockerfile</p>
</blockquote>
<div><pre><code>pipeline<span>{</span>
    agent any  <span>//全局必须带有agent表明此pipeline执行节点</span>
    stages<span>{</span>
        <span>stage</span><span>(</span><span>"first stage"</span><span>)</span><span>{</span>
            agent <span>{</span> label <span>'master'</span> <span>}</span>  <span>//具体执行的步骤节点，非必须</span>
            steps<span>{</span>
                <span>echo</span> <span>"this is first step"</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>参数示例：</p>
<div><pre><code><span>//运行在任意的可用节点上</span>
agent <span>any</span>
<span>//全局不指定运行节点，由各自stage来决定</span>
agent none
<span>//运行在指定标签的机器上,具体标签名称由agent配置决定</span>
agent <span>{</span> label <span>'master'</span> <span>}</span>
<span>//node参数可以扩展节点信息</span>
agent <span>{</span> 
     node <span>{</span>
         label <span>'master'</span>
         customWorkspace <span>'xxx'</span>
    <span>}</span> 
<span>}</span>
<span>//使用指定运行的容器</span>
agent <span>{</span> docker <span>'python'</span>  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="_3-stages"> 3.stages</h4>
<blockquote>
<p>作用域：全局或者stage阶段内，每个作用域内只能使用一次</p>
<p>是否必须：全局必须</p>
<p>参数：无</p>
</blockquote>
<div><pre><code>pipeline<span>{</span>
    agent any
    stages<span>{</span>
        <span>stage</span><span>(</span><span>"first stage"</span><span>)</span><span>{</span>
            stages<span>{</span>  <span>//嵌套在stage里</span>
                <span>stage</span><span>(</span><span>"inside"</span><span>)</span><span>{</span>
                    steps<span>{</span>
                        <span>echo</span> <span>"inside"</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>stage</span><span>(</span><span>"stage2"</span><span>)</span><span>{</span>
            steps<span>{</span>
                <span>echo</span> <span>"outside"</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>看下运行结果,发现嵌套的stage也是能够展现在视图里面的</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/2399048-1c06fd744811b10b.webp" alt="img" /></p>
<h4 id="_4-stage"> 4.stage</h4>
<blockquote>
<p>作用域：被stages包裹，作用在自己的stage包裹范围内</p>
<p>是否必须：必须</p>
<p>参数：需要一个string参数，表示此阶段的工作内容</p>
<p>备注：stage内部可以嵌套stages，内部可单独制定运行的agent</p>
</blockquote>
<h4 id="_5-steps"> 5.steps</h4>
<p>作用域：被stage包裹，作用在stage内部
是否必须：必须
参数：无</p>
<h4 id="_6-post"> 6.post</h4>
<p>作用域：作用在pipeline结束后者stage结束后
条件：always、changed、failure、success、unstable、aborted</p>
<h3 id="declarative-pipeline-声明式-指令"> Declarative Pipeline（声明式）指令</h3>
<p>指令是帮助pipeline更容易的执行命令，可以理解为一个封装好的公共函数和方法，提供给pipeline使用</p>
<h4 id="_1-environment-声明一个全局变量或者步骤内部的局部变量"> 1.environment：声明一个全局变量或者步骤内部的局部变量</h4>
<div><pre><code>pipeline<span>{</span>
    agent any
    environment <span>{</span>
        <span>P1</span><span>=</span><span>"parameters 1"</span>
    <span>}</span>
    stages<span>{</span>
        stage<span>(</span><span>"stage2"</span><span>)</span><span>{</span>
            environment <span>{</span>
                <span>P2</span><span>=</span><span>"parameters 2"</span>
            <span>}</span>
            steps<span>{</span>
                <span>echo</span> <span>"<span>$P1</span>"</span>
                <span>echo</span> <span>"<span>$P2</span>"</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id="_2-options-options指令能够提供给脚本更多的选项"> 2.options:options指令能够提供给脚本更多的选项</h4>
<ul>
<li>buildDiscarder:指定build history与console的保存数量
用法：options { buildDiscarder(logRotator(numToKeepStr: '1')) }</li>
<li>disableConcurrentBuilds：设置job不能够同时运行
用法：options { disableConcurrentBuilds() }</li>
<li>skipDefaultCheckout：跳过默认设置的代码check out
用法：options { skipDefaultCheckout() }</li>
<li>skipStagesAfterUnstable:一旦构建状态变得UNSTABLE，跳过该阶段
用法：options { skipStagesAfterUnstable() }</li>
<li>checkoutToSubdirectory:在工作空间的子目录进行check out
用法：options { checkoutToSubdirectory('children_path') }</li>
<li>timeout:设置jenkins运行的超时时间，超过超时时间，job会自动被终止
用法：options { timeout(time: 1, unit: 'MINUTES') }</li>
<li>retry :设置retry作用域范围的重试次数
用法：options { retry(3) }</li>
<li>timestamps:为控制台输出增加时间戳
用法：options { timestamps() }</li>
</ul>
<p>备注：当options作用在stage内部的时候，可选的只能是跟stage相关的选项（skipDefaultCheckout、timeout、retry、timestamps)</p>
<p>以其中几个作为例子</p>
<div><pre><code>pipeline<span>{</span>
    agent any
    options <span>{</span>
       timestamps<span>(</span><span>)</span> 
       disableConcurrentBuilds<span>(</span><span>)</span>
        
    <span>}</span>
    stages<span>{</span>
        
        stage<span>(</span><span>"stage1"</span><span>)</span><span>{</span>
            options <span>{</span> timeout<span>(</span>time:1,unit:<span>'MINUTES'</span><span>)</span> 
                        retry<span>(</span><span>2</span><span>)</span>
            <span>}</span>
            steps<span>{</span>
                <span>echo</span> <span>"beging===================="</span>
                <span>sh</span> <span>"xxx.sh"</span>
            <span>}</span>
        <span>}</span>   
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h4 id="_3-parameters-提供pipeline运行的参数"> 3.parameters：提供pipeline运行的参数</h4>
<ul>
<li>作用域：被最外层pipeline所包裹，并且只能出现一次，参数可被全局使用</li>
<li>好处：使用parameters好处是能够使参数也变成code,达到pipeline as code，pipeline中设置的参数会自动在job构建的时候生成，形成参数化构建</li>
<li>用法：</li>
</ul>
<div><pre><code>pipeline<span>{</span>
    agent any
    parameters <span>{</span>
        string<span>(</span>name: <span>'P1'</span>, defaultValue: <span>'it is p1'</span>, description: <span>'it is p1'</span><span>)</span>
        booleanParam<span>(</span>name: <span>'P2'</span>, defaultValue: true, description: <span>'it is p2'</span><span>)</span>
    <span>}</span>
    stages<span>{</span>
        stage<span>(</span><span>"stage1"</span><span>)</span><span>{</span>
            steps<span>{</span>
                <span>echo</span> <span>"<span>$P1</span>"</span>
                <span>echo</span> <span>"<span>$P2</span>"</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>自动生成的构建参数</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/2399048-cdd0be1f6dcfea2e.webp" alt="img" /></p>
<h4 id="_4-triggers-触发器是自动化运行pipeline的方法"> 4.triggers:触发器是自动化运行pipeline的方法</h4>
<ul>
<li>作用域：被pipeline包裹，在符合条件下自动触发pipeline</li>
</ul>
<p>目前包含三种自动触发的方式：
第一种：cron</p>
<ul>
<li>作用：以指定的时间来运行pipeline</li>
<li>用法：triggers { cron('*/1 * * * *') }</li>
</ul>
<p>第二种：pollSCM</p>
<ul>
<li>作用：以固定的时间检查代码仓库更新（或者当代码仓库有更新时）自动触发pipeline构建</li>
<li>用法：triggers { pollSCM('H */4 * * 1-5') }或者triggers { pollSCM() }（后者需要配置post-commit/post-receive钩子）</li>
</ul>
<p>第三种：upstream</p>
<ul>
<li>作用：可以利用上游Job的运行状态来进行触发</li>
<li>用法：triggers { upstream(upstreamProjects: 'job1,job2', threshold: hudson.model.Result.SUCCESS) }</li>
</ul>
<div><pre><code>pipeline<span>{</span>
    agent any
    <span>//说明：当test_8或者test_7运行成功的时候，自动触发</span>
    triggers <span>{</span> <span>upstream</span><span>(</span><span>upstreamProjects</span><span>:</span> <span>'test_8,test_7'</span><span>,</span> <span>threshold</span><span>:</span> hudson<span>.</span>model<span>.</span>Result<span>.</span><span>SUCCESS</span><span>)</span> <span>}</span>
    stages<span>{</span>
        <span>stage</span><span>(</span><span>"stage1"</span><span>)</span><span>{</span>
            steps<span>{</span>
                <span>echo</span> <span>"hello"</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h4 id="_5-tools-用于引用配置好的工具"> 5.tools:用于引用配置好的工具</h4>
<p>引用的工具需要在管理页面的全局工具配置里配置过</p>
<div><pre><code>pipeline <span>{</span>
    agent <span>any</span>
    tools <span>{</span>
        maven <span>'apache-maven-3.0.1'</span> 
    <span>}</span>
    stages <span>{</span>
        <span>stage</span><span>(</span><span>'Example'</span><span>)</span> <span>{</span>
            steps <span>{</span>
                sh <span>'mvn --version'</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="_6-input-input指令允许暂时中断pipeline执行-等待用户输入-根据用户输入进行下一步动作"> 6.input:input指令允许暂时中断pipeline执行，等待用户输入，根据用户输入进行下一步动作</h4>
<div><pre><code>pipeline <span>{</span>
    agent any
    stages <span>{</span>
        stage<span>(</span><span>'Example'</span><span>)</span> <span>{</span>
            input <span>{</span>
                message <span>"Should we continue?"</span>
                ok <span>"Yes, we should."</span>
                submitter <span>"alice,bob"</span>
                parameters <span>{</span>
                    string<span>(</span>name: <span>'PERSON'</span>, defaultValue: <span>'Mr Jenkins'</span>, description: <span>'Who should I say hello to?'</span><span>)</span>
                <span>}</span>
            <span>}</span>
            steps <span>{</span>
                <span>echo</span> <span>"Hello, <span>${PERSON}</span>, nice to meet you."</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>看下效果</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/2399048-767303542aa7a1ee.webp" alt="img" /></p>
<h4 id="_7-when-根据when指令的判断结果来决定是否执行后面的阶段"> 7.when：根据when指令的判断结果来决定是否执行后面的阶段</h4>
<p>可选条件</p>
<ul>
<li>branch ：判断分支名称是否符合预期
用法：when { branch 'master' }</li>
<li>environment ： 判断环境变量是否符合预期
用法：when { environment name: 'DEPLOY_TO', value: 'production' }</li>
<li>expression：判断表达式是否符合预期
用法：when { expression { return params.DEBUG_BUILD } }</li>
<li>not : 判断条件是否为假
用法：when { not { branch 'master' } }</li>
<li>allOf：判断所有条件是不是都为真
用法：when { allOf { branch 'master'; environment name: 'DEPLOY_TO', value: 'production' } }</li>
<li>anyOf：判断是否有一个条件为真
用法：when { anyOf { branch 'master'; branch 'staging' } }</li>
</ul>
<p>特别的：如果我们想要在进入agent之前进行判断，需要将beforeAgent设置为true</p>
<div><pre><code>pipeline <span>{</span>
    agent none
    stages <span>{</span>
        <span>stage</span><span>(</span><span>'Example Build'</span><span>)</span> <span>{</span>
            steps <span>{</span>
                <span>echo</span> <span>'Hello World'</span>
            <span>}</span>
        <span>}</span>
        <span>stage</span><span>(</span><span>'Example Deploy'</span><span>)</span> <span>{</span>
            agent <span>{</span>
                label <span>"some-label"</span>
            <span>}</span>
            when <span>{</span>
                beforeAgent <span>true</span> <span>//设置先对条件进行判断，符合预期才进入steps</span>
                branch <span>'production'</span>
            <span>}</span>
            steps <span>{</span>
                <span>echo</span> <span>'Deploying'</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="并行执行"> 并行执行</h3>
<p>通过将阶段设置为parallel来表明该stage为并行运行，但是需要注意以下几点</p>
<ul>
<li>一个stage只能有一个steps或者parallel</li>
<li>嵌套的stages里不能使用parallel</li>
<li>parallel不能包含agent或者tools</li>
<li>通过设置failFast 为true表示：并行的job中如果其中的一个失败，则终止其他并行的stage</li>
</ul>
<div><pre><code>pipeline <span>{</span>
    agent any
    stages <span>{</span>
        stage<span>(</span><span>'Non-Parallel Stage'</span><span>)</span> <span>{</span>
            steps <span>{</span>
                <span>echo</span> <span>'Non-parallel'</span>
            <span>}</span>
        <span>}</span>
        stage<span>(</span><span>'Parallel Stage'</span><span>)</span> <span>{</span>
            agent any
            failFast <span>true</span>
            parallel <span>{</span>
                stage<span>(</span><span>'parallel 1'</span><span>)</span> <span>{</span>
                    agent any
                    steps <span>{</span>
                        <span>echo</span> <span>"parallel 1"</span>
                    <span>}</span>
                <span>}</span>
                stage<span>(</span><span>'parallel 2'</span><span>)</span> <span>{</span>
                    steps <span>{</span>
                        <span>echo</span> <span>"parallel 2"</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="脚本"> 脚本</h3>
<blockquote>
<p>在声明式的pipeline中默认无法使用脚本语法，但是pipeline提供了一个脚本环境入口：script{},通过使用script来包裹脚本语句，即可使用脚本语法</p>
</blockquote>
<ul>
<li>条件判断：</li>
</ul>
<div><pre><code>pipeline <span>{</span>
    agent any
    stages <span>{</span>
        stage<span>(</span><span>'stage 1'</span><span>)</span> <span>{</span>
            steps <span>{</span>
                script<span>{</span>
                    <span>if</span> <span>(</span> <span>"1"</span> <span>==</span><span>"1"</span> <span>)</span> <span>{</span>
                        <span>echo</span> <span>"lalala"</span>
                    <span>}</span>else <span>{</span>
                        <span>echo</span> <span>"oooo"</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ul>
<li>异常处理</li>
</ul>
<div><pre><code>pipeline <span>{</span>
    agent any
    stages <span>{</span>
        <span>stage</span><span>(</span><span>'stage 1'</span><span>)</span> <span>{</span>
            steps <span>{</span>
                script<span>{</span>
                    <span>try</span> <span>{</span>
                        sh <span>'exit 1'</span>
                    <span>}</span>
                    <span>catch</span> <span>(</span><span>exc</span><span>)</span> <span>{</span>
                        <span>echo</span> <span>'Something failed'</span>
                        
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="局部变量的定义和传递"> 局部变量的定义和传递</h3>
<p>自定义变量（局部）</p>
<div><pre><code>def username = &#39;Jenkins&#39;
echo &quot;Hello Mr.${username}&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>环境变量（局部）</p>
<div><pre><code>withEnv([&#39;MYTOOL_HOME=/usr/local/mytool&#39;]){
    sh &#39;$MYTOOL_HOME/bin/start&#39;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="exit-code-stdout-and-stderr-返回值和输出"> exit code, stdout and stderr 返回值和输出</h3>
<p>其做法是，把stdout定向到一个文件，sh 配置 returnStatus: true，它的返回是一个0或非0的整数，然后从文件读取stdout的内容。stderr同理可得。</p>
<div><pre><code>def status = sh(returnStatus: true, script: &quot;git merge --no-edit $branches &gt; merge_output.txt&quot;)
if (status != 0) {
  currentBuild.result = &#39;FAILED&#39;
  def output = readFile(&#39;merge_output.txt&#39;).trim()
  slackSend channel: SLACK_CHANNEL, message: &quot;&lt;${env.JOB_URL}|${env.JOB_NAME}&gt; ran into an error merging the PR branches into the ${TARGET_BRANCH} branch:\n```\n${output}\n```\n&lt;${env.BUILD_URL}/console|See the full output&gt;&quot;, color: &#39;warning&#39;, tokenCredentialId: &#39;slack-token&#39;
  error &#39;Merge conflict&#39;
}
sh &#39;rm merge_output.txt&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="三、前端项目实例"> 三、前端项目实例</h2>
<p>vue</p>
<div><pre><code>pipeline {
    agent { label &#39;master&#39;}

    options {
        timestamps()
        disableConcurrentBuilds()
        buildDiscarder(
            logRotator(
                numToKeepStr: &#39;20&#39;,
                daysToKeepStr: &#39;30&#39;,
            )
        )
    }

    parameters {
        choice(
           name: &quot;DEPLOY_FLAG&quot;,
           choices: [&#39;deploy&#39;, &#39;rollback&#39;],
           description: &quot;发布/回滚&quot;
        )
    }

    /*=======================================常修改变量-start=======================================*/

    environment {
        gitUrl = &quot;http://gitlab.schengle.com/driving-frontend/h5.git&quot;
        branchName = &quot;master&quot;
        gitlabCredentialsId = &quot;437c69b5-a874-4da6-8fe1-61e0275fdf0d&quot;
        projectBuildDir = &quot;build&quot;
        projectBuildPath = &quot;${env.WORKSPACE}/${projectBuildDir}/&quot;
        nginxIp = &quot;192.168.16.141&quot;
        nginxHtmlRoot = &quot;/tmp/${env.JOB_NAME}&quot;
        owner = &quot;font&quot;
        group = &quot;font&quot;
        backupRootDir = &quot;/opt/backup&quot;
        backupJob = &quot;${backupRootDir}/${env.JOB_NAME}&quot;
        backupDir = &quot;${backupJob}/${env.BUILD_NUMBER}&quot;
        rollbackVersion = &quot;&quot;
    }

    /*=======================================常修改变量-end=======================================*/

    stages {
        stage(&#39;Deploy&#39;) {
            when {
                expression { return params.DEPLOY_FLAG == &#39;deploy&#39; }
            }
            stages {
                stage(&#39;Pre Env&#39;) {
                    steps {
                        echo &quot;======================================项目名称 = ${env.JOB_NAME}&quot;
                        echo &quot;======================================项目 URL = ${gitUrl}&quot;
                        echo &quot;======================================项目分支 = ${branchName}&quot;
                        echo &quot;======================================当前编译版本号 = ${env.BUILD_NUMBER}&quot;
                        echo &quot;======================================项目 Build 文件夹路径 = ${projectBuildPath}&quot;
                        echo &quot;======================================项目 Nginx 的 ROOT 路径 = ${nginxHtmlRoot}&quot;
                    }
                }

                stage(&#39;Git Clone&#39;) {
                    steps {
                        git branch: &quot;${branchName}&quot;,
                        credentialsId: &quot;${gitlabCredentialsId}&quot;,
                        url: &quot;${gitUrl}&quot;
                    } 
                }

                stage(&#39;NPM Install&#39;) {
                    steps {
                        nodejs(&#39;nodejs&#39;) {
                            sh &quot;npm install&quot;
                        }
                    }
                }

                stage(&#39;NPM Build&#39;) {
                    steps {
                        nodejs(&#39;nodejs&#39;) {
                            sh &quot;npm run build&quot;
                        }
                    }
                }

                stage(&#39;Backup&#39;) {
                    agent { label &#39;ansible&#39;}
                    steps {
                        script {
                            try {
                                isItBackupToday = sh (returnStatus: true, script:&#39;ansible ${nginxIp} -m shell -a &quot;ls -l --time-style=+%D ${backupJob} | grep $(date +%D)&quot;&#39;)
                                if (isItBackupToday !=0){
                                    try {
                                        sh &#39;ansible ${nginxIp} -m file -a &quot;path=${backupDir} state=directory owner=${owner} group=${group}&quot;&#39;
                                        sh &#39;ansible ${nginxIp} -m shell -a &quot;cp -a ${nginxHtmlRoot}/* ${backupDir}&quot;&#39;
                                    }
                                    catch (exc) {
                                        echo &#39;Something failed!&#39;
                                    }  
                                }
                            }
                            catch (exc) {
                                echo &#39;Something failed!&#39;
                            }                             
                        }
                    }
                }

                stage(&#39;Nginx Deploy&#39;) {
                    agent { label &#39;ansible&#39;}
                    steps {
                        sh &#39;ansible ${nginxIp} -m synchronize -a &quot;src=${projectBuildPath} dest=${nginxHtmlRoot} delete=yes&quot;&#39;
                        sh &#39;ansible ${nginxIp} -m file -a &quot;path=${nginxHtmlRoot} owner=${owner} group=${group} recurse=yes&quot;&#39;
                    }
                }

                stage(&#39;Tar Build&#39;) {
                    steps {
                        sh &quot;tar -zcf  ${env.JOB_NAME}.tar.gz ${projectBuildDir}&quot;
                    }
                }

                stage(&#39;Archive Artifacts&#39;) {
                    steps {
                        archiveArtifacts &quot;${env.JOB_NAME}.tar.gz&quot;
                    }
                }
            }
        }

        stage(&#39;Rollback&#39;) {
            when {
                expression { return params.DEPLOY_FLAG == &#39;rollback&#39; }
            }
            agent { label &#39;ansible&#39;}
            steps{
                script {
                    sh &#39;ansible ${nginxIp} -m shell -a &quot;ls -l  ${backupJob}&quot; | grep -v &quot;CHANGED&quot;&#39;
                    rollbackVersion = input(
                        message: &quot;请填写要回滚的版本&quot;,
                        parameters: [
                            string(name:&#39;BUILD_NUMBER&#39;)
                        ]
                    )
                    sh &#39;ansible ${nginxIp} -m file -a &quot;path=${nginxHtmlRoot} state=absent&quot;&#39;
                    sh &#39;ansible ${nginxIp} -m file -a &quot;path=${nginxHtmlRoot} state=directory owner=${owner} group=${group}&quot;&#39;                    
                    withEnv([&quot;rollbackVersion=${rollbackVersion}&quot;]){
                        sh &#39;ansible ${nginxIp} -m shell -a &quot;cp -a  ${backupJob}/${rollbackVersion}/* ${nginxHtmlRoot}&quot;&#39;
                    }
                }
            }
        }
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br></div></div><p>这个jenkinsfile中有保存   制品，</p>
<p>需要注意的是：制品的保存时间，和jenkins丢弃旧的构建参数，相同</p>
<blockquote>
<p>参考链接
https://www.jianshu.com/p/f1167e8850cd</p>
<p>https://blog.csdn.net/triThirty/article/details/91381502</p>
<p>https://www.cnblogs.com/pekkle/p/9882927.html</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-01-16T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">jenkins 常见问题</title>
    <id>https://clay-wangzhi.com/automate/jenkins/qa/</id>
    <link href="https://clay-wangzhi.com/automate/jenkins/qa/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jenkins-常见问题"> jenkins 常见问题</h1>
<h2 id="jenkins报错error-cloning-remote-repo-origin"> Jenkins报错Error cloning remote repo 'origin'</h2>
<p>Jenkins配置了2个节点，但是只有master安装了git，很有可能任务被调到slave上执行所以报错</p>
<p>解决办法</p>
<ul>
<li>slave安装git</li>
<li>指定任务在master执行</li>
</ul>
<h2 id="jenkins添加从节点失败"> jenkins添加从节点失败</h2>
<p>jenkins在添加从节点时
可以在启动方式中选择：Non verifying Verification Strategy</p>
<h2 id="jenkins配置ldap错误导致无法登陆的问题"> Jenkins配置ldap错误导致无法登陆的问题</h2>
<p>为了方便用户管理，通过ldap集中式认证，让Gitlab和Jenkins都接入，这样就省去每个系统都是要创建用户的麻烦了。上一篇<a href="https://www.58jb.com/html/121.html" target="_blank" rel="noopener noreferrer">Jenkins整合ldap认证</a>的文章中有网友发邮件说了，配置不当导致Jenkins无法登陆，可能文章未能详细说明。</p>
<p>运维人员都会有这样的操作，修改任何配置文件前都会来一个备份。就是确保万一出错了可以回到之前的状态。所以建议就是Jenkins配置的问题，特别是这个登陆认证的配置，一搞错了就无法登陆。甚至无法正常访问到系统。
默认Centos7使用rpm安装的目录为：/var/lib/jenkins/</p>
<p>备份配置文件：config.xml</p>
<div><pre><code>[root@jenkins ~]# cp /var/lib/jenkins/config.xml{,$(date +%F)}
[root@jenkins ~]# ls /var/lib/jenkins/config.xml
config.xml            config.xml2019-06-12
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后在config.xml配置文件中找到这段关于ldap认证的信息：</p>
<div><pre><code>  &lt;securityRealm class=&quot;hudson.security.LDAPSecurityRealm&quot; plugin=&quot;ldap@1.20&quot;&gt;
    &lt;disableMailAddre***esolver&gt;false&lt;/disableMailAddre***esolver&gt;
    &lt;configurations&gt;
      &lt;jenkins.security.plugins.ldap.LDAPConfiguration&gt;
        &lt;server&gt;ldap://XXXXXX.com:389&lt;/server&gt;
        &lt;rootDN&gt;dc=XXXXXX,dc=com&lt;/rootDN&gt;
        &lt;inhibitInferRootDN&gt;false&lt;/inhibitInferRootDN&gt;
        &lt;userSearchBase&gt;&lt;/userSearchBase&gt;
        &lt;userSearch&gt;uid={0}&lt;/userSearch&gt;
        &lt;groupMembershipStrategy class=&quot;jenkins.security.plugins.ldap.FromGroupSearchLDAPGroupMembershipStrategy&quot;&gt;
          &lt;filter&gt;cn=jenkins&lt;/filter&gt;
        &lt;/groupMembershipStrategy&gt;
        &lt;managerDN&gt;uid=jarry,ou=People,dc=XXXXXX,dc=com&lt;/managerDN&gt;
        &lt;managerPasswordSecret&gt;{AQAAABAAAAAQWfZrb7qoIjewuj3SK/z53/oRo86cW5wi/t07QeW/4mM=}&lt;/managerPasswordSecret&gt;
        &lt;displayNameAttributeName&gt;uid&lt;/displayNameAttributeName&gt;
        &lt;mailAddressAttributeName&gt;mail&lt;/mailAddressAttributeName&gt;
        &lt;ignoreIfUnavailable&gt;false&lt;/ignoreIfUnavailable&gt;
        &lt;extraEnvVars class=&quot;linked-hash-map&quot;&gt;
          &lt;entry&gt;
            &lt;string&gt;&lt;/string&gt;
            &lt;string&gt;&lt;/string&gt;
          &lt;/entry&gt;
        &lt;/extraEnvVars&gt;
      &lt;/jenkins.security.plugins.ldap.LDAPConfiguration&gt;
    &lt;/configurations&gt;
    &lt;userIdStrategy class=&quot;jenkins.model.IdStrategy$CaseInsensitive&quot;/&gt;
    &lt;groupIdStrategy class=&quot;jenkins.model.IdStrategy$CaseInsensitive&quot;/&gt;
    &lt;disableRolePrefixing&gt;true&lt;/disableRolePrefixing&gt;
  &lt;/securityRealm&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>上面的配置不当导致了无法通过ldap认证，而且导致jenkins也无法正常登陆了，可以把上面一段修改成以下样子：</p>
<div><pre><code>   &lt;securityRealm class=&quot;hudson.security.HudsonPrivateSecurityRealm&quot;&gt;
     &lt;disableSignup&gt;false&lt;/disableSignup&gt;
     &lt;enableCaptcha&gt;false&lt;/enableCaptcha&gt;
   &lt;/securityRealm&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>文章来源：https://www.58jb.com/html/jenkins_ldap_login_failure.html</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-01-16T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">jenkins的安装配置</title>
    <id>https://clay-wangzhi.com/automate/jenkins/</id>
    <link href="https://clay-wangzhi.com/automate/jenkins/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jenkins的安装配置"> jenkins的安装配置</h1>
<blockquote>
<p>经实验：ansible 2.7.10版本可以安装 jenkins 2.210版本</p>
<p>安装更高版本，请一并升级ansible，低版本ansible在安装插件时会报如下错误：</p>
<blockquote>
<p>{&quot;attempts&quot;: 5, &quot;changed&quot;: false, &quot;details&quot;: &quot;HTTP Error 403: Forbidden&quot;, &quot;item&quot;: &quot;ansible&quot;, &quot;msg&quot;: &quot;Cannot install plugin.&quot;}</p>
</blockquote>
</blockquote>
<h2 id="ansible安装jenkins"> ansible安装jenkins</h2>
<div><pre><code>ansible-galaxy <span>install</span> clay_wangzhi.jenkins
</code></pre>
<div><span>1</span><br></div></div><p>galaxy中有详细的文档说明：</p>
<blockquote>
<p>链接地址：https://galaxy.ansible.com/clay_wangzhi/jenkins</p>
</blockquote>
<p>额外注意一些插件的安装：</p>
<div><pre><code>Role-based Authorization Strategy  #权限控制插件
git-parameter
Publish Over SSH
DIngDIng
git-parameter #选项参数增加，git-brach选项
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="配置管理工具"> 配置管理工具</h2>
<p>安装完成后，配置管理工具</p>
<h3 id="安装并配置git"> 安装并配置git</h3>
<div><pre><code>yum -y <span>install</span> <span>git</span>
</code></pre>
<div><span>1</span><br></div></div><p>编辑git环境变量为/usr/bin/git</p>
<h3 id="安装并配置maven"> 安装并配置maven</h3>
<div><pre><code><span>wget</span> https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz
<span>tar</span> -xvf apache-maven-3.6.3-bin.tar.gz
<span>mv</span> apache-maven-3.6.3 /usr/local/maven
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>vim /etc/profile.d/maven.sh</code></p>
<div><pre><code><span>#!/bin/bash</span>
<span>export</span> <span>M2_HOME</span><span>=</span>/usr/local/maven
<span>export</span> <span><span>PATH</span></span><span>=</span><span>$PATH</span><span>:</span><span>$M2_HOME</span>/bin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code>source /etc/profile.d/maven.sh
mvn --version
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>编辑maven的环境变量为/usr/local/maven</p>
<h3 id="安装并配置ansible"> 安装并配置ansible</h3>
<div><pre><code>yum -y <span>install</span> ansible
</code></pre>
<div><span>1</span><br></div></div><p>编辑ansible的环境变量为/usr/bin</p>
<h2 id="jenkins集成openldap"> jenkins集成openldap</h2>
<p>参考图片</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/jen_ld.png" alt="jen_ld" /></p>
<blockquote>
<p>集成ldap参考链接：https://www.cnblogs.com/mascot1/p/10498513.html</p>
</blockquote>
<h2 id="三种构建方式"> 三种构建方式</h2>
<ul>
<li>
<p>jenkins触发式构建：用于开发环境部署，开发人员push代码或者合并代码到gitlab项目的master分支，jenkins就部署代码到对应服务器。</p>
</li>
<li>
<p>jenkins参数化构建：用于测试环境预上线环境部署，开发push代码或者合并代码到gitlab项目的master分支之后，并不会部署代码，而是需要登录到jenkins的web界面，点击构建按钮，传入对应的参数（比如参数需要构建的tag，需要部署的分支）然后才会部署。</p>
</li>
<li>
<p>jenkins定时构建：用于APP自动打包，定时构建是在参数化构建的基础上添加的，开发人员可以登录jenkins手动传入tag进行打包，如果不手动打包，那么jenkins就每天凌晨从gitlab拉取最新的APP代码打包。</p>
</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-01-16T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Jenkins关闭和重启的实现方式</title>
    <id>https://clay-wangzhi.com/automate/jenkins/restart/</id>
    <link href="https://clay-wangzhi.com/automate/jenkins/restart/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jenkins关闭和重启的实现方式"> Jenkins关闭和重启的实现方式</h1>
<h2 id="关闭jenkins"> 关闭jenkins</h2>
<p>只需要在访问jenkins服务器的网址url地址后加上exit。例如我jenkins的地址http://localhost:8080/，那么我只需要在浏览器地址栏上敲下<strong>http://localhost:8080/exit</strong> 网址就能关闭jenkins服务.</p>
<h2 id="重启jenkins"> 重启Jenkins</h2>
<p><strong>http://localhost:8080/restart</strong></p>
<h2 id="重新加载配置信息"> 重新加载配置信息</h2>
<p><strong>http://localhost:8080/reload</strong></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-01-16T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">activemq5.15.9集群搭建步骤</title>
    <id>https://clay-wangzhi.com/build/activemq-install/</id>
    <link href="https://clay-wangzhi.com/build/activemq-install/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="activemq5-15-9集群搭建步骤"> activemq5.15.9集群搭建步骤</h1>
<h3 id="下载解压软件"> 下载解压软件</h3>
<div><pre><code>cd /opt
wget https://www-eu.apache.org/dist/activemq/5.15.9/apache-activemq-5.15.9-bin.tar.gz
tar -xvf apache-activemq-5.15.9-bin.tar.gz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="修改主机名"> 修改主机名</h3>
<p>三台主机三分别操作</p>
<div><pre><code>hostnamectl set-hostname activemq01.csp
hostnamectl set-hostname activemq02.csp
hostnamectl set-hostname activemq03.csp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>注意主机名的设置，不能带下划线，否则会报错</p>
</blockquote>
<h3 id="修改配置文件"> 修改配置文件</h3>
<div><pre><code>cd /opt/apache-activemq-5.15.9/conf/
vim activemq.xml 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>修改以下文件</p>
<div><pre><code>brokerName=&quot;activemqCluster&quot;
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>brokaerName三台主机名称必须一致</p>
</blockquote>
<div><pre><code>        &lt;persistenceAdapter&gt;
            &lt;!--&lt;kahaDB directory=&quot;${activemq.data}/kahadb&quot;/&gt;--&gt;
            &lt;replicatedLevelDB
            directory=&quot;${activemq.data}/leveldb&quot;
            replicas=&quot;3&quot;
            bind=&quot;tcp://0.0.0.0:62222&quot;
            zkAddress=&quot;192.168.165.29:2181,192.168.165.30:2181,192.168.165.31:2181&quot;
            hostname=&quot;192.168.165.33&quot;
            zkPath=&quot;/activemq/leveldb-stores&quot;
            sync=&quot;local_disk&quot;/&gt;
        &lt;/persistenceAdapter&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>注释掉<code>&lt;kahaDB directory=&quot;${activemq.data}/kahadb&quot;/&gt;</code>这一行</p>
<p>新增下面内容</p>
<p>directory=&quot;${activemq.data}/leveldb&quot; 集群方式</p>
<p>replicas=&quot;3&quot; 集群结点个数</p>
<p>bind activemq集群通信端口</p>
<p>zkAddress zookeeper集群地址</p>
<p>hostname 本机IP</p>
<p>zkPath activemq集群在zookeeper集群交互文件存储位置</p>
<p>sync：在消息被消费完成前，同步信息所存贮的策略。如果有多种策略用逗号隔开，ActiveMQ会选择较强的策略。而如果有local_mem, local_disk这两种策略的话，那么ActiveMQ则优先选择local_disk策略，存储在本地硬盘。</p>
<h3 id="开放防火墙端口"> 开放防火墙端口</h3>
<div><pre><code># cat /etc/sysconfig/iptables
*filter
:INPUT ACCEPT [0systemctl restart iptables.service:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 8161 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 61616 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 62222 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 10050 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT

# systemctl restart iptables.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="启动-停止"> 启动&amp;停止</h3>
<div><pre><code>/opt/apache-activemq-5.15.9/bin/activemq start
/opt/apache-activemq-5.15.9/bin/activemq stop
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="验证activemq集群高可用"> 验证ActiveMQ集群高可用</h3>
<p>要验证ActiveMQ集群的高可用，我们只需要关闭能访问http://ip:8161/admin/的ActiveMQ服务，然后访问其他两个。</p>
<p>如果其中有一个能访问，那就说明ActiveMQ+ZooKeeper集群高可用已经配置成功</p>
<p>当一个ActiveMQ节点挂掉，或者一个ZooKeeper节点挂掉，ActiveMQ服务依然正常运转。如果仅剩一个ActiveMQ节点，因为不能选举Master，ActiveMQ不能正常运转；同样的，如果ZooKeeper仅剩一个节点活动，不管ActiveMQ各节点是否存活，ActiveMQ也不能正常提供服务。
（ActiveMQ集群的高可用，依赖于ZooKeeper集群的高可用。）</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="常见服务的搭建"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Linux下配置jdk的环境变量</title>
    <id>https://clay-wangzhi.com/build/centos-jdk/</id>
    <link href="https://clay-wangzhi.com/build/centos-jdk/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux下配置jdk的环境变量"> Linux下配置jdk的环境变量</h1>
<p>Hello everyone, let's learn jdk together！</p>
<h3 id="yum安装"> yum安装</h3>
<p>yum 查询可以安装的软件</p>
<div><pre><code>yum list | grep jdk
</code></pre>
<div><span>1</span><br></div></div><p><img src="/images/jdk1.png" alt="" /></p>
<p>根据需求选择版本进行安装</p>
<div><pre><code>yum -y install java-1.8.0-openjdk* 
</code></pre>
<div><span>1</span><br></div></div><h3 id="rpm安装"> rpm安装</h3>
<p>jdk官网地址为：http://www.oracle.com</p>
<p>各个版本的下载地址为：http://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html   （网页会变，请自动百度，当前日期：2018-03-06）</p>
<p>根据需求下载rpm版本  （必须有oracle账号进行登录）</p>
<div><pre><code>wget http://download.oracle.com/otn/java/jdk/7u75-b13/jdk-7u75-linux-x64.rpm?AuthParam=1520474898_85357527f14068896db993a783a48e94
rpm -ivh jdk-7u75-linux-x64.rpm\?AuthParam\=1520474898_85357527f14068896db993a783a48e94 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="压缩包安装"> 压缩包安装</h3>
<p>我个人喜欢压缩包安装，灵活性较高</p>
<p>根据需求下载压缩包版本</p>
<div><pre><code>wget http://download.oracle.com/otn/java/jdk/7u76-b13/jdk-7u76-linux-x64.tar.gz?AuthParam=1520475252_b3af0149915380bf1a4a0a8d962893ca
mv jdk-7u76-linux-x64.tar.gz\?AuthParam\=1520475252_b3af0149915380bf1a4a0a8d962893ca jdk-7u76-linux-x64.tar.gz
tar -xvf jdk-7u76-linux-x64.tar.gz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>配置环境变量</p>
<div><pre><code># vim /etc/profile
export JAVA_HOME=/opt/jdk1.7.0_76
export JRE_HOME=/opt/jdk1.7.0_76/jre
export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib
export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
# source /etc/profile
# java -version
java version &quot;1.7.0_76&quot;
Java(TM) SE Runtime Environment (build 1.7.0_76-b13)
Java HotSpot(TM) 64-Bit Server VM (build 24.76-b04, mixed mode)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="常见服务的搭建"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">centos7下搭建shadowsocks</title>
    <id>https://clay-wangzhi.com/build/centos7-shadowsocks/</id>
    <link href="https://clay-wangzhi.com/build/centos7-shadowsocks/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="centos7下搭建shadowsocks"> centos7下搭建shadowsocks</h1>
<h3 id="安装pip"> 安装pip</h3>
<p>由于安装的是python 版本的 shadowsocks，所以首先安装pip</p>
<div><pre><code>$ curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot;
$ python get-pip.py
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="安装shadowsocks"> 安装shadowsocks</h3>
<div><pre><code>$ pip install --upgrade pip
$ pip install shadowsocks
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="创建配置文件"> 创建配置文件</h3>
<p>创建文件所在目录:/etc</p>
<div><pre><code>#创建文件命令,
$ vi /etc/shadowsocks.json
#若进入了etc目录
$ vi shadowsocks.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>配置文件内容：</p>
<div><pre><code>单端口：
 {
 &quot;server&quot;:&quot;0.0.0.0&quot;,            --服务器IP，直接用0.0.0.0也可
 &quot;server_port&quot;:8888,            --端口端口
 &quot;local_address&quot;: &quot;127.0.0.1&quot;,  --本地地址，可省略
 &quot;local_port&quot;:1080,             --本地端口，可省略
 &quot;password&quot;:&quot;password&quot;,         --密码
 &quot;timeout&quot;:300,                 --超时时间，可省略
 &quot;method&quot;:&quot;aes-256-cfb&quot;,        --加密策略，有多重策略，具体自查
}
多端口：
{
    &quot;server&quot;:&quot;0.0.0.0&quot;,
    &quot;local_address&quot;:&quot;127.0.0.1&quot;,
    &quot;local_port&quot;:1080,
    &quot;port_password&quot;:{           --每个端口对应一个密码
        &quot;1111&quot;:&quot;password1&quot;,
        &quot;1112&quot;:&quot;password2&quot;,
        &quot;1113&quot;:&quot;password3&quot;
    },
    &quot;timeout&quot;:300,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
    &quot;fast_open&quot;:false
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="启动shadowsocks"> 启动shadowsocks</h3>
<div><pre><code>#启动
ssserver -c /etc/shadowsocks.json -d start
#停止
ssserver -c /etc/shadowsocks.json -d stop
#重启
ssserver -c /etc/shadowsocks.json -d restart
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>启动成功即可通过ss客户端使用。
在window端可以在控制台通过以下命令查看端口是否打开</p>
<div><pre><code>telnet {ip} {potr}
</code></pre>
<div><span>1</span><br></div></div><h3 id="配置自启动"> 配置自启动</h3>
<p>新建启动脚本文件/etc/systemd/system/shadowsocks.service，内容如下：</p>
<div><pre><code>[Unit]
Description=Shadowsocks

[Service]
TimeoutStartSec=0
ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json

[Install]
WantedBy=multi-user.target
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>通过以下命令注册，启动服务</p>
<div><pre><code>$ systemctl enable shadowsocks
$ systemctl start shadowsocks
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>启动后可以查看服务状态</p>
<div><pre><code>$ systemctl status shadowsocks -l
</code></pre>
<div><span>1</span><br></div></div><p>若启动成功：</p>
<div><pre><code>● shadowsocks.service - Shadowsocks
   Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)
   Active: active (running) since Sun 2017-08-13 18:03:41 CST; 1h 29min ago
 Main PID: 9567 (ssserver)
   CGroup: /system.slice/shadowsocks.service
           └─9567 /usr/bin/python2 /usr/bin/ssserver -c /etc/shadowsocks.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="firewalld防火墙"> firewalld防火墙</h3>
<p>centos7用的firewalld，若不进行设置，可能会导致SS无法使用
这部分规则可以通过阿里云安全组添加，也可以直接通过代码添加，这里介绍直接添加规则方法</p>
<div><pre><code># 开放端口
$ firewall-cmd --permanent --add-port=18381-18385/tcp 
# 修改规则后需要重启
$ firewall-cmd --reload 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>转载链接：https://segmentfault.com/a/1190000010639190</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="常见服务的搭建"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">基于docker搭建confluence</title>
    <id>https://clay-wangzhi.com/build/docker-confluence/</id>
    <link href="https://clay-wangzhi.com/build/docker-confluence/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="基于docker搭建confluence"> 基于docker搭建confluence</h1>
<p>系统版本：centos7</p>
<h2 id="安装docker"> 安装docker</h2>
<ol>
<li>yum安装docker</li>
</ol>
<div><pre><code>yum update # 更新yum
yum install docker # yum安装docker
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="2">
<li>
<p>开启镜像加速</p>
<p>由于国内网络问题拉取 Docker 镜像会十分缓慢，所以可以添加网易镜像地址：http://hub-mirror.c.163.com 加速。</p>
<div><pre><code>vi /etc/docker/daemon.json
</code></pre>
<div><span>1</span><br></div></div><p>将其中的内容替换为如下，当然你可以添加其它镜像地址。</p>
<div><pre><code>{
  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>启动docker</p>
</li>
</ol>
<div><pre><code>docker --version # 查看docker版本
systemctl start docker # 启动docker
systemctl enable docker #设置开机自启
ps -ef | grep docker # 查看docker进程是否正常启动
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="安装数据库postgresql"> 安装数据库PostgreSQL</h2>
<ol>
<li>安装PostgreSQL</li>
</ol>
<div><pre><code>docker pull postgres # 下拉镜像
docker run --name postgresdb -p 5432:5432 -e POSTGRES_PASSWORD=W*** -d docker.io/postgres:latest
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>注意：</p>
<p>1）-p 5432:5432 选项是可选的，因为在后面启动Confluence容器的时候，postgresdb这个容器会以别名db连接到confluence容器，也就是说对confluence这个容器来说，可以通过db:5432的网络地址访问到postgresql服务，不需要在主机上开放5432端口。</p>
<p>2）W**** 是密码需要设置成你需要的密码。</p>
<ol start="2">
<li>进入docker容器并创建confluence数据库</li>
</ol>
<div><pre><code>docker exec -it postgresdb bash # 进入docker容器
psql -U postgres 
\l
CREATE DATABASE confluence WITH OWNER postgres; 
\q
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="安装wiki-confluence"> 安装wiki Confluence</h2>
<ol>
<li>安装wiki Confluence</li>
</ol>
<div><pre><code>docker pull cptactionhank/atlassian-confluence #下拉镜像
docker run -d --name confluence -p 10080:8090 --link postgresdb:db --user root:root docker.io/cptactionhank/atlassian-confluence:latest
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="2">
<li>检查confluence是否启动</li>
</ol>
<div><pre><code>docker ps # 列出运行的容器
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/docker_ps.png" alt="" /></p>
<p>可以看到 wiki confluence已经启动</p>
<ol start="3">
<li>访问http://IP:10080/ 就可以看到Confluence的配置页面</li>
</ol>
<h2 id="破解-wiki-confluence"> 破解 wiki Confluence</h2>
<ol>
<li>访问http://IP:10080/ 记录 Server ID</li>
<li>进入docker confluence 容器，查找decoder.jar文件</li>
</ol>
<div><pre><code>docker exec -it confluence /bin/bash # 进入docker容器 confluence
su - # 切换到root账户
find -name &quot;*decoder*&quot; # 查找名称中包括 decoder 的文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="3">
<li>将decoder.jar文件从容器中复制出来，其中 “confluence:” 是Wiki confluence容器名称，atlassian-extras-decoder-v2-3.4.1.jar 是安装版本wiki的decode文件</li>
</ol>
<div><pre><code>docker cp confluence:/opt/atlassian/confluence/confluence/WEB-INF/lib/atlassian-extras-decoder-v2-3.4.1.jar .
</code></pre>
<div><span>1</span><br></div></div><ol start="4">
<li>破解</li>
</ol>
<p>a) 下载 atlassian-extras-decoder-v2-3.4.1.jar 文件到windows上</p>
<p>b) 将文件名改为 “atlassian-extras-2.4.jar” 破解工具只识别这个文件名</p>
<p>c) 下载破解文件 <a href="https://raw.githubusercontent.com/clay-wangzhi/clay-wiki/master/utils/confluence5.1-crack.zip" target="_blank" rel="noopener noreferrer">https://raw.githubusercontent.com/clay-wangzhi/clay-wiki/master/utils/confluence5.1-crack.zip</a></p>
<p>d)解压并进入文件目录</p>
<p>e) 执行java -jar confluence_keygen.jar 运行破解文件</p>
<p>f）填入 name ，server id 处输入步骤1中得到的id，点击 “gen” 生成key</p>
<p>g）点击 patch，选择刚才改名为  “atlassian-extras-2.4.jar” 的jar包，显示 “jar success fully patched” 则破解成功</p>
<ul>
<li>注意：path前先删除atlassian-extras-2.4.bak文件否则path失败</li>
</ul>
<p>h）将 “atlassian-extras-2.4.jar” 文件名改回原来的 “atlassian-extras-decoder-v2-3.4.1.jar ”</p>
<p>i）复制key中的内容备用</p>
<p>j) 将”atlassian-extras-decoder-v2-3.4.1.jar “文件上传回服务器</p>
<ol start="5">
<li>将破解后的文件复制回 confluence 容器</li>
</ol>
<div><pre><code> docker cp atlassian-extras-decoder-v2-3.4.1.jar confluence:/opt/atlassian/confluence/confluence/WEB-INF/lib/atlassian-extras-decoder-v2-3.4.1.jar
</code></pre>
<div><span>1</span><br></div></div><ol start="6">
<li>重启confluence容器</li>
</ol>
<div><pre><code>docker restart confluence
</code></pre>
<div><span>1</span><br></div></div><ol start="7">
<li>再次访问页面,输入之前复制的key后点击下一步</li>
<li>点击 ”My own database“ 后点击 next</li>
<li>输入数据库连接信息，用户名密码是之前创建数据库中的用户名和密码</li>
</ol>
<p><img src="./images/confluence.png" alt="" /></p>
<ol start="10">
<li>
<p>单击“Empty Site”</p>
</li>
<li>
<p>点击 “Manage users and groups within Confluence”</p>
</li>
<li>
<p>填入管理员信息后点击 “next”</p>
</li>
<li>
<p>点击 ”start“</p>
</li>
</ol>
<h2 id="解决慢时长gc的问题"> 解决慢时长gc的问题</h2>
<p>默认java配置为1G内存使用一段时间后回经常gc造成卡顿，单击“系统信息”可以看到jvm使用情况</p>
<p>进入docker容器</p>
<div><pre><code>docker exec -it confluence /bin/bash # 进入docker容器 confluence
</code></pre>
<div><span>1</span><br></div></div><p>修改java配置</p>
<div><pre><code>vi /opt/atlassian/confluence/bin/catalina.sh
</code></pre>
<div><span>1</span><br></div></div><p>在 “cygwin=false” 上面添加如下内容，最大内存为2G</p>
<div><pre><code>JAVA_OPTS=&quot;-Xms256m -Xmx2048m -XX:PermSize=128m -XX:MaxPermSize=512m&quot;
或
CATALINA_OPTS=&quot;-Xms256m -Xmx2048m -XX:PermSize=128m -XX:MaxPermSize=512m&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>重启 wiki confluence</p>
<div><pre><code>docker stop confluence # 停止
docker start confluence # 启动
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>参考文档：https://www.cnblogs.com/rslai/p/8845777.html</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="常见服务的搭建"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">分布式FastDfs+nginx缓存高可用集群构建</title>
    <id>https://clay-wangzhi.com/build/fastdfs-install/</id>
    <link href="https://clay-wangzhi.com/build/fastdfs-install/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="分布式fastdfs-nginx缓存高可用集群构建"> 分布式FastDfs+nginx缓存高可用集群构建</h1>
<h3 id="介绍"> 介绍</h3>
<p>FastDFS：开源的高性能分布式文件系统；主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡</p>
<p>FastDFS：角色：跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)</p>
<ol>
<li>Tracker Server: 跟踪服务器，主要做调度工作，起到均衡的作用；负责管理所有的storage server和group，每个storage在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。多个Tracker之间是对等关系，不存在单点故障</li>
<li>Storage Server: 存储服务器，主要提供容量和备份服务；以 group 为单位，每个 group 内可以有多台 storage server（高可用），组内的storage server上的数据互为备份</li>
<li>Client:客户端，上传下载数据的服务器</li>
</ol>
<p><img src="./images/fastdfs1.png" alt="" /></p>
<p><strong>FastDfs+nginx缓存高可用集群环境流程示意图：</strong></p>
<p><img src="./images/fastdfs2.png" alt="" /></p>
<p>实验环境机器说明：</p>
<table>
<thead>
<tr>
<th>机器名称</th>
<th>IP地址</th>
<th>应用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tracker01.csp</td>
<td>192.168.165.36</td>
<td>FastDFS,libfastcommon,nginx,keepalived，ngx_cache_purge</td>
<td>CentOS Linux release 7.6.1810 (Core)</td>
</tr>
<tr>
<td>tracker02.csp</td>
<td>192.168.165.37</td>
<td>FastDFS,libfastcommon,nginx,keepalived，ngx_cache_purge</td>
<td>CentOS Linux release 7.6.1810 (Core)</td>
</tr>
<tr>
<td>storage01.csp</td>
<td>192.168.165.38</td>
<td>FastDFS,libfastcommon,nginx,fastdfs-nginx-module</td>
<td>CentOS Linux release 7.6.1810 (Core)</td>
</tr>
<tr>
<td>storage02.csp</td>
<td>192.168.165.39</td>
<td>FastDFS,libfastcommon,nginx,fastdfs-nginx-module</td>
<td>CentOS Linux release 7.6.1810 (Core)</td>
</tr>
<tr>
<td>storage03.csp</td>
<td>192.168.165.40</td>
<td>FastDFS,libfastcommon,nginx,fastdfs-nginx-module</td>
<td>CentOS Linux release 7.6.1810 (Core)</td>
</tr>
<tr>
<td>storage04.csp</td>
<td>192.168.165.41</td>
<td>FastDFS,libfastcommon,nginx,fastdfs-nginx-module</td>
<td>CentOS Linux release 7.6.1810 (Core)</td>
</tr>
<tr>
<td>VIP</td>
<td>192.168.165.42</td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="fastdfs的安装"> fastdfs的安装</h3>
<p>6台主机同时进行</p>
<p>下载安装包</p>
<div><pre><code>mkdir -p /usr/local/software
cd /usr/local/software
wget https://github.com/happyfish100/fastdfs/archive/V5.11.tar.gz
wget https://github.com/happyfish100/fastdfs-client-java/archive/master.zip
mv master.zip fastdfs-client-java.zip
wget https://github.com/happyfish100/fastdfs-nginx-module/archive/master.zip
mv master.zip fastdfs-nginx-module.zip
wget https://github.com/happyfish100/libfastcommon/archive/master.zip
mv master.zip libfastcommon.zip
wget http://nginx.org/download/nginx-1.16.0.tar.gz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>安装相关依赖</p>
<div><pre><code>yum -y install make cmake gcc gcc-c++
</code></pre>
<div><span>1</span><br></div></div><p>安装 libfastcommon</p>
<div><pre><code>unzip libfastcommon.zip -d /usr/local/fast/
cd /usr/local/fast/libfastcommon-master
./make.sh 
./make.sh install
ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>安装 FastDFS</p>
<div><pre><code>tar -zxf V5.11.tar.gz -C /usr/local/fast/
cd /usr/local/fast/fastdfs-5.11
./make.sh
./make.sh install
cp -f ./conf/client.conf /etc/fdfs/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="tracker安装"> tracker安装</h3>
<p>在两台tracker上执行</p>
<div><pre><code>cd /etc/fdfs/
cp tracker.conf.sample tracker.conf
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>修改tracker配置文件</p>
<div><pre><code># egrep -v &quot;^$|^#&quot; tracker.conf
disabled=false
bind_addr=0.0.0.0
port=22122
connect_timeout=30
network_timeout=60
base_path=/fastdfs/tracker
max_connections=256
accept_threads=1
work_threads=4
min_buff_size = 8KB
max_buff_size = 128KB
store_lookup=2
store_group=group2
store_server=0
store_path=0
download_server=0
reserved_storage_space = 10%
log_level=info
run_by_group=
run_by_user=
allow_hosts=*
sync_log_buff_interval = 10
check_active_interval = 120
thread_stack_size = 64KB
storage_ip_changed_auto_adjust = true
storage_sync_file_max_delay = 86400
storage_sync_file_max_time = 300
use_trunk_file = false 
slot_min_size = 256
slot_max_size = 16MB
trunk_file_size = 64MB
trunk_create_file_advance = false
trunk_create_file_time_base = 02:00
trunk_create_file_interval = 86400
trunk_create_file_space_threshold = 20G
trunk_init_check_occupying = false
trunk_init_reload_from_binlog = false
trunk_compress_binlog_min_interval = 0
use_storage_id = false
storage_ids_filename = storage_ids.conf
id_type_in_filename = ip
store_slave_file_use_link = false
rotate_error_log = false
error_log_rotate_time=00:00
rotate_error_log_size = 0
log_file_keep_days = 0
use_connection_pool = false
connection_pool_max_idle_time = 3600
http.server_port=8080
http.check_alive_interval=30
http.check_alive_type=tcp
http.check_alive_uri=/status.html
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>修改的内容为：</p>
<div><pre><code>bind_addr=0.0.0.0
base_path=/fastdfs/tracker
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>创建工作目录</p>
<div><pre><code>mkdir -pv /fastdfs/tracker
</code></pre>
<div><span>1</span><br></div></div><p>启动追踪器</p>
<div><pre><code>/etc/init.d/fdfs_trackerd start
tail -f /fastdfs/tracker/logs/trackerd.log
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>开放防火墙端口</p>
<div><pre><code># cat /etc/sysconfig/iptables
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22122 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 10050 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT

# systemctl restart iptables.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="storage安装"> storage安装</h3>
<div><pre><code>cd /etc/fdfs/
cp storage.conf.sample storage.conf
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>修改配置文件</p>
<div><pre><code># egrep -v &quot;^$|^#&quot; storage.conf
disabled=false
group_name=group1
bind_addr=
client_bind=true
port=23000
connect_timeout=30
network_timeout=60
heart_beat_interval=30
stat_report_interval=60
base_path=/fastdfs/storage
max_connections=256
buff_size = 256KB
accept_threads=1
work_threads=4
disk_rw_separated = true
disk_reader_threads = 1
disk_writer_threads = 1
sync_wait_msec=50
sync_interval=0
sync_start_time=00:00
sync_end_time=23:59
write_mark_file_freq=500
store_path_count=1
store_path0=/fastdfs/storage
subdir_count_per_path=256
tracker_server=192.168.162.193:22122
tracker_server=192.168.162.194:22122
log_level=info
run_by_group=
run_by_user=
allow_hosts=*
file_distribute_path_mode=0
file_distribute_rotate_count=100
fsync_after_written_bytes=0
sync_log_buff_interval=10
sync_binlog_buff_interval=10
sync_stat_file_interval=300
thread_stack_size=512KB
upload_priority=10
if_alias_prefix=
check_file_duplicate=0
file_signature_method=hash
key_namespace=FastDFS
keep_alive=0
use_access_log = false
rotate_access_log = false
access_log_rotate_time=00:00
rotate_error_log = false
error_log_rotate_time=00:00
rotate_access_log_size = 0
rotate_error_log_size = 0
log_file_keep_days = 0
file_sync_skip_invalid_record=false
use_connection_pool = false
connection_pool_max_idle_time = 3600
http.domain_name=
http.server_port=8888
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><p>修改的文件内容为：</p>
<div><pre><code>group_name=group1 #4台机器分成2组(group1:192.168.165.38,39和group2:192.168.165.40,41)
base_path=/fastdfs/storage #设置 storage 的日志目录
store_path_count=1 #默认就为1，（存储路径个数，需要和 store_path个数匹配）
store_path0=/fastdfs/storage #设置存储路径
tracker_server=192.168.162.193:22122
tracker_server=192.168.162.194:22122#tracker 服务的IP和端口，多个就添加多条记录
http.server_port=8888 #设置http端口号
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>创建目录</p>
<div><pre><code>mkdir -pv /fastdfs/storage
</code></pre>
<div><span>1</span><br></div></div><p>启动 storage：</p>
<div><pre><code>/etc/init.d/fdfs_storaged start
tail -f /fastdfs/storage/logs/storaged.log
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>查看集群状态：</p>
<p>在任意一台storage主机即可</p>
<div><pre><code>/usr/bin/fdfs_monitor /etc/fdfs/storage.conf
</code></pre>
<div><span>1</span><br></div></div><p>开放防火墙端口</p>
<div><pre><code>cat /etc/sysconfig/iptables
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 8888 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 23000 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 10050 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT

# systemctl restart iptables.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="客户端测试"> 客户端测试</h3>
<p>tracker台中可以随意找一台做客户端测试下:</p>
<div><pre><code># egrep -v &quot;^$|^#&quot; client.conf
connect_timeout=30
network_timeout=60
base_path=/fastdfs/tracker
tracker_server=192.168.165.36:22122
tracker_server=192.168.165.37:22122
log_level=info
use_connection_pool = false
connection_pool_max_idle_time = 3600
load_fdfs_parameters_from_tracker=false
use_storage_id = false
storage_ids_filename = storage_ids.conf
http.tracker_server_port=8888
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>修改文件的内容为：</p>
<div><pre><code>base_path=/fastdfs/tracker #tracker服务器文件路径
tracker_server=192.168.165.36:22122
tracker_server=192.168.165.37:22122
http.tracker_server_port=8888 # tracker 服务器的 http端口号，必须和tracker的设置对应起来
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上传一张图片到服务器上</p>
<div><pre><code>/usr/bin/fdfs_upload_file /etc/fdfs/client.conf /home/111/1.jpg 
</code></pre>
<div><span>1</span><br></div></div><h3 id="配置fastdfs集群支持http"> 配置FastDFS集群支持http</h3>
<p>支持http请求，安装nginx（4个storage节点安装nginx,首先安装fastdfs-nginx-module,fastdfs与nginx集成模块）</p>
<div><pre><code>cd /usr/local/software/
unzip fastdfs-nginx-module.zip -d /usr/local/fast/
cd /usr/local/fast/fastdfs-nginx-module-master/src
yum -y install pcre pcre-devel
yum -y install zlib zlib-devel
yum -y install openssl openssl-devel
cd /usr/local/software
tar -zxf nginx-1.9.9.tar.gz -C /usr/local/
cd /usr/local/nginx-1.9.9
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>修改config编译文件</p>
<div><pre><code># vim /usr/local/fast/fastdfs-nginx-module-master/src/config
ngx_addon_name=ngx_http_fastdfs_module

if test -n &quot;${ngx_module_link}&quot;; then
    ngx_module_type=HTTP
    ngx_module_name=$ngx_addon_name
    ngx_module_incs=&quot;/usr/include/fastdfs /usr/include/fastcommon&quot;
    ngx_module_libs=&quot;-lfastcommon -lfdfsclient&quot;
    ngx_module_srcs=&quot;$ngx_addon_dir/ngx_http_fastdfs_module.c&quot;
    ngx_module_deps=
    CFLAGS=&quot;$CFLAGS -D_FILE_OFFSET_BITS=64 -DFDFS_OUTPUT_CHUNK_SIZE=&#39;256*1024&#39; -DFDFS_MOD_CONF_FILENAME=&#39;\&quot;/etc/fdfs/mod_fastdfs.conf\&quot;&#39;&quot;
    . auto/module
else
    HTTP_MODULES=&quot;$HTTP_MODULES ngx_http_fastdfs_module&quot;
    NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_fastdfs_module.c&quot;
    CORE_INCS=&quot;$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon&quot;
    CORE_LIBS=&quot;$CORE_LIBS -lfastcommon -lfdfsclient&quot;
    CFLAGS=&quot;$CFLAGS -D_FILE_OFFSET_BITS=64 -DFDFS_OUTPUT_CHUNK_SIZE=&#39;256*1024&#39; -DFDFS_MOD_CONF_FILENAME=&#39;\&quot;/etc/fdfs/mod_fastdfs.conf\&quot;&#39;&quot;
fi
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>编译安装</p>
<div><pre><code>./configure --add-module=/usr/local/fast/fastdfs-nginx-module-master/src/
make -j 4
make install
cd /usr/local/fast/fastdfs-nginx-module-master/src/
cp mod_fastdfs.conf /etc/fdfs/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>修改mod_fastdfs.conf配置文件</p>
<div><pre><code># egrep -v &quot;^$|^#&quot; /etc/fdfs/mod_fastdfs.conf
connect_timeout=20
network_timeout=30
base_path=/tmp
load_fdfs_parameters_from_tracker=true
storage_sync_file_max_delay = 86400
use_storage_id = false
storage_ids_filename = storage_ids.conf
tracker_server=192.168.165.36:22122
tracker_server=192.168.165.37:22122
storage_server_port=23000
group_name=group1
url_have_group_name = true
store_path_count=1
store_path0=/fastdfs/storage
log_level=info
log_filename=
response_mode=proxy
if_alias_prefix=
flv_support = true
flv_extension = flv
group_count = 2
[group1]
group_name=group1
storage_server_port=23000
store_path_count=1
store_path0=/fastdfs/storage
[group2]
group_name=group3
storage_server_port=23000
store_path_count=1
store_path0=/fastdfs/storage

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><blockquote>
<p>注意:group1:192.168.165.38,39和group2:192.168.165.40,41</p>
</blockquote>
<p>复制FastDFS(fastdfs-5.11)里的2个文件到/etc/fdfs/目录下</p>
<div><pre><code>cd /usr/local/fast/fastdfs-5.11/conf/
cp http.conf mime.types /etc/fdfs/
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>创建一个软链接，在/fastdfs/storage 文件存储目录下创建软链接，将其链接到实际存放数据的目录</p>
<div><pre><code>ln -s /fastdfs/storage/data/ /fastdfs/storage/data/M00
</code></pre>
<div><span>1</span><br></div></div><p>修改nginx配置文件为：</p>
<div><pre><code>cat /usr/local/nginx/conf/nginx.conf

#user  nobody;
worker_processes  4;
worker_cpu_affinity auto;
worker_rlimit_nofile 65535;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  65535;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    server {
        listen       8888;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        #location / {
        #    root   html;
        #    index  index.html index.htm;
        #}
        location ~ /group([0-9])/M00 {
            ngx_fastdfs_module;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
}

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><p>启动nginx</p>
<div><pre><code>/usr/local/nginx/sbin/nginx
</code></pre>
<div><span>1</span><br></div></div><p>上传图片，然后访问测试</p>
<h3 id="tracker-server-上安装-nginx缓存"> tracker server 上安装 nginx缓存</h3>
<div><pre><code>tar -zxf ngx_cache_purge-2.3.tar.gz -C /usr/local/fast/
yum -y install pcre pcre-devel
yum -y install zlib zlib-devel
yum -y install openssl openssl-devel
cd /usr/local/software
tar -xvf nginx-1.16.0.tar.gz -C /usr/local/
cd /usr/local/nginx-1.16.0/
./configure --add-module=/usr/local/fast/ngx_cache_purge-2.3
make -j 4
make install
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>创建缓存目录</p>
<div><pre><code>mkdir -pv /fastdfs/cache/nginx/proxy_cache
</code></pre>
<div><span>1</span><br></div></div><p>修改nginx配置文件：</p>
<div><pre><code># cat /usr/local/nginx/conf/nginx.conf

#user  nobody;
worker_processes  4;
worker_cpu_affinity auto;
worker_rlimit_nofile 65535;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  65535;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;
    server_tokens off;
    gzip on;
    gzip_disable &quot;MSIE [1-6]\.&quot;;
    gzip_min_length 1100;
    gzip_buffers 4 8k;
    gzip_comp_level 3;
    gzip_proxied any;
    gzip_types text/plain text/css application/x-javascript text/xml application/xml application/xml+rss text/javascript application/json image/jpeg image/gif image/png image/jpg;

    large_client_header_buffers 4 8k;
    client_header_buffer_size 8k;
    tcp_nopush on;
    tcp_nodelay on;
    server_names_hash_bucket_size 128;
    client_max_body_size 300m;
    client_body_buffer_size 128k;

    proxy_redirect off;
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_connect_timeout 90;
    proxy_send_timeout 90;
    proxy_read_timeout 90;
    proxy_buffer_size 16k;
    proxy_buffers 4 64k;
    proxy_busy_buffers_size 128k;
    proxy_temp_file_write_size 128k;
    proxy_cache_path /fastdfs/cache/nginx/proxy_cache levels=1:2 keys_zone=http-cache:200m max_size=1g inactive=30d;
    proxy_temp_path /fastdfs/cache/nginx/proxy_cache/tmp;

    upstream fdfs {
        server 192.168.165.38:8888 weight=1 max_fails=3 fail_timeout=30s;
        server 192.168.165.39:8888 weight=1 max_fails=3 fail_timeout=30s;
        server 192.168.165.40:8888 weight=1 max_fails=3 fail_timeout=30s;
        server 192.168.165.41:8888 weight=1 max_fails=3 fail_timeout=30s;
    }


    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        location ~/group([0-9])/M00 {
            proxy_next_upstream http_502 http_504 error timeout invalid_header;
            proxy_cache http-cache;
            proxy_cache_valid 200 304 12h;
            proxy_cache_key $uri$is_args$args;
            proxy_pass http://fdfs;
            expires 30d;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
}

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br></div></div><p>启动nginx</p>
<div><pre><code>/usr/local/nginx/sbin/nginx
</code></pre>
<div><span>1</span><br></div></div><p>上传图片，访问测试</p>
<h3 id="keepalived安装"> keepalived安装</h3>
<div><pre><code>yum -y install keepalived
</code></pre>
<div><span>1</span><br></div></div><p>修改配置文件</p>
<div><pre><code># cat /etc/keepalived/keepalived.conf 
! Configuration File for keepalived

global_defs {
    router_id LVS_DEVEL
}

vrrp_script chk_nginx {
    script &quot;/etc/keepalived/chk_nginx.sh&quot;
    interval 6
    weight -2
}

vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.165.42/24
    }
    track_script {
        chk_nginx
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><blockquote>
<p>准备：另一台的state改为BACKUP，priority改为小于100的值</p>
</blockquote>
<p>配置健康检查脚本：</p>
<div><pre><code># cat /etc/keepalived/chk_nginx.sh 
#!/bin/bash
#
# check nginx status

A=$(ps -C nginx --no-header |wc -l)
if [[ ${A} -eq 0 ]];then
  /usr/local/nginx/sbin/nginx
  sleep 3
  if [ $(ps -C nginx --no-header |wc -l) -eq 0 ];then
    local message=&quot;$(date) &#39;:nginx is not healthy, try to killall keepalived&#39;&quot;
    echo ${message} &gt;&gt; /etc/keepalived/keepalived.log
    systemctl stop keepalived.service
  fi
fi

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>赋予执行权限：</p>
<div><pre><code>chomd +x /etc/keepalived/chk_nginx.sh 
</code></pre>
<div><span>1</span><br></div></div><p>添加防火墙规则</p>
<div><pre><code># cat /etc/sysconfig/iptables
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -p vrrp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22122 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 10050 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT

#  systemctl restart iptables.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>启动服务</p>
<div><pre><code>systemctl start keepalived
</code></pre>
<div><span>1</span><br></div></div><p>用vip访问测试</p>
<p>参考链接：</p>
<blockquote>
<p><a href="https://www.cnblogs.com/NGames/archive/2019/06/23/11065282.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/NGames/archive/2019/06/23/11065282.html</a></p>
</blockquote>
<h3 id=""> </h3>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="常见服务的搭建"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">hexo(next)+github博客的搭建</title>
    <id>https://clay-wangzhi.com/build/hexo-blog/</id>
    <link href="https://clay-wangzhi.com/build/hexo-blog/"/>
    <updated>2021-05-11T06:50:07.000Z</updated>
    <content type="html"><![CDATA[<p>​	本文主要讲解博客的搭建过程，next主题优化，next配置文件详解等。<img src="./images/blogchongjianfengmian.jpg" alt="" /></p>

<h2 id="hexo-github的搭建过程2"> hexo+github的搭建过程2</h2>
<h3 id="准备安装软件"> 准备安装软件</h3>
<p><strong>依次安装</strong></p>
<ul>
<li><a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">Node.js</a></li>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener noreferrer">Git</a></li>
</ul>
<h3 id="配置和使用github"> 配置和使用github</h3>
<h4 id="注册github"> 注册github</h4>
<p>访问<a href="https://github.com/" target="_blank" rel="noopener noreferrer">github.com</a>右上角singnup</p>
<p>uername 最好都用小写，因为最后建立的博客地址是：<a href="https://link.zhihu.com/?target=http%3A//username.github.io" target="_blank" rel="noopener noreferrer">http://username.github.io</a>；邮箱十分重要，GitHub 上很多通知都是通过邮箱的。</p>
<h4 id="创建repository"> 创建Repository</h4>
<p>Repository 名字应该是<a href="https://link.zhihu.com/?target=http%3A//username.github.io" target="_blank" rel="noopener noreferrer">http://username.github.io</a>。</p>
<p>其他的可以选择添加一些描述也可以选择默认什么也不添加 ，点击creat repository</p>
<h4 id="配置ssh-keys"> 配置SSH keys</h4>
<p>运行git bash</p>
<div><pre><code>$ ssh-keygen -t rsa -C <span>"邮件地址@youremail.com"</span>
Generating public/private rsa key pair.
Enter <span>file</span> <span>in</span> <span>which</span> to save the key <span>(</span>/Users/your_user_directory/.ssh/id_rsa<span>)</span>:<span>&lt;</span>回车就好<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>【提示1】这里的邮箱地址，输入注册 Github 的邮箱地址；</p>
<p>【提示2】「-C」的是大写的「C」</p>
<p>然后系统会要你输入密码：</p>
<div><pre><code>Enter passphrase <span>(</span>empty <span>for</span> no passphrase<span>)</span>:<span>&lt;</span>设置密码<span>></span>
Enter same passphrase again:<span>&lt;</span>再次输入密码<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</p>
<p>注意：输入密码的时候没有输入痕迹的，不要以为什么也没有输入。</p>
<h4 id="添加ssh-key到github"> 添加SSH Key到GitHub</h4>
<p>在本地文件夹找到id_rsa.pub文件，.ssh文件夹里记事本打开这个文件复制全部内容到github相应位。</p>
<p><strong>测试</strong></p>
<p>打开git bash，输入以下代码</p>
<div><pre><code>$ <span>ssh</span> -T git@github.com
</code></pre>
<div><span>1</span><br></div></div><p>如何返回值中有successfully字段代表配置成功了。</p>
<h4 id="设置用户信息"> 设置用户信息</h4>
<p>打开git bash，完善个人信息</p>
<div><pre><code>$ <span>git</span> config --global user.name <span>"user"</span> //输入注册时的username
$ <span>git</span> config --global user.email  <span>"email"</span> //填写注册邮箱
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="搭建hexo博客"> 搭建hexo博客</h3>
<p>利用npm命令安装hexo</p>
<div><pre><code>$ npm install -g hexo
</code></pre>
<div><span>1</span><br></div></div><ul>
<li><strong>创建独立博客项目文件夹</strong></li>
</ul>
<p>安装完成后，关掉前面那个 Git Bash 窗口。在本地创建一个与 Repository 中博客项目同名的文件夹（如E:\username.github.io）在文件夹上点击鼠标右键，选择 Git bash here；</p>
<p>【提示】在进行博客搭建工作时，每次使用命令都要在E:\username.github.io目录下。</p>
<p>执行下面的指令，Hexo 就会自动在 E:\username.github.io文件夹建立独立博客所需要的所有文件啦！</p>
<div><pre><code>$ hexo init
</code></pre>
<div><span>1</span><br></div></div><ul>
<li><strong>安装依赖包</strong></li>
</ul>
<div><pre><code>$ <span>npm</span> <span>install</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li><strong>确保git部署</strong></li>
</ul>
<div><pre><code>$ <span>npm</span> <span>install</span> hexo-deployer-git --save
</code></pre>
<div><span>1</span><br></div></div><ul>
<li><strong>本地查看</strong></li>
</ul>
<p>现在已经搭建好本地的 Hexo 博客了，执行完下面的命令就可以到浏览器输入 localhost:4000 查看到啦</p>
<div><pre><code>$ hexo g
$ hexo s
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>hexo g 每次进行相应改动都要hexo g 生成一下</p>
<p>hexo s 启动服务预览</p>
<p>执行完 hexo init 命令后会给一个默认的主题：landscape</p>
<p>你可以到官网找你喜欢的主题进行下载 <a href="https://hexo.io/themes/" target="_blank" rel="noopener noreferrer">hexo themes</a> <a href="https://www.zhihu.com/question/24422335/answer/46357100" target="_blank" rel="noopener noreferrer">知乎：有哪些好看的 Hexo 主题？</a></p>
<p>找到它所在的 Github Repository （怎么找，我喜欢的那个，恰好博主放了他的github地址）</p>
<p>找到之后通过git命令下载</p>
<p>在主题的repository点击clone 复制一下那个地址</p>
<div><pre><code>$ <span>git</span> clone https://github.com/theme-next/hexo-theme-next themes/next
</code></pre>
<div><span>1</span><br></div></div><h2 id="next主题使用及优化"> next主题使用及优化</h2>
<h3 id="启用主题"> 启用主题</h3>
<p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p>
<p>启用 NexT 主题</p>
<div><pre><code><span>theme</span><span>:</span> next
</code></pre>
<div><span>1</span><br></div></div><p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p>
<h3 id="选择-scheme"> 选择 Scheme</h3>
<p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
</ul>
<p>Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 <code>#</code> 去除即可。</p>
<p>选择 Pisces Scheme</p>
<div><pre><code><span>#scheme: Muse</span>
<span>#scheme: Mist</span>
<span>scheme</span><span>:</span> Pisces
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="设置-语言"> 设置 语言</h3>
<p>编辑 站点配置文件， 将 <code>language</code> 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：</p>
<div><pre><code><span>language</span><span>:</span> zh<span>-</span>CN
</code></pre>
<div><span>1</span><br></div></div><h3 id="local-search"> Local Search</h3>
<p>添加百度/谷歌/本地 自定义站点内容搜索</p>
<ol>
<li>安装 <code>hexo-generator-searchdb</code>，在站点的根目录下执行以下命令：</li>
</ol>
<div><pre><code>$ <span>npm</span> <span>install</span> hexo-generator-searchdb --save
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>编辑 站点配置文件，新增以下内容到任意位置：</li>
</ol>
<div><pre><code><span>search</span><span>:</span>
  <span>path</span><span>:</span> search.xml
  <span>field</span><span>:</span> post
  <span>format</span><span>:</span> html
  <span>limit</span><span>:</span> <span>10000</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="3">
<li>编辑 主题配置文件，启用本地搜索功能：</li>
</ol>
<div><pre><code><span># Local search</span>
<span>local_search</span><span>:</span>
  <span>enable</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="文章模块的美化"> 文章模块的美化</h2>
<h3 id="文章内代码美化"> 文章内代码美化</h3>
<ul>
<li>行内代码
在主题目录下，将<code>source/css/_custom/custom.styl</code>文件修改如下：</li>
</ul>
<div><pre><code><span>//行内代码样式
code</span> <span>{</span>
    <span>color</span><span>:</span> #ff7600<span>;</span>
    <span>background</span><span>:</span> #fbf7f8<span>;</span>
    <span>border</span><span>:</span> 1px solid #d6d6d6<span>;</span>
    <span>padding</span><span>:</span>1px 4px<span>;</span>
    <span>word-break</span><span>:</span> break-all<span>;</span>
    <span>border-radius</span><span>:</span>4px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>区块代码
在主题目录下，修改<code>config.yml</code>文件：</li>
</ul>
<div><pre><code><span>#   样式可选： normal | night | night eighties | night blue | night bright</span>
<span>highlight_theme</span><span>:</span> night
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="文章结束语"> 文章结束语</h3>
<ul>
<li>**添加模块文件 **</li>
</ul>
<p>在主题目录下<code>layout/_macro</code>中新建 <code>passage-end-tag.swig</code>文件,并添加以下内容：</p>
<div><pre><code><span>&lt;div></span>
    <span>{</span>% if not is_index %<span>}</span>
        <span>&lt;div style="text-align:center;color: #ccc;font-size:14px;">
              -------------本文结束&lt;i>&lt;/i>感谢您的阅读-------------
        &lt;/div></span>
    <span>{</span>% endif %<span>}</span>
&lt;/div>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li><strong>导入模板文件</strong></li>
</ul>
<p>在<code>layout/_macro/post.swig</code>文件中，找到：</p>
<div><pre><code><span>{</span>#####################<span>}</span>
<span>{</span>### END POST BODY ###<span>}</span>
<span>{</span>#####################<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在上面代码之前添加：</p>
<div><pre><code><span>&lt;div></span>
      <span>{</span>% if not is_index %<span>}</span>
          <span>{</span>% include <span>'passage-end-tag.swig'</span> %<span>}</span>
      <span>{</span>% endif %<span>}</span>
&lt;/div>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li><strong>配置</strong>
在主题配置文件中添加：</li>
</ul>
<div><pre><code><span># 文章末尾添加“本文结束”标记</span>
<span>passage_end_tag</span><span>:</span>
  <span>enabled</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="增强文章底部版权信息"> 增强文章底部版权信息</h3>
<ul>
<li>增加文章md文件的头部信息中添加<code>copyright: true</code>时，添加版权声明</li>
<li>增加文章标题、发布时间、更新时间等信息</li>
</ul>
<p>在目录 <code>next/layout/_macro/下</code>添加 <code>my-copyright.swig</code>：</p>
<div><pre><code><span>{</span>% if page.copyright %<span>}</span>
<span>&lt;div>
  &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js">&lt;/script>
  
  &lt;!-- JS库 sweetalert 可修改路径 -->
  &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js">&lt;/script>
  &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js">&lt;/script>
  &lt;p>&lt;span>本文标题:&lt;/span>&lt;a href="{{ url_for(page.path) }}"></span><span>{</span><span>{</span> page.title <span>}</span><span>}</span><span>&lt;/a>&lt;/p>
  &lt;p>&lt;span>文章作者:&lt;/span>&lt;a href="/" title="访问 {{ theme.author }} 的个人博客"></span><span>{</span><span>{</span> theme.author <span>}</span><span>}</span><span>&lt;/a>&lt;/p>
  &lt;p>&lt;span>发布时间:&lt;/span></span><span>{</span><span>{</span> page.date.<span>format</span><span>(</span><span>"YYYY年MM月DD日 - HH:MM"</span><span>)</span> <span>}</span><span>}</span><span>&lt;/p>
  &lt;p>&lt;span>最后更新:&lt;/span></span><span>{</span><span>{</span> page.updated.<span>format</span><span>(</span><span>"YYYY年MM月DD日 - HH:MM"</span><span>)</span> <span>}</span><span>}</span><span>&lt;/p>
  &lt;p>&lt;span>原始链接:&lt;/span>&lt;a href="{{ url_for(page.path) }}" title="{{ page.title }}"></span><span>{</span><span>{</span> page.permalink <span>}</span><span>}</span>&lt;/a>
    &lt;span class=<span>"copy-path"  title="点击复制文章链接">&lt;i data-clipboard-text="</span><span>{</span><span>{</span> page.permalink <span>}</span><span>}</span><span>"  aria-label="</span>复制成功！">&lt;/i>&lt;/span>
  &lt;/p>
  &lt;p>&lt;span><span>许可协议</span><span>:</span>&lt;/span>&lt;i class=<span>"fa fa-creative-commons"</span>>&lt;/i> &lt;a rel=<span>"license"</span> href=<span>"https://creativecommons.org/licenses/by-nc-nd/4.0/"</span> target=<span>"_blank"</span> title=<span>"Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"</span>>署名-非商业性使用-禁止演绎 4.0 国际&lt;/a> 转载请保留原文链接及作者。&lt;/p>  
&lt;/div>
&lt;script> 
    var clipboard = new <span>Clipboard</span><span>(</span><span>'.fa-clipboard'</span><span>)</span><span>;
    $(".fa-clipboard").click(function()</span><span>{</span>
      <span>clipboard.on('success', function()</span><span>{</span>
        <span>swal(</span><span>{</span>   
          <span>title</span><span>:</span> <span>""</span><span>,</span>   
          <span>text</span><span>:</span> <span>'复制成功'</span><span>,</span>
          <span>icon</span><span>:</span> <span>"success"</span><span>,</span> 
          <span>showConfirmButton</span><span>:</span> true
          <span>}</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;  
&lt;/script></span>
<span>{</span>% endif %<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>在目录<code>next/source/css/_common/components/post/</code>下添加<code>my-post-copyright.styl</code>：</p>
<div><pre><code><span>.my_post_copyright</span> <span>{</span>
  <span>width</span><span>:</span> 85%<span>;</span>
  <span>max-width</span><span>:</span> 45em<span>;</span>
  <span>margin</span><span>:</span> 2.8em auto 0<span>;</span>
  <span>padding</span><span>:</span> 0.5em 1.0em<span>;</span>
  <span>border</span><span>:</span> 1px solid #d3d3d3<span>;</span>
  <span>font-size</span><span>:</span> 0.93rem<span>;</span>
  <span>line-height</span><span>:</span> 1.6em<span>;</span>
  <span>word-break</span><span>:</span> break-all<span>;</span>
  <span>background</span><span>:</span> <span>rgba</span><span>(</span>255<span>,</span>255<span>,</span>255<span>,</span>0.4<span>)</span><span>;</span>
<span>}</span>
<span>.my_post_copyright p</span><span>{</span><span>margin</span><span>:</span>0<span>;</span><span>}</span>
<span>.my_post_copyright span</span> <span>{</span>
  <span>display</span><span>:</span> inline-block<span>;</span>
  <span>width</span><span>:</span> 5.2em<span>;</span>
  <span>color</span><span>:</span> #b5b5b5<span>;</span>
  <span>font-weight</span><span>:</span> bold<span>;</span>
<span>}</span>
<span>.my_post_copyright .raw</span> <span>{</span>
  <span>margin-left</span><span>:</span> 1em<span>;</span>
  <span>width</span><span>:</span> 5em<span>;</span>
<span>}</span>
<span>.my_post_copyright a</span> <span>{</span>
  <span>color</span><span>:</span> #808080<span>;</span>
  <span>border-bottom</span><span>:</span>0<span>;</span>
<span>}</span>
<span>.my_post_copyright a:hover</span> <span>{</span>
  <span>color</span><span>:</span> #a3d2a3<span>;</span>
  <span>text-decoration</span><span>:</span> underline<span>;</span>
<span>}</span>
<span>.my_post_copyright:hover .fa-clipboard</span> <span>{</span>
  <span>color</span><span>:</span> #000<span>;</span>
<span>}</span>
<span>.my_post_copyright .post-url:hover</span> <span>{</span>
  <span>font-weight</span><span>:</span> normal<span>;</span>
<span>}</span>
<span>.my_post_copyright .copy-path</span> <span>{</span>
  <span>margin-left</span><span>:</span> 1em<span>;</span>
  <span>width</span><span>:</span> 1em<span>;
  +mobile()</span><span>{</span><span>display</span><span>:</span>none<span>;</span><span>}</span>
<span>}</span>
<span>.my_post_copyright .copy-path:hover</span> <span>{</span>
  <span>color</span><span>:</span> #808080<span>;</span>
  <span>cursor</span><span>:</span> pointer<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>修改<code>next/layout/_macro/post.swig</code>，在代码</p>
<div><pre><code><span>{</span>#####################<span>}</span>
<span>{</span>### END POST BODY ###<span>}</span>
<span>{</span>#####################<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>之前添加增加如下代码：</p>
<div><pre><code><span>&lt;div></span>
      <span>{</span>% if not is_index %<span>}</span>
        <span>{</span>% include <span>'my-copyright.swig'</span> %<span>}</span>
      <span>{</span>% endif %<span>}</span>
&lt;/div>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>修改<code>next/source/css/_common/components/post/post.styl</code>文件，在最后一行增加代码：</p>
<div><pre><code>@import <span>"my-post-copyright"</span>
</code></pre>
<div><span>1</span><br></div></div><p>保存重新生成即可。</p>
<h2 id="遇到的问题"> 遇到的问题</h2>
<p><code>LaTeX-incompatible input and strict mode is set to 'warn': Unicode text character</code></p>
<p>产生的原因：而在 Markdown 语法中，<strong>两个 $ 符号是数学符号和公式</strong>的使用。要想使用单个 $，要加个转义字符 <code>\</code>。</p>
<h2 id="参考"> 参考</h2>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/32957389" target="_blank" rel="noopener noreferrer">技术小白搭建hexo+github博客</a></p>
<p><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener noreferrer">next最新版主题下载使用</a></p>
<p><a href="https://theme-next.iissnan.com" target="_blank" rel="noopener noreferrer">next主题官方文档</a></p>
<p><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener noreferrer">next主题个性化教程</a></p>
<p><a href="https://iassas.com/archives/d6a90b9.html" target="_blank" rel="noopener noreferrer">next主题配置文件详解</a></p>
<p><a href="https://blog.csdn.net/weixin_39345384/article/details/80544660" target="_blank" rel="noopener noreferrer">NexT v6.0+ 背景动画Canvas_nest设置无效的解决方案</a></p>
<p><a href="http://zhuxin.tech/2017/10/20/%E7%BB%99%20Hexo%20%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E9%AA%8C%E8%AF%81/" target="_blank" rel="noopener noreferrer">给Hexo搭建的博客增加百度谷歌搜索引擎验证</a></p>
<p><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener noreferrer">添加文章字数和读取文章的时间</a></p>
<p><a href="https://www.jianshu.com/p/344cf061598d" target="_blank" rel="noopener noreferrer">hexo + next主题高级配置</a></p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2016-06-06T14:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">centos6.5下安装python3.6、pip、ipython</title>
    <id>https://clay-wangzhi.com/build/linux-python/</id>
    <link href="https://clay-wangzhi.com/build/linux-python/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>centos6.5下安装python3.6、pip、ipython</p>

<h2 id="安装依赖包"> 安装依赖包</h2>
<p>test</p>
<div><pre><code># yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel
</code></pre>
<div><span>1</span><br></div></div><p>开始下载、编译、安装python3.6</p>
<div><pre><code># wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgz
# tar vxf Python-3.6.1.tgz
# cd Python-3.6.1.tgz
# ./configure --prefix=/usr/local   #编译，自定义安装目录，如果自定目录不在环境变量重要，要把安装的目录加入到环境变量中
# make &amp;&amp; make install  #这个过程会非常慢 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>检查是否安装成功</p>
<div><pre><code># python3
Python 3.6.1 (default, May 12 2017, 00:21:59) 
[GCC 4.4.7 20120313 (Red Hat 4.4.7-4)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="安装pip-pip-9-0"> 安装pip（pip-9.0）</h2>
<div><pre><code># wget https://pypi.python.org/packages/11/b6/abcb525026a4be042b486df43905d6893fb04f05aac21c32c638e939e447/pip-9.0.1.tar.gz#md5=35f01da33009719497f01a4ba69d63c9  #pip下载，官网去下载。
# tar zxf pip-9.0.1.tar.gz 
# cd pip-9.0.1
# python3 setup.py install
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="安装ipython"> 安装ipython</h2>
<div><pre><code># pip install ipython
</code></pre>
<div><span>1</span><br></div></div><h2 id="设置-3-x-为默认版本"> 设置 3.x 为默认版本</h2>
<div><pre><code>rm -f /usr/bin/python
ln -s /usr/local/bin/python3 /usr/bin/python
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="配置yum"> 配置yum</h2>
<p>升级 Python 之后，由于将默认的 python 指向了 python3，yum 不能正常使用，需要编辑 yum 的配置文件：</p>
<div><pre><code>vim /usr/bin/yum
</code></pre>
<div><span>1</span><br></div></div><p>同时修改：</p>
<div><pre><code>vim /usr/libexec/urlgrabber-ext-down
</code></pre>
<div><span>1</span><br></div></div><p>将 #!/usr/bin/python 改为 #!/usr/bin/python2.7，保存退出即可。</p>
<p>参考链接；</p>
<p>https://www.cnblogs.com/thong2006/p/6843633.html</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="常见服务的搭建"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2017-09-27T21:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">centos7安装rabbitmq-3.7.9</title>
    <id>https://clay-wangzhi.com/build/rabbitmq-install/</id>
    <link href="https://clay-wangzhi.com/build/rabbitmq-install/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="centos7安装rabbitmq-3-7-9"> centos7安装rabbitmq-3.7.9</h1>
<p>安装方式：rpm包安装</p>
<p>系统版本: centos7.x</p>
<h2 id="安装erlang"> 安装erlang</h2>
<p>安装<a href="https://github.com/rabbitmq/erlang-rpm" target="_blank" rel="noopener noreferrer">erlang-rpm</a>包，该包经过RabbitMQ官方处理，去掉了一些无用的依赖，只保存运行RabbitMQ所需要的Erlang模块。</p>
<p>这里下载的版本为21.2</p>
<p><img src="./images/erlang.png" alt="" /></p>
<p>下载完后上传到服务器上，安装</p>
<div><pre><code>yum -y install erlang-21.2-1.el7.centos.x86_64.rpm
</code></pre>
<div><span>1</span><br></div></div><h2 id="安装rabbitmq"> 安装rabbitmq</h2>
<p>从官网下载rpm包并上传到服务器上。<a href="http://www.rabbitmq.com/install-rpm.html#install-monolithic-from-esl-repository" target="_blank" rel="noopener noreferrer">官方下载链接</a></p>
<p><img src="./images/rabbitmq.png" alt="" /></p>
<p>导入签名</p>
<div><pre><code>rpm --import https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc
</code></pre>
<div><span>1</span><br></div></div><p>安装</p>
<div><pre><code>yum install rabbitmq-server-3.7.9-1.el7.noarch.rpm -y
</code></pre>
<div><span>1</span><br></div></div><h2 id="启动rabbitmq"> 启动rabbitmq</h2>
<p>设置开机启动</p>
<div><pre><code>systemctl enable rabbitmq-server.service
</code></pre>
<div><span>1</span><br></div></div><p>启动rabbitmq</p>
<div><pre><code>systemctl start rabbitmq-server.service
</code></pre>
<div><span>1</span><br></div></div><p>停止rabbitmq</p>
<div><pre><code>systemctl stop rabbitmq-server.service
</code></pre>
<div><span>1</span><br></div></div><h2 id="配置rabbitmq"> 配置rabbitmq</h2>
<p>拷贝默认配置文件</p>
<div><pre><code>cp /usr/share/doc/rabbitmq-server-3.7.9/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config
</code></pre>
<div><span>1</span><br></div></div><p>开启管理后台</p>
<div><pre><code>rabbitmq-plugins enable rabbitmq_management
</code></pre>
<div><span>1</span><br></div></div><p>开放防火墙端口</p>
<p><code>vim /etc/sysconfig/iptables</code>增加下面两行</p>
<div><pre><code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 5672 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 15672 -j ACCEPT
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>重启防火墙</p>
<div><pre><code>systemctl restart iptables.service
</code></pre>
<div><span>1</span><br></div></div><p>配置用户权限，增加一个用户</p>
<div><pre><code>systemctl start rabbitmq-server.service
rabbitmqctl add_user admin admin
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>赋予用户管理员角色</p>
<div><pre><code>rabbitmqctl set_user_tags admin administrator
</code></pre>
<div><span>1</span><br></div></div><p>访问页面，http://ip:15672</p>
<p><img src="./images/rabbitmq_web.png" alt="" /></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="常见服务的搭建"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">rocketmq集群的搭建</title>
    <id>https://clay-wangzhi.com/build/rocketmq-install/</id>
    <link href="https://clay-wangzhi.com/build/rocketmq-install/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="rocketmq集群的搭建"> rocketmq集群的搭建</h1>
<p>环境</p>
<ul>
<li>JDK1.8</li>
<li>maven3.6.0</li>
<li>centos7.6主机两台</li>
</ul>
<h2 id="下载解压"> 下载解压</h2>
<div><pre><code><span>wget</span> https://mirrors.tuna.tsinghua.edu.cn/apache/rocketmq/4.6.0/rocketmq-all-4.6.0-bin-release.zip
<span>unzip</span> rocketmq-all-4.6.0-bin-release.zip
<span>mv</span> rocketmq-all-4.6.0-bin-release /usr/local/rocketmq
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="修改配置文件"> 修改配置文件</h2>
<p>rocketmq默认给出了三种建议配置模式
2m-2s-async(主从异步),----本文采用这种
2m-2s-sync(主从同步)
2m-noslave(仅master)</p>
<ol>
<li>对主机一（192.168.163.196）进行操作</li>
</ol>
<div><pre><code><span>cd</span> /usr/local/rocketmq/conf/2m-2s-async
<span>vim</span> broker-a.properties
<span># 向配置文件中追加如下内容</span>
<span>namesrvAddr</span><span>=</span><span>192.168</span>.163.196:9876<span>;</span><span>192.168</span>.163.197:9876
<span>listenPort</span><span>=</span><span>10911</span>
<span>storePathRootDir</span><span>=</span>/usr/local/rocketmq/master/store
<span>storePathCommitLog</span><span>=</span>/usr/local/rocketmq/master/store/commitlog
<span>storePathConsumeQueue</span><span>=</span>/usr/local/rocketmq/master/store/consumequeue
<span>storePathIndex</span><span>=</span>/usr/local/rocketmq/master/store/index
<span>storeCheckpoint</span><span>=</span>/usr/local/rocketmq/master/store/checkpoint
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>vim</span> broker-b-s.properties
<span># 向配置文件中追加如下内容</span>
<span>namesrvAddr</span><span>=</span><span>192.168</span>.163.196:9876<span>;</span><span>192.168</span>.163.197:9876
<span>listenPort</span><span>=</span><span>20911</span>
<span>storePathRootDir</span><span>=</span>/usr/local/rocketmq/slave/store
<span>storePathCommitLog</span><span>=</span>/usr/local/rocketmq/slave/store/commitlog
<span>storePathConsumeQueue</span><span>=</span>/usr/local/rocketmq/slave/store/consumequeue
<span>storePathIndex</span><span>=</span>/usr/local/rocketmq/slave/store/index
<span>storeCheckpoint</span><span>=</span>/usr/local/rocketmq/slave/store/checkpoint
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol start="2">
<li>对主机二（192.168.163.197）进行操作</li>
</ol>
<div><pre><code><span>cd</span> /usr/local/rocketmq/conf/2m-2s-async
<span>vim</span> broker-b.properties
<span># 向配置文件中追加如下内容</span>
<span>namesrvAddr</span><span>=</span><span>192.168</span>.163.196:9876<span>;</span><span>192.168</span>.163.197:9876
<span>listenPort</span><span>=</span><span>10911</span>
<span>storePathRootDir</span><span>=</span>/usr/local/rocketmq/master/store
<span>storePathCommitLog</span><span>=</span>/usr/local/rocketmq/master/store/commitlog
<span>storePathConsumeQueue</span><span>=</span>/usr/local/rocketmq/master/store/consumequeue
<span>storePathIndex</span><span>=</span>/usr/local/rocketmq/master/store/index
<span>storeCheckpoint</span><span>=</span>/usr/local/rocketmq/master/store/checkpoint
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>vim</span> broker-a-s.properties
<span># 向配置文件中追加如下内容</span>
<span>namesrvAddr</span><span>=</span><span>192.168</span>.163.196:9876<span>;</span><span>192.168</span>.163.197:9876
<span>listenPort</span><span>=</span><span>20911</span>
<span>storePathRootDir</span><span>=</span>/usr/local/rocketmq/slave/store
<span>storePathCommitLog</span><span>=</span>/usr/local/rocketmq/slave/store/commitlog
<span>storePathConsumeQueue</span><span>=</span>/usr/local/rocketmq/slave/store/consumequeue
<span>storePathIndex</span><span>=</span>/usr/local/rocketmq/slave/store/index
<span>storeCheckpoint</span><span>=</span>/usr/local/rocketmq/slave/store/checkpoint
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol start="3">
<li>设置Rocketmq运行时的JVM内存</li>
</ol>
<div><pre><code><span>cd</span> /usr/local/rocketmq/bin
<span>vim</span> runbroker.sh
<span>#JAVA_OPT="${JAVA_OPT} -server -Xms8g -Xmx8g -Xmn4g"</span>
<span>#改成：</span>
<span>JAVA_OPT</span><span>=</span><span>"<span>${JAVA_OPT}</span> -server -Xms512m -Xmx512m -Xmn256m"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>vim</span> runserver.sh 
<span># JAVA_OPT="${JAVA_OPT} -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span>
<span># 改成</span>
<span>JAVA_OPT</span><span>=</span><span>"<span>${JAVA_OPT}</span> -server -Xms512m -Xmx512m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="启动rocketmq"> 启动Rocketmq</h2>
<ol>
<li>主机一上操作</li>
</ol>
<div><pre><code>nohup sh mqnamesrv &amp;
nohup sh mqbroker -c ../conf/2m-2s-async/broker-a.properties &amp;
nohup sh mqbroker -c ../conf/2m-2s-async/broker-b-s.properties &amp;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li>主机二上操作</li>
</ol>
<div><pre><code><span>nohup</span> <span>sh</span> mqnamesrv <span>&amp;</span>
<span>nohup</span> <span>sh</span> mqbroker -c <span>..</span>/conf/2m-2s-async/broker-a-s.properties <span>&amp;</span>
<span>nohup</span>  <span>sh</span> mqbroker -c <span>..</span>/conf/2m-2s-async/broker-b.properties <span>&amp;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="搭建console可视化控制台"> 搭建Console可视化控制台</h2>
<div><pre><code><span>git</span> clone https://github.com/apache/rocketmq-externals.git
<span>cd</span> rocketmq-externals/rocketmq-console/
<span>vim</span> src/main/resources/application.properties
<span># 添加两个namesvr的主机ip</span>
rocketmq.config.namesrvAddr<span>=</span><span>192.168</span>.163.196:9876<span>;</span><span>192.168</span>.163.197:9876
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span># 打包</span>
 mvn clean package -Dmaven.test.skip<span>=</span>true
 <span>scp</span> target/rocketmq-console-ng-1.0.1.jar <span>192.168</span>.163.196:/home/ncar/service/webapps
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span># 启动jar包，在主机一（192.168.163.196）上</span>
 <span>nohup</span> java -jar rocketmq-console-ng-1.0.1.jar <span>&amp;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>打开控制台查看集群启动状态</p>
<div><pre><code>http://192.168.163.196:8080/#/cluster
</code></pre>
<div><span>1</span><br></div></div><h2 id="关闭命令"> 关闭命令</h2>
<div><pre><code>sh bin/mqshutdown broker
sh bin/mqshutdown namesrv
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="常见服务的搭建"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">zookeeper3.4.14集群搭建步骤</title>
    <id>https://clay-wangzhi.com/build/zookeeper-install/</id>
    <link href="https://clay-wangzhi.com/build/zookeeper-install/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="zookeeper3-4-14集群搭建步骤"> zookeeper3.4.14集群搭建步骤</h1>
<h3 id="下载解压"> 下载解压</h3>
<div><pre><code>cd /opt
wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz
tar -xvf zookeeper-3.4.14.tar.gz 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="修改相关配置"> 修改相关配置</h3>
<div><pre><code>mkdir -p /var/lib/zookeeper/data
mkdir -p /var/lib/zookeeper/log
mkdir -p /var/log/zookeeper
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>生产myid文件（三台主机分别执行）</p>
<div><pre><code>echo 29 &gt; /var/lib/zookeeper/data/myid
echo 30 &gt; /var/lib/zookeeper/data/myid
echo 31 &gt; /var/lib/zookeeper/data/myid
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>修改zoo.cfg文件</p>
<div><pre><code>cd /opt/zookeeper-3.4.14/conf
cp zoo_sample.cfg zoo.cfg
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code># egrep -v &quot;^#|^$&quot; zoo.cfg 
tickTime=2000
initLimit=10
syncLimit=5
dataDir=/var/lib/zookeeper/data
dataLogDir=/var/lib/zookeeper/log
clientPort=2181
server.29=192.168.165.29:2888:3888
server.30=192.168.165.30:2888:3888
server.31=192.168.165.31:2888:3888
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>修改/zkEnv.sh文件</p>
<div><pre><code>cd /opt/zookeeper-3.4.14/bin
</code></pre>
<div><span>1</span><br></div></div><p>找到 ZOO_LOG_DIR=&quot;.&quot; 一行，换成如下</p>
<div><pre><code># vim zkEnv.sh
ZOO_LOG_DIR=&quot;/var/log/zookeeper&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="修改防火墙规则"> 修改防火墙规则</h3>
<div><pre><code># cat /etc/sysconfig/iptables
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 2181 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 2888 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 3888 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 10050 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT

# systemctl restart iptables.service 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="启动集群"> 启动集群</h3>
<div><pre><code>/opt/zookeeper-3.4.14/bin/zkServer.sh start
/opt/zookeeper-3.4.14/bin/zkServer.sh status
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>通过<code>nc</code>方式验证</p>
<div><pre><code>yum -y install nc
echo stat | nc 192.168.165.46 2181
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>通过四字命令<code>srvr</code>方式验证</p>
<div><pre><code># telnet 192.168.165.45 2181
Trying 192.168.165.45...
Connected to 192.168.165.45.
Escape character is &#39;^]&#39;.
srvr
Zookeeper version: 3.4.14-4c25d480e66aadd371de8bd2fd8da255ac140bcf, built on 03/06/2019 16:18 GMT
Latency min/avg/max: 0/0/0
Received: 2
Sent: 1
Connections: 1
Outstanding: 0
Zxid: 0x0
Mode: follower
Node count: 4
Connection closed by foreign host.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="常见服务的搭建"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">命名</title>
    <id>https://clay-wangzhi.com/code/golang/4.1%20%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</id>
    <link href="https://clay-wangzhi.com/code/golang/4.1%20%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="命名"> 命名</h2>
<p>命名规则：</p>
<p>1）可以使用字母 数字 下划线</p>
<p>2）不允许使用数字开头</p>
<p>3）不允许使用系统关键字</p>
<p>4）区分大小写</p>
<p>5）见名知意</p>
<p>函数命名规则：</p>
<p>1）包本身的名字一般总是小写字母开头</p>
<p>2）可以被外部访问的包是大写字母开头</p>
<p>作用域命名规则：
1）局部变量一般用<code>i</code>这类的短名字</p>
<p>2）全局变量的名字一般较长，更有意义</p>
<p>命名习惯：</p>
<p>1）推荐使用驼峰式命名。</p>
<h2 id="声明"> 声明</h2>
<p>Go语言主要有四种类型的声明语句：</p>
<p>1） var 变量</p>
<p>2） const 常量</p>
<p>3） type 类型</p>
<p>4） func 函数实体</p>
<p><strong>一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。</strong></p>
<p>如果函数没有返回值，那么返回值列表是省略的。</p>
<p>执行函数从函数的第一个语句开始，依次顺序执行直到遇到renturn返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。</p>
<h2 id="变量"> 变量</h2>
<p>变量声明的一般语法：</p>
<div><pre><code>var 变量名字 类型 = 表达式
</code></pre>
<div><span>1</span><br></div></div><p>其中“类型”或“= 表达式”两个部分可以省略其中的一个。</p>
<p>如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。</p>
<p>如果初始化表达式被省略，那么将用零值初始化该变量。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody>
<tr>
<td>数值</td>
<td>0</td>
</tr>
<tr>
<td>布尔</td>
<td>false</td>
</tr>
<tr>
<td>字符串</td>
<td>空字符串</td>
</tr>
<tr>
<td>接口</td>
<td>nil</td>
</tr>
<tr>
<td>引用</td>
<td>nil</td>
</tr>
<tr>
<td>slice/map/chan</td>
<td>nil</td>
</tr>
<tr>
<td>数组/结构</td>
<td>每个元素或字段的零值</td>
</tr>
</tbody>
</table>
<h3 id="简短变量声明-自动推导类型"> 简短变量声明（自动推导类型）</h3>
<p>简短变量声明被广泛用于大部分的局部变量的声明和初始化。</p>
<p>var形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p>
<p>声明方法：</p>
<div><pre><code>名字 := 表达式
</code></pre>
<div><span>1</span><br></div></div><h3 id="指针"> 指针</h3>
<p>一个指针的值是另一个变量的地址。</p>
<p>一个指针对应变量在内存中的存储位置。</p>
<p>并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。</p>
<p>通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。</p>
<div><pre><code>x := 1
p := &amp;x // p, of type *int, points to x
fmt.Println(*p) // &quot;1&quot;
*p = 2 // equivalent to x = 2
fmt.Println(x) // &quot;2&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受&amp;取地址操作。</p>
<p>任何类型的指针的零值都是nil。</p>
<h3 id="new函数"> new函数</h3>
<p>表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。</p>
<div><pre><code>p := new(int) // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // &quot;0&quot;
*p = 2 // 设置 int 匿名变量的值为 2
fmt.Println(*p) // &quot;2&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="赋值"> 赋值</h2>
<p>使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。</p>
<div><pre><code>x = 1 // 命令变量的赋值
*p = true // 通过指针间接赋值
person.name = &quot;bob&quot; // 结构体字段赋值
count[x] = count[x] * scale // 数组、slice或map的元素赋值
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="元组赋值-多重赋值"> 元组赋值（多重赋值）</h3>
<p>元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。</p>
<div><pre><code>x, y = y, x
a[i], a[j] = a[j], a[i]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>例题：计算两个整数值的的最大公约数（GCD）</p>
<div><pre><code>func gcd(x, y int) int {
for y != 0 {
x, y = y, x%y
}
return x
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>例题：计算斐波纳契数列（Fibonacci）的第N个数：</p>
<div><pre><code>func fib(n int) int {
x, y := 0, 1
for i := 0; i &lt; n; i++ {
x, y = y, x+y
}
return x
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右边一致。</p>
<p>如果<code>map查找</code>、<code>类型断言</code>或<code>通道接收</code>出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功：</p>
<div><pre><code>v, ok = m[key] // map lookup
v, ok = x.(T) // type assertion
v, ok = &lt;-ch // channel receive
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>译注：map查找）、类型断言或通道接收出现在赋值语句的右边时，并不一定是产生两个结果，也可能只产生一个结果。对于值产生一个结果的情形，map查找失败时会返回零值，类型断言失败时会发送运行时panic异常，通道接收失败时会返回零值（阻塞不算是失败）。例如下面的例子：</p>
<div><pre><code>v = m[key] // map查找，失败时返回零值
v = x.(T) // type断言，失败时panic异常
v = &lt;-ch // 管道接收，失败时返回零值（阻塞不算是失败）
_, ok = m[key] // map返回2个值
_, ok = mm[&quot;&quot;], false // map返回1个值
_ = mm[&quot;&quot;] // map返回1个值
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>和变量声明一样，我们可以用下划线空白标识符_来丢弃不需要的值。</p>
<div><pre><code>_, err = io.Copy(dst, src) // 丢弃字节数
_, ok = x.(T) // 只检测类型，忽略具体值
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="类型"> 类型</h2>
<p>变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。</p>
<p>在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。例如，一个int类型的变量可以用来表示一个循环的迭代索引、或者一个时间戳、或者一个文件描述符、或者一个月份；一个float64类型的变量可以用来表示每秒移动几米的速度、或者是不同温度单位下的温度；一个字符串可以用来表示一个密码或者一个颜色的名称。</p>
<p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p>
<p>类型声明方法：</p>
<div><pre><code>type 类型名字 底层类型
</code></pre>
<div><span>1</span><br></div></div><p><strong>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在外部包也可以使用</strong>。</p>
<h2 id="包和文件"> 包和文件</h2>
<p>Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。</p>
<p>每个包都对应一个独立的名字空间。</p>
<p>例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。</p>
<p>要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。</p>
<p><strong>包级别的常量名都是以大写字母开头</strong>。</p>
<h3 id="导入包"> 导入包</h3>
<p>除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，一个包的名字和包的导入路径的最后一个字段相同，例如gopl.io/ch2/tempconv包的名字一般是tempconv。
导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容。</p>
<h3 id="包的初始化"> 包的初始化</h3>
<p>包的初始化首先是解决包级变量的依赖顺序，然后安照包级变量声明出现的顺序依次初始化：</p>
<div><pre><code>var a = b + c // a 第三个初始化, 为 3
var b = f() // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1 // c 第一个初始化, 为 1
func f() int { return c + 1 }
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个<code>init初始化函数</code>。</p>
<div><pre><code>func init() { /* ... */ }
</code></pre>
<div><span>1</span><br></div></div><p>以这种方式，可以确保在main函数执行之前，所有依然的包都已经完成初始化工
作了。</p>
<h2 id="作用域"> 作用域</h2>
<p>一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。</p>
<p>不要将作用域和生命周期混为一谈。</p>
<p>声明语句的作用域对应的是一个源代码的文本区域；它是一个<strong>编译时的属性</strong>。</p>
<p>一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个<strong>运行时的概念</strong>。</p>
<p>语法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧对应的语法块那样。语法块内部声明的名字是无法被外部语法块访问的。语法决定了内部声明的名字的作用域范围。</p>
<p>有一个语法块为整个源代码，称为全局语法块；</p>
<p>然后是每个包的包语法决；每个for、if和switch语句的语法决；</p>
<p>每个switch或select的分支也有独立的语法决；当然也包括显式书写的语法块（花括弧包含的语句）。</p>
<p>对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。</p>
<p>控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。</p>
<p>下面的代码有三个不同的变量x，因为它们是定义在不同的词法域（这个例子只是为了演示作用域规则，但不是好的编程风格）。</p>
<div><pre><code>func main() {
x := &quot;hello!&quot;
for i := 0; i &lt; len(x); i++ {
x := x[i]
if x != &#39;!&#39; {
x := x + &#39;A&#39; - &#39;a&#39;
fmt.Printf(&quot;%c&quot;, x) // &quot;HELLO&quot; (one letter per iteration)
}
}
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>正如上面例子所示，并不是所有的词法域都显式地对应到由花括弧包含的语句；还有一些隐含的规则。</p>
<p>上面的for语句创建了两个词法域：花括弧包含的是显式的部分是for的循环体部分词法域，另外一个隐式的部分则是循环的初始化部分，比如用于迭代变量i的初始化。</p>
<p>隐式的词法域部分的作用域还包含条件测试部分和循环后的迭代部分（i++），当然也包含循环体词法域。
下面的例子同样有三个不同的x变量，每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化词法域，一个在for循环体词法域；只有两个块是显式创建的：</p>
<div><pre><code>func main() {
x := &quot;hello&quot;
for _, x := range x {
x := x + &#39;A&#39; - &#39;a&#39;
fmt.Printf(&quot;%c&quot;, x) // &quot;HELLO&quot; (one letter per iteration)
}
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">使用docker安装jenkins</title>
    <id>https://clay-wangzhi.com/automate/jenkins/docker-install-jenkins/</id>
    <link href="https://clay-wangzhi.com/automate/jenkins/docker-install-jenkins/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用docker安装jenkins"> 使用docker安装jenkins</h1>
<h2 id="安装配置docker"> 安装配置docker</h2>
<ol>
<li>
<p>更换yum源，如果本来就是国内源，无需更换</p>
<div><pre><code><span>curl</span> -fsSL <span>"https://gitee.com/clay-wangzhi/shell/raw/master/repo_replace.sh"</span> <span>|</span> <span>bash</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>安装配置Docker</p>
<p>使用官方脚本安装 Docker</p>
<div><pre><code><span>curl</span> -fsSL <span>"https://get.docker.com/"</span> <span>|</span> <span>bash</span> -s -- --mirror Aliyun
</code></pre>
<div><span>1</span><br></div></div><p>加载br_netfilter</p>
<div><pre><code>modprobe br_netfilter
</code></pre>
<div><span>1</span><br></div></div><p>设置下系统内核参数</p>
<div><pre><code>cat<span>&lt;&lt;</span><span>EOF<span> <span>></span> /etc/sysctl.d/docker.conf</span>
# 要求iptables不对bridge的数据进行处理
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-arptables = 1
# 开启转发
net.ipv4.ip_forward = 1
EOF</span>
sysctl -p /etc/sysctl.d/docker.conf
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>⚠️ 慎用<code>sysctl --system</code>命令，如果参数在不同文件中设置，会有优先级问题，目前看来<code>/etc/sysctl.conf</code>的优先级最高</p>
</blockquote>
<p>配置docker镜像加速器</p>
<div><pre><code><span>curl</span> -sSL https://get.daocloud.io/daotools/set_mirror.sh <span>|</span> <span>sh</span> -s http://f1361db2.m.daocloud.io
</code></pre>
<div><span>1</span><br></div></div><p>启动docker服务并加入开机自启</p>
<div><pre><code>systemctl <span>enable</span> docker <span>&amp;&amp;</span> systemctl start docker
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
<h2 id="安装配置nginx"> 安装配置nginx</h2>
<ol>
<li>
<p>新增nginx yum源</p>
<p>To set up the yum repository, create the file named <code>/etc/yum.repos.d/nginx.repo</code> with the following contents:</p>
<div><pre><code>[nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true

[nginx-mainline]
name=nginx mainline repo
baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/
gpgcheck=1
enabled=0
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
<li>
<p>安装&amp;&amp;启动nginx</p>
<div><pre><code>yum -y <span>install</span> nginx
nginx
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>配置hosts解析</p>
<div><pre><code><span>echo</span> <span>"127.0.0.1 www.google.com"</span> <span>>></span> /etc/hosts
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
<h2 id="安装配置jenkins"> 安装配置jenkins</h2>
<blockquote>
<p>⚠️ 执行此步骤前，需要先安装配置nginx，在container启动时network设置为host时，我更新主机的hosts文件后，发现容器内的hosts文件没有更新，当前docker版本为20.10.6</p>
</blockquote>
<ol>
<li>
<p>下载jenkins镜像</p>
<div><pre><code>docker pull jenkinsci/blueocean:1.24.6
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>创建挂载目录</p>
<div><pre><code><span>mkdir</span> -p /opt/jenkins-data
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>创建并启动jenkins</p>
<div><pre><code>docker run -u root --rm -d -e <span>JAVA_OPTS</span><span>=</span>-Duser.timezone<span>=</span>Asia/Shanghai --mount <span>type</span><span>=</span>bind,source<span>=</span>/opt/jenkins-data,target<span>=</span>/var/jenkins_home --network<span>=</span>host --name jenkins jenkinsci/blueocean:1.24.6
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>剩下的步骤按着提示完成就行，安装配置nginx的原因如下：</p>
<p>输入密码后第二步报”该Jenkins实例似乎已离线“，网上搜方案有两种：</p>
<p>1）更改插件下载源，具体步骤如下：</p>
<div><pre><code><span># 进入http://ip:8080/jenkins/pluginManager/advanced</span>
<span># 将最下面的 Update Site 的 URL 地址替换成：http://mirror.esuni.jp/jenkins/updates/update-center.json</span>
<span># 点“submit”按钮，然后点右下角角 “check now”</span>
<span># 然后输入地址 http://ip:8080/jenkins/restart 重启 jenkins 后再重新安装插件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>2）修改 /var/lib/jenkins/updates/default.json 文件中的 connectionCheckUrl 项值为国内可访问的地址。</p>
<p>经实验，两种方式都不能保证100% 初始化成功</p>
<p>方法一更新的是插件的下载源，但是我还没开始下载插件，只是下载插件前的检查网络；</p>
<p>方法二重启jenkins又被重置为谷歌域名。</p>
<p>考虑connectionCheckUrl 只是用来安装插件时检查网络是否ping通，因此直接在本机上给www.google.com 指向到本地，再给配一个nginx 响应即可</p>
</li>
</ol>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">01 Python基础语法</title>
    <id>https://clay-wangzhi.com/code/python/python-basic-grammar/</id>
    <link href="https://clay-wangzhi.com/code/python/python-basic-grammar/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_01-python基础语法"> 01 Python基础语法</h1>
<p>Python 语言 后续补充</p>
<p>计算机基础知识 后续补充</p>
<h2 id="python-解释器"> Python 解释器</h2>
<table>
<thead>
<tr>
<th>解释器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CPython</code></td>
<td>官方，C 语言开发，最广泛的 Python 解释器</td>
</tr>
<tr>
<td><code>IPython</code></td>
<td>一个交互式、功能增强的<code>CPython</code></td>
</tr>
<tr>
<td><code>PyPy</code></td>
<td>Python 语言写的 Python 解释器，<code>JIT</code>技术，动态编译 Python 代码</td>
</tr>
<tr>
<td><code>Jython</code></td>
<td>Python 的源代码编译成 Java 的字节码，跑在<code>JVM</code>上</td>
</tr>
<tr>
<td><code>IronPython</code></td>
<td>与<code>Jytho</code>n类似，运行在<code>.Net</code>平台上的解释器，Python 代码被编译成<code>.Net</code>的字节码</td>
</tr>
<tr>
<td><code>stackless</code></td>
<td>Python的增强版本解释器，不使用<code>CPython</code>的 C 的栈，采用微线程概念编程，并发编程</td>
</tr>
</tbody>
</table>
<h2 id="基础语法"> 基础语法</h2>
<h3 id="注释"> 注释</h3>
<p><code>#</code> 井号标注的文本</p>
<h3 id="数字"> 数字</h3>
<ul>
<li>
<p>整数<code>int</code></p>
<ul>
<li><code>Python3</code>开始不再区分 long 、int ，long 被重命名为int，所以只有 int 类型了</li>
<li>进制表示：
<ul>
<li>十进制10</li>
<li>十六进制0x10</li>
<li>八进制0o10</li>
<li>二进制0b10</li>
</ul>
</li>
<li>bool 类型，有2个值 True、False</li>
</ul>
</li>
<li>
<p>浮点数 float</p>
<ul>
<li>1.2、3.1415、-0.12、1.46e9等价于科学计数法1.46*10<sup>9</sup></li>
</ul>
</li>
<li>
<p>复数 complex</p>
<ul>
<li>1+2j 或 +2J</li>
</ul>
</li>
</ul>
<h3 id="字符串"> 字符串</h3>
<ul>
<li>使用‘ ”单双引号引用的字符的序列</li>
<li>'''和&quot;&quot;&quot; 单双三引号，可以跨行、可以在其中自由的使用单双引号</li>
<li>r 前缀：在字符串前面加上 r 或者 R 前缀，表示该字符串不做特殊的处理</li>
<li>f 前缀：3.6版本开始，新增 f 前缀，格式化字符串</li>
</ul>
<h3 id="转义序列"> 转义序列</h3>
<ul>
<li><code>\\</code> <code>\t</code> <code>\r</code> <code>\n</code> <code>\'</code> <code>\&quot;</code></li>
<li>上面每一个转义字符只代表一个字符，例如<code>\t</code>显示时占了4个字符位置，但是它是一个字符</li>
<li>前缀 r，把里面的所有字符当普通字符对待，则转义字符就不转义了</li>
</ul>
<p>转义：让字符不再是它当前的意义，例如 \t，t 就不是当前意义字符 t 了，而是被 \ 转成了 tab 键</p>
<h3 id="缩进"> 缩进</h3>
<ul>
<li>未使用 C 等语言的花括号，而是采用缩进的方式表示层次关系</li>
<li>约定使用4个空格缩进</li>
</ul>
<h3 id="续行"> 续行</h3>
<ul>
<li>在行尾使用 \，注意 \ 之后除了紧跟着换行之外不能有其他字符</li>
<li>如果使用各种括号，认为括号内是一个整体，其内部跨行不用 \</li>
</ul>
<h3 id="标识符"> 标识符</h3>
<p><strong>标识符</strong></p>
<ol>
<li>一个名字，用来指代一个值</li>
<li>只能是字母、下划线和数字</li>
<li>只能以字母或下划线开头</li>
<li>不能是 python 的关键字，例如 def、class 就不能作为标识符</li>
<li>Python 是大小写敏感的</li>
</ol>
<p>标识符约定：</p>
<ul>
<li>不允许使用中文，也不建议使用拼音</li>
<li>不要使用歧义单词，例如class_</li>
<li>在python中不要随便使用下划线开头的标识符</li>
</ul>
<p><strong>常量</strong></p>
<ul>
<li>一旦赋值不能改变值的标识符</li>
<li>python中无法定义常量</li>
</ul>
<p><strong>字面常量</strong></p>
<ul>
<li>一个单独的不可变量，例如 12、&quot;abc&quot; 、'2341356514.03e-9'</li>
</ul>
<p><strong>变量</strong></p>
<ul>
<li>赋值后，可以改变值的标识符</li>
</ul>
<p><strong>标识符本质</strong></p>
<p>每一个标识符对应一个具有数据结构的值，但是这个值不方便直接访问，程序员就可以通过其对应的标
识符来访问数据，标识符就是一个指代。一句话，标识符是给程序员编程使用的。</p>
<h3 id="语言类型"> 语言类型</h3>
<blockquote>
<p>详见 https://wiki.clay-wangzhi.com/23-wei-fen-lei/bian-cheng-yu-yan-de-fen-lei</p>
</blockquote>
<h3 id="false-等价"> False 等价</h3>
<table>
<thead>
<tr>
<th>对象/常量</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>&quot;&quot;</td>
<td>假</td>
</tr>
<tr>
<td>“string”</td>
<td>真</td>
</tr>
<tr>
<td>0</td>
<td>假</td>
</tr>
<tr>
<td>&gt;=1</td>
<td>真</td>
</tr>
<tr>
<td>&lt;=-1</td>
<td>真</td>
</tr>
<tr>
<td>()空元组</td>
<td>假</td>
</tr>
<tr>
<td>[]空列表</td>
<td>假</td>
</tr>
<tr>
<td>{}空字典</td>
<td>假</td>
</tr>
<tr>
<td>None</td>
<td>假</td>
</tr>
</tbody>
</table>
<p>False 等价布尔值，相当于<code>bool(value)</code></p>
<ul>
<li>空容器
<ul>
<li>空集合 set</li>
<li>空字典 dict</li>
<li>空列表 list</li>
<li>空元组 tuple</li>
</ul>
</li>
<li>空字符串</li>
<li>None</li>
<li>0</li>
</ul>
<h3 id="逻辑运算真值表"> 逻辑运算真值表</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/log_op.png" alt="log_ope" /></p>
<h3 id="运算符-operator"> 运算符 Operator</h3>
<p><strong>算数运算符</strong></p>
<p>+、-、*、/、//向下取整整除、%取模、**幂</p>
<p>注：在<code>Python2</code>中/和//都是整除。</p>
<p><strong>位运算符</strong></p>
<p>&amp;位与、|位或、^异或、&lt;&lt;左移、&gt;&gt;右移</p>
<p>~按位取反，包括符号位</p>
<p><strong>比较运算符</strong></p>
<p>==、!=、&gt;、&gt;=、&lt;、&lt;=</p>
<p>链式比较： 4 &gt; 3 &gt; 2</p>
<p><strong>逻辑运算符</strong></p>
<p>与and、或or、非not</p>
<p>逻辑运算符也是短路运算符</p>
<ul>
<li>
<p>and 如果前面的表达式等价为False，后面就没有必要计算了，这个逻辑表达式最终一定等价为
False
1 and '2' and 0
0 and 'abc' and 1</p>
</li>
<li>
<p>or 如果前面的表达式等价为True，后面没有必要计算了，这个逻辑表达式最终一定等价为True
1 or False or None</p>
</li>
<li>
<p>特别注意，返回值。返回值不一定是 bool 型</p>
</li>
<li>
<p>把最频繁使用的，做最少计算就可以知道结果的条件放到前面，如果它能短路，将大大减少计算量</p>
</li>
</ul>
<p><strong>赋值运算符</strong></p>
<p>a = min(3, 5)</p>
<p>+=、 -= 、*=、/=、%=、//= 等</p>
<p>x = y = z = 10</p>
<p><strong>成员运算符</strong></p>
<p>in、not in</p>
<p><strong>身份运算符</strong></p>
<p>is、is not</p>
<h3 id="运算符优先级"> 运算符优先级</h3>
<ul>
<li>单目运算符 &gt; 双目运算符</li>
<li>算数运算符 &gt; 位运算符 &gt; 比较运算符 &gt; 逻辑运算符
<ul>
<li>-3 + 2 &gt; 5 and 'a' &gt; 'b'</li>
</ul>
</li>
</ul>
<p>搞不清楚就使用括号。长表达式，多用括号，易懂、易读。</p>
<h3 id="表达式"> 表达式</h3>
<p>由数字、符号、括号、变量等的组合。有算数表达式、逻辑表达式、赋值表达式、lambda 表达式等
等。</p>
<p>Python 中，赋值即定义。Python 是动态语言，只有赋值才会创建一个变量，并决定了变量的类型和
值。</p>
<p>如果一个变量已经定义，赋值相当于重新定义。</p>
<h2 id="内建函数"> 内建函数</h2>
<table>
<thead>
<tr>
<th>内建函数</th>
<th>函数签名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>print</td>
<td>print(value, ..., sep=' ', end='\n')</td>
<td>将多个数据输出到控制台，默认使用空格分隔、\n 换行</td>
</tr>
<tr>
<td>input</td>
<td>input([prompt])</td>
<td>在控制台和用户交互，接收用户输入，并返回字符串</td>
</tr>
<tr>
<td>int</td>
<td>int(value)</td>
<td>将给定的值，转换成整数。int 本质是类</td>
</tr>
<tr>
<td>str</td>
<td>str(value)</td>
<td>将给定的值，转换成字符串。str 本质是元类</td>
</tr>
<tr>
<td>type</td>
<td>type(value)</td>
<td>返回对象的类型。本质是元类</td>
</tr>
<tr>
<td>isinstance</td>
<td>isinstance(obj, class_or_tuple)</td>
<td>比较对象的类型，类型可以是 obj 的基类</td>
</tr>
</tbody>
</table>
<div><pre><code><span>print</span><span>(</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span>sep<span>=</span><span>'\n'</span><span>,</span> end<span>=</span><span>'***'</span><span>)</span>

<span>type</span><span>(</span><span>1</span><span>)</span> <span># 返回的是类型，不是字符串</span>
<span>type</span><span>(</span><span>'abc'</span><span>)</span> <span># 返回的是类型，不是字符串</span>
<span>type</span><span>(</span><span>int</span><span>)</span> <span># 返回type，意思是这个int类型由type构造出来</span>
<span>type</span><span>(</span><span>str</span><span>)</span> <span># 返回type，也是类型</span>
<span>type</span><span>(</span><span>type</span><span>)</span> <span># 也是type</span>

<span>print</span><span>(</span><span>isinstance</span><span>(</span><span>1</span><span>,</span> <span>int</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>isinstance</span><span>(</span><span>False</span><span>,</span> <span>int</span><span>)</span><span>)</span> <span># True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="程序控制"> 程序控制</h2>
<ul>
<li>顺序
<ul>
<li>按照先后顺序一条条执行
例如，先洗手，再吃饭，再洗碗</li>
</ul>
</li>
<li>分支
<ul>
<li>根据不同的情况判断，条件满足执行某条件下的语句
例如，先洗手，如果饭没有做好，玩游戏；如果饭做好了，就吃饭；如果饭都没有做，叫外卖</li>
</ul>
</li>
<li>循环
<ul>
<li>条件满足就反复执行，不满足就不执行或不再执行
例如，先洗手，看饭好了没有，没有好，一会来看一次是否好了，一会儿来看一次，直到饭
好了，才可是吃饭。这里循环的条件是饭没有好，饭没有好，就循环的来看饭好了没有</li>
</ul>
</li>
</ul>
<h3 id="单分支"> 单分支</h3>
<div><pre><code><span>if</span> condition<span>:</span>
    代码块
    

<span>if</span> <span>1</span><span>&lt;</span><span>2</span><span>:</span> <span># if True:</span>
    <span>print</span><span>(</span><span>'1 less than 2'</span><span>)</span> <span># 代码块</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>condition 必须是一个 bool 类型，这个地方有一个隐式转换 bool(condition) ，相当于 False 等价</li>
<li>if 语句这行最后，会有一个冒号，冒号之后如果有多条语句的代码块，需要另起一行，并缩进
<ul>
<li>if、for、def、class等关键字后面都可以跟代码块</li>
<li>这些关键后面，如果有一条语句，也可以跟在这一行后面。例如 <code>if 1&gt;2: pass</code></li>
</ul>
</li>
</ul>
<h3 id="多分支"> 多分支</h3>
<div><pre><code><span>if</span> condition1<span>:</span>
    代码块<span>1</span>
<span>elif</span> condition2<span>:</span>
    代码块<span>2</span>
<span>elif</span> condition3<span>:</span>
    代码块<span>3</span>
<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>else</span><span>:</span>
    代码块
    

   
a <span>=</span> <span>5</span>
<span>if</span> a<span>&lt;</span><span>0</span><span>:</span>
    <span>print</span><span>(</span><span>'negative'</span><span>)</span>
<span>elif</span> a<span>==</span><span>0</span><span>:</span> <span># 相当于 a >= 0</span>
    <span>print</span><span>(</span><span>'zero'</span><span>)</span>
<span>else</span><span>:</span> <span># 相当于 a > 0</span>
    <span>print</span><span>(</span><span>'positive'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ul>
<li>多分支结构，只要有一个分支被执行，其他分支都不会被执行</li>
<li>前一个条件被测试过，下一个条件相当于隐含着这个条件</li>
</ul>
<div><pre><code><span># 嵌套</span>
a <span>=</span> <span>5</span>
<span>if</span> a <span>==</span> <span>0</span><span>:</span>
    <span>print</span><span>(</span><span>'zero'</span><span>)</span>
<span>else</span><span>:</span>
    <span>if</span> a <span>&lt;</span> <span>0</span><span>:</span>
    <span>print</span><span>(</span><span>'negative'</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>'positive'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="while-循环"> while 循环</h3>
<p>while循环多用于死循环，或者不明确知道循环次数的场景</p>
<div><pre><code><span>while</span> cond<span>:</span>
    block

    
<span>while</span> <span>True</span><span>:</span> <span># 死循环</span>
    <span>pass</span>

a <span>=</span> <span>10</span>
<span>while</span> a<span>:</span> <span># 条件满足则进入循环</span>
    <span>print</span><span>(</span>a<span>)</span>
    a <span>-=</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="for-语句"> for 语句</h3>
<div><pre><code><span>for</span> element <span>in</span> iterable<span>:</span>
    block
   
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> <span>10</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>i<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><table>
<thead>
<tr>
<th>内建函数</th>
<th>函数签名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>range</td>
<td>range(stop)<br />range(start, stop, [step])</td>
<td>返回惰性的对象<br/>可以生成一个序列，遍历它就可以得到这个序列的一个个元素<br/>前包后不包</td>
</tr>
</tbody>
</table>
<h3 id="continue"> continue</h3>
<p>跳过当前循环的当次循环，继续下一次循环</p>
<div><pre><code><span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> <span>10</span><span>)</span><span>:</span>
    <span>if</span> i <span>%</span> <span>2</span> <span>!=</span> <span>0</span><span>:</span> <span>continue</span>
    <span>print</span><span>(</span>i<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="break"> break</h3>
<p>结束当前循环</p>
<div><pre><code><span># 计算1000以内的被7整除的前20个正整数</span>
count <span>=</span> <span>0</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>7</span><span>,</span> <span>1000</span><span>,</span> <span>7</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>i<span>)</span>
	count <span>+=</span> <span>1</span>
	<span>if</span> count <span>>=</span> <span>20</span><span>:</span>
		<span>print</span><span>(</span>count<span>)</span>
		<span>break</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>总结</p>
<ul>
<li>continue 和 break 是循环的控制语句，只影响当前循环，包括 while、for 循环</li>
<li>如果循环嵌套， continue 和 break 也只影响语句所在的那一层循环</li>
<li>continue 和 break 只影响循环，所以<code>if cond: break</code>不是跳出 if，而是终止 if 外的 break 所在的循环</li>
<li>分支和循环结构可以嵌套使用，可以嵌套多层</li>
</ul>
<h3 id="else-字句"> else 字句</h3>
<p>如果循环正常结束，else子句会被执行，即使是可迭代对象没有什么元素可迭代</p>
<div><pre><code><span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>)</span><span>:</span> <span># 可迭代对象没有迭代</span>
    <span>pass</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>'ok'</span><span>)</span>
    
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> <span>10</span><span>)</span><span>:</span>
    <span>break</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>'ok'</span><span>)</span>
    
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> <span>10</span><span>)</span><span>:</span>
    <span>continue</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>'ok'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>有上例可知，一般情况下，循环正常执行，只要当前循环不是被break打断的，就可以执行else子句。
哪怕是range(0)也可以执行else子句。</p>
<h3 id="三元表达式"> 三元表达式</h3>
<p>在Python中，也有类似C语言的三目运算符构成的表达式，但python中的三元表达式不支持复杂的语句</p>
<div><pre><code>真值表达式 <span>if</span> 条件表达式 <span>else</span> 假值表达式
</code></pre>
<div><span>1</span><br></div></div><p>三元表达式比较适合简化非常简单的if-else语句</p>
<div><pre><code><span># 判断用户的输入的值，如果为空，输出"empty"，否则输出该值</span>

value <span>=</span> <span>input</span><span>(</span><span>'>>>'</span><span>)</span>
<span>if</span> value<span>:</span>
    <span>print</span><span>(</span>value<span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>'empty'</span><span>)</span>
   
value <span>=</span> <span>input</span><span>(</span><span>'>>>'</span><span>)</span>
<span>print</span><span>(</span>value <span>if</span> value <span>else</span> <span>'empty'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">05 装饰器</title>
    <id>https://clay-wangzhi.com/code/python/python-decorator/</id>
    <link href="https://clay-wangzhi.com/code/python/python-decorator/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_05-装饰器"> 05 装饰器</h1>
<h2 id="高阶函数"> 高阶函数</h2>
<p><strong>一等共民</strong></p>
<ul>
<li>函数在Python是一等公民（First-Class Object）</li>
<li>函数也是对象，是可调用对象</li>
<li>函数可以作为普通变量，也可以作为函数的参数、返回值</li>
</ul>
<p><strong>高级函数</strong></p>
<p>高阶函数（High-order Function）</p>
<ul>
<li>数学概念 y = f(g(x))</li>
<li>在数学和计算机科学中，高阶函数应当是至少满足下面一个条件的函数
<ul>
<li>接受一个或多个函数作为参数</li>
<li>输出一个函数</li>
</ul>
</li>
</ul>
<div><pre><code><span>def</span> <span>counter</span><span>(</span>base<span>)</span><span>:</span>
    <span>def</span> <span>inc</span><span>(</span>step<span>=</span><span>1</span><span>)</span><span>:</span> <span># 有没有闭包？</span>
        <span>nonlocal</span> base <span># 形参base也是外部函数counter的local变量</span>
        base <span>+=</span> step
        <span>return</span> base
    <span>return</span> inc
c1 <span>=</span> counter<span>(</span><span>5</span><span>)</span>
<span>print</span><span>(</span>c1<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span>c1<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span>c1<span>(</span><span>)</span><span>)</span>
c2 <span>=</span> counter<span>(</span><span>5</span><span>)</span>
<span>print</span><span>(</span>c2<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span>c1 <span>==</span> c2<span>)</span> <span># 相等吗？ 不相等，两个不同的实例</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="柯里化"> 柯里化</h2>
<ul>
<li>指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数</li>
<li>z = f(x, y) 转换成 z = f(x)(y) 的形式</li>
</ul>
<p>例如</p>
<div><pre><code><span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>return</span> x <span>+</span> y
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>原来函数调用为 add(4, 5) ，柯里化目标是 add(4)(5) 。如何实现？</p>
<p>每一次括号说明是函数调用，说明 add(4)(5) 是2次函数调用。</p>
<div><pre><code>add(4)(5)
等价于
t = add(4)
t(5)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>也就是说add(4)应该返回函数</p>
<div><pre><code><span>def</span> <span>add</span><span>(</span>x<span>)</span><span>:</span>
    <span>def</span> <span>_add</span><span>(</span>y<span>)</span><span>:</span>
        <span>return</span> x <span>+</span> y
    <span>return</span> _add
<span>print</span><span>(</span>add<span>(</span><span>100</span><span>)</span><span>(</span><span>200</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>通过嵌套函数就可以把函数转成柯里化函数。</p>
<h2 id="时间模块"> 时间模块</h2>
<h3 id="datetime-模块"> datetime 模块</h3>
<p>datetime类</p>
<ul>
<li>时间高级类</li>
<li>类方法，即使用类调用的方法，由类方法获得一个时间对象
<ul>
<li>now(tz=None) 返回当前时间的datetime对象，时间到微秒，如果tz为None，返回当前时区的不带时区信息的时间</li>
<li>utcnow() 不带时区的0时区时间</li>
<li>fromtimestamp(timestamp, tz=None) 从一个时间戳返回一个datetime对象</li>
</ul>
</li>
<li>时间对象方法
<ul>
<li>timestamp() 返回一个到微秒的时间戳
<ul>
<li>时间戳：格林威治时间1970年1月1日0点到现在的秒数</li>
</ul>
</li>
<li>构造方法 datetime.datetime(2016, 12, 6, 16, 29, 43, 79043)</li>
<li>year、month、day、hour、minute、second、microsecond，取datetime对象的年月日时分秒及微秒</li>
<li>weekday() 返回星期的天，周一0，周日6</li>
<li>isoweekday() 返回星期的天，周一1，周日7</li>
<li>date() 返回日期date对象</li>
<li>time() 返回时间time对象</li>
</ul>
</li>
</ul>
<div><pre><code><span>import</span> datetime

<span># 类方法获得时间对象</span>
<span>print</span><span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span>datetime<span>.</span>timezone<span>(</span>datetime<span>.</span>timedelta<span>(</span>hours<span>=</span><span>8</span><span>)</span><span>)</span><span>)</span><span>)</span> <span># 时区时间</span>
<span>print</span><span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span><span>)</span> <span># 无时区时间</span>
<span>print</span><span>(</span>datetime<span>.</span>datetime<span>.</span>utcnow<span>(</span><span>)</span><span>)</span> <span># UTC时间，可以认为是GMT或0时区时间</span>

<span># 时间戳操作</span>
stamp <span>=</span> datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span><span>.</span>timestamp<span>(</span><span>)</span> <span># 获得时间戳</span>
<span>print</span><span>(</span>stamp<span>)</span>
dt <span>=</span> datetime<span>.</span>datetime<span>.</span>fromtimestamp<span>(</span>stamp<span>)</span> <span># 从时间戳获得时间对象</span>
<span>print</span><span>(</span>dt<span>)</span>

<span>print</span><span>(</span><span>type</span><span>(</span>dt<span>.</span>date<span>(</span><span>)</span><span>)</span><span>,</span> dt<span>.</span>date<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>type</span><span>(</span>dt<span>.</span>time<span>(</span><span>)</span><span>)</span><span>,</span> dt<span>.</span>time<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="日期与格式化"> 日期与格式化</h3>
<ul>
<li>类方法 strptime(date_string, format) ，返回datetime对象（时间字符串+格式化字符串 =&gt; 时间对象）</li>
<li>对象方法 strftime(format) ，返回字符串（时间对象通过格式字符串 =&gt; 时间字符串）</li>
<li>字符串format函数格式化（时间对象通过格式字符串 =&gt; 时间字符串）</li>
</ul>
<div><pre><code><span>import</span> datetime

datestr <span>=</span> <span>'2018-01-10 17:16:08'</span>
dt <span>=</span> datetime<span>.</span>datetime<span>.</span>strptime<span>(</span>datestr<span>,</span> <span>'%Y-%m-%d %H:%M:%S'</span><span>)</span> <span>#由字符串到时间对象</span>
<span>print</span><span>(</span><span>type</span><span>(</span>dt<span>)</span><span>,</span> dt<span>)</span>
<span>print</span><span>(</span>dt<span>.</span>strftime<span>(</span><span>'%Y/%m/%d-%H:%M:%S'</span><span>)</span><span>)</span> <span># 输出为字符串</span>
<span>print</span><span>(</span><span>"{:%Y/%m/%d %H:%M:%S}"</span><span>.</span><span>format</span><span>(</span>dt<span>)</span><span>)</span> <span># 输出为字符串</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="timedelta-类"> timedelta 类</h3>
<ul>
<li>datetime2 = datetime1 + timedelta</li>
<li>datetime2 = datetime1 - timedelta</li>
<li>timedelta = datetime1 - datetime2</li>
<li>构造方法
<ul>
<li>datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0,hours=0, weeks=0)</li>
<li>year = datetime.timedelta(days=365)</li>
</ul>
</li>
<li>timedelta对象有方法total_seconds()， 返回<strong>时间差的总秒数</strong></li>
</ul>
<h3 id="time-模块"> time 模块</h3>
<ul>
<li>time.sleep(secs) 将调用线程挂起指定的秒数</li>
</ul>
<h2 id="装饰器"> 装饰器</h2>
<h3 id="由来"> 由来</h3>
<p>需求：为一个加法函数增加记录实参的功能</p>
<div><pre><code><span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'add called. x={}, y={}'</span><span>.</span><span>format</span><span>(</span>x<span>,</span> y<span>)</span><span>)</span> <span># 增加的记录功能</span>
    <span>return</span> x <span>+</span> y

add<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的代码满足了需求，但有缺点：</p>
<p>记录信息的功能，可以是一个单独的功能。显然和add函数耦合太紧密。加法函数属于业务功能，输出信息属于非功能代码，不该放在add函数中</p>
<p>1、提供一个函数logger完成记录功能</p>
<div><pre><code><span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>return</span> x <span>+</span> y

<span>def</span> <span>logger</span><span>(</span>fn<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'调用前增强'</span><span>)</span>
    ret <span>=</span> fn<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
    <span>print</span><span>(</span><span>'调用后增强'</span><span>)</span>
    <span>return</span> ret

<span>print</span><span>(</span>logger<span>(</span>add<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>2、改进传参</p>
<div><pre><code><span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>return</span> x <span>+</span> y

<span>def</span> <span>logger</span><span>(</span>fn<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'调用前增强'</span><span>)</span>
    ret <span>=</span> fn<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>
    <span>print</span><span>(</span><span>'调用后增强'</span><span>)</span>
    <span>return</span> ret

<span>print</span><span>(</span>logger<span>(</span>add<span>,</span> <span>4</span><span>,</span> <span>5</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>3、柯里化</p>
<div><pre><code><span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>return</span> x <span>+</span> y

<span>def</span> <span>logger</span><span>(</span>fn<span>)</span><span>:</span>
    <span>def</span> <span>wrapper</span><span>(</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'调用前增强'</span><span>)</span>
        ret <span>=</span> fn<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>
        <span>print</span><span>(</span><span>'调用后增强'</span><span>)</span>
        <span>return</span> ret
    <span>return</span> wrapper

inner <span>=</span> logger<span>(</span>add<span>)</span>
x <span>=</span> inner<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
<span>print</span><span>(</span>x<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>再进一步</p>
<div><pre><code><span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>return</span> x <span>+</span> y

<span>def</span> <span>logger</span><span>(</span>fn<span>)</span><span>:</span>
    <span>def</span> <span>wrapper</span><span>(</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'调用前增强'</span><span>)</span>
        ret <span>=</span> fn<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>
        <span>print</span><span>(</span><span>'调用后增强'</span><span>)</span>
        <span>return</span> ret
    <span>return</span> wrapper

add <span>=</span> logger<span>(</span>add<span>)</span>
<span>print</span><span>(</span>add<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>4、装饰器语法</p>
<div><pre><code><span>def</span> <span>logger</span><span>(</span>fn<span>)</span><span>:</span>
    <span>def</span> <span>wrapper</span><span>(</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'调用前增强'</span><span>)</span>
        ret <span>=</span> fn<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>
        <span>print</span><span>(</span><span>'调用后增强'</span><span>)</span>
        <span>return</span> ret
    <span>return</span> wrapper

<span>@logger</span> <span># 等价于 add = wrapper &lt;=> add = logger(add)</span>
<span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>return</span> x <span>+</span> y

<span>print</span><span>(</span>add<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>@logger就是装饰器语法</p>
<p><em><strong>等价式非常重要，如果你不能理解装饰器，开始的时候一定要把等价式写在后面</strong></em></p>
<h3 id="无参装饰器"> 无参装饰器</h3>
<ul>
<li>上例的装饰器语法，称为无参装饰器</li>
<li>@符号后是一个函数</li>
<li>虽然是无参装饰器，但是@后的函数本质上是单参函数</li>
<li>上例的 logger 函数是一个高阶函数</li>
</ul>
<h3 id="日志记录装饰器实现"> 日志记录装饰器实现</h3>
<div><pre><code><span>import</span> time
<span>import</span> datetime

<span>def</span> <span>logger</span><span>(</span>fn<span>)</span><span>:</span>
    <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'调用前增强'</span><span>)</span>
        start <span>=</span> datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span>
        ret <span>=</span> fn<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span> <span># 参数解构</span>
        <span>print</span><span>(</span><span>'调用后增强'</span><span>)</span>
        delta <span>=</span> <span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span> <span>-</span> start<span>)</span><span>.</span>total_seconds<span>(</span><span>)</span>
        <span>print</span><span>(</span><span>'Function {} took {}s.'</span><span>.</span><span>format</span><span>(</span>fn<span>.</span>__name__<span>,</span> delta<span>)</span><span>)</span>
        <span>return</span> ret
    <span>return</span> wrapper

<span>@logger</span> <span># 等价于 add = wrapper &lt;=> add = logger(add)</span>
<span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>return</span> x <span>+</span> y

<span>print</span><span>(</span>add<span>(</span><span>100</span><span>,</span> <span>200</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="文档字符串"> 文档字符串</h3>
<ul>
<li>Python 文档字符串 Documentation Strings</li>
<li>在函数（类、模块）语句块的第一行，且习惯是多行的文本，所以多使用三引号</li>
<li>文档字符串也算是合法的一条语句</li>
<li>惯例是首字母大写，第一行写概述，空一行，第三行写详细描述</li>
<li>可以使用特殊属性__doc__访问这个文档</li>
</ul>
<div><pre><code><span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>"""这是加法函数的文档"""</span>
    <span>return</span> x <span>+</span> y

<span>print</span><span>(</span><span>"{}'s doc = {}"</span><span>.</span><span>format</span><span>(</span>add<span>.</span>__name__ <span>,</span> add<span>.</span>__doc__<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>import</span> time
<span>import</span> datetime

<span>def</span> <span>logger</span><span>(</span>fn<span>)</span><span>:</span>
    <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span>'''wrapper's doc'''</span>
        <span>print</span><span>(</span><span>'调用前增强'</span><span>)</span>
        start <span>=</span> datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span>
        ret <span>=</span> fn<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span> <span># 参数解构</span>
        <span>print</span><span>(</span><span>'调用后增强'</span><span>)</span>
        delta <span>=</span> <span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span> <span>-</span> start<span>)</span><span>.</span>total_seconds<span>(</span><span>)</span>
        <span>print</span><span>(</span><span>'Function {} took {}s.'</span><span>.</span><span>format</span><span>(</span>fn<span>.</span>__name__<span>,</span> delta<span>)</span><span>)</span>
        <span>return</span> ret
    <span>return</span> wrapper

<span>@logger</span> <span># 等价于 add = wrapper &lt;=> add = logger(add)</span>
<span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>'''add's doc'''</span>
    time<span>.</span>sleep<span>(</span><span>0.1</span><span>)</span>
    <span>return</span> x <span>+</span> y

<span>print</span><span>(</span>add<span>(</span><span>100</span><span>,</span> <span>200</span><span>)</span><span>)</span>

<span>print</span><span>(</span><span>"name={}, doc={}"</span><span>.</span><span>format</span><span>(</span>add<span>.</span>__name__<span>,</span> add<span>.</span>__doc__<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>被装饰后，函数名和文档都不对了。如何解决？</p>
<p><strong>functools模块</strong>提供了一个wraps装饰器函数，本质上调用的是update_wrapper，它就是一个属性复制函数。</p>
<p>wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)</p>
<ul>
<li>wrapped 就是被包装函数</li>
<li>wrapper 就是包装函数</li>
<li>用被包装函数的属性覆盖包装函数的同名属性</li>
<li>元组 WRAPPER_ASSIGNMENTS 中是要被覆盖的属性
<ul>
<li><code>__module__</code> ,  <code>__name__</code> ,  <code>__qualname__</code> ,  <code>__doc__</code> ,  <code>__annotations__</code></li>
<li>模块名、名称、限定名、文档、参数注解</li>
</ul>
</li>
</ul>
<div><pre><code><span>import</span> time
<span>import</span> datetime
<span>from</span> functools <span>import</span> wraps

<span>def</span> <span>logger</span><span>(</span>fn<span>)</span><span>:</span>
    <span>@wraps</span><span>(</span>fn<span>)</span> <span># 用被包装函数fn的属性覆盖包装函数wrapper的同名属性</span>
    <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span>'''wrapper's doc'''</span>
        <span>print</span><span>(</span><span>'调用前增强'</span><span>)</span>
        start <span>=</span> datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span>
        ret <span>=</span> fn<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span> <span># 参数解构</span>
        <span>print</span><span>(</span><span>'调用后增强'</span><span>)</span>
        delta <span>=</span> <span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span> <span>-</span> start<span>)</span><span>.</span>total_seconds<span>(</span><span>)</span>
        <span>print</span><span>(</span><span>'Function {} took {}s.'</span><span>.</span><span>format</span><span>(</span>fn<span>.</span>__name__<span>,</span> delta<span>)</span><span>)</span>
        <span>return</span> ret
    <span>return</span> wrapper

<span>@logger</span> <span># 等价于 add = wrapper &lt;=> add = logger(add)</span>
<span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>'''add's doc'''</span>
    time<span>.</span>sleep<span>(</span><span>0.1</span><span>)</span>
    <span>return</span> x <span>+</span> y

<span>print</span><span>(</span>add<span>(</span><span>100</span><span>,</span> <span>200</span><span>)</span><span>)</span>

<span>print</span><span>(</span><span>"name={}, doc={}"</span><span>.</span><span>format</span><span>(</span>add<span>.</span>__name__<span>,</span> add<span>.</span>__doc__<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id="带参装饰器"> 带参装饰器</h3>
<ul>
<li>@之后不是一个单独的标识符，是一个函数调用</li>
<li>函数调用的返回值又是一个函数，此函数是一个无参装饰器</li>
<li>带参装饰器，可以有任意个参数
<ul>
<li>@func()</li>
<li>@func(1)</li>
<li>@func(1, 2)</li>
</ul>
</li>
</ul>
<h3 id="进阶"> 进阶</h3>
<div><pre><code><span>import</span> datetime
<span>from</span> functools <span>import</span> wraps

<span>def</span> <span>logger</span><span>(</span>fn<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'logger run'</span><span>)</span>
    <span>@wraps</span><span>(</span>fn<span>)</span> <span># 用被包装函数fn的属性覆盖包装函数wrapper的同名属性</span>
    <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span> <span># wrapper = wraps(fn)(wrapper)</span>
        <span>"wrapper's doc"</span>
        <span>print</span><span>(</span><span>'wrapper run'</span><span>)</span>
        start <span>=</span> datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span>
        ret <span>=</span> fn<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span> <span># 参数解构</span>
        delta <span>=</span> <span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span> <span>-</span> start<span>)</span><span>.</span>total_seconds<span>(</span><span>)</span>
        <span>print</span><span>(</span><span>'Function {} took {}s.'</span><span>.</span><span>format</span><span>(</span>fn<span>.</span>__name__<span>,</span> delta<span>)</span><span>)</span>
        <span>return</span> ret
    <span>return</span> wrapper

<span>@logger</span> <span># 等价于 add = wrapper &lt;=> add = logger(add)</span>
<span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>"""add function"""</span>

<span>@logger</span>
<span>def</span> <span>sub</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>"""sub function"""</span>

<span>print</span><span>(</span>add<span>.</span>__name__<span>,</span> sub<span>.</span>__name__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><ul>
<li>logger 什么时候执行？  从上到下执行</li>
<li>logger 执行过几次？ 两次</li>
<li>wraps 装饰器执行过几次？ 两次 ， 也是进入函数，从上到下依次执行，函数没调用前，跳过函数部分代码</li>
<li>wrapper 的 <code>__name__</code> 等属性被覆盖过几次？ 两次</li>
<li><code>add.__name__</code> 打印什么名称？add</li>
<li><code>sub.__name__</code> 打印什么名称？sub</li>
</ul>
<h2 id="内建函数"> 内建函数</h2>
<h3 id="排序-sorted"> 排序 sorted</h3>
<p>定义 <code>sorted(iterable, *, key=None, reverse=False) -&gt;list</code></p>
<p>key 需要为 可调用的，如函数</p>
<div><pre><code><span>sorted</span><span>(</span>lst<span>,</span> key<span>=</span><span>lambda</span> x<span>:</span><span>6</span><span>-</span>x<span>)</span> <span># 返回新列表</span>
<span>list</span><span>.</span>sort<span>(</span>key<span>=</span><span>lambda</span> x<span>:</span> <span>6</span><span>-</span>x<span>)</span> <span># 就地修改</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="过滤-filter"> 过滤 filter</h3>
<ul>
<li>定义 filter(function, iterable)</li>
<li>对可迭代对象进行遍历，返回一个迭代器</li>
<li>function 参数是一个参数的函数，且返回值应当是 bool 类型，或其返回值等效布尔值。</li>
<li>function 参数如果是 None，可迭代对象的每一个元素自身等效布尔值</li>
</ul>
<div><pre><code><span>print</span><span>(</span><span>list</span><span>(</span><span>filter</span><span>(</span><span>lambda</span> x<span>:</span> x<span>%</span><span>3</span><span>==</span><span>0</span><span>,</span> <span>[</span><span>1</span><span>,</span><span>9</span><span>,</span><span>55</span><span>,</span><span>150</span><span>,</span><span>-</span><span>3</span><span>,</span><span>78</span><span>,</span><span>28</span><span>,</span><span>123</span><span>]</span><span>)</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>list</span><span>(</span><span>filter</span><span>(</span><span>None</span><span>,</span> <span>range</span><span>(</span><span>5</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>list</span><span>(</span><span>filter</span><span>(</span><span>None</span><span>,</span> <span>range</span><span>(</span><span>-</span><span>5</span><span>,</span> <span>5</span><span>)</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="映射-map"> 映射 map</h3>
<ul>
<li>定义 map(function, *iterables) -&gt; map object</li>
<li>对多个可迭代对象的元素，按照指定的函数进行映射</li>
<li>返回一个迭代器</li>
</ul>
<div><pre><code><span>print</span><span>(</span><span>list</span><span>(</span><span>map</span><span>(</span><span>lambda</span> x<span>:</span> <span>2</span><span>*</span>x<span>+</span><span>1</span><span>,</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>dict</span><span>(</span><span>map</span><span>(</span><span>lambda</span> x<span>:</span> <span>(</span>x<span>%</span><span>5</span><span>,</span> x<span>)</span><span>,</span> <span>range</span><span>(</span><span>500</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>dict</span><span>(</span><span>map</span><span>(</span><span>lambda</span> x<span>,</span>y<span>:</span> <span>(</span>x<span>,</span>y<span>)</span><span>,</span> <span>'abcde'</span><span>,</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="拉链函数-zip"> 拉链函数 zip</h3>
<ul>
<li>zip(*iterables)</li>
<li>像拉链一样，把多个可迭代对象合并在一起，返回一个迭代器</li>
<li>将每次从不同对象中取到的元素合并成一个元组</li>
</ul>
<div><pre><code><span>print</span><span>(</span><span>list</span><span>(</span><span>zip</span><span>(</span><span>range</span><span>(</span><span>10</span><span>)</span><span>,</span><span>range</span><span>(</span><span>10</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>list</span><span>(</span><span>zip</span><span>(</span><span>range</span><span>(</span><span>10</span><span>)</span><span>,</span><span>range</span><span>(</span><span>10</span><span>)</span><span>,</span><span>range</span><span>(</span><span>5</span><span>)</span><span>,</span><span>range</span><span>(</span><span>10</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>dict</span><span>(</span><span>zip</span><span>(</span><span>range</span><span>(</span><span>10</span><span>)</span><span>,</span><span>range</span><span>(</span><span>10</span><span>)</span><span>)</span><span>)</span><span>)</span>

d1 <span>=</span> <span>{</span><span>str</span><span>(</span>x<span>)</span><span>:</span>y <span>for</span> x<span>,</span>y <span>in</span> <span>zip</span><span>(</span><span>range</span><span>(</span><span>10</span><span>)</span><span>,</span><span>range</span><span>(</span><span>10</span><span>)</span><span>)</span><span>}</span> <span># 字典解析式</span>
<span>print</span><span>(</span>d1<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="匿名函数"> 匿名函数</h2>
<p>Python 中，匿名函数也叫 lambda 表达式。</p>
<p>匿名：隐藏名字，即没有名称</p>
<p>匿名函数：没有名字的函数。</p>
<p>函数没有名字该如何定义？函数没有名字如何调用？</p>
<p><strong>Lambda 表达式</strong></p>
<p>Python中，使用 Lambda 表达式构建匿名函数。</p>
<div><pre><code><span>def</span> <span>foo</span><span>(</span>x<span>)</span><span>:</span>
    <span>return</span> x <span>**</span> <span>2</span>
<span>lambda</span> x<span>:</span> x <span>**</span> <span>2</span> <span># 定义</span>
a <span>=</span> <span>(</span><span>lambda</span> x<span>:</span> x <span>**</span> <span>2</span><span>)</span><span>(</span><span>4</span><span>)</span> <span># 调用</span>
<span>print</span><span>(</span>a<span>)</span>
foo <span>=</span> <span>lambda</span> x<span>,</span>y<span>:</span> <span>(</span>x<span>+</span>y<span>)</span> <span>**</span> <span>2</span> <span># 定义函数</span>
<span>print</span><span>(</span>foo<span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>)</span>
<span># 等价于</span>
<span>def</span> <span>foo</span><span>(</span>x<span>,</span>y<span>)</span><span>:</span>
    <span>return</span> <span>(</span>x<span>+</span>y<span>)</span> <span>**</span> <span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>使用 lambda 关键字定义匿名函数，格式为 lambda [参数列表]: 表达式</li>
<li>参数列表不需要小括号。无参就不写参数</li>
<li>冒号用来分割参数列表和表达式部分</li>
<li>不需要使用return。表达式的值，就是匿名函数的返回值。表达式中不能出现等号</li>
<li>Python的lambda表达式（匿名函数）只能写在一行上，也称为单行函数</li>
</ul>
<p>匿名函数往往用在为高阶函数传参时，使用 lambda 表达式，往往能简化代码</p>
<div><pre><code><span># 返回常量的函数</span>
<span>print</span><span>(</span><span>(</span><span>lambda</span> <span>:</span><span>3</span><span>)</span><span>(</span><span>)</span><span>)</span>

<span># 加法匿名函数，带缺省值</span>
<span>print</span><span>(</span><span>(</span><span>lambda</span> x<span>,</span> y<span>=</span><span>3</span><span>:</span> x <span>+</span> y<span>)</span><span>(</span><span>5</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>(</span><span>lambda</span> x<span>,</span> y<span>=</span><span>3</span><span>:</span> x <span>+</span> y<span>)</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>)</span><span>)</span>

<span># keyword-only参数</span>
<span>print</span><span>(</span><span>(</span><span>lambda</span> x<span>,</span> <span>*</span><span>,</span> y<span>=</span><span>30</span><span>:</span> x <span>+</span> y<span>)</span><span>(</span><span>5</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>(</span><span>lambda</span> x<span>,</span> <span>*</span><span>,</span> y<span>=</span><span>30</span><span>:</span> x <span>+</span> y<span>)</span><span>(</span><span>5</span><span>,</span> y<span>=</span><span>10</span><span>)</span><span>)</span>

<span># 可变参数</span>
<span>print</span><span>(</span><span>(</span><span>lambda</span> <span>*</span>args<span>:</span> <span>(</span>x <span>for</span> x <span>in</span> args<span>)</span><span>)</span><span>(</span><span>*</span><span>range</span><span>(</span><span>5</span><span>)</span><span>)</span><span>)</span> <span># 生成器</span>
<span>print</span><span>(</span><span>(</span><span>lambda</span> <span>*</span>args<span>:</span> <span>[</span>x<span>+</span><span>1</span> <span>for</span> x <span>in</span> args<span>]</span><span>)</span><span>(</span><span>*</span><span>range</span><span>(</span><span>5</span><span>)</span><span>)</span><span>)</span> <span># 列表</span>
<span>print</span><span>(</span><span>(</span><span>lambda</span> <span>*</span>args<span>:</span> <span>{</span>x<span>%</span><span>2</span> <span>for</span> x <span>in</span> args<span>}</span><span>)</span><span>(</span><span>*</span><span>range</span><span>(</span><span>5</span><span>)</span><span>)</span><span>)</span> <span># 集合</span>
<span>print</span><span>(</span><span>(</span><span>lambda</span> <span>*</span>args<span>:</span> <span>{</span><span>str</span><span>(</span>x<span>)</span><span>:</span>x <span>for</span> x <span>in</span> args<span>}</span><span>)</span><span>(</span><span>*</span><span>range</span><span>(</span><span>5</span><span>)</span><span>)</span><span>)</span> <span># 字典</span>

<span>print</span><span>(</span><span>dict</span><span>(</span><span>map</span><span>(</span><span>lambda</span> x<span>:</span> <span>(</span><span>chr</span><span>(</span><span>65</span><span>+</span>x<span>)</span><span>,</span> <span>10</span><span>-</span>x<span>)</span><span>,</span> <span>range</span><span>(</span><span>5</span><span>)</span><span>)</span><span>)</span><span>)</span> <span># 高阶函数，构建字典</span>

d <span>=</span> <span>dict</span><span>(</span><span>map</span><span>(</span><span>lambda</span> x<span>:</span> <span>(</span><span>chr</span><span>(</span><span>65</span><span>+</span>x<span>)</span><span>,</span> <span>10</span><span>-</span>x<span>)</span><span>,</span> <span>range</span><span>(</span><span>5</span><span>)</span><span>)</span><span>)</span> <span># 高阶函数</span>
a <span>=</span> <span>sorted</span><span>(</span>d<span>.</span>items<span>(</span><span>)</span><span>,</span> key<span>=</span><span>lambda</span> x<span>:</span>x<span>[</span><span>1</span><span>]</span><span>)</span>
<span>print</span><span>(</span>a<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="生成器函数"> 生成器函数</h2>
<p>后续补充</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">06 目录文件处理</title>
    <id>https://clay-wangzhi.com/code/python/python-dir-file-pro/</id>
    <link href="https://clay-wangzhi.com/code/python/python-dir-file-pro/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_06-目录文件处理"> 06 目录文件处理</h1>
<h2 id="文件io操作"> 文件IO操作</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>open</strong></td>
<td>打开</td>
</tr>
<tr>
<td><strong>read</strong></td>
<td>读取</td>
</tr>
<tr>
<td><strong>write</strong></td>
<td>写入</td>
</tr>
<tr>
<td><strong>close</strong></td>
<td>关闭</td>
</tr>
<tr>
<td>readline</td>
<td>行读取</td>
</tr>
<tr>
<td>readlines</td>
<td>多行读取</td>
</tr>
</tbody>
</table>
<h3 id="open-方法"> open 方法</h3>
<p><code>open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code></p>
<p>打开一个文件，返回一个文件对象(流对象)和文件描述符。打开文件失败，则返回异常</p>
<p>基本使用：创建一个文件test，然后打开它，用完<strong>关闭</strong></p>
<div><pre><code>f <span>=</span> <span>open</span><span>(</span><span>"test"</span><span>)</span> <span># file对象</span>
<span># windows &lt;_io.TextIOWrapper name='test' mode='r' encoding='cp936'></span>
<span># linux &lt;_io.TextIOWrapper name='test' mode='r' encoding='UTF-8'></span>
<span>print</span><span>(</span>f<span>.</span>read<span>(</span><span>)</span><span>)</span> <span># 读取文件</span>
f<span>.</span>close<span>(</span><span>)</span> <span># 关闭文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>文件操作中，最常用的操作就是读和写。</p>
<p>文件访问的模式有两种：文本模式和二进制模式。不同模式下，操作函数不尽相同，表现的结果也不一样。</p>
<blockquote>
<p>注：windows中使用codepage代码页，可以认为每一个代码页就是一张编码表。cp936等同于GBK。</p>
</blockquote>
<h3 id="open-参数"> open 参数</h3>
<p><strong>file</strong></p>
<p>打开或者要创建的文件名。如果不指定路径，默认是当前路径</p>
<p><strong>mode 模式</strong></p>
<table>
<thead>
<tr>
<th>模式描述字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>缺省模式，只读打开</td>
</tr>
<tr>
<td>w</td>
<td>只写打开</td>
</tr>
<tr>
<td>x</td>
<td>创建并写入一个新文件</td>
</tr>
<tr>
<td>a</td>
<td>只写打开，追加内容</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式</td>
</tr>
<tr>
<td>t</td>
<td>缺省模式，文本模式</td>
</tr>
<tr>
<td>+</td>
<td>读或写打开后，使用+来增加缺失的写或读的能力</td>
</tr>
</tbody>
</table>
<p>模式对于IO操作来说，其实只有读和写两种：</p>
<ul>
<li>只读 r</li>
<li>只写 w、x、a</li>
<li>增加缺失能力 +</li>
</ul>
<p>r 模式</p>
<ul>
<li>只读打开文件，如果使用write方法，会抛异常</li>
<li>如果文件不存在，抛出FileNotFoundError异常</li>
</ul>
<p>w 模式</p>
<ul>
<li>表示只写方式打开，如果读取则抛出异常</li>
<li>如果文件不存在，则直接创建文件</li>
<li>如果文件存在，则清空文件内容</li>
</ul>
<p>x 模式</p>
<ul>
<li>文件不存在，创建文件，并只写方式打开</li>
<li>文件存在，抛出 FileExistsError 异常</li>
</ul>
<p>a 模式</p>
<ul>
<li>文件存在，只写打开，追加内容</li>
<li>文件不存在，则创建后，只写打开，追加内容</li>
</ul>
<p>wxa 模式都可以产生新文件</p>
<ul>
<li>w 不管文件存在与否，都会生成全新内容的文件</li>
<li>a 不管文件是否存在，都能在打开的文件尾部追加</li>
<li>x 必须要求文件事先不存在，自己要造一个新文件</li>
</ul>
<p>文本模式 t</p>
<ul>
<li>字符流，将文件的字节按照某种字符编码理解，按照字符操作。open 的默认 mode 就是rt。</li>
</ul>
<p>二进制模式 b</p>
<ul>
<li>字节流，将文件就按照字节理解，与字符编码无关。二进制模式操作时，字节操作使用bytes类型</li>
</ul>
<p>+ 模式</p>
<ul>
<li>为r、w、a、x提供缺失的读或写功能，但是，获取文件对象依旧按照r、w、a、x自己的特征。</li>
<li>+模式不能单独使用，可以认为它是为前面的模式字符做增强功能的。</li>
</ul>
<p><strong>encoding：编码，仅文本模式使用</strong></p>
<p>None 表示使用缺省编码，依赖操作系统。windows、linux下测试如下代码</p>
<div><pre><code>f <span>=</span> <span>open</span><span>(</span><span>'test1'</span><span>,</span><span>'w'</span><span>)</span>
f<span>.</span>write<span>(</span><span>'啊'</span><span>)</span>
f<span>.</span>close<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>windows 下缺省 GBK（0xB0A1），Linux 下缺省 UTF-8（0xE5 95 8A）</p>
<p><strong>文件指针</strong></p>
<p>mode=r，指针起始在0</p>
<p>mode=a，指针起始在EOF</p>
<div><pre><code>f <span>=</span> <span>open</span><span>(</span><span>'test.txt'</span><span>,</span> <span>'wb+'</span><span>)</span>
<span>print</span><span>(</span>f<span>)</span>
f<span>.</span>write<span>(</span><span>b'abc'</span><span>)</span>
<span>print</span><span>(</span>f<span>.</span>tell<span>(</span><span>)</span><span>)</span>
f<span>.</span>close<span>(</span><span>)</span>

f <span>=</span> <span>open</span><span>(</span><span>'test.txt'</span><span>,</span> <span>'rt+'</span><span>)</span> <span># windows下打开</span>
f<span>.</span>write<span>(</span><span>'啊'</span><span>)</span> <span># 从什么地方开始写几个字节？</span>
<span>print</span><span>(</span><span>hex</span><span>(</span><span>ord</span><span>(</span><span>'啊'</span><span>)</span><span>)</span><span>,</span> <span>'啊'</span><span>.</span>encode<span>(</span><span>)</span><span>,</span> <span>'啊'</span><span>.</span>encode<span>(</span><span>'gbk'</span><span>)</span><span>)</span>
<span>print</span><span>(</span>f<span>.</span>tell<span>(</span><span>)</span><span>)</span>
f<span>.</span>close<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="read"> read</h3>
<p>read(size=-1)</p>
<ul>
<li>size 表示读取的多少个字符或字节；负数或者 None 表示读取到 EOF</li>
</ul>
<div><pre><code>filename <span>=</span> <span>'test.txt'</span>
f <span>=</span> <span>open</span><span>(</span>filename<span>,</span> <span>'w+'</span><span>)</span>
f<span>.</span>write<span>(</span><span>'百度站长'</span><span>)</span>
f<span>.</span>close<span>(</span><span>)</span>

f <span>=</span> <span>open</span><span>(</span>filename<span>)</span>
<span>print</span><span>(</span><span>1</span><span>,</span> f<span>.</span>read<span>(</span><span>1</span><span>)</span><span>)</span> <span># 按字符</span>
<span>print</span><span>(</span><span>2</span><span>,</span> f<span>.</span>read<span>(</span><span>2</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>3</span><span>,</span> f<span>.</span>read<span>(</span><span>)</span><span>)</span>
f<span>.</span>close<span>(</span><span>)</span>

f <span>=</span> <span>open</span><span>(</span>filename<span>,</span> <span>'rb'</span><span>)</span>
<span>print</span><span>(</span><span>4</span><span>,</span> f<span>.</span>read<span>(</span><span>1</span><span>)</span><span>)</span> <span># 按字节</span>
<span>print</span><span>(</span><span>5</span><span>,</span> f<span>.</span>read<span>(</span><span>2</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>6</span><span>,</span> <span>'百度站长'</span><span>.</span>encode<span>(</span><span>'gbk'</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>7</span><span>,</span> f<span>.</span>read<span>(</span><span>)</span><span>)</span>
f<span>.</span>close<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>建议，使用文件对象时，一定要指定编码，而不是使用默认编码</p>
<h3 id="write"> write</h3>
<ul>
<li>write(s)，文本模式时，从当前指针处把字符串 s 写入到文件中并返回写入字符的个数；二进制时将 bytes写入文件并返回写入字节数</li>
<li>writelines(lines)，将字符串列表写入文件</li>
</ul>
<div><pre><code>filename <span>=</span> <span>'test.txt'</span>
f <span>=</span> <span>open</span><span>(</span>filename<span>,</span> <span>'w+'</span><span>)</span>
lines <span>=</span> <span>[</span><span>'abc'</span><span>,</span> <span>'123\n'</span><span>,</span> <span>'baidu'</span><span>]</span> <span># 需提供换行符</span>
<span># for line in lines:</span>
<span># f.write(line)</span>
f<span>.</span>writelines<span>(</span>lines<span>)</span>
f<span>.</span>seek<span>(</span><span>0</span><span>)</span> <span># 回到开始</span>
<span>print</span><span>(</span>f<span>.</span>read<span>(</span><span>)</span><span>)</span>
f<span>.</span>close<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>close</strong></p>
<p>flush并关闭文件对象。文件已经关闭，再次关闭没有任何效果。可以查看文件对象的closed属性，判断是否关闭</p>
<h2 id="上下文管理"> 上下文管理</h2>
<p>文件对象这种打开资源并一定要关闭的对象，为了保证其打开后一定关闭，为其提供了上下文支持。</p>
<div><pre><code>filename <span>=</span> <span>'test.txt'</span>
<span>with</span> <span>open</span><span>(</span>filename<span>)</span> <span>as</span> f<span>:</span>
    <span>print</span><span>(</span><span>1</span><span>,</span> f<span>.</span>closed<span>)</span>
    <span>print</span><span>(</span>f<span>.</span>write<span>(</span><span>'abcd'</span><span>)</span><span>)</span> <span># r模式写入失败，抛异常</span>
<span>print</span><span>(</span><span>2</span><span>,</span> f<span>.</span>closed<span>)</span> <span># with中不管是否抛异常，with结束时都会保证关闭文件对象</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>with</span> 文件对象 <span>as</span> 标识符<span>:</span> <span># 等同于 标识符 = 文件对象</span>
    <span>pass</span> <span># 标识符可以在内部使用</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上下文管理</p>
<ol>
<li>使用with关键字，上下文管理针对的是with后的对象</li>
<li>使用with ... as 关键字</li>
<li>上下文管理的语句块并不会开启新的作用域</li>
</ol>
<p>文件对象上下文管理</p>
<ol>
<li>进入with 时，with 后的文件对象是被管理对象</li>
<li>as 子句后的标识符，指向 with 后的文件对象</li>
<li>with 语句块执行完的时候，会自动关闭文件对象</li>
</ol>
<div><pre><code>filename <span>=</span> <span>'test.txt'</span>
f <span>=</span> <span>open</span><span>(</span>filename<span>)</span>
<span>with</span> f <span>as</span> f2<span>:</span>
    <span>print</span><span>(</span>f <span>is</span> f2<span>)</span> <span># True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>文件的遍历</strong></p>
<p>类似于日志文件，文件需要遍历，最常用的方式就是逐行遍历。</p>
<div><pre><code>filename <span>=</span> <span>'test.txt'</span>
<span>with</span> <span>open</span><span>(</span>filename<span>,</span> <span>'w'</span><span>)</span> <span>as</span> f<span>:</span>
    f<span>.</span>write<span>(</span><span>'\n'</span><span>.</span>join<span>(</span><span>map</span><span>(</span><span>str</span><span>,</span> <span>range</span><span>(</span><span>101</span><span>,</span> <span>120</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>with</span> <span>open</span><span>(</span>filename<span>)</span> <span>as</span> f<span>:</span>
    <span>for</span> line <span>in</span> f<span>:</span> <span># 文件对象时可迭代对象，逐行遍历</span>
        <span>print</span><span>(</span>line<span>.</span>encode<span>(</span><span>)</span><span>)</span> <span># 带换行符</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="路径操作"> 路径操作</h2>
<h3 id="os-path-模块"> os.path 模块</h3>
<div><pre><code><span># os模块常用函数</span>
<span>from</span> os <span>import</span> path

p <span>=</span> path<span>.</span>join<span>(</span><span>'/etc'</span><span>,</span> <span>'sysconfig'</span><span>,</span> <span>'network'</span><span>)</span> <span># 拼接</span>
<span>print</span><span>(</span><span>type</span><span>(</span>p<span>)</span><span>,</span> p<span>)</span>
<span>print</span><span>(</span>path<span>.</span>exists<span>(</span>p<span>)</span><span>)</span> <span># 存在</span>

<span>print</span><span>(</span>path<span>.</span>split<span>(</span>p<span>)</span><span>)</span> <span># 分割</span>
<span>print</span><span>(</span>path<span>.</span>dirname<span>(</span>p<span>)</span><span>,</span> path<span>.</span>basename<span>(</span>p<span>)</span><span>)</span> <span># 路径和基名</span>

<span>print</span><span>(</span>path<span>.</span>abspath<span>(</span><span>''</span><span>)</span><span>,</span> path<span>.</span>abspath<span>(</span><span>'.'</span><span>)</span><span>)</span> <span># 绝对路径</span>
<span>print</span><span>(</span>path<span>.</span>splitdrive<span>(</span><span>'o:/temp/test'</span><span>)</span><span>)</span> <span># windows方法</span>

<span># 打印父目录</span>
p1 <span>=</span> path<span>.</span>abspath<span>(</span>__file__<span>)</span>
<span>print</span><span>(</span>p1<span>)</span>
<span>while</span> p1 <span>!=</span> path<span>.</span>dirname<span>(</span>p1<span>)</span><span>:</span>
    p1 <span>=</span> path<span>.</span>dirname<span>(</span>p1<span>)</span>
    <span>print</span><span>(</span>p1<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>os.path模块操作的都是字符串。</p>
<h3 id="path-类"> Path 类</h3>
<p>从3.4开始Python提供了pathlib模块，使用Path类操作目录更加方便。</p>
<p><strong>初始化</strong></p>
<div><pre><code><span>from</span> pathlib <span>import</span> Path

p <span>=</span> Path<span>(</span><span>)</span> <span># 当前目录， Path()、Path('.')、Path('')</span>
<span>print</span><span>(</span><span>type</span><span>(</span>p<span>)</span><span>,</span> p<span>)</span>
p <span>=</span> Path<span>(</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c/d'</span><span>)</span> <span># 当前目录下的a/b/c/d</span>
<span>print</span><span>(</span><span>type</span><span>(</span>p<span>)</span><span>,</span> p<span>)</span>
p <span>=</span> Path<span>(</span><span>'/etc'</span><span>,</span> Path<span>(</span><span>'sysconfig'</span><span>)</span><span>,</span> <span>'network/ifcfg'</span><span>)</span> <span># 根下的etc目录</span>
<span>print</span><span>(</span><span>type</span><span>(</span>p<span>)</span><span>,</span> p<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>拼接</strong></p>
<p><em>操作符 /</em></p>
<ul>
<li>Path对象 / Path对象</li>
<li>Path对象 / 字符串</li>
<li>字符串 / Path对象</li>
</ul>
<p>joinpath</p>
<ul>
<li>joinpath(*other) 在当前Path路径上连接多个字符串返回新路径对象</li>
</ul>
<div><pre><code><span>from</span> pathlib <span>import</span> Path

p <span>=</span> Path<span>(</span><span>)</span>
p <span>=</span> p <span>/</span> <span>'a'</span>
p1 <span>=</span> <span>'b'</span> <span>/</span> p
p2 <span>=</span> Path<span>(</span><span>'c'</span><span>)</span>
p3 <span>=</span> p2 <span>/</span> p1
<span>print</span><span>(</span>p1<span>,</span> p2<span>,</span> p3<span>)</span>
<span>print</span><span>(</span>p3<span>.</span>parts<span>)</span>
<span>print</span><span>(</span>p3<span>.</span>joinpath<span>(</span><span>'d'</span><span>,</span> <span>'e/f'</span><span>,</span> Path<span>(</span><span>'g/h'</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>分解</strong></p>
<p>parts属性，会返回目录各部分的元组</p>
<div><pre><code>p <span>=</span> Path<span>(</span><span>'/a/b/c/d'</span><span>)</span>
<span>print</span><span>(</span>p<span>.</span>parts<span>)</span> <span># 最左边的/是根目录</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>父目录</strong></p>
<div><pre><code><span>from</span> pathlib <span>import</span> Path
p <span>=</span> Path<span>(</span><span>'/clay/mysql/install/mysql.tar.gz'</span><span>)</span>
<span>print</span><span>(</span>p<span>.</span>parent<span>)</span>
<span>for</span> x <span>in</span> p<span>.</span>parents<span>:</span> <span># 可迭代对象</span>
    <span>print</span><span>(</span>x<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>目录组成部分</strong></p>
<p>name、stem、suffix、suffixes、with_suffix(suffix)、with_name(name)</p>
<ul>
<li>name 目录的最后一个部分</li>
<li>suffix 目录中最后一个部分的扩展名</li>
<li>stem 目录最后一个部分，没有后缀</li>
<li>name = stem + suffix</li>
</ul>
<p>suffixes 返回多个扩展名列表</p>
<ul>
<li>with_suffix(suffix) 有扩展名则替换，无则补充扩展名</li>
<li>with_name(name) 替换目录最后一个部分并返回一个新的路径</li>
</ul>
<div><pre><code><span>from</span> pathlib <span>import</span> Path

p <span>=</span> Path<span>(</span><span>'/clay/mysql/install/mysql.tar.gz'</span><span>)</span>
<span>print</span><span>(</span>p<span>.</span>parent<span>)</span>
<span>print</span><span>(</span>p<span>.</span>name<span>)</span>
<span>print</span><span>(</span>p<span>.</span>stem<span>)</span>
<span>print</span><span>(</span>p<span>.</span>suffix<span>)</span>
<span>print</span><span>(</span>p<span>.</span>suffixes<span>)</span>
<span>print</span><span>(</span>p<span>.</span>with_name<span>(</span><span>'redis'</span><span>)</span><span>)</span>
<span>print</span><span>(</span>p<span>.</span>with_name<span>(</span><span>'redis'</span><span>)</span><span>.</span>with_suffix<span>(</span><span>'.zip'</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>全局方法</strong></p>
<ul>
<li>cwd() 返回当前工作目录</li>
<li>home() 返回当前家目录</li>
</ul>
<div><pre><code><span>from</span> pathlib <span>import</span> Path

p <span>=</span> Path<span>(</span><span>'/clay/mysql/install/mysql.tar.gz'</span><span>)</span>
<span>print</span><span>(</span>p<span>.</span>cwd<span>(</span><span>)</span><span>,</span> Path<span>.</span>cwd<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span>p<span>.</span>home<span>(</span><span>)</span><span>,</span> Path<span>.</span>home<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>判断方法</strong></p>
<ul>
<li>exists() 目录或文件是否存在</li>
<li>is_dir() 是否是目录，目录存在返回True</li>
<li>is_file() 是否是普通文件，文件存在返回True</li>
<li>is_symlink() 是否是软链接</li>
<li>is_socket() 是否是socket文件</li>
<li>is_block_device() 是否是块设备</li>
<li>is_char_device() 是否是字符设备</li>
<li>is_absolute() 是否是绝对路径</li>
</ul>
<blockquote>
<p>注意：文件只有存在，才能知道它是什么类型文件</p>
</blockquote>
<p><strong>绝对路径</strong></p>
<ul>
<li>resolve() 非Windows，返回一个新的路径，这个新路径就是当前Path对象的绝对路径，如果是软链接则直接被解析。</li>
<li>absolute() 获取绝对路径。</li>
</ul>
<p><strong>通配符</strong></p>
<ul>
<li>glob(pattern) 通配给定的模式，返回生成器对象</li>
<li>rglob(pattern) 通配给定的模式，递归目录，返回生成器对象</li>
<li>? 代表一个字符</li>
<li>* 表示任意个字符</li>
<li>[abc]或[a-z] 表示一个字符</li>
</ul>
<div><pre><code><span>list</span><span>(</span>p<span>.</span>glob<span>(</span><span>'test*'</span><span>)</span><span>)</span> <span># 返回当前目录对象下的test开头的文件</span>
<span>list</span><span>(</span>p<span>.</span>glob<span>(</span><span>'**/*.py'</span><span>)</span><span>)</span> <span># 递归所有目录，等同rglob</span>
<span>list</span><span>(</span>p<span>.</span>glob<span>(</span><span>'**/*'</span><span>)</span><span>)</span>

g <span>=</span> p<span>.</span>rglob<span>(</span><span>'*.py'</span><span>)</span> <span># 生成器，递归</span>
<span>next</span><span>(</span>g<span>)</span>
<span>list</span><span>(</span>p<span>.</span>rglob<span>(</span><span>'*.???'</span><span>)</span><span>)</span> <span># 匹配扩展名为3个字符的文件</span>
<span>list</span><span>(</span>p1<span>.</span>rglob<span>(</span><span>'[a-z]*.???'</span><span>)</span><span>)</span> <span># 匹配字母开头的且扩展名是3个字符的文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>其他操作</strong></p>
<ul>
<li>
<p>rmdir() 删除空目录。没有提供判断目录为空的方法</p>
</li>
<li>
<p>touch(mode=0o666, exist_ok=True) 创建一个文件</p>
</li>
<li>
<p>as_uri() 将路径返回成URI，例如'file:///etc/passwd'</p>
</li>
<li>
<p>mkdir(mode=0o777, parents=False, exist_ok=False)</p>
<p>parents，是否创建父目录，True等同于mkdir -p。False时，父目录不存在，则抛出
FileNotFoundError
exist_ok参数，在3.5版本加入。False时，路径存在，抛出FileExistsError；True时，
FileExistsError被忽略</p>
</li>
<li>
<p>iterdir() 迭代当前目录，不递归</p>
</li>
</ul>
<div><pre><code><span>from</span> pathlib <span>import</span> Path

p <span>=</span> Path<span>(</span><span>'o:/a/b/c/d'</span><span>)</span>
p<span>.</span>mkdir<span>(</span>parents<span>=</span><span>True</span><span>,</span> exist_ok<span>=</span><span>True</span><span>)</span>
<span>(</span>p <span>/</span> <span>'test'</span><span>)</span><span>.</span>touch<span>(</span><span>)</span>
<span>for</span> x <span>in</span> p<span>.</span>parents<span>[</span><span>len</span><span>(</span>p<span>.</span>parents<span>)</span> <span>-</span> <span>1</span><span>]</span><span>.</span>iterdir<span>(</span><span>)</span><span>:</span> <span># 不支持负索引</span>
	<span>if</span> x<span>.</span>is_dir<span>(</span><span>)</span><span>:</span>
		<span>print</span><span>(</span><span>'dir ='</span><span>,</span> x<span>)</span>
	<span>elif</span> x<span>.</span>is_file<span>(</span><span>)</span><span>:</span>
		<span>print</span><span>(</span><span>'file ='</span><span>,</span> x<span>)</span>
	<span>else</span><span>:</span>
		<span>print</span><span>(</span><span>'other ='</span><span>,</span> x<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li>stat 相当于stat命令</li>
<li>lstat 使用方法同stat()，但如果是符号链接，则显示符号链接本身的文件信息</li>
</ul>
<h2 id="shutil-模块"> shutil 模块</h2>
<p>文件拷贝：使用打开2个文件对象，源文件读取内容，写入目标文件中来完成拷贝过程。但是这样丢失 stat 数据信息（权限等），因为根本没有复制这些信息过去。</p>
<p>目录复制又怎么办呢？</p>
<p>Python 提供了一个方便的库 shutil（高级文件操作）。</p>
<h3 id="copy-复制"> copy 复制</h3>
<p><code>copyfileobj(fsrc, fdst[, length])</code>
文件对象的复制，fsrc和fdst是open打开的文件对象，复制内容。fdst要求可写。
length 指定了表示buffer的大小；</p>
<p><code>copyfile(src, dst, *, follow_symlinks=True)</code>
复制文件内容，不含元数据。src、dst为文件的路径字符串
本质上调用的就是copyfileobj，所以不带元数据二进制内容复制。</p>
<p><code>copymode(src, dst, *, follow_symlinks=True)</code>
仅仅复制权限。</p>
<p><code>copystat(src, dst, *, follow_symlinks=True)</code>
复制元数据，stat包含权限</p>
<p><code>copy(src, dst, *, follow_symlinks=True)</code>
复制文件内容、权限和部分元数据，不包括创建时间和修改时间。</p>
<p>本质上调用的是
<code>copyfile(src, dst, follow_symlinks=follow_symlinks)</code>
<code>copymode(src, dst, follow_symlinks=follow_symlinks)</code></p>
<p><code>copy2</code> 比copy多了复制全部元数据，但需要平台支持。
本质上调用的是
<code>copyfile(src, dst, follow_symlinks=follow_symlinks)</code>
<code>copystat(src, dst, follow_symlinks=follow_symlinks)</code></p>
<p><code>copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,ignore_dangling_symlinks=False)</code>
<strong>递归复制</strong>目录。默认使用copy2，也就是带更多的元数据复制。
src、dst必须是目录，src必须存在，dst必须<strong>不存在</strong>
ignore = func ，提供一个 callable(src, names) -&gt; ignored_names。提供一个函数，它会被调用。src是源目录，names 是 os.listdir(src) 的结果，就是列出 src 中的文件名，返回值是要被过滤的文件名的 set类型数据。</p>
<div><pre><code><span>def</span> <span>ignore</span><span>(</span>src<span>,</span> names<span>)</span><span>:</span>
	ig <span>=</span> <span>filter</span><span>(</span><span>lambda</span> x<span>:</span> x<span>.</span>startswith<span>(</span><span>'a'</span><span>)</span><span>,</span> names<span>)</span> <span># 忽略a开头的</span>
	<span>return</span> <span>set</span><span>(</span>ig<span>)</span>

shutil<span>.</span>copytree<span>(</span><span>'o:/temp'</span><span>,</span><span>'o:/tt/o'</span><span>,</span>ignore<span>=</span>ignore<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="rm-删除"> rm 删除</h3>
<p><code>shutil.rmtree(path, ignore_errors=False, onerror=None)</code></p>
<p>递归删除。如同 rm -rf 一样危险，慎用。</p>
<p>它不是原子操作，有可能删除错误，就会中断，已经删除的就删除了。</p>
<p>ignore_errors为true，忽略错误。当为False或者omitted时onerror生效。</p>
<p>onerror为callable，接受函数function、path和execinfo。</p>
<div><pre><code>shutil<span>.</span>rmtree<span>(</span><span>'O:/tmp'</span><span>)</span> <span># 类似 rm -rf</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="move-移动"> move 移动</h3>
<p><code>move(src, dst, copy_function=copy2)</code></p>
<p>递归移动文件、目录到目标，返回目标。</p>
<p>本身使用的是 os.rename方法。</p>
<p>如果不支持rename，如果是目录则copytree再删除源目录。</p>
<p>默认使用copy2方法。</p>
<div><pre><code>shutil<span>.</span>move<span>(</span><span>'o:/a'</span><span>,</span> <span>'o:/aaa'</span><span>)</span>
os<span>.</span>rename<span>(</span><span>'o:/t.txt'</span><span>,</span><span>'o:/temp/t'</span><span>)</span>
os<span>.</span>rename<span>(</span><span>'test3'</span><span>,</span><span>'/tmp/py/test300'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>shutil还有打包功能。生成tar并压缩。支持zip、gz、bz、xz。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">08 异常处理</title>
    <id>https://clay-wangzhi.com/code/python/python-exception/</id>
    <link href="https://clay-wangzhi.com/code/python/python-exception/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_08-异常处理"> 08 异常处理</h1>
<p><strong>错误 Error</strong></p>
<p>逻辑错误：算法写错了，例如加法写成了减法</p>
<p>笔误：例如变量名写错了，语法错误</p>
<p>函数或类使用错误，其实这也属于逻辑错误</p>
<p>总之，错误是可以避免的</p>
<p><strong>异常 Exception</strong></p>
<p>本意就是意外情况</p>
<p>这有个前提，没有出现上面说的错误，也就是说程序写的没有问题，但是在某些情况下，会出现一些意外，导致程序无法正常的执行下去。</p>
<p>例如open函数操作一个文件，文件不存在，或者创建一个文件时已经存在了，或者访问一个网络文件，突然断网了，这就是异常，是个意外的情况。</p>
<p>异常不可能避免</p>
<p>**错误和异常</p>
<p>在高级编程语言中，一般都有错误和异常的概念，异常是可以捕获，并被处理的，但是错误是不能被捕获的。
举例
对比异常和错误</p>
<div><pre><code><span>with</span> <span>open</span><span>(</span><span>'testabc'</span><span>)</span> <span>as</span> f<span>:</span>
    <span>pass</span>
<span># 异常</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"C:/Users/user/PycharmProjects/pr1/test1.py"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
    <span>with</span> <span>open</span><span>(</span><span>'testabc'</span><span>)</span> <span>as</span> f<span>:</span>
FileNotFoundError<span>:</span> <span>[</span>Errno <span>2</span><span>]</span> No such <span>file</span> <span>or</span> directory<span>:</span> <span>'testabc'</span>
        
<span>def</span> <span>0A</span><span>(</span><span>)</span><span>:</span>
    <span>pass</span>

<span># 错误</span>
  File <span>"test1.py"</span><span>,</span> line <span>1</span>
    <span>def</span> <span>0A</span><span>(</span><span>)</span><span>:</span>
        <span>^</span>
SyntaxError<span>:</span> invalid syntax
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>一个健壮的程序</p>
<ul>
<li>尽可能的避免错误</li>
<li>尽可能的捕获、处理各种异常</li>
</ul>
<h2 id="产生异常"> 产生异常</h2>
<p>产生：</p>
<ul>
<li>raise 语句显式的抛出异常</li>
<li>Python解释器自己检测到异常并引发它</li>
</ul>
<div><pre><code><span>def</span> <span>foo</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'before'</span><span>)</span>
    <span>print</span><span>(</span><span>1</span><span>/</span><span>0</span><span>)</span> <span># 除零异常</span>
    <span>print</span><span>(</span><span>'after'</span><span>)</span>

foo<span>(</span><span>)</span>

<span>def</span> <span>bar</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'before'</span><span>)</span>
    <span>raise</span> Exception<span>(</span><span>'my exception'</span><span>)</span> <span># raise主动抛出异常</span>
    <span>print</span><span>(</span><span>'after'</span><span>)</span>
bar<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>程序会在异常抛出的地方中断执行，如果不捕获，就会提前结束程序（其实是终止当前线程的执行）</p>
<h2 id="异常的捕获"> 异常的捕获</h2>
<div><pre><code><span>try</span><span>:</span>
	待捕获异常的代码块
<span>except</span> <span>[</span>异常类型<span>]</span><span>:</span>
	异常的处理代码块
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>def</span> <span>foo</span><span>(</span><span>)</span><span>:</span>
    <span>try</span><span>:</span>
        <span>print</span><span>(</span><span>'before'</span><span>)</span>
        <span>print</span><span>(</span><span>1</span><span>/</span><span>0</span><span>)</span> <span># 除零异常</span>
        <span>print</span><span>(</span><span>'after'</span><span>)</span>
    <span>except</span><span>:</span>
        <span>print</span><span>(</span><span>'catch u'</span><span>)</span>
    <span>print</span><span>(</span><span>'finished'</span><span>)</span>

foo<span>(</span><span>)</span>
<span>print</span><span>(</span><span>'==== end ===='</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上例执行到 <code>c = 1/0</code> 时产生异常并抛出，由于使用了 try...except 语句块则捕捉到了这个异常，异常生成位置之后语句将不再执行，转而执行对应的 except 部分的语句，最后执行 try...except 语句块之外的语句。</p>
<p><strong>捕获指定类型的异常</strong></p>
<div><pre><code><span>def</span> <span>foo</span><span>(</span><span>)</span><span>:</span>
    <span>try</span><span>:</span>
        <span>print</span><span>(</span><span>'before'</span><span>)</span>
        <span>print</span><span>(</span><span>1</span><span>/</span><span>0</span><span>)</span> <span># 除零异常</span>
        <span>print</span><span>(</span><span>'after'</span><span>)</span>
    <span>except</span> ArithmeticError<span>:</span>
        <span>print</span><span>(</span><span>'catch u'</span><span>)</span>
    <span>print</span><span>(</span><span>'finished'</span><span>)</span>

foo<span>(</span><span>)</span>
<span>print</span><span>(</span><span>'==== end ===='</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="异常类及继承层次"> 异常类及继承层次</h2>
<div><pre><code><span># Python异常的继承</span>
BaseException
    <span>+</span><span>-</span><span>-</span> SystemExit
    <span>+</span><span>-</span><span>-</span> KeyboardInterrupt
    <span>+</span><span>-</span><span>-</span> GeneratorExit
    <span>+</span><span>-</span><span>-</span> Exception
    <span>+</span><span>-</span><span>-</span> RuntimeError
    <span>|</span> <span>+</span><span>-</span><span>-</span> RecursionError
    <span>+</span><span>-</span><span>-</span> MemoryError
    <span>+</span><span>-</span><span>-</span> NameError
    <span>+</span><span>-</span><span>-</span> StopIteration
    <span>+</span><span>-</span><span>-</span> StopAsyncIteration
    <span>+</span><span>-</span><span>-</span> ArithmeticError
    <span>|</span> <span>+</span><span>-</span><span>-</span> FloatingPointError
    <span>|</span> <span>+</span><span>-</span><span>-</span> OverflowError
    <span>|</span> <span>+</span><span>-</span><span>-</span> ZeroDivisionError
    <span>+</span><span>-</span><span>-</span> LookupError
    <span>|</span> <span>+</span><span>-</span><span>-</span> IndexError
    <span>|</span> <span>+</span><span>-</span><span>-</span> KeyError
    <span>+</span><span>-</span><span>-</span> SyntaxError
    <span>+</span><span>-</span><span>-</span> OSError
    <span>|</span> <span>+</span><span>-</span><span>-</span> BlockingIOError
    <span>|</span> <span>+</span><span>-</span><span>-</span> ChildProcessError
    <span>|</span> <span>+</span><span>-</span><span>-</span> ConnectionError
    <span>|</span> <span>|</span> <span>+</span><span>-</span><span>-</span> BrokenPipeError
    <span>|</span> <span>|</span> <span>+</span><span>-</span><span>-</span> ConnectionAbortedError
    <span>|</span> <span>|</span> <span>+</span><span>-</span><span>-</span> ConnectionRefusedError
    <span>|</span> <span>|</span> <span>+</span><span>-</span><span>-</span> ConnectionResetError
    <span>|</span> <span>+</span><span>-</span><span>-</span> FileExistsError
    <span>|</span> <span>+</span><span>-</span><span>-</span> FileNotFoundError
    <span>|</span> <span>+</span><span>-</span><span>-</span> InterruptedError
    <span>|</span> <span>+</span><span>-</span><span>-</span> IsADirectoryError
    <span>|</span> <span>+</span><span>-</span><span>-</span> NotADirectoryError
    <span>|</span> <span>+</span><span>-</span><span>-</span> PermissionError
    <span>|</span> <span>+</span><span>-</span><span>-</span> ProcessLookupError
    <span>|</span> <span>+</span><span>-</span><span>-</span> TimeoutError
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h2 id="baseexception-及子类"> BaseException 及子类</h2>
<h3 id="baseexception"> BaseException</h3>
<p>所有内建异常类的基类是BaseException</p>
<h3 id="systemexit"> SystemExit</h3>
<p>sys.exit()函数引发的异常，异常不捕获处理，就直接交给Python解释器，解释器退出。</p>
<div><pre><code><span>import</span> sys
<span>print</span><span>(</span><span>'before'</span><span>)</span>
sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>
<span>print</span><span>(</span><span>'SysExit'</span><span>)</span>
<span>print</span><span>(</span><span>'after'</span><span>)</span> <span># 是否执行？ 不执行</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span># 捕获这个异常</span>
<span>import</span> sys
<span>try</span><span>:</span>
    <span>print</span><span>(</span><span>'before'</span><span>)</span>
    sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span>'SysExit'</span><span>)</span>
    <span>print</span><span>(</span><span>'after'</span><span>)</span> 
<span>except</span> SystemExit<span>:</span> <span># 换成Exception能否捕获 ,能</span>
    <span>print</span><span>(</span><span>'SysExit'</span><span>)</span>
<span>print</span><span>(</span><span>'outer'</span><span>)</span>  <span># 是否执行？ 执行</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>如果except语句捕获了该异常，则继续向后面执行，如果没有捕获住该异常SystemExit，解释器直接退出程序。</p>
<p>注意捕获前后程序退出状态码的变化。（捕获后状态码变为0）</p>
<h3 id="keyboardinterrupt"> KeyboardInterrupt</h3>
<p>对应的捕获用户中断行为Ctrl + C</p>
<div><pre><code><span>import</span> time
<span>try</span><span>:</span>
    <span>while</span> <span>True</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>'running'</span><span>)</span>
<span>except</span> KeyboardInterrupt<span>:</span>
    <span>print</span><span>(</span><span>"Ctrl + c"</span><span>)</span>
<span>print</span><span>(</span><span>'='</span> <span>*</span> <span>30</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="exception及子类"> Exception及子类</h2>
<p>Exception是所有内建的、非系统退出的异常的基类，自定义异常类应该继承自它</p>
<p><strong>SyntaxError 语法错误</strong></p>
<p>Python将这种错误也归到异常类下面的Exception下的子类，但是这种错误是不可捕获的</p>
<div><pre><code><span>def</span> <span>a</span><span>(</span><span>)</span><span>:</span>
    <span>try</span><span>:</span>
        <span>0a</span> <span>=</span> <span>5</span>
    <span>except</span><span>:</span>
        <span>pass</span>
a<span>(</span><span>)</span>
  File <span>"test1.py"</span><span>,</span> line <span>3</span>
    <span>0a</span> <span>=</span> <span>5</span>
     <span>^</span>
SyntaxError<span>:</span> invalid syntax
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>ArithmeticError</strong></p>
<p>所有算术计算引发的异常，其子类有除零异常等</p>
<p><strong>LookupError</strong></p>
<p>使用映射的键或序列的索引无效时引发的异常的基类：IndexError, KeyError</p>
<p><strong>自定义异常类</strong></p>
<p>从 Exception 继承的类</p>
<div><pre><code><span>class</span> <span>MyException</span><span>(</span>Exception<span>)</span><span>:</span>
    <span>pass</span>

<span>try</span><span>:</span>
    <span>raise</span> MyException<span>(</span><span>)</span>
<span>except</span> MyException<span>:</span> <span># 捕获自定义异常</span>
    <span>print</span><span>(</span><span>'catch u'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="多种捕获"> 多种捕获</h2>
<p>except 可以指定捕获的类型，捕获多种异常</p>
<div><pre><code><span>import</span> sys
<span>class</span> <span>MyException</span><span>(</span>Exception<span>)</span><span>:</span>
    <span>pass</span>

<span>try</span><span>:</span>
    a <span>=</span> <span>1</span><span>/</span><span>0</span>
    <span>raise</span> MyException<span>(</span><span>)</span>
    <span>open</span><span>(</span><span>'t'</span><span>)</span>
    sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>
<span>except</span> ZeroDivisionError<span>:</span>
    <span>print</span><span>(</span><span>'zero'</span><span>)</span>
<span>except</span> ArithmeticError<span>:</span>
    <span>print</span><span>(</span><span>'arith'</span><span>)</span>
<span>except</span> MyException<span>:</span> <span># 捕获自定义异常</span>
    <span>print</span><span>(</span><span>'catch u'</span><span>)</span>
<span>except</span> Exception<span>:</span>
    <span>print</span><span>(</span><span>'exception'</span><span>)</span>
<span>except</span><span>:</span> <span># 写在最后，缺省捕获</span>
    <span>print</span><span>(</span><span>'error'</span><span>)</span>
<span>print</span><span>(</span><span>'====end===='</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>捕获规则</p>
<ul>
<li>捕获是从上到下依次比较，如果匹配，则执行匹配的except语句块</li>
<li>如果被一个except语句捕获，其他except语句就不会再次捕获了</li>
<li>如果没有任何一个except语句捕获到这个异常，则该异常向外抛出</li>
<li><code>except:</code> 称为缺省捕获，缺省捕获必须是最后一个捕获语句</li>
</ul>
<p>捕获的原则</p>
<ul>
<li>从小到大，从具体到宽泛</li>
</ul>
<h2 id="as-子句"> as 子句</h2>
<p>先看一个例子</p>
<div><pre><code><span># raise 能抛出什么样的异常？</span>
<span>class</span> <span>A</span><span>:</span> <span>pass</span>
<span>try</span><span>:</span>
    <span># 1/0</span>
    <span>raise</span> <span>1</span>
    <span># raise "abc"</span>
    <span># raise A</span>
    <span># raise A()</span>
    <span># raise {}</span>
<span>except</span><span>:</span>  <span># 写在最后，缺省捕获</span>
    <span>print</span><span>(</span><span>'catch u'</span><span>)</span>

<span>print</span><span>(</span><span>'====end===='</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>raise 真的什么类型都能抛出吗？</p>
<p>被抛出的异常，应该是异常类的实例，如何获得这个对象呢？使用 as 子句</p>
<div><pre><code><span># raise 能抛出什么样的异常？</span>
<span>class</span> <span>A</span><span>:</span> <span>pass</span>
<span>try</span><span>:</span>
    <span># 1/0</span>
    <span># raise 1</span>
    <span>raise</span> <span>"abc"</span>
    <span># raise A</span>
    <span># raise A()</span>
    <span># raise {}</span>
<span>except</span> Exception <span>as</span> e<span>:</span>  <span># 写在最后，缺省捕获</span>
    <span>print</span><span>(</span><span>type</span><span>(</span>e<span>)</span><span>,</span> e<span>)</span>  <span># 抛出TypeError类型异常实例</span>

<span>print</span><span>(</span><span>'====end===='</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>raise语句</p>
<ul>
<li>
<p>raise后要求应该是BaseException类的子类或实例，如果是类，将被无参实例化。自定义应该是Exception子类</p>
</li>
<li>
<p>raise后什么都没有，表示抛出最近一个被激活的异常，如果没有被激活的异常，则抛类型异常。</p>
<p>这种方式较少用，它用在except中</p>
</li>
</ul>
<h2 id="finally子句"> finally子句</h2>
<p>finally 最终，即最后一定要执行的，try...finally 语句块中，不管是否发生了异常，都要执行finally的部分</p>
<div><pre><code><span>try</span><span>:</span>
    f <span>=</span> <span>open</span><span>(</span><span>'test.tt'</span><span>)</span>
<span>except</span> FileNotFoundError <span>as</span> e<span>:</span>
    <span>print</span><span>(</span><span>'{} {} {}'</span><span>.</span><span>format</span><span>(</span>e<span>.</span>__class__<span>,</span> e<span>.</span>errno<span>,</span> e<span>.</span>strerror<span>)</span><span>)</span>
<span>finally</span><span>:</span>
    <span>print</span><span>(</span><span>'清理工作'</span><span>)</span>
	f<span>.</span>close<span>(</span><span>)</span> <span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>注意上例中的f的作用域，解决的办法是在外部定义 f</p>
<p>finally 中一般放置资源的清理、释放工作的语句</p>
<div><pre><code>f <span>=</span> <span>None</span>
<span>try</span><span>:</span>
    f <span>=</span> <span>open</span><span>(</span><span>'test.tt'</span><span>)</span>
<span>except</span> Exception <span>as</span> e<span>:</span>
    <span>print</span><span>(</span><span>'{}'</span><span>.</span><span>format</span><span>(</span>e<span>)</span><span>)</span>
<span>finally</span><span>:</span>
    <span>print</span><span>(</span><span>'清理工作'</span><span>)</span>
    <span>if</span> f<span>:</span>
        f<span>.</span>close<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>也可以在 finally 中再次捕捉异常</p>
<div><pre><code><span>try</span><span>:</span>
    f <span>=</span> <span>open</span><span>(</span><span>'test.tt'</span><span>)</span>
<span>except</span> FileNotFoundError <span>as</span> e<span>:</span>
    <span>print</span><span>(</span><span>'{} {} {}'</span><span>.</span><span>format</span><span>(</span>e<span>.</span>__class__<span>,</span> e<span>.</span>errno<span>,</span> e<span>.</span>strerror<span>)</span><span>)</span>
<span>finally</span><span>:</span>
    <span>print</span><span>(</span><span>'清理工作'</span><span>)</span>
    <span>try</span><span>:</span>
	    f<span>.</span>close<span>(</span><span>)</span> <span>#</span>
    <span>except</span> Exception <span>as</span> e<span>:</span>
        <span>print</span><span>(</span>e<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>语句嵌套和捕获</p>
<ul>
<li>异常语句内部可以嵌入到try块、except块、finally块中</li>
<li>异常在内部产生后，如果没有捕获到，就会继续向外部抛出</li>
<li>如果外部也没能捕获，将继续再向外部抛出，直至异常代码所在线程，导致线程崩溃</li>
<li>finally中有return、break语句，则异常就不会继续向外抛出</li>
</ul>
<div><pre><code><span>try</span><span>:</span>
    <span>try</span><span>:</span>
        <span>1</span><span>/</span><span>0</span>
    <span>except</span> KeyError <span>as</span> e<span>:</span>
        <span>print</span><span>(</span><span>1</span><span>,</span> e<span>)</span>
    <span>finally</span><span>:</span>
        <span>print</span><span>(</span><span>2</span><span>,</span> <span>'inner fin'</span><span>)</span>
<span>except</span> FileNotFoundError <span>as</span> e<span>:</span>
    <span>print</span><span>(</span><span>3</span><span>,</span> e<span>)</span>
<span>finally</span><span>:</span>
    <span>print</span><span>(</span><span>4</span><span>,</span> <span>'outer fin'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="else-子句"> else 子句</h2>
<div><pre><code><span>try</span><span>:</span>
    ret <span>=</span> <span>1</span> <span>*</span> <span>0</span>
<span>except</span> ArithmeticError <span>as</span> e<span>:</span>
    <span>print</span><span>(</span>e<span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>'OK'</span><span>)</span>
<span>finally</span><span>:</span>
    <span>print</span><span>(</span><span>'fin'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>else 子句，<strong>没有任何异常发生</strong>，则执行</p>
<h2 id="总结"> 总结</h2>
<div><pre><code><span>try</span><span>:</span>
    <span>&lt;</span>语句<span>></span> <span>#运行别的代码</span>
<span>except</span> <span>&lt;</span>异常类<span>></span>：
    <span>&lt;</span>语句<span>></span> <span># 捕获某种类型的异常</span>
<span>except</span> <span>&lt;</span>异常类<span>></span> <span>as</span> <span>&lt;</span>变量名<span>></span><span>:</span>
    <span>&lt;</span>语句<span>></span> <span># 捕获某种类型的异常并获得对象</span>
<span>else</span><span>:</span>
    <span>&lt;</span>语句<span>></span> <span>#如果没有异常发生</span>
<span>finally</span><span>:</span>
    <span>&lt;</span>语句<span>></span> <span>#退出try时总会执行</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol>
<li>如果try中语句执行时发生异常，搜索except子句，并执行第一个匹配该异常的except子句</li>
<li>如果try中语句执行时发生异常，却没有匹配的except子句，异常将被递交到外层的try，如果外层不处理这个异常，异常将继续向外层传递。如果都不处理该异常，则会传递到最外层，如果还没有处理，就终止异常所在的线程</li>
<li>如果在try执行时没有发生异常，如有else子句，可执行else子句中的语句</li>
<li>无论try中是否发生异常，finally子句最终都会执行</li>
</ol>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">04 函数</title>
    <id>https://clay-wangzhi.com/code/python/python-function/</id>
    <link href="https://clay-wangzhi.com/code/python/python-function/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_04-函数"> 04 函数</h1>
<h2 id="函数"> 函数</h2>
<p>数学定义</p>
<ul>
<li>y=f(x) ，y是x的函数，x是自变量。y=f(x0, x1, ..., xn)</li>
</ul>
<p>Python函数</p>
<ul>
<li>由若干语句组成的语句块、函数名称、参数列表构成，它是组织代码的最小单元</li>
<li>完成一定的功能</li>
</ul>
<p>函数的作用</p>
<ul>
<li>结构化编程对代码的最基本的封装，一般按照功能组织一段代码</li>
<li>封装的目的为了复用，减少冗余代码</li>
<li>代码更加简洁美观、可读易懂</li>
</ul>
<p>函数的分类</p>
<ul>
<li>内建函数，如max()、reversed()等</li>
<li>库函数，如math.ceil()等</li>
<li>自定义函数，使用def关键字定义</li>
</ul>
<h2 id="函数定义"> 函数定义</h2>
<div><pre><code><span>def</span> 函数名<span>(</span>参数列表<span>)</span><span>:</span>
	函数体（代码块）
	<span>[</span><span>return</span> 返回值<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>函数名就是标识符，命名要求一样</li>
<li>语句块必须缩进，约定4个空格</li>
<li>Python的函数若没有return语句，会隐式返回一个None值</li>
<li>定义中的参数列表称为形式参数，只是一种符号表达（标识符），简称形参</li>
</ul>
<h2 id="函数调用"> 函数调用</h2>
<ul>
<li>函数定义，只是声明了一个函数，它不能被执行，需要调用执行</li>
<li>调用的方式，就是函数名后加上小括号，如有必要在括号内填写上参数</li>
<li>调用时写的参数是实际参数，是实实在在传入的值，简称实参</li>
</ul>
<div><pre><code><span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span> <span># 函数定义</span>
	result <span>=</span> x <span>+</span> y <span># 函数体</span>
	<span>return</span> result <span># 返回值</span>

out <span>=</span> add<span>(</span><span>4</span><span>,</span><span>5</span><span>)</span> <span># 函数调用，可能有返回值，使用变量接收这个返回值</span>
<span>print</span><span>(</span>out<span>)</span> <span># print函数加上括号也是调用</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码解释：</p>
<ul>
<li>定义一个函数add，及函数名是add，能接受2个参数</li>
<li>该函数计算的结果，通过返回值返回，需要return语句</li>
<li>调用时，通过函数名add后加2个参数，返回值可使用变量接收</li>
<li>函数名也是标识符</li>
<li>返回值也是值</li>
<li>定义需要在调用前，也就是说调用时，已经被定义过了，否则抛NameError异常</li>
<li>函数是可调用的对象，callable(add)返回True</li>
</ul>
<h2 id="函数参数"> 函数参数</h2>
<p>函数在定义是要定义好形式参数，调用时也提供足够的实际参数，一般来说，形参和实参个数要一致（可变参数除外）。</p>
<h3 id="实参传参方式"> 实参传参方式</h3>
<p>1、位置传参</p>
<p>定义时def f(x, y, z)， 调用使用 f(1, 3, 5)，按照参数定义顺序传入实参</p>
<p>2、关键字传参</p>
<p>定义时def f(x, y, z)，调用使用 f(x=1, y=3, z=5)，使用形参的名字来传入实参的方式，如果使用了形参名字，那么传参顺序就可和定义顺序不同</p>
<p>要求位置参数必须在关键字参数之前传入，位置参数是按位置对应的</p>
<blockquote>
<p>切记：传参指的是调用时传入实参，就2种方式。</p>
</blockquote>
<p>下面讲的都是形参定义。</p>
<h3 id="形参缺省值"> 形参缺省值</h3>
<p>缺省值也称为默认值，可以在函数定义时，为形参增加一个缺省值。其作用：</p>
<ul>
<li>参数的默认值可以在未传入足够的实参的时候，对没有给定的参数赋值为默认值</li>
<li>参数非常多的时候，并不需要用户每次都输入所有的参数，简化函数调用</li>
</ul>
<h3 id="可变参数"> 可变参数</h3>
<p>需求：写一个函数，可以对多个数累加求和</p>
<div><pre><code><span>def</span> <span>sum</span><span>(</span>iterable<span>)</span><span>:</span>
	s <span>=</span> <span>0</span>
	<span>for</span> x <span>in</span> iterable<span>:</span>
		s <span>+=</span> x
	<span>return</span> s

<span>print</span><span>(</span><span>sum</span><span>(</span><span>[</span><span>1</span><span>,</span><span>3</span><span>,</span><span>5</span><span>]</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>sum</span><span>(</span><span>range</span><span>(</span><span>4</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上例，传入可迭代对象，并累加每一个元素。</p>
<p>也可以使用可变参数完成上面的函数。</p>
<div><pre><code><span>def</span> <span>sum</span><span>(</span><span>*</span>nums<span>)</span><span>:</span>
	<span>sum</span> <span>=</span> <span>0</span>
	<span>for</span> x <span>in</span> nums<span>:</span>
		<span>sum</span> <span>+=</span> x
	<span>return</span> <span>sum</span>

<span>print</span><span>(</span><span>sum</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>1、可变位置参数</p>
<ul>
<li>在形参前使用 * 表示该形参是可变位置参数，可以接受多个实参</li>
<li>它将收集来的实参组织到一个 tuple 中</li>
</ul>
<p>2、可变关键字参数</p>
<ul>
<li>在形参前使用 ** 表示该形参是可变关键字参数，可以接受多个关键字参数</li>
<li>它将收集来的实参的名称和值，组织到一个dict中</li>
</ul>
<p>总结：</p>
<ul>
<li>有可变位置参数和可变关键字参数</li>
<li>可变位置参数在形参前使用一个星号*</li>
<li>可变关键字参数在形参前使用两个星号**</li>
<li>可变位置参数和可变关键字参数都可以收集若干个实参，可变位置参数收集形成一个tuple，可变关键字参数收集形成一个dict</li>
<li>混合使用参数的时候，普通参数需要放到参数列表前面，可变参数要放到参数列表的后面，可变位置参数需要在可变关键字参数之前</li>
</ul>
<h3 id="keyword-only参数"> keyword-only参数</h3>
<p>在Python3之后，新增了keyword-only参数。</p>
<p>keyword-only参数：在形参定义时，在一个*星号之后，或一个可变位置参数之后，出现的普通参数，就已经不是普通的参数了，称为keyword-only参数。</p>
<p>keyword-only参数，言下之意就是这个参数必须采用关键字传参。</p>
<h3 id="positional-only参数"> positional-only参数</h3>
<p>Python 3.8 开始，增加了最后一种形参类型的定义：Positional-only参数。（2019年10月发布3.8.0）</p>
<div><pre><code><span>def</span> <span>fn</span><span>(</span>a<span>,</span> <span>/</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>a<span>,</span> sep<span>=</span><span>'\n'</span><span>)</span>
fn<span>(</span><span>3</span><span>)</span>
fn<span>(</span>a<span>=</span><span>4</span><span>)</span> <span># 错误，仅位置参数，不可以使用关键字传参</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="参数规则"> 参数规则</h3>
<p>参数列表参数一般顺序是：positional-only参数、普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值）、可变关键字参数。
注意：</p>
<ul>
<li>代码应该易读易懂，而不是为难别人</li>
<li>请按照书写习惯定义函数参数</li>
<li>定义最常用参数为普通参数，可不提供缺省值，必须由用户提供。注意这些参数的顺序，最常用的先定义</li>
<li>将必须使用名称的才能使用的参数，定义为keyword-only参数，要求必须使用关键字传参</li>
<li>如果函数有很多参数，无法逐一定义，可使用可变参数。如果需要知道这些参数的意义，则使用可变关键字参数收集</li>
</ul>
<h3 id="参数解构"> 参数解构</h3>
<p>参数解构：</p>
<ul>
<li>在给函数提供实参的时候，可以在可迭代对象前使用 * 或者 ** 来进行结构的解构，提取出其中所有元素作为函数的实参</li>
<li>使用 * 解构成位置传参</li>
<li>使用 ** 解构成关键字传参</li>
<li>提取出来的元素数目要和参数的要求匹配</li>
</ul>
<h2 id="函数返回值"> 函数返回值</h2>
<ul>
<li>
<p>Python 函数使用 return 语句返回“返回值”</p>
</li>
<li>
<p>所有函数都有返回值，如果没有return语句，隐式调用return None</p>
</li>
<li>
<p>return 语句并不一定是函数的语句块的最后一条语句</p>
</li>
<li>
<p>一个函数可以存在多个return语句，但是只有一条可以被执行。如果没有一条return语句被执行到，隐式调用return None</p>
</li>
<li>
<p>如果有必要，可以显示调用return None，可以简写为return</p>
</li>
<li>
<p>如果函数执行了return语句，函数就会返回，当前被执行的return语句之后的其它语句就不会被执行了</p>
</li>
<li>
<p>返回值的作用：结束函数调用、返回“返回值”</p>
</li>
<li>
<p>函数不能同时返回多个值</p>
</li>
<li>
<p>return 1, 3, 5 看似返回多个值，隐式的被python封装成了一个元组</p>
</li>
<li>
<p>x, y, z = showlist() 使用解构提取返回值更为方便</p>
</li>
</ul>
<h2 id="作用域"> 作用域</h2>
<p>一个标识符的可见范围，这就是标识符的作用域。一般常说的是变量的作用域</p>
<div><pre><code><span>def</span> <span>foo</span><span>(</span><span>)</span><span>:</span>
	x <span>=</span> <span>100</span>
<span>print</span><span>(</span>x<span>)</span> <span># 可以访问到吗</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上例中x不可以访问到，会抛出异常（NameError: name 'x' is not defined），原因在于函数是一个封装，它会开辟一个作用域，x变量被限制在这个作用域中，所以在函数外部x变量不可见。</p>
<blockquote>
<p>注意：每一个函数都会开辟一个作用域</p>
</blockquote>
<h2 id="作用域分类"> 作用域分类</h2>
<ul>
<li>全局作用域
<ul>
<li>在整个程序运行环境中都可见</li>
<li>全局作用域中的变量称为全局变量global</li>
</ul>
</li>
<li>局部作用域
<ul>
<li>在函数、类等内部可见</li>
<li>局部作用域中的变量称为局部变量，其使用范围不能超过其所在局部作用域</li>
<li>也称为本地作用域local</li>
</ul>
</li>
</ul>
<h2 id="函数嵌套"> 函数嵌套</h2>
<p>在一个函数中定义了另外一个函数</p>
<div><pre><code><span>def</span> <span>outer</span><span>(</span><span>)</span><span>:</span>
	<span>def</span> <span>inner</span><span>(</span><span>)</span><span>:</span>
		<span>print</span><span>(</span><span>"inner"</span><span>)</span>
	inner<span>(</span><span>)</span>
	<span>print</span><span>(</span><span>"outer"</span><span>)</span>
outer<span>(</span><span>)</span> <span># 可以吗？ 可以</span>
inner<span>(</span><span>)</span> <span># 可以吗？ 不可以</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>内部函数inner不能在外部直接使用，会抛NameError异常，因为它在函数外部不可见。</p>
<p>其实，inner不过就是一个标识符，就是一个函数outer内部定义的变量而已。</p>
<p><strong>嵌套结构的作用域</strong></p>
<p>对比下面嵌套结构，代码执行的效果</p>
<div><pre><code><span>def</span> <span>outer1</span><span>(</span><span>)</span><span>:</span> <span>#</span>
    o <span>=</span> <span>65</span>
    <span>def</span> <span>inner</span><span>(</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"inner {}"</span><span>.</span><span>format</span><span>(</span>o<span>)</span><span>)</span>
        <span>print</span><span>(</span><span>chr</span><span>(</span>o<span>)</span><span>)</span>

    inner<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>"outer {}"</span><span>.</span><span>format</span><span>(</span>o<span>)</span><span>)</span>

outer1<span>(</span><span>)</span> <span># 打印结果</span>
<span>#inner 65</span>
<span>#A</span>
<span>#outer 65</span>

<span>def</span> <span>outer2</span><span>(</span><span>)</span><span>:</span> <span>#</span>
    o <span>=</span> <span>65</span>
    <span>def</span> <span>inner</span><span>(</span><span>)</span><span>:</span>
        o <span>=</span> <span>97</span>
        <span>print</span><span>(</span><span>"inner {}"</span><span>.</span><span>format</span><span>(</span>o<span>)</span><span>)</span>
        <span>print</span><span>(</span><span>chr</span><span>(</span>o<span>)</span><span>)</span>

    inner<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>"outer {}"</span><span>.</span><span>format</span><span>(</span>o<span>)</span><span>)</span>

outer2<span>(</span><span>)</span> <span># 打印结果</span>
<span>#inner 97</span>
<span>#a</span>
<span>#outer 65</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>从执行的结果来看：</p>
<ul>
<li>外层变量在内部作用域可见</li>
<li>内层作用域 inner 中，如果定义了 <code>o = 97</code> ，相当于在当前函数 inner 作用域中重新定义了一个新的变量o，但是，<em><strong>这个 o 并不能覆盖掉外部作用域 outer2 中的变量 o</strong></em>。只不过对于 inner 函数来说，其只能可见自己作用域中定义的变量 o 了</li>
</ul>
<table>
<thead>
<tr>
<th>内建函数</th>
<th>函数签名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>chr</td>
<td>chr(i)</td>
<td>通过unicode编码返回对应字符</td>
</tr>
<tr>
<td>ord</td>
<td>ord(c)</td>
<td>获得字符对应的unicode</td>
</tr>
</tbody>
</table>
<div><pre><code><span>print</span><span>(</span><span>ord</span><span>(</span><span>'中'</span><span>)</span><span>,</span> <span>hex</span><span>(</span><span>ord</span><span>(</span><span>'中'</span><span>)</span><span>)</span><span>,</span> <span>'中'</span><span>.</span>encode<span>(</span><span>)</span><span>,</span> <span>'中'</span><span>.</span>encode<span>(</span><span>'gbk'</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>chr</span><span>(</span><span>20013</span><span>)</span><span>)</span> <span># '中'</span>
<span>print</span><span>(</span><span>chr</span><span>(</span><span>97</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>一个赋值语句的问题</strong></p>
<p>函数内，变量未定义，+= 1问题</p>
<p>略</p>
<h2 id="global-语句"> global 语句</h2>
<div><pre><code>x <span>=</span> <span>5</span>
<span>def</span> <span>foo</span><span>(</span><span>)</span><span>:</span>
    <span>global</span> x <span># 全局变量</span>
    x <span>+=</span> <span>1</span>
    <span>print</span><span>(</span>x<span>)</span>
foo<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>使用 global 关键字的变量，将 foo 内的 x 声明为使用外部的全局作用域中定义的 x</li>
<li>全局作用域中必须有 x 的定义</li>
<li>使用了global，foo中的x不再是局部变量了，它是全局变量。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><code>x+=1</code> 这种是特殊形式产生的错误的原因？先引用后赋值，而 python 动态语言是赋值才算定义，才能被引用。解决办法，在这条语句前增加 x=0 之类的赋值语句，或者使用global 告诉内部作用域，去全局作用域查找变量定义</li>
<li>内部作用域使用 <code>x = 10</code> 之类的赋值语句会重新定义局部作用域使用的变量x，但是，一旦这个作
用域中使用 global 声明x为全局的，那么<code>x=10</code>相当于在为全局作用域的变量x赋值</li>
</ul>
<p><strong>global使用原则</strong></p>
<ul>
<li>外部作用域变量会在内部作用域可见，但也不要在这个内部的局部作用域中直接使用，因为函数的目的就是为了封装，尽量与外界隔离</li>
<li>如果函数需要使用外部全局变量，请尽量使用函数的形参定义，并在调用传实参解决</li>
<li>一句话：不用global。学习它就是为了深入理解变量作用域</li>
</ul>
<h2 id="闭包"> 闭包</h2>
<p><strong>自由变量</strong>：未在本地作用域中定义的变量。例如定义在内层函数外的外层函数的作用域中的变量</p>
<p><strong>闭包</strong>：就是一个概念，出现在嵌套函数中，指的是<strong>内层函数引用到了外层函数的自由变量</strong>，就形成了闭包。很多语言都有这个概念，最熟悉就是JavaScript</p>
<div><pre><code><span>def</span> <span>counter</span><span>(</span><span>)</span><span>:</span>
    c <span>=</span> <span>[</span><span>0</span><span>]</span>
    <span>def</span> <span>inc</span><span>(</span><span>)</span><span>:</span>
        c<span>[</span><span>0</span><span>]</span> <span>+=</span> <span>1</span> <span># 报错吗？ 为什么 # line 4</span>
        <span>return</span> c<span>[</span><span>0</span><span>]</span>
    <span>return</span> inc
foo <span>=</span> counter<span>(</span><span>)</span> <span># line 8</span>
<span>print</span><span>(</span>foo<span>(</span><span>)</span><span>,</span> foo<span>(</span><span>)</span><span>)</span> <span># line 9</span>
c <span>=</span> <span>100</span>
<span>print</span><span>(</span>foo<span>(</span><span>)</span><span>)</span> <span># line 11</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码分析</p>
<ul>
<li>第8行会执行 counter 函数并返回 inc 对应的函数对象，注意这个函数对象并不释放，因为有 foo 记着</li>
<li>第4行会报错吗？为什么
<ul>
<li>不会报错，c 已经在 counter 函数中定义过了。而且 inc 中的使用方式是为 c 的元素修改值，而不是重新定义 c 变量</li>
</ul>
</li>
<li>第9行打印什么结果？
<ul>
<li>打印 1 2</li>
</ul>
</li>
<li>第11行打印什么结果？
<ul>
<li>打印 3</li>
<li>第9行的 c 和 counter 中的 c 不一样，而 inc 引用的是自由变量正是 counter 中的变量 c</li>
</ul>
</li>
</ul>
<p>这是 Python2 中实现闭包的方式，Python3 还可以使用 nonlocal 关键字</p>
<p>再看下面这段代码，会报错吗？使用 global 能解决吗？</p>
<div><pre><code><span>def</span> <span>counter</span><span>(</span><span>)</span><span>:</span>
    count <span>=</span> <span>0</span>
    <span>def</span> <span>inc</span><span>(</span><span>)</span><span>:</span>
        count <span>+=</span> <span>1</span>
        <span>return</span> count
    <span>return</span> inc

foo <span>=</span> counter<span>(</span><span>)</span>
<span>print</span><span>(</span>foo<span>(</span><span>)</span><span>,</span> foo<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上例一定出错，使用gobal可以解决</p>
<div><pre><code><span>def</span> <span>counter</span><span>(</span><span>)</span><span>:</span>
    <span>global</span> count
    count <span>=</span> <span>0</span>
    <span>def</span> <span>inc</span><span>(</span><span>)</span><span>:</span>
        <span>global</span> count
        count <span>+=</span> <span>1</span>
        <span>return</span> count
    <span>return</span> inc

foo <span>=</span> counter<span>(</span><span>)</span>
<span>print</span><span>(</span>foo<span>(</span><span>)</span><span>,</span> foo<span>(</span><span>)</span><span>)</span>
count <span>=</span> <span>100</span>
<span>print</span><span>(</span>foo<span>(</span><span>)</span><span>)</span> <span># 打印几？ 101</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上例使用 global 解决，这是全局变量的实现，而不是闭包了。</p>
<p>如果要对这个普通变量使用闭包，Python3中可以使用nonlocal关键字。</p>
<h2 id="nonlocal-语句"> nonlocal 语句</h2>
<p><strong>nonlocal</strong>：将变量标记为不在本地作用域定义，而是在<strong>上级的某一级局部作用域</strong>中定义，但<strong>不能是全局</strong>
<strong>作用域中定义</strong>。</p>
<div><pre><code><span>def</span> <span>counter</span><span>(</span><span>)</span><span>:</span>
    count <span>=</span> <span>0</span>
    <span>def</span> <span>inc</span><span>(</span><span>)</span><span>:</span>
        <span>nonlocal</span> count <span># 声明变量count不是本地变量</span>
        count <span>+=</span> <span>1</span>
        <span>return</span> count
    <span>return</span> inc

foo <span>=</span> counter<span>(</span><span>)</span>
<span>print</span><span>(</span>foo<span>(</span><span>)</span><span>,</span> foo<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>count 是外层函数的局部变量，被内部函数引用。</p>
<p>内部函数使用 nonlocal 关键字声明 count 变量在上级作用域而非本地作用域中定义。</p>
<p>代码中内层函数引用外部局部作用域中的自由变量，形成闭包。</p>
<div><pre><code>count <span>=</span> <span>10</span>
<span>def</span> <span>counter</span><span>(</span><span>)</span><span>:</span>
    <span>nonlocal</span> count
    count <span>+=</span> <span>1</span>
    <span>return</span> count

foo <span>=</span> counter<span>(</span><span>)</span>
<span>print</span><span>(</span>foo<span>(</span><span>)</span><span>,</span> foo<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上例是错误的，nonlocal 声明变量 a 不在当前作用域，但是往外就是全局作用域了，所以错误。</p>
<h2 id="函数的销毁"> 函数的销毁</h2>
<p>定义一个函数就是生成一个函数对象，函数名指向的就是函数对象。</p>
<p>可以使用 del 语句删除函数，使其引用计数减1。</p>
<p>可以使用同名标识符覆盖原有定义，本质上也是使其引用计数减1。</p>
<p>Python 程序结束时，所有对象销毁。</p>
<p>函数也是对象，也不例外，是否销毁，还是看引用计数是否减为0。</p>
<h2 id="变量名解析原则legb"> 变量名解析原则LEGB</h2>
<ul>
<li>Local，本地作用域、局部作用域的 local 命名空间。函数调用时创建，调用结束消亡</li>
<li>Enclosing，Python2.2 时引入了嵌套函数，实现了闭包，这个就是嵌套函数的外部函数的命名空间</li>
<li>Global，全局作用域，即一个模块的命名空间。模块被 import 时创建，解释器退出时消亡</li>
<li>Build-in，内置模块的命名空间，生命周期从 python 解释器启动时创建到解释器退出时消亡。例如print(open)，print 和 open 都是内置的变量</li>
</ul>
<p>所以一个名词的查找顺序就是LEGB</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/LEGB.png" alt="LEGB" /></p>
<table>
<thead>
<tr>
<th>内建函数</th>
<th>函数签名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter</td>
<td>iter(iterable)</td>
<td>把一个可迭代对象包装成迭代器</td>
</tr>
<tr>
<td>next</td>
<td>next(iterable[,default])</td>
<td>取迭代器下一个元素<br/>如果已经取完，继续取抛StopIteration异常</td>
</tr>
<tr>
<td>reversed</td>
<td>reversed(seq)</td>
<td>返回一个翻转元素的迭代器</td>
</tr>
<tr>
<td>enumerate</td>
<td>enumerate(seq, start=0)</td>
<td>迭代一个可迭代对象，返回一个迭代器<br/>每一个元素都是数字和元素构成的二元组</td>
</tr>
</tbody>
</table>
<p>迭代器</p>
<ul>
<li>特殊的对象，一定是可迭代对象，具备可迭代对象的特征</li>
<li>通过 iter 方法把一个可迭代对象封装成迭代器</li>
<li>通过 next 方法，迭代 迭代器对象</li>
<li>生成器对象，就是迭代器对象。但是迭代器对象未必是生成器对象</li>
</ul>
<p>可迭代对象</p>
<ul>
<li>能够通过迭代一次次返回不同的元素的对象
<ul>
<li>所谓相同，不是指值是否相同，而是元素在容器中是否是同一个，例如列表中值可以重复的，['a', 'a']，虽然这个列表有2个元素，值一样，但是两个'a'是不同的元素</li>
</ul>
</li>
<li>可以迭代，但是未必有序，未必可索引</li>
<li>可迭代对象有：list、tuple、string、bytes、bytearray、range、set、dict、生成器、迭代器等</li>
<li>可以使用成员操作符in、not in
<ul>
<li>对于线性数据结构，in本质上是在遍历对象，时间复杂度为O(n)</li>
</ul>
</li>
</ul>
<div><pre><code>lst <span>=</span> <span>[</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>]</span>
it <span>=</span> <span>iter</span><span>(</span>lst<span>)</span> <span># 返回一个迭代器对象</span>
<span>print</span><span>(</span><span>next</span><span>(</span>it<span>)</span><span>)</span> <span># 1</span>
<span>print</span><span>(</span><span>next</span><span>(</span>it<span>)</span><span>)</span> <span># 3</span>
<span>for</span> i<span>,</span> x <span>in</span> <span>enumerate</span><span>(</span>it<span>,</span> <span>2</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>i<span>,</span> x<span>)</span>
<span>#2 5</span>
<span>#3 7</span>
<span>#4 9</span>

<span># print(next(it)) # StopIteration</span>
<span>print</span><span>(</span><span>)</span>

<span>for</span> x <span>in</span> <span>reversed</span><span>(</span>lst<span>)</span><span>:</span>
    <span>print</span><span>(</span>x<span>)</span> <span># 9 7 5 3 1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">14 多进程</title>
    <id>https://clay-wangzhi.com/code/python/python-gil-multiprocessing/</id>
    <link href="https://clay-wangzhi.com/code/python/python-gil-multiprocessing/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_14-多进程"> 14 多进程</h1>
<h2 id="gil"> GIL</h2>
<p>CPython 在解释器进程级别有一把锁，叫做GIL，即全局解释器锁。</p>
<p>GIL 保证CPython进程中，只有一个线程执行字节码。甚至是在多核CPU的情况下，也只允许同时只能有一个CPU核心上运行该进程的一个线程。</p>
<p>CPython中</p>
<ul>
<li>IO密集型，某个线程阻塞，GIL会释放，就会调度其他就绪线程</li>
<li>CPU密集型，当前线程可能会连续的获得GIL，导致其它线程几乎无法使用CPU</li>
<li>在CPython中由于有GIL存在，IO密集型，使用多线程较为合算；CPU密集型，使用多进程，要绕开GIL</li>
</ul>
<p>新版CPython正在努力优化GIL的问题，但不是移除。
如果在意多线程的效率问题，请绕行，选择其它语言erlang、Go等。</p>
<blockquote>
<p>Python中绝大多数内置数据结构的读、写操作都是原子操作。
由于GIL的存在，Python的内置数据类型在多线程编程的时候就变成了安全的了，但是实际上它们本身 不是线程安全类型。</p>
</blockquote>
<p>保留GIL的原因：
GvR坚持的简单哲学，对于初学者门槛低，不需要高深的系统知识也能安全、简单的使用Python。
而且移除GIL，会降低CPython单线程的执行效率。
测试下面2个程序，请问下面的程序是计算密集型还是IO密集型？</p>
<div><pre><code><span>import</span> logging
<span>import</span> datetime

logging<span>.</span>basicConfig<span>(</span>level<span>=</span>logging<span>.</span>INFO<span>,</span> <span>format</span><span>=</span><span>"%(thread)s %(message)s"</span><span>)</span>
start <span>=</span> datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span>
<span># 计算</span>
<span>def</span> <span>calc</span><span>(</span><span>)</span><span>:</span>
    <span>sum</span> <span>=</span> <span>0</span>
    <span>for</span> _ <span>in</span> <span>range</span><span>(</span><span>10000000</span><span>)</span><span>:</span>
        <span>sum</span> <span>+=</span> <span>1</span>

calc<span>(</span><span>)</span>
calc<span>(</span><span>)</span>
calc<span>(</span><span>)</span>
calc<span>(</span><span>)</span>
delta <span>=</span> <span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span> <span>-</span> start<span>)</span><span>.</span>total_seconds<span>(</span><span>)</span>
logging<span>.</span>info<span>(</span>delta<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>import</span> threading
<span>import</span> logging
<span>import</span> datetime

logging<span>.</span>basicConfig<span>(</span>level<span>=</span>logging<span>.</span>INFO<span>,</span> <span>format</span><span>=</span><span>"%(thread)s %(message)s"</span><span>)</span>
start <span>=</span> datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span>
<span># 计算</span>
<span>def</span> <span>calc</span><span>(</span><span>)</span><span>:</span>
    <span>sum</span> <span>=</span> <span>0</span>
    <span>for</span> _ <span>in</span> <span>range</span><span>(</span><span>10000000</span><span>)</span><span>:</span>
        <span>sum</span> <span>+=</span> <span>1</span>

t1 <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>calc<span>)</span>
t2 <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>calc<span>)</span>
t3 <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>calc<span>)</span>
t4 <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>calc<span>)</span>
t1<span>.</span>start<span>(</span><span>)</span>
t2<span>.</span>start<span>(</span><span>)</span>
t3<span>.</span>start<span>(</span><span>)</span>
t4<span>.</span>start<span>(</span><span>)</span>
t1<span>.</span>join<span>(</span><span>)</span>
t2<span>.</span>join<span>(</span><span>)</span>
t3<span>.</span>join<span>(</span><span>)</span>
t4<span>.</span>join<span>(</span><span>)</span>
delta <span>=</span> <span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span> <span>-</span> start<span>)</span><span>.</span>total_seconds<span>(</span><span>)</span>
logging<span>.</span>info<span>(</span>delta<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>注意，不要在代码中出现print等访问IO的语句。访问IO，线程阻塞，会释放GIL锁，其他线程被调度。</p>
<p>程序1是单线程程序，所有calc()依次执行，根本就不是并发。在主线程内，函数串行执行。
程序2是多线程程序，calc()执行在不同的线程中，但是由于GIL的存在，线程的执行变成了假并发。但是这些线程可以被调度到不同的CPU核心上执行，只不过GIL让同一时间该进程只有一个线程被执行。</p>
<p>从两段程序测试的结果来看，CPython中多线程根本没有任何优势，和一个线程执行时间相当。因为GIL的存在，尤其是像上面的计算密集型程序，和单线程串行效果相当。这样，实际上就没有用上CPU多核心的优势。</p>
<h2 id="多进程"> 多进程</h2>
<p>由于Python的GIL全局解释器锁存在，多线程未必是CPU密集型程序的好的选择。
多进程可以完全独立的进程环境中运行程序，可以较充分地利用多处理器。
但是进程本身的隔离带来的数据不共享也是一个问题。而且线程比进程轻量级。</p>
<h3 id="multiprocessing"> multiprocessing</h3>
<p><strong>Process类</strong></p>
<p>Process类遵循了Thread类的API，减少了学习难度。</p>
<p>先看一个例子，前面介绍的单线程、多线程比较的例子的多进程版本</p>
<div><pre><code><span>import</span> multiprocessing
<span>import</span> datetime


<span># 计算</span>
<span>def</span> <span>calc</span><span>(</span>i<span>)</span><span>:</span>
    <span>sum</span> <span>=</span> <span>0</span>
    <span>for</span> _ <span>in</span> <span>range</span><span>(</span><span>10000000</span><span>)</span><span>:</span>
        <span>sum</span> <span>+=</span> <span>1</span>
    <span>return</span> i<span>,</span> <span>sum</span>

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    start <span>=</span> datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span>

    ps <span>=</span> <span>[</span><span>]</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>4</span><span>)</span><span>:</span>
        p <span>=</span> multiprocessing<span>.</span>Process<span>(</span>target<span>=</span>calc<span>,</span> args<span>=</span><span>(</span>i<span>,</span> <span>)</span><span>,</span> name<span>=</span><span>'calc-{}'</span><span>.</span><span>format</span><span>(</span>i<span>)</span><span>)</span>
        ps<span>.</span>append<span>(</span>p<span>)</span>
        p<span>.</span>start<span>(</span><span>)</span>

    <span>for</span> p <span>in</span> ps<span>:</span>
        p<span>.</span>join<span>(</span><span>)</span>
        <span>print</span><span>(</span>p<span>.</span>name<span>,</span> p<span>.</span>exitcode<span>)</span>

    delta <span>=</span> <span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span> <span>-</span> start<span>)</span><span>.</span>total_seconds<span>(</span><span>)</span>
    <span>print</span><span>(</span>delta<span>)</span>
    <span>for</span> p <span>in</span> ps<span>:</span>
        <span>print</span><span>(</span>p<span>.</span>name<span>,</span> p<span>.</span>exitcode<span>)</span>
    <span>print</span><span>(</span><span>'===end==='</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>对于上面这个程序，在同一主上运行时长的对比</p>
<ul>
<li>使用单线程、多线程跑了4分钟多</li>
<li>多进程用了1分半</li>
</ul>
<p>看到了多个进程都在使用CPU，这是真并行，而且进程库几乎没有什么学习难度</p>
<p>注意：多进程代码一定要放在 <code>__name__ == '__main__'</code> 下面执行。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid</td>
<td>进程 id</td>
</tr>
<tr>
<td>exitcode</td>
<td>进程的退出状态码</td>
</tr>
<tr>
<td>terminate()</td>
<td>终止指定的进程</td>
</tr>
</tbody>
</table>
<h3 id="进程间同步"> 进程间同步</h3>
<p>Python 在进程间同步提供了和线程同步一样的类，使用的方法一样，使用的效果也类似。
不过，进程间代价要高于线程间，而且系统底层实现是不同的，只不过 Python 屏蔽了这些不同之处，让用户简单使用多进程。
multiprocessing 还提供共享内存、服务器进程来共享数据，还提供了用于进程间通讯的 Queue队列、Pipe 管道。</p>
<p>通信方式不同</p>
<ol>
<li>多进程就是启动多个解释器进程，进程间通信必须序列化、反序列化</li>
<li>数据的线程安全性问题
如果每个进程中没有实现多线程，GIL可以说没什么用了</li>
</ol>
<h3 id="多进程、多线程的选择"> 多进程、多线程的选择</h3>
<p>1、CPU密集型
CPython中使用到了GIL，多线程的时候锁相互竞争，且多核优势不能发挥，选用Python多进程效率更
高。</p>
<p>2、IO密集型
在Python中适合是用多线程，可以减少多进程间IO的序列化开销。且在IO等待的时候，切换到其他线程继续执行，效率不错。</p>
<p><strong>应用</strong></p>
<p>请求/应答模型：WEB应用中常见的处理模型</p>
<p>master启动多个worker工作进程，一般和CPU数目相同。发挥多核优势。
worker工作进程中，往往需要操作网络IO和磁盘IO，启动多线程，提高并发处理能力。worker处理用户的请求，往往需要等待数据，处理完请求还要通过网络IO返回响应。
这就是nginx工作模式。</p>
<h2 id="concurrent-futures包"> concurrent.futures包</h2>
<p>3.2版本引入的模块。</p>
<p>异步并行任务编程模块，提供一个高级的异步可执行的便利接口。</p>
<p>提供了2个池执行器：</p>
<ul>
<li>ThreadPoolExecutor 异步调用的线程池的 Executor</li>
<li>ProcessPoolExecutor 异步调用的进程池的Executor</li>
</ul>
<h3 id="threadpoolexecutor对象"> ThreadPoolExecutor对象</h3>
<p>首先需要定义一个池的执行器对象，Executor类的子类实例。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ThreadPoolExecutor(max_workers=1)</td>
<td>池中至多创建max_workers个线程的池来同时异步执行，返回Executor实例<br/>支持上下文，进入时返回自己，退出时调用shutdown(wait=True)</td>
</tr>
<tr>
<td>submit(fn, *args, **kwargs)</td>
<td>提交执行的函数及其参数，如有空闲开启daemon线程，返回Future类的实例</td>
</tr>
<tr>
<td>shutdown(wait=True)</td>
<td>清理池，wait 表示是否等待到任务线程完成</td>
</tr>
</tbody>
</table>
<p>Future 类</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>done()</td>
<td>如果调用被成功的取消或者执行完成，返回True</td>
</tr>
<tr>
<td>cancelled()</td>
<td>如果调用被成功的取消，返回True</td>
</tr>
<tr>
<td>running()</td>
<td>如果正在运行且不能被取消，返回True</td>
</tr>
<tr>
<td>cancel()</td>
<td>尝试取消调用。如果已经执行且不能取消返回False，否则返回True</td>
</tr>
<tr>
<td>result(timeout=None)</td>
<td>取返回的结果，timeout为None，一直等待返回；timeout设置到期，抛出<br/>concurrent.futures.TimeoutError 异常</td>
</tr>
<tr>
<td>exception(timeout=None)</td>
<td>取返回的异常，timeout为None，一直等待返回；timeout设置到期，抛出<br/>concurrent.futures.TimeoutError 异常</td>
</tr>
</tbody>
</table>
<div><pre><code><span>from</span> concurrent<span>.</span>futures <span>import</span> ThreadPoolExecutor<span>,</span> wait
<span>import</span> datetime
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s [%(processName)s %(threadName)s] %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

<span>def</span> <span>calc</span><span>(</span>base<span>)</span><span>:</span>
    <span>sum</span> <span>=</span> base
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>1000000</span><span>)</span><span>:</span>
        <span>sum</span> <span>+=</span> <span>1</span>
    logging<span>.</span>info<span>(</span><span>sum</span><span>)</span>
    <span>return</span> <span>sum</span>

start <span>=</span> datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span>
executor <span>=</span> ThreadPoolExecutor<span>(</span><span>3</span><span>)</span>
<span>with</span> executor<span>:</span> <span># 默认shutdown阻塞</span>
    fs <span>=</span> <span>[</span><span>]</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>3</span><span>)</span><span>:</span>
        future <span>=</span> executor<span>.</span>submit<span>(</span>calc<span>,</span> i<span>*</span><span>100</span><span>)</span>
        fs<span>.</span>append<span>(</span>future<span>)</span>

    <span>#wait(fs) # 阻塞</span>
    <span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

<span>for</span> f <span>in</span> fs<span>:</span>
    <span>print</span><span>(</span>f<span>,</span> f<span>.</span>done<span>(</span><span>)</span><span>,</span> f<span>.</span>result<span>(</span><span>)</span><span>)</span> <span># done不阻塞，result阻塞</span>
<span>print</span><span>(</span><span>'='</span> <span>*</span> <span>30</span><span>)</span>

delta <span>=</span> <span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span> <span>-</span> start<span>)</span><span>.</span>total_seconds<span>(</span><span>)</span>

<span>print</span><span>(</span>delta<span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id="processpoolexecutor对象"> ProcessPoolExecutor对象</h3>
<p>方法一样。就是使用多进程完成。</p>
<div><pre><code><span>from</span> concurrent<span>.</span>futures <span>import</span> ProcessPoolExecutor<span>,</span> wait
<span>import</span> datetime
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s [%(processName)s %(threadName)s] %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

<span>def</span> <span>calc</span><span>(</span>base<span>)</span><span>:</span>
    <span>sum</span> <span>=</span> base
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10000000</span><span>)</span><span>:</span>
        <span>sum</span> <span>+=</span> <span>1</span>
    logging<span>.</span>info<span>(</span><span>sum</span><span>)</span>
    <span>return</span> <span>sum</span>

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    start <span>=</span> datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span>
    executor <span>=</span> ProcessPoolExecutor<span>(</span><span>3</span><span>)</span>
    <span>with</span> executor<span>:</span> <span># 默认shutdown阻塞</span>
        fs <span>=</span> <span>[</span><span>]</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>3</span><span>)</span><span>:</span>
            future <span>=</span> executor<span>.</span>submit<span>(</span>calc<span>,</span> i<span>*</span><span>100</span><span>)</span>
            fs<span>.</span>append<span>(</span>future<span>)</span>

        <span>#wait(fs) # 阻塞</span>
        <span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

    <span>for</span> f <span>in</span> fs<span>:</span>
        <span>print</span><span>(</span>f<span>,</span> f<span>.</span>done<span>(</span><span>)</span><span>,</span> f<span>.</span>result<span>(</span><span>)</span><span>)</span> <span># done不阻塞，result阻塞</span>
    <span>print</span><span>(</span><span>'='</span> <span>*</span> <span>30</span><span>)</span>

    delta <span>=</span> <span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span> <span>-</span> start<span>)</span><span>.</span>total_seconds<span>(</span><span>)</span>
    <span>print</span><span>(</span>delta<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p><strong>总结</strong></p>
<p>该库统一了线程池、进程池调用，简化了编程。
是Python简单的思想哲学的体现。</p>
<p>唯一的缺点：无法设置线程名称。但这都不值一提。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">03 哈希表和解析式</title>
    <id>https://clay-wangzhi.com/code/python/python-ha-tables-analytic-expre/</id>
    <link href="https://clay-wangzhi.com/code/python/python-ha-tables-analytic-expre/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_03-哈希表和解析式"> 03 哈希表和解析式</h1>
<h2 id="封装和解构"> 封装和解构</h2>
<h3 id="基本概念"> 基本概念</h3>
<div><pre><code>t1 <span>=</span> <span>1</span><span>,</span> <span>2</span>
<span>print</span><span>(</span><span>type</span><span>(</span>t1<span>)</span><span>)</span> <span># 什么类型, tuple</span>

t2 <span>=</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>
<span>print</span><span>(</span><span>type</span><span>(</span>t2<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Python等式右侧出现逗号分隔的多值的时候，就会将这几个值封装到元组中。这种操作称为封装packing。</p>
<div><pre><code>x<span>,</span> y <span>=</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>
<span>print</span><span>(</span>x<span>)</span> <span># 1</span>
<span>print</span><span>(</span>y<span>)</span> <span># 2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Python 中等式右侧是一个容器类型，左侧是逗号分隔的多个标识符，将右侧容器中数据的一个个和左侧
标识符一一对应。这种操作称为解构 unpacking。</p>
<p>从 Python3 开始，对解构做了很大的改进，现在用起来已经非常的方便快捷。</p>
<p>封装和解构是非常方便的提取数据的方法，在 Python、JavaScript 等语言中应用极广。</p>
<div><pre><code><span># 交换数据</span>
x <span>=</span> <span>4</span>
y <span>=</span> <span>5</span>
t <span>=</span> x
x <span>=</span> y
y <span>=</span> t

<span># 封装和解构，交换</span>
x <span>=</span> <span>10</span>
y <span>=</span> <span>11</span>
x<span>,</span> y <span>=</span> y<span>,</span> x
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="简单解构"> 简单解构</h3>
<div><pre><code><span># 左右个数相同  ,必须相等</span>
a<span>,</span>b <span>=</span> <span>1</span><span>,</span><span>2</span>
a<span>,</span>b <span>=</span> <span>(</span><span>1</span><span>,</span><span>2</span><span>)</span>
a<span>,</span>b <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>]</span>
a<span>,</span>b <span>=</span> <span>[</span><span>10</span><span>,</span><span>20</span><span>]</span>
a<span>,</span>b <span>=</span> <span>{</span><span>10</span><span>,</span><span>20</span><span>}</span> <span># 非线性结构</span>
a<span>,</span>b <span>=</span> <span>{</span><span>'a'</span><span>:</span><span>10</span><span>,</span><span>'b'</span><span>:</span><span>20</span><span>}</span> <span># 非线性结构也可以解构</span>
<span>[</span>a<span>,</span>b<span>]</span> <span>=</span> <span>(</span><span>1</span><span>,</span><span>2</span><span>)</span>
<span>[</span>a<span>,</span>b<span>]</span> <span>=</span> <span>10</span><span>,</span><span>20</span>
<span>(</span>a<span>,</span>b<span>)</span> <span>=</span> <span>{</span><span>30</span><span>,</span><span>40</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="剩余变量解构"> 剩余变量解构</h3>
<p>在 Python3.0 中增加了剩余变量解构（rest）。</p>
<div><pre><code>a<span>,</span> <span>*</span>rest<span>,</span> b <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span>
<span>print</span><span>(</span>a<span>,</span> b<span>)</span>
<span>print</span><span>(</span><span>type</span><span>(</span>rest<span>)</span><span>,</span> rest<span>)</span> <span># &lt;class 'list'> [2, 3, 4]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>标识符 rest 将尽可能收集剩余的数据组成一个列表。</p>
<div><pre><code>a<span>,</span> <span>*</span>_<span>,</span> b <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span>
<span>print</span><span>(</span>_<span>)</span> <span># 在IPython中实验，_是最后一个输出值，这里将把它覆盖</span>
_<span>,</span> <span>*</span>b<span>,</span> _ <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>
<span>print</span><span>(</span>_<span>)</span> <span># 第一个_是什么</span>
<span>print</span><span>(</span>b<span>)</span> <span># 是什么</span>
<span>print</span><span>(</span>_<span>)</span> <span># 第二个_是什么</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>_ 是合法的标识符，这里它没有什么可读性，它在这里的作用就是表示不关心这个变量的值，我不想要。有人把它称作 丢弃(Throwaway)变量。</p>
<h2 id="集合-set"> 集合 set</h2>
<p>集合，简称集。由任意个元素构成的集体。高级语言都实现了这个非常重要的数据结构类型。</p>
<p>Python中，它是可变的、无序的、不重复的元素的集合。</p>
<h3 id="初始化"> 初始化</h3>
<ul>
<li>set() -&gt; new empty set object</li>
<li>set(iterable) -&gt; new set object</li>
</ul>
<div><pre><code>s1 <span>=</span> <span>set</span><span>(</span><span>)</span>
s2 <span>=</span> <span>set</span><span>(</span><span>range</span><span>(</span><span>5</span><span>)</span><span>)</span>
s3 <span>=</span> <span>set</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span>  <span># 报错</span>
s4 <span>=</span> <span>set</span><span>(</span><span>'abcdabcd'</span><span>)</span>
s5 <span>=</span> <span>{</span><span>}</span> <span># 这是什么？  z字典</span>
s6 <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span>
s7 <span>=</span> <span>{</span><span>1</span><span>,</span> <span>(</span><span>1</span><span>,</span><span>)</span><span>}</span>
s8 <span>=</span> <span>{</span><span>1</span><span>,</span> <span>(</span><span>1</span><span>,</span><span>)</span><span>,</span> <span>[</span><span>1</span><span>]</span><span>}</span> <span>#  报错</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="元素性质"> 元素性质</h3>
<ul>
<li>去重：在集合中，所有元素必须相异</li>
<li>无序：因为无序，所以不可索引</li>
<li>可哈希：Python集合中的元素必须可以hash，即元素都可以使用内建函数hash
<ul>
<li>目前学过不可hash的类型有：list、set、bytearray</li>
</ul>
</li>
<li>可迭代：set中虽然元素不一样，但元素都可以迭代出来</li>
</ul>
<h3 id="增加"> 增加</h3>
<ul>
<li>add(elem)
<ul>
<li>增加一个元素到 set 中</li>
<li>如果元素存在，什么都不做</li>
</ul>
</li>
<li>update(*others)
<ul>
<li>合并其他元素到set集合中来</li>
<li>参数others必须是可迭代对象</li>
<li>就地修改</li>
</ul>
</li>
</ul>
<div><pre><code>s <span>=</span> <span>set</span><span>(</span><span>)</span>
s<span>.</span>add<span>(</span><span>1</span><span>)</span>
s<span>.</span>update<span>(</span><span>(</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>)</span><span>,</span> <span>[</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="删除"> 删除</h3>
<ul>
<li>
<p>remove(elem)</p>
<ul>
<li>从set中移除一个元素</li>
<li>元素不存在，抛出KeyError异常。为什么是KeyError？</li>
</ul>
</li>
<li>
<p>discard(elem)</p>
<ul>
<li>从set中移除一个元素</li>
<li>元素不存在，什么都不做</li>
</ul>
</li>
<li>
<p>pop() -&gt; item</p>
<ul>
<li>移除并返回任意的元素。为什么是任意元素？ 因为是随机的，无序的</li>
<li>空集返回KeyError异常</li>
</ul>
</li>
<li>
<p>clear()</p>
<ul>
<li>移除所有元素</li>
</ul>
</li>
</ul>
<div><pre><code>s <span>=</span> <span>set</span><span>(</span><span>range</span><span>(</span><span>10</span><span>)</span><span>)</span>
s<span>.</span>remove<span>(</span><span>0</span><span>)</span>
<span>#s.remove(11) # KeyError为什么</span>
s<span>.</span>discard<span>(</span><span>11</span><span>)</span>
s<span>.</span>pop<span>(</span><span>)</span>
s<span>.</span>clear<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="修改"> 修改</h3>
<p>集合类型没有修改。因为元素唯一。如果元素能够加入到集合中，说明它和别的元素不一样。</p>
<p>所谓修改，其实就是把当前元素改成一个完全不同的元素，就是删除加入新元素。</p>
<h3 id="索引"> 索引</h3>
<p>非线性结构，不可索引。</p>
<h3 id="遍历"> 遍历</h3>
<p>只要是容器，都可以遍历元素。但是效率都是O(n)</p>
<h3 id="成员运算符-in"> 成员运算符 in</h3>
<div><pre><code><span>print</span><span>(</span><span>10</span> <span>in</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span>
<span>print</span><span>(</span><span>10</span> <span>in</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面2句代码，分别在列表和集合中搜索元素。如果列表和集合的元素都有100万个，谁的效率高？ 集合效率高</p>
<p>set、dict 使用 hash 表实现，内部使用 hash 值作为 key，时间复杂度为 O(1)，查询时间和数据规模无关，不会随着数据规模增大而搜索性能下降。</p>
<h3 id="集合概念"> 集合概念</h3>
<ul>
<li>全集
<ul>
<li>所有元素的集合。例如实数集，所有实数组成的集合就是全集</li>
</ul>
</li>
<li>子集 bset 和超集 superset
<ul>
<li>一个集合A所有元素都在另一个集合B内，A是B的子集，B是A的超集</li>
</ul>
</li>
<li>真子集和真超集
<ul>
<li>A是B的子集，且A不等于B，A就是B的真子集，B是A的真超集</li>
</ul>
</li>
<li>并集：多个集合合并的结果</li>
<li>交集：多个集合的公共部分</li>
<li>差集：集合中除去和其他集合公共部分</li>
</ul>
<p><strong>并集</strong></p>
<p>将两个集合A和B的所有的元素合并到一起，组成的集合称作集合A与集合B的并集</p>
<ul>
<li>union(*others) 返回和多个集合合并后的新的集合</li>
<li><code>|</code> 运算符重载，等同 union</li>
<li>update(*others) 和多个集合合并，就地修改</li>
<li><code>|=</code> 等同update</li>
</ul>
<p><strong>交集</strong></p>
<p>集合A和B，由所有属于A且属于B的元素组成的集合</p>
<ul>
<li>intersection(*others) 返回和多个集合的交集</li>
<li><code>&amp;</code> 等同 intersection</li>
<li><code>intersection_update(*others)</code> 获取和多个集合的交集，并就地修改</li>
<li><code>&amp;=</code> 等同 intersection_update</li>
</ul>
<p><strong>差集</strong></p>
<p>集合A和B，由所有属于A且不属于B的元素组成的集合</p>
<ul>
<li>
<p><code>difference(*others)</code> 返回和多个集合的差集</p>
</li>
<li>
<p><code>-</code> 等同difference</p>
</li>
<li>
<p><code>difference_update(*others)</code>获取和多个集合的差集并就地修改</p>
</li>
<li>
<p><code>-=</code> 等同difference_update</p>
</li>
</ul>
<p><strong>对称差集</strong></p>
<p>集合A和B，由所有不属于A和B的交集元素组成的集合，记作（A-B）∪（B-A）</p>
<ul>
<li><code>symmetric_differece(other)</code>返回和另一个集合的对称差集</li>
<li><code>^</code> 等同symmetric_differece</li>
<li><code>symmetric_differece_update(other)</code> 获取和另一个集合的对称差集并就地修改</li>
<li><code>^=</code> 等同symmetric_differece_update</li>
</ul>
<p><strong>其它集合运算</strong></p>
<ul>
<li><code>issubset(other)、&lt;=</code> 判断当前集合是否是另一个集合的子集</li>
<li><code>set1 &lt; set2</code> 判断set1是否是set2的真子集</li>
<li><code>issuperset(other)、&gt;=</code> 判断当前集合是否是other的超集</li>
<li><code>set1 &gt; set2</code> 判断set1是否是set2的真超集</li>
<li><code>isdisjoint(other)</code> 当前集合和另一个集合没有交集，没有交集，返回True</li>
</ul>
<h2 id="字典-dict"> 字典 dict</h2>
<p>Dict 即 Dictionary，也称为 mapping。</p>
<p>Python 中，字典由任意个元素构成的集合，每一个元素称为 Item，也称为 Entry。这个 Item 是由(key,
value)组成的二元组。</p>
<p>字典是可变的、无序的、key 不重复的 key-value 键值对集合。</p>
<h3 id="初始化-2"> 初始化</h3>
<ul>
<li><code>dict(**kwargs)</code> 使用 name=value 对初始化一个字典</li>
<li><code>dict(iterable, **kwarg)</code> 使用可迭代对象和name=value对构造字典，不过可迭代对象的元素必须是一个二元结构</li>
<li><code>dict(mapping, **kwarg)</code> 使用一个字典构建另一个字典</li>
</ul>
<p>字典的初始化方法都非常常用，都需要会用</p>
<div><pre><code>d1 <span>=</span> <span>{</span><span>}</span>
d2 <span>=</span> <span>dict</span><span>(</span><span>)</span>
d3 <span>=</span> <span>dict</span><span>(</span>a<span>=</span><span>100</span><span>,</span> b<span>=</span><span>200</span><span>)</span>
d4 <span>=</span> <span>dict</span><span>(</span>d3<span>)</span> <span># 构造另外一个字典</span>
d5 <span>=</span> <span>dict</span><span>(</span>d4<span>,</span> a<span>=</span><span>300</span><span>,</span> c<span>=</span><span>400</span><span>)</span>
d6 <span>=</span> <span>dict</span><span>(</span><span>[</span><span>(</span><span>'a'</span><span>,</span> <span>100</span><span>)</span><span>,</span> <span>[</span><span>'b'</span><span>,</span> <span>200</span><span>]</span><span>,</span> <span>(</span><span>1</span><span>,</span> <span>'abc'</span><span>)</span><span>]</span><span>,</span> b<span>=</span><span>300</span><span>,</span> c<span>=</span><span>400</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span># 类方法dict.fromkeys(iterable, value)</span>
d <span>=</span> <span>dict</span><span>.</span>fromkeys<span>(</span><span>range</span><span>(</span><span>5</span><span>)</span><span>)</span>
d <span>=</span> <span>dict</span><span>.</span>fromkeys<span>(</span><span>range</span><span>(</span><span>5</span><span>)</span><span>,</span> <span>0</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="元素访问"> 元素访问</h3>
<ul>
<li>d[key]
<ul>
<li>返回 key 对应的值 value</li>
<li>key 不存在抛出 KeyError 异常</li>
</ul>
</li>
<li>get(key[, default])
<ul>
<li>返回 key 对应的值 value</li>
<li>key 不存在返回缺省值，如果没有设置缺省值就返回 None</li>
</ul>
</li>
<li>setdefault(key[, default])
<ul>
<li>返回 key 对应的值 value</li>
<li>key 不存在，添加 kv 对，value 设置为 default，并返回 default，如果 default 没有设置，缺省
为None</li>
</ul>
</li>
</ul>
<h3 id="新增和修改"> 新增和修改</h3>
<ul>
<li>d[key] = value
<ul>
<li>将 key 对应的值修改为 value</li>
<li>key不存在添加新的kv对</li>
</ul>
</li>
<li>update([other]) -&gt; None
<ul>
<li>使用另一个字典的 kv 对更新本字典</li>
<li>key不存在，就添加</li>
<li>key存在，覆盖已经存在的key对应的值</li>
<li>就地修改</li>
</ul>
</li>
</ul>
<div><pre><code>d <span>=</span> <span>{</span><span>}</span>
d<span>[</span><span>'a'</span><span>]</span> <span>=</span> <span>1</span>
d<span>.</span>update<span>(</span>red<span>=</span><span>1</span><span>)</span>
d<span>.</span>update<span>(</span><span>[</span><span>'red'</span><span>,</span> <span>2</span><span>]</span><span>)</span> <span># 错误格式</span>
d<span>.</span>update<span>(</span><span>{</span><span>'red'</span><span>:</span><span>3</span><span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="删除-2"> 删除</h3>
<ul>
<li>pop(key[, default])
<ul>
<li>key存在，移除它，并返回它的value</li>
<li>key不存在，返回给定的default</li>
<li>default未设置，key不存在则抛出KeyError异常</li>
</ul>
</li>
<li>popitem()
<ul>
<li>移除并返回一个任意的键值对</li>
<li>字典为empty，抛出KeyError异常</li>
</ul>
</li>
<li>clear()
<ul>
<li>清空字典</li>
</ul>
</li>
</ul>
<h3 id="遍历-2"> 遍历</h3>
<p>1、遍历 Key</p>
<div><pre><code><span>for</span> k <span>in</span> d<span>:</span>
	<span>print</span><span>(</span>k<span>)</span>
    
<span>for</span> k <span>in</span> d<span>.</span>keys<span>(</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>k<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>2、遍历Value</p>
<div><pre><code><span>for</span> v <span>in</span> d<span>.</span>values<span>(</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>v<span>)</span>
    
<span>for</span> k <span>in</span> d<span>.</span>keys<span>(</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>d<span>[</span>k<span>]</span><span>)</span>
	<span>print</span><span>(</span>d<span>.</span>get<span>(</span>k<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>3、遍历Item</p>
<div><pre><code><span>for</span> item <span>in</span> d<span>.</span>items<span>(</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>item<span>)</span>
	<span>print</span><span>(</span>item<span>[</span><span>0</span><span>]</span><span>,</span> item<span>[</span><span>1</span><span>]</span><span>)</span>
    
<span>for</span> k<span>,</span>v <span>in</span> d<span>.</span>items<span>(</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>k<span>,</span> v<span>)</span>
    
<span>for</span> k<span>,</span>_ <span>in</span> d<span>.</span>items<span>(</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>k<span>)</span>
    
<span>for</span> _<span>,</span>v <span>in</span> d<span>.</span>items<span>(</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>v<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>Python3 中，keys、values、items方法返回一个类似一个生成器的可迭代对象</p>
<ul>
<li>Dictionary view对象，可以使用len()、iter()、in操作</li>
<li>字典的entry的动态的视图，字典变化，视图将反映出这些变化</li>
<li>keys返回一个类set对象，也就是可以看做一个set集合。如果values都可以hash，那么items也可以看做是类set对象</li>
</ul>
<p>Python2 中，上面的方法会返回一个新的列表，立即占据新的内存空间。所以 Python2 建议使用 iterkeys、itervalues、iteritems 版本，返回一个迭代器，而不是返回一个copy</p>
<h3 id="遍历与删除"> 遍历与删除</h3>
<div><pre><code><span># 错误的做法</span>
d <span>=</span> <span>dict</span><span>(</span>a<span>=</span><span>1</span><span>,</span> b<span>=</span><span>2</span><span>,</span> c<span>=</span><span>3</span><span>)</span>
<span>for</span> k<span>,</span>v <span>in</span> d<span>.</span>items<span>(</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>d<span>.</span>pop<span>(</span>k<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在使用keys、values、items方法遍历的时候，不可以改变字典的size</p>
<div><pre><code><span>while</span> <span>len</span><span>(</span>d<span>)</span><span>:</span>
	<span>print</span><span>(</span>d<span>.</span>popitem<span>(</span><span>)</span><span>)</span>
    
<span>while</span> d<span>:</span>
	<span>print</span><span>(</span>d<span>.</span>popitem<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的 while 循环虽然可以移除字典元素，但是很少使用，不如直接 clear。</p>
<div><pre><code><span># for 循环正确删除</span>
d <span>=</span> <span>dict</span><span>(</span>a<span>=</span><span>1</span><span>,</span> b<span>=</span><span>2</span><span>,</span> c<span>=</span><span>3</span><span>)</span>
keys <span>=</span> <span>[</span><span>]</span>
<span>for</span> k<span>,</span>v <span>in</span> d<span>.</span>items<span>(</span><span>)</span><span>:</span>
	keys<span>.</span>append<span>(</span>k<span>)</span>
    
<span>for</span> k <span>in</span> keys<span>:</span>
	d<span>.</span>pop<span>(</span>k<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="key"> key</h3>
<p>字典的 key 和 set 的元素要求一致</p>
<ul>
<li>set 的元素可以就是看做 key，set 可以看做 dict 的简化版</li>
<li>hashable 可哈希才可以作为 key，可以使用 hash() 测试</li>
<li>使用key访问，就如同列表使用index访问一样，时间复杂度都是O(1)，这也是最好的访问元素的方式</li>
</ul>
<div><pre><code>d <span>=</span> <span>{</span>
    <span>1</span> <span>:</span> <span>0</span><span>,</span>
    <span>2.0</span> <span>:</span> <span>3</span><span>,</span>
    <span>"abc"</span> <span>:</span> <span>None</span><span>,</span>
    <span>(</span><span>'hello'</span><span>,</span> <span>'world'</span><span>,</span> <span>'python'</span><span>)</span> <span>:</span> <span>"string"</span><span>,</span>
    <span>b'abc'</span> <span>:</span> <span>'135'</span>
<span>}</span>

<span>print</span><span>(</span>d<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="有序性"> 有序性</h3>
<p>后续补充</p>
<h2 id="解析式和生成器表达式"> 解析式和生成器表达式</h2>
<h3 id="列表解析式"> 列表解析式</h3>
<p>列表解析式 List Comprehension，也叫列表推导式。</p>
<div><pre><code><span># 生成一个列表，元素0~9，将每一个元素加1后的平方值组成新的列表</span>
x <span>=</span> <span>[</span><span>]</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
    x<span>.</span>append<span>(</span><span>(</span>i<span>+</span><span>1</span><span>)</span><span>**</span><span>2</span><span>)</span>
<span>print</span><span>(</span>x<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span># 列表解析式</span>
<span>print</span><span>(</span><span>[</span><span>(</span>i<span>+</span><span>1</span><span>)</span><span>**</span><span>2</span> <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>语法</p>
<ul>
<li>[返回值 for 元素 in 可迭代对象 if 条件]</li>
<li>使用中括号[]，内部是 for 循环，if 条件语句可选</li>
<li>返回一个新的列表</li>
</ul>
<p>列表解析式是一种语法糖</p>
<ul>
<li>编译器会优化，不会因为简写而影响效率，反而因优化提高了效率</li>
<li>减少程序员工作量，减少出错</li>
<li>简化了代码，增强了可读性</li>
</ul>
<div><pre><code><span>[</span>expr <span>for</span> item <span>in</span> iterable <span>if</span> cond1 <span>if</span> cond2<span>]</span>
等价于
ret <span>=</span> <span>[</span><span>]</span>
<span>for</span> item <span>in</span> iterable<span>:</span>
    <span>if</span> cond1<span>:</span>
    	<span>if</span> cond2<span>:</span>
        	ret<span>.</span>append<span>(</span>expr<span>)</span>
<span>#</span>
<span>[</span>expr <span>for</span> i <span>in</span> iterable1 <span>for</span> j <span>in</span> iterable2 <span>]</span>
等价于
ret <span>=</span> <span>[</span><span>]</span>
<span>for</span> i <span>in</span> iterable1<span>:</span>
    <span>for</span> j <span>in</span> iterable2<span>:</span>
        ret<span>.</span>append<span>(</span>expr<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span># 因为循环或判断只有一个，一斜到底，所以结果相同</span>
<span>[</span><span>(</span>i<span>,</span>j<span>)</span> <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>7</span><span>)</span> <span>if</span> i<span>></span><span>4</span> <span>for</span> j <span>in</span> <span>range</span><span>(</span><span>20</span><span>,</span><span>25</span><span>)</span> <span>if</span> j<span>></span><span>23</span><span>]</span>
<span>[</span><span>(</span>i<span>,</span>j<span>)</span> <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>7</span><span>)</span> <span>for</span> j <span>in</span> <span>range</span><span>(</span><span>20</span><span>,</span><span>25</span><span>)</span> <span>if</span> i<span>></span><span>4</span> <span>if</span> j<span>></span><span>23</span><span>]</span>
<span>[</span><span>(</span>i<span>,</span>j<span>)</span> <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>7</span><span>)</span> <span>for</span> j <span>in</span> <span>range</span><span>(</span><span>20</span><span>,</span><span>25</span><span>)</span> <span>if</span> i<span>></span><span>4</span> <span>and</span> j<span>></span><span>23</span><span>]</span>
<span># 都是[(5, 24), (6, 24)]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="生成器表达式"> 生成器表达式</h3>
<p>语法</p>
<ul>
<li>(返回值 for 元素 in 可迭代对象 if 条件)</li>
<li>列表解析式的中括号换成小括号就行了</li>
<li>返回一个生成器对象</li>
</ul>
<p>和列表解析式的区别</p>
<ul>
<li>生成器表达式是按需计算（或称惰性求值、延迟计算），需要的时候才计算值，返回可迭代对象迭代器，只能迭代一次</li>
<li>列表解析式是立即返回值，返回可迭代对象列表，不是迭代器，可反复迭代</li>
</ul>
<p>生成器对象</p>
<ul>
<li>可迭代对象</li>
<li>迭代器</li>
</ul>
<p><strong>生成器表达式和列表解析式对比</strong></p>
<ul>
<li>计算方式
<ul>
<li>生成器表达式延迟计算，列表解析式立即计算</li>
</ul>
</li>
<li>内存占用
<ul>
<li>单从返回值本身来说，生成器表达式省内存，列表解析式返回新的列表</li>
<li>生成器没有数据，内存占用极少，但是使用的时候，虽然一个个返回数据，但是合起来占用的内存也差不多</li>
<li>列表解析式构造新的列表需要立即占用掉内存</li>
</ul>
</li>
<li>计算速度
<ul>
<li>单看计算时间看，生成器表达式耗时非常短，列表解析式耗时长</li>
<li>但生成器本身并没有返回任何值，只返回了一个生成器对象</li>
<li>列表解析式构造并返回了一个新的列表</li>
</ul>
</li>
</ul>
<h3 id="集合解析式"> 集合解析式</h3>
<p>语法</p>
<ul>
<li>{返回值 for 元素 in 可迭代对象 if 条件}</li>
<li>列表解析式的中括号换成大括号{}就变成了集合解析式</li>
<li>立即返回一个集合</li>
</ul>
<div><pre><code><span>{</span><span>(</span>x<span>,</span> x<span>+</span><span>1</span><span>)</span> <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>}</span>
<span>{</span><span>[</span>x<span>]</span> <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>}</span> <span># 可以吗？ 不可以 list是不可hash的</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="字典解析式"> 字典解析式</h3>
<p>语法</p>
<ul>
<li>{key:value for 元素 in 可迭代对象 if 条件}</li>
<li>列表解析式的中括号换成大括号{}，元素的构造使用 key:value 形式</li>
<li>立即返回一个字典</li>
</ul>
<div><pre><code><span>print</span><span>(</span><span>{</span>x<span>:</span><span>(</span>x<span>,</span>x<span>+</span><span>1</span><span>)</span> <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>}</span><span>)</span>
<span>print</span><span>(</span><span>{</span>x<span>:</span><span>[</span>x<span>,</span>x<span>+</span><span>1</span><span>]</span> <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>}</span><span>)</span>
<span>print</span><span>(</span><span>{</span><span>(</span>x<span>,</span><span>)</span><span>:</span><span>[</span>x<span>,</span>x<span>+</span><span>1</span><span>]</span> <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>}</span><span>)</span>
<span># print({[x]:[x,x+1] for x in range(10)}) # 错误 key要求 可hash</span>
<span>print</span><span>(</span><span>{</span><span>str</span><span>(</span>x<span>)</span><span>:</span>y <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>3</span><span>)</span> <span>for</span> y <span>in</span> <span>range</span><span>(</span><span>4</span><span>)</span><span>}</span><span>)</span> <span># 输出多少个元素？ 返回三个元素，key值唯一，{'0': 3, '1': 3, '2': 3}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="总结"> 总结</h3>
<ul>
<li>Python2 引入列表解析式</li>
<li>Python2.4 引入生成器表达式</li>
<li>Python3 引入集合、字典解析式，并迁移到了2.7</li>
</ul>
<p>一般来说，应该多应用解析式，简短、高效。如果一个解析式非常复杂，难以读懂，要考虑拆解成for循环。</p>
<p>生成器和迭代器是不同的对象，但都是可迭代对象。</p>
<p>如果不需要立即获得所有可迭代对象的元素，在Python 3中，推荐使用惰性求值的迭代器。</p>
<table>
<thead>
<tr>
<th>内建函数</th>
<th>函数签名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sorted</td>
<td>sorted(iterable[,key][,reverse])</td>
<td>默认升序，对可迭代对象排序<br/>立即返回列表</td>
</tr>
</tbody>
</table>
<div><pre><code><span># 排序一定是容器内全体参与</span>
<span>print</span><span>(</span><span>sorted</span><span>(</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>]</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>sorted</span><span>(</span><span>range</span><span>(</span><span>10</span><span>,</span> <span>20</span><span>)</span><span>,</span> reverse<span>=</span><span>True</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>sorted</span><span>(</span><span>{</span><span>'a'</span><span>:</span><span>100</span><span>,</span> <span>'b'</span><span>:</span><span>'abc'</span><span>}</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>sorted</span><span>(</span><span>{</span><span>'a'</span><span>:</span><span>100</span><span>,</span> <span>'b'</span><span>:</span><span>'abc'</span><span>}</span><span>.</span>items<span>(</span><span>)</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>sorted</span><span>(</span><span>{</span><span>'a'</span><span>:</span><span>'ABC'</span><span>,</span> <span>'b'</span><span>:</span><span>'abc'</span><span>}</span><span>.</span>values<span>(</span><span>)</span><span>,</span> key<span>=</span><span>str</span><span>,</span> reverse<span>=</span><span>True</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">python 实际工作中的实例</title>
    <id>https://clay-wangzhi.com/code/python/python-instance/</id>
    <link href="https://clay-wangzhi.com/code/python/python-instance/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="python-实际工作中的实例"> python 实际工作中的实例</h1>
<h2 id="调用zabbixapi批量添加web监控"> 调用zabbixAPI批量添加web监控</h2>
<p>起因：刚来一家公司，要求我添加web监控，800多个页面监控，手动一个个加，不得加死了，所以写了个python脚本，批量添加</p>
<p>脚本如下：</p>
<div><pre><code><span>#!/usr/bin/env python3</span>
<span># ~*~ coding:utf-8 ~*~</span>
<span>from</span> zabbix_api <span>import</span> ZabbixAPI
<span>import</span> sys
<span>import</span> json

ZABBIX_SREVER <span>=</span> <span>"http://192.168.162.122"</span>
USERNAME <span>=</span> <span>"Admin"</span>
PASSWORD <span>=</span> <span>"zabbix"</span>
<span>#HOSTNAME = "sh_ylf_15"</span>
<span>#HOSTNAME = "h5_web_monitor"</span>
HOSTNAME <span>=</span> sys<span>.</span>argv<span>[</span><span>4</span><span>]</span>
urlname <span>=</span> sys<span>.</span>argv<span>[</span><span>1</span><span>]</span>
url <span>=</span> sys<span>.</span>argv<span>[</span><span>2</span><span>]</span>
delay <span>=</span> sys<span>.</span>argv<span>[</span><span>3</span><span>]</span>


<span># 登录</span>
<span>def</span> <span>login</span><span>(</span>ZABBIX_SREVER<span>,</span> USERNAME<span>,</span> PASSWORD<span>)</span><span>:</span>
    zapi <span>=</span> ZabbixAPI<span>(</span>ZABBIX_SREVER<span>)</span>
    zapi<span>.</span>login<span>(</span>USERNAME<span>,</span> PASSWORD<span>)</span>
    <span>return</span> zapi


<span># 获取主机id</span>
<span>def</span> <span>gethostid</span><span>(</span>auth<span>,</span> HOSTNAME<span>)</span><span>:</span>
    json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'host.get'</span><span>,</span> params<span>=</span><span>{</span><span>"filter"</span><span>:</span> <span>{</span><span>"host"</span><span>:</span> HOSTNAME<span>}</span><span>}</span><span>)</span>
    request <span>=</span> ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>

    <span>if</span> request<span>[</span><span>'result'</span><span>]</span><span>:</span>
        <span>return</span> request<span>[</span><span>'result'</span><span>]</span><span>[</span><span>0</span><span>]</span><span>[</span><span>'hostid'</span><span>]</span>
    <span>else</span><span>:</span>
        <span>print</span><span>(</span><span>"找不到该主机"</span><span>)</span>
        sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>


<span># 获取应用级id</span>
<span>def</span> <span>getapplicationid</span><span>(</span>auth<span>,</span> hostid<span>)</span><span>:</span>
    <span># try:</span>
    <span>#     json_obj = ZabbixAPI.json_obj(auth, 'application.create', params={"name": "Web监测","hostid": hostid})</span>
    <span>#     ZabbixAPI.do_request(auth, json_obj)</span>
    <span># except Exception as e:</span>
    <span>#     print(e)</span>
    json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'application.get'</span><span>,</span> params<span>=</span><span>{</span><span>"hostids"</span><span>:</span> hostid<span>}</span><span>)</span>
    request <span>=</span> ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
    <span>for</span> num <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> <span>len</span><span>(</span>request<span>[</span><span>'result'</span><span>]</span><span>)</span><span>)</span><span>:</span>
        <span>if</span> request<span>[</span><span>'result'</span><span>]</span><span>[</span>num<span>]</span><span>[</span><span>'name'</span><span>]</span> <span>==</span> <span>'Web'</span><span>:</span>
            <span>return</span> request<span>[</span><span>'result'</span><span>]</span><span>[</span>num<span>]</span><span>[</span><span>'applicationid'</span><span>]</span>


<span># 增加web监控</span>
<span>def</span> <span>create_web_scenario</span><span>(</span>auth<span>,</span> urlname<span>,</span> url<span>,</span> hostid<span>,</span> applicationid<span>,</span> delay<span>)</span><span>:</span>
    json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'httptest.get'</span><span>,</span> params<span>=</span><span>{</span><span>"filter"</span><span>:</span> <span>{</span><span>"name"</span><span>:</span> urlname<span>}</span><span>}</span><span>)</span>
    request <span>=</span> ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
    <span>if</span> request<span>[</span><span>'result'</span><span>]</span><span>:</span>
        <span>print</span><span>(</span><span>'该web监控已经添加过了'</span><span>)</span>
    <span>else</span><span>:</span>
        <span>try</span><span>:</span>
            json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'httptest.create'</span><span>,</span>
                                          params<span>=</span><span>{</span><span>"name"</span><span>:</span> urlname<span>,</span> <span>"hostid"</span><span>:</span> hostid<span>,</span> <span>"applicationid"</span><span>:</span> applicationid<span>,</span>
                                                  <span>"delay"</span><span>:</span> delay<span>,</span> <span>"retries"</span><span>:</span> <span>'1'</span><span>,</span> <span>"steps"</span><span>:</span> <span>[</span>
                                                  <span>{</span><span>'name'</span><span>:</span> urlname<span>,</span> <span>'url'</span><span>:</span> url<span>,</span> <span>'timeout'</span><span>:</span> <span>'10'</span><span>,</span> <span>'status_codes'</span><span>:</span> <span>'200'</span><span>,</span>
                                                   <span>'no'</span><span>:</span> <span>'1'</span><span>}</span><span>]</span><span>}</span><span>)</span>
            ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
        <span>except</span> Exception <span>as</span> e<span>:</span>
            <span>print</span><span>(</span>e<span>)</span>
            sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>


<span># 增加触发器</span>
<span>def</span> <span>create_trigger</span><span>(</span>auth<span>,</span> HOSTNAME<span>,</span> urlname<span>,</span> url<span>)</span><span>:</span>
    expression <span>=</span> <span>"{"</span> <span>+</span> <span>"{0}:web.test.fail[{1}].avg(#3)"</span><span>.</span><span>format</span><span>(</span>HOSTNAME<span>,</span> urlname<span>)</span> <span>+</span> <span>"}"</span> <span>+</span> <span>">=1"</span>
    <span>try</span><span>:</span>
        json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'trigger.create'</span><span>,</span>
                                      params<span>=</span><span>{</span><span>"description"</span><span>:</span> <span>"{0}访问失败"</span><span>.</span><span>format</span><span>(</span>urlname<span>)</span><span>,</span> <span>"expression"</span><span>:</span> expression<span>,</span>
                                              <span>"priority"</span><span>:</span> <span>5</span><span>,</span> <span>"url"</span><span>:</span> url<span>}</span><span>)</span>
        ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
    <span>except</span> Exception <span>as</span> e<span>:</span>
        <span>print</span><span>(</span>e<span>)</span>
        sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>

    expression <span>=</span> <span>"{"</span> <span>+</span> <span>"{0}:web.test.rspcode[{1},{1}].last(0)"</span><span>.</span><span>format</span><span>(</span>HOSTNAME<span>,</span> urlname<span>)</span> <span>+</span> <span>"}"</span> <span>+</span> <span>"&lt;>200"</span>
    <span>try</span><span>:</span>
        json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'trigger.create'</span><span>,</span>
                                      params<span>=</span><span>{</span><span>"description"</span><span>:</span> <span>"{0}访问异常"</span><span>.</span><span>format</span><span>(</span>urlname<span>)</span><span>,</span> <span>"expression"</span><span>:</span> expression<span>,</span>
                                              <span>"priority"</span><span>:</span> <span>4</span><span>,</span> <span>"url"</span><span>:</span> url<span>}</span><span>)</span>
        ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
    <span>except</span> Exception <span>as</span> e<span>:</span>
        <span>print</span><span>(</span>e<span>)</span>
        sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>


<span># 获取监控项id</span>
<span>def</span> <span>getitem</span><span>(</span>auth<span>,</span> hostid<span>,</span> urlname<span>)</span><span>:</span>
    json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'item.get'</span><span>,</span>
                                  params<span>=</span><span>{</span><span>"hostids"</span><span>:</span> hostid<span>,</span> <span>"webitems"</span><span>:</span> <span>"1"</span><span>,</span>
                                          <span>"filter"</span><span>:</span> <span>{</span><span>"name"</span><span>:</span> <span>"Response code for step \"$2\" of scenario \"$1\"."</span><span>,</span>
                                                     <span>"key_"</span><span>:</span> <span>"web.test.rspcode[{0},{1}]"</span><span>.</span><span>format</span><span>(</span>urlname<span>,</span> urlname<span>)</span><span>}</span><span>}</span><span>)</span>
    request <span>=</span> ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
    <span>return</span> request<span>[</span><span>"result"</span><span>]</span><span>[</span><span>0</span><span>]</span><span>[</span><span>"itemid"</span><span>]</span>


<span># 增加图形</span>
<span>def</span> <span>create_graph</span><span>(</span>auth<span>,</span> urlname<span>,</span> hostid<span>)</span><span>:</span>
    <span>try</span><span>:</span>
        itemid <span>=</span> getitem<span>(</span>auth<span>,</span> hostid<span>,</span> urlname<span>)</span>
        json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'graph.create'</span><span>,</span>
                                      params<span>=</span><span>{</span><span>"name"</span><span>:</span> <span>"h5_{0}状态显示"</span><span>.</span><span>format</span><span>(</span>urlname<span>)</span><span>,</span> <span>"width"</span><span>:</span> <span>900</span><span>,</span> <span>"height"</span><span>:</span> <span>200</span><span>,</span>
                                              <span>"gitems"</span><span>:</span> <span>[</span><span>{</span><span>"itemid"</span><span>:</span> itemid<span>,</span> <span>"color"</span><span>:</span> <span>"008800"</span><span>}</span><span>]</span><span>}</span><span>)</span>
        ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
    <span>except</span> Exception <span>as</span> e<span>:</span>
        <span>print</span><span>(</span>e<span>)</span>
        sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>


<span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    auth <span>=</span> login<span>(</span>ZABBIX_SREVER<span>,</span> USERNAME<span>,</span> PASSWORD<span>)</span>
    hostid <span>=</span> gethostid<span>(</span>auth<span>,</span> HOSTNAME<span>)</span>
    applicationid <span>=</span> getapplicationid<span>(</span>auth<span>,</span> hostid<span>)</span>

    create_web_scenario<span>(</span>auth<span>,</span> urlname<span>,</span> url<span>,</span> hostid<span>,</span> applicationid<span>,</span> delay<span>)</span>
    create_trigger<span>(</span>auth<span>,</span> HOSTNAME<span>,</span> urlname<span>,</span> url<span>)</span>
    create_graph<span>(</span>auth<span>,</span> urlname<span>,</span> hostid<span>)</span>


<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    main<span>(</span><span>)</span>

<span># json_obj = ZabbixAPI.json_obj(auth, 'httptest.get', params={"applicationids": applicationid})</span>
<span># request = ZabbixAPI.do_request(auth, json_obj)</span>
<span># print(json.dumps(request, ensure_ascii=False, indent=4))</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br></div></div><p>结合下面的shell脚本运行，</p>
<p>shell脚本如下：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>export</span> <span><span>LANG</span></span><span>=</span><span>"en_US.UTF-8"</span>

<span>arr_hostname</span><span>=</span><span>(</span><span>"192.168.165.115"</span> <span>"192.168.9.13"</span><span>)</span>
<span>len</span><span>=</span><span>${<span>#</span>arr_hostname<span>[</span>@<span>]</span>}</span>
<span>dir</span><span>=</span><span><span>$(</span><span>cd</span> <span>$(</span>dirname $0<span>)</span> <span>&amp;&amp;</span> <span>pwd</span><span>)</span></span>
<span>tdir</span><span>=</span><span>"<span>$dir</span>/tmp"</span>

<span>dt</span><span>=</span><span><span>`</span><span>date</span> <span>"+%F %T"</span><span>`</span></span>

<span>[</span> -f <span>$tdir</span>/code_error.txt <span>]</span> <span>&amp;&amp;</span> <span>true</span> <span>></span><span>$tdir</span>/code_error.txt

<span>## i: 项目信息   j: url   k:时间间隔</span>
<span>while</span> <span>read</span> i j k o<span>;</span><span>do</span>
    <span>if</span> <span>[</span><span>[</span> <span>!</span> x<span>"<span>$o</span>"</span> <span>==</span> x<span>""</span> <span>&amp;&amp;</span> <span>$o</span> -le <span><span>$((</span>$len<span>-</span><span>1</span><span>))</span></span> <span>]</span><span>]</span><span>;</span><span>then</span>
        <span>curl</span> -s -I <span>"<span>$j</span>"</span> <span>></span> <span>$tdir</span>/curl.txt
        <span>code</span><span>=</span><span><span>`</span><span>grep</span> <span>'HTTP/1.1'</span> $tdir/curl.txt<span>|</span><span>awk</span> <span>'{print <span>$2</span>}'</span><span>`</span></span>
        <span>#echo "$i $j $code" </span>

        <span>if</span> <span>[</span> <span>$code</span> -eq <span>200</span> -o <span>$code</span> -eq <span>301</span> -o <span>$code</span> -eq <span>302</span> -o <span>$code</span> -eq <span>405</span> <span>]</span><span>;</span><span>then</span>
            python <span>$dir</span>/zabbix_agent.py <span>$i</span> <span>$j</span> <span>$k</span> <span>${arr_hostname<span>[</span>$o<span>]</span>}</span>
            <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>echo</span> <span>"<span>$dt</span> <span>$i</span> <span>$j</span> <span>$k</span> <span>$o</span> create ok"</span> <span>>></span> <span>$tdir</span>/info <span>||</span> <span>echo</span> <span>"<span>$dt</span> <span>$i</span> <span>$j</span> <span>$k</span> <span>$o</span> create fail"</span> <span>>></span><span>$tdir</span>/info
        <span>else</span>
            <span>echo</span> <span>"<span>$i</span> <span>$j</span> <span>$k</span> <span>$o</span> <span>$code</span>"</span> <span>>></span><span>$tdir</span>/code_error.txt
            <span>echo</span> <span>"<span>$i</span> <span>$code</span>"</span>
        <span>fi</span>
    <span>else</span>
        <span>echo</span> <span>"hostname参数传递错误"</span>
    <span>fi</span>
<span>done</span> <span>&lt;</span><span>$dir</span>/list
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><ul>
<li>arr_hostname为添加web监控的两个主机，我进行的是交叉互检</li>
</ul>
<p>最后还需要一个list文件，list文件内容格式如下</p>
<div><pre><code>csp-web-syndata http://192.168.100.15:8085/csp-web-syndata/shop/synShopInfo/111 3m 0
</code></pre>
<div><span>1</span><br></div></div><h2 id="调用jenkinsapi批量拷贝视图job"> 调用jenkinsAPI批量拷贝视图job</h2>
<p>起因：一个视图下有好多job，新建一套微服务的job，完全可以用批量拷贝，然后改一些配置参数</p>
<p>脚本如下：</p>
<div><pre><code><span>#!/usr/bin/env python</span>
<span># coding:utf-8</span>

<span>import</span> jenkins
<span>import</span> sys

src_view <span>=</span> <span>'jxltz'</span>
dest_view <span>=</span> <span>'jxyz'</span>
old_branch <span>=</span> <span>'jxltz-csp-parent'</span>
new_branch <span>=</span> <span>'jxyz-csp-parent'</span>


<span>def</span> <span>get_server_instance</span><span>(</span><span>)</span><span>:</span>
    jenkins_url <span>=</span> <span>'http://192.168.162.175:8080'</span>
    server <span>=</span> jenkins<span>.</span>Jenkins<span>(</span>jenkins_url<span>,</span> username<span>=</span><span>'admin'</span><span>,</span> password<span>=</span><span>'sdqc#2019#cqds'</span><span>)</span>
    <span>return</span> server


<span>def</span> <span>delete_job</span><span>(</span><span>)</span><span>:</span>
    server <span>=</span> get_server_instance<span>(</span><span>)</span>
    <span>if</span> server<span>.</span>view_exists<span>(</span>dest_view<span>)</span><span>:</span>
        server<span>.</span>delete_view<span>(</span>dest_view<span>)</span>
    <span>else</span><span>:</span>
        <span>print</span><span>(</span><span>"view不存在"</span><span>)</span>
    jobs <span>=</span> server<span>.</span>get_jobs<span>(</span><span>)</span>
    <span>for</span> job <span>in</span> jobs<span>:</span>
        <span>if</span> dest_view <span>in</span> job<span>[</span><span>'name'</span><span>]</span><span>:</span>
            server<span>.</span>delete_job<span>(</span>job<span>[</span><span>'name'</span><span>]</span><span>)</span>


<span>def</span> <span>copy_job</span><span>(</span><span>)</span><span>:</span>
    server <span>=</span> get_server_instance<span>(</span><span>)</span>
    jobs <span>=</span> server<span>.</span>get_jobs<span>(</span>view_name<span>=</span>src_view<span>)</span>
    <span>for</span> job <span>in</span> jobs<span>:</span>
        job_name <span>=</span> job<span>[</span><span>'name'</span><span>]</span>
        newjob_name <span>=</span> job_name<span>.</span>replace<span>(</span>src_view<span>,</span> dest_view<span>)</span>
        <span>if</span> server<span>.</span>job_exists<span>(</span>newjob_name<span>)</span><span>:</span>
            <span>print</span><span>(</span><span>"job已存在"</span><span>)</span>
        <span>else</span><span>:</span>
            server<span>.</span>copy_job<span>(</span>job_name<span>,</span> newjob_name<span>)</span>
    configxml <span>=</span> server<span>.</span>get_view_config<span>(</span>src_view<span>)</span>
    newconfigxml <span>=</span> configxml<span>.</span>replace<span>(</span>src_view<span>,</span> dest_view<span>)</span>
    <span>if</span> server<span>.</span>view_exists<span>(</span>dest_view<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"view已存在"</span><span>)</span>
    <span>else</span><span>:</span>
        server<span>.</span>create_view<span>(</span>dest_view<span>,</span> newconfigxml<span>)</span>


<span>def</span> <span>reconfig_job</span><span>(</span><span>)</span><span>:</span>
    server <span>=</span> get_server_instance<span>(</span><span>)</span>
    jobs <span>=</span> server<span>.</span>get_jobs<span>(</span>view_name<span>=</span>dest_view<span>)</span>
    <span>for</span> job <span>in</span> jobs<span>:</span>
        job_config <span>=</span> server<span>.</span>get_job_config<span>(</span>job<span>[</span><span>'name'</span><span>]</span><span>)</span>
        new_job_config <span>=</span> job_config<span>.</span>replace<span>(</span>old_branch<span>,</span> new_branch<span>)</span>
        server<span>.</span>reconfig_job<span>(</span>job<span>[</span><span>'name'</span><span>]</span><span>,</span> new_job_config<span>)</span>


<span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>if</span> sys<span>.</span>argv<span>[</span><span>1</span><span>]</span> <span>==</span> <span>'delete'</span><span>:</span>
        delete_job<span>(</span><span>)</span>
    <span>elif</span> sys<span>.</span>argv<span>[</span><span>1</span><span>]</span> <span>==</span> <span>'copy'</span><span>:</span>
        copy_job<span>(</span><span>)</span>
    <span>elif</span> sys<span>.</span>argv<span>[</span><span>1</span><span>]</span> <span>==</span> <span>'reconfig'</span><span>:</span>
        reconfig_job<span>(</span><span>)</span>
    <span>else</span><span>:</span>
        <span>print</span><span>(</span><span>"Usage: python %s delete|copy|reconfig"</span> <span>%</span> sys<span>.</span>argv<span>[</span><span>0</span><span>]</span><span>)</span>


<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    main<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div><h2 id="解析-nginx-配置文件生成-excel-表格"> 解析 nginx 配置文件生成 Excel 表格</h2>
<p>起因：领导要求统计每个域名下有哪些项目，将域名，端口，后端ip地址统计到Excel表格中。</p>
<h3 id="导入nginx配置文件"> 导入nginx配置文件</h3>
<div><pre><code>scp -r /etc/nginx 192.168.167.24:/etc/
</code></pre>
<div><span>1</span><br></div></div><h3 id="pip安装相关依赖模块"> pip安装相关依赖模块</h3>
<div><pre><code>pip3 install xlrd xlwt xlutils
</code></pre>
<div><span>1</span><br></div></div><p>之前在github找到过一个相关的模块，之前用过，现在不用了，讲一下，它怎么导入，命令如下</p>
<div><pre><code>pip3 install git+https://github.com/fatiherikli/nginxparser.git
</code></pre>
<div><span>1</span><br></div></div><h3 id="编写python脚本"> 编写python脚本</h3>
<p><code>cat nginx_excel.py</code></p>
<div><pre><code><span>#!/usr/bin/python3</span>
<span># coding:utf-8</span>
<span>import</span> re
<span>import</span> os
<span>import</span> xlrd
<span>import</span> xlwt
<span>from</span> xlutils<span>.</span>copy <span>import</span> copy


<span># from nginx import NGINX</span>

<span>class</span> <span>Nginx</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> conf_path<span>)</span><span>:</span>
        self<span>.</span>conf_path <span>=</span> conf_path
        self<span>.</span>backend <span>=</span> <span>list</span><span>(</span><span>)</span>
        self<span>.</span>serverBlock <span>=</span> <span>list</span><span>(</span><span>)</span>
        self<span>.</span>servers <span>=</span> <span>list</span><span>(</span><span>)</span>
        self<span>.</span>tmp_conf <span>=</span> <span>'/tmp/tmp_nginx.conf'</span>
        self<span>.</span>all_conf <span>=</span> <span>'/tmp/nginx.conf'</span>
        self<span>.</span>merge_conf<span>(</span><span>)</span>
        self<span>.</span>parse_backend_ip<span>(</span><span>)</span>
        self<span>.</span>parse_server_block<span>(</span><span>)</span>

    <span>def</span> <span>merge_conf</span><span>(</span>self<span>)</span><span>:</span>
        conf_dir <span>=</span> os<span>.</span>path<span>.</span>dirname<span>(</span>self<span>.</span>conf_path<span>)</span>
        <span>if</span> <span>len</span><span>(</span>conf_dir<span>)</span> <span>!=</span> <span>0</span><span>:</span>
            os<span>.</span>chdir<span>(</span>conf_dir<span>)</span>
        include_regex <span>=</span> <span>'.*include.*'</span>
        fm <span>=</span> <span>open</span><span>(</span>self<span>.</span>tmp_conf<span>,</span> <span>'w+'</span><span>)</span>
        <span>with</span> <span>open</span><span>(</span>self<span>.</span>conf_path<span>,</span> <span>'r'</span><span>)</span> <span>as</span> f<span>:</span>
            <span>for</span> line <span>in</span> f<span>.</span>readlines<span>(</span><span>)</span><span>:</span>
                r <span>=</span> re<span>.</span>findall<span>(</span>include_regex<span>,</span> line<span>)</span>
                <span>if</span> <span>len</span><span>(</span>r<span>)</span> <span>></span> <span>0</span><span>:</span>
                    include_line <span>=</span> r<span>[</span><span>0</span><span>]</span><span>.</span>split<span>(</span><span>" "</span><span>)</span>
                    include_path <span>=</span> include_line<span>[</span><span>5</span><span>]</span><span>.</span>split<span>(</span><span>";"</span><span>)</span><span>[</span><span>0</span><span>]</span>
                    <span>if</span> os<span>.</span>path<span>.</span>exists<span>(</span>include_path<span>)</span><span>:</span>
                        <span>with</span> <span>open</span><span>(</span>include_path<span>,</span> <span>'r'</span><span>)</span> <span>as</span> ff<span>:</span>
                            include_con <span>=</span> ff<span>.</span>read<span>(</span><span>)</span>
                            fm<span>.</span>write<span>(</span>include_con<span>)</span>
                <span>else</span><span>:</span>
                    fm<span>.</span>write<span>(</span>line<span>)</span>
        fm<span>.</span>close<span>(</span><span>)</span>

        <span># 去掉注释行</span>
        fm <span>=</span> <span>open</span><span>(</span>self<span>.</span>tmp_conf<span>,</span> <span>'r'</span><span>)</span>
        <span>with</span> <span>open</span><span>(</span>self<span>.</span>all_conf<span>,</span> <span>'w+'</span><span>)</span> <span>as</span> fp<span>:</span>
            <span>for</span> xx <span>in</span> fm<span>.</span>readlines<span>(</span><span>)</span><span>:</span>
                <span>if</span> <span>len</span><span>(</span>re<span>.</span>findall<span>(</span><span>'^\s*#'</span><span>,</span> xx<span>)</span><span>)</span> <span>==</span> <span>0</span><span>:</span>
                    fp<span>.</span>write<span>(</span>xx<span>)</span>
        fm<span>.</span>close<span>(</span><span>)</span>

        <span># 删除临时配置文件</span>
        <span>if</span> os<span>.</span>path<span>.</span>exists<span>(</span>self<span>.</span>tmp_conf<span>)</span><span>:</span>
            os<span>.</span>remove<span>(</span>self<span>.</span>tmp_conf<span>)</span>

    <span>def</span> <span>parse_backend_ip</span><span>(</span>self<span>)</span><span>:</span>
        <span>with</span> <span>open</span><span>(</span>self<span>.</span>all_conf<span>,</span> <span>'r'</span><span>)</span> <span>as</span> fp<span>:</span>
            alllines <span>=</span> fp<span>.</span>read<span>(</span><span>)</span>

            <span># 获取每个upstream块</span>
            regex_1 <span>=</span> <span>'upstream\s+([^{ ]+)\s*{([^}]*)}'</span>
            upstreams <span>=</span> re<span>.</span>findall<span>(</span>regex_1<span>,</span> alllines<span>)</span>

            <span>for</span> up <span>in</span> upstreams<span>:</span>
                <span># 获取后端的ip</span>
                regex_2 <span>=</span> <span>'server\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(?::\d{2,5})?)'</span>
                backend <span>=</span> re<span>.</span>findall<span>(</span>regex_2<span>,</span> up<span>[</span><span>1</span><span>]</span><span>)</span>
                <span># 判断是否有后端的ip设置</span>
                <span>if</span> <span>len</span><span>(</span>backend<span>)</span> <span>></span> <span>0</span><span>:</span>
                    pool_and_ip <span>=</span> <span>{</span><span>'poolname'</span><span>:</span> up<span>[</span><span>0</span><span>]</span><span>,</span> <span>'ip'</span><span>:</span> <span>' '</span><span>.</span>join<span>(</span>backend<span>)</span><span>}</span>
                    self<span>.</span>backend<span>.</span>append<span>(</span>pool_and_ip<span>)</span>

    <span>def</span> <span>parse_server_block</span><span>(</span>self<span>)</span><span>:</span>
        flag <span>=</span> <span>False</span>
        serverblock <span>=</span> <span>''</span>
        num_of_quote <span>=</span> <span>0</span>

        <span>with</span> <span>open</span><span>(</span>self<span>.</span>all_conf<span>,</span> <span>'r'</span><span>)</span> <span>as</span> fp<span>:</span>
            <span>for</span> line <span>in</span> fp<span>.</span>readlines<span>(</span><span>)</span><span>:</span>
                x <span>=</span> line<span>.</span>replace<span>(</span><span>' '</span><span>,</span> <span>''</span><span>)</span>
                <span>if</span> x<span>.</span>startswith<span>(</span><span>'server{'</span><span>)</span><span>:</span>
                    num_of_quote <span>+=</span> <span>1</span>
                    flag <span>=</span> <span>True</span>
                    serverblock <span>+=</span> line
                    <span>continue</span>
                <span>if</span> flag <span>and</span> <span>'{'</span> <span>in</span> line<span>:</span>
                    num_of_quote <span>+=</span> <span>1</span>

                <span># 将proxy_pass的别名换成ip</span>
                <span>if</span> flag <span>and</span> <span>'proxy_pass'</span> <span>in</span> line<span>:</span>
                    r <span>=</span> re<span>.</span>findall<span>(</span><span>'proxy_pass\s+https?://([^;/]*)[^;]*;'</span><span>,</span> line<span>)</span>
                    <span>if</span> <span>len</span><span>(</span>r<span>)</span> <span>></span> <span>0</span><span>:</span>
                        <span>for</span> pool <span>in</span> self<span>.</span>backend<span>:</span>
                            <span>if</span> r<span>[</span><span>0</span><span>]</span> <span>==</span> pool<span>[</span><span>'poolname'</span><span>]</span><span>:</span>
                                line <span>=</span> line<span>.</span>replace<span>(</span>r<span>[</span><span>0</span><span>]</span><span>,</span> pool<span>[</span><span>'ip'</span><span>]</span><span>)</span>

                <span>if</span> flag <span>and</span> num_of_quote <span>!=</span> <span>0</span><span>:</span>
                    serverblock <span>+=</span> line

                <span>if</span> flag <span>and</span> <span>'}'</span> <span>in</span> line<span>:</span>
                    num_of_quote <span>-=</span> <span>1</span>

                <span>if</span> flag <span>and</span> num_of_quote <span>==</span> <span>0</span><span>:</span>
                    self<span>.</span>serverBlock<span>.</span>append<span>(</span>serverblock<span>)</span>
                    flag <span>=</span> <span>False</span>
                    serverblock <span>=</span> <span>''</span>
                    num_of_quote <span>=</span> <span>0</span>

        <span>for</span> singleServer <span>in</span> self<span>.</span>serverBlock<span>:</span>
            <span># port和server_name均只有一个的情况下</span>
            port <span>=</span> re<span>.</span>findall<span>(</span><span>'listen\s*((?:\d|\s)*)[^;]*;'</span><span>,</span> singleServer<span>)</span><span>[</span><span>0</span><span>]</span>
            r <span>=</span> re<span>.</span>findall<span>(</span><span>'server_name\s+([^;]*);'</span><span>,</span> singleServer<span>)</span>

            <span>if</span> <span>len</span><span>(</span>r<span>)</span> <span>></span> <span>0</span><span>:</span>
                servername <span>=</span> r<span>[</span><span>0</span><span>]</span>
            <span>else</span><span>:</span>
                <span>continue</span>

            <span># location可能不止一个</span>
            locations <span>=</span> re<span>.</span>findall<span>(</span><span>'location\s*[\^~\*=]{0,3}\s*([^{ ]*)\s*\{[^}]*proxy_pass\s+https?://([^;/]*)[^;]*;'</span><span>,</span>
                                   singleServer<span>)</span>

            backend_list <span>=</span> <span>list</span><span>(</span><span>)</span>
            backend_ip <span>=</span> <span>''</span>

            <span>if</span> <span>len</span><span>(</span>locations<span>)</span> <span>></span> <span>0</span><span>:</span>
                <span>for</span> location <span>in</span> locations<span>:</span>
                    backend_path <span>=</span> location<span>[</span><span>0</span><span>]</span>
                    poolname <span>=</span> location<span>[</span><span>1</span><span>]</span>
                    <span># 如果不是ip的pool name，就取出后端对应的ip</span>
                    <span>if</span> <span>len</span><span>(</span>re<span>.</span>findall<span>(</span><span>'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'</span><span>,</span> poolname<span>)</span><span>)</span> <span>==</span> <span>0</span><span>:</span>
                        <span>for</span> backend <span>in</span> self<span>.</span>backend<span>:</span>
                            <span>if</span> poolname <span>==</span> backend<span>[</span><span>'poolname'</span><span>]</span><span>:</span>
                                backend_ip <span>=</span> backend<span>[</span><span>'ip'</span><span>]</span>
                                <span>break</span>
                    <span>else</span><span>:</span>
                        backend_ip <span>=</span> poolname

                    backend_list<span>.</span>append<span>(</span><span>{</span><span>"backend_path"</span><span>:</span> backend_path<span>,</span> <span>"backend_ip"</span><span>:</span> backend_ip<span>}</span><span>)</span>

            server <span>=</span> <span>{</span>
                <span>'port'</span><span>:</span> port<span>,</span>
                <span>'server_name'</span><span>:</span> servername<span>,</span>
                <span>'backend'</span><span>:</span> backend_list
            <span>}</span>

            self<span>.</span>servers<span>.</span>append<span>(</span>server<span>)</span>


<span>class</span> <span>NginxExcel</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> row<span>,</span> col<span>)</span><span>:</span>
        self<span>.</span>row <span>=</span> row
        self<span>.</span>col <span>=</span> col

    <span>def</span> <span>read_from_txt</span><span>(</span>self<span>,</span> txt_filename<span>,</span> line<span>)</span><span>:</span>
        file_txt <span>=</span> <span>open</span><span>(</span>txt_filename<span>)</span>
        lines <span>=</span> file_txt<span>.</span>readlines<span>(</span><span>)</span>
        strlist <span>=</span> lines<span>[</span>line<span>]</span><span>.</span>split<span>(</span><span>" "</span><span>)</span>
        self<span>.</span>project_name <span>=</span> strlist<span>[</span><span>0</span><span>]</span>
        self<span>.</span>domain <span>=</span> strlist<span>[</span><span>1</span><span>]</span>
        self<span>.</span>link <span>=</span> strlist<span>[</span><span>2</span><span>]</span>
        self<span>.</span>proxy_pass <span>=</span> strlist<span>[</span><span>3</span><span>:</span><span>]</span>

    <span>def</span> <span>write_to_excel</span><span>(</span>self<span>,</span> excel_filename<span>)</span><span>:</span>
        <span>if</span> os<span>.</span>path<span>.</span>exists<span>(</span>excel_filename<span>)</span><span>:</span>
            rb <span>=</span> xlrd<span>.</span>open_workbook<span>(</span>excel_filename<span>)</span>
            wb <span>=</span> copy<span>(</span>rb<span>)</span>
            sheet <span>=</span> wb<span>.</span>get_sheet<span>(</span><span>0</span><span>)</span>
        <span>else</span><span>:</span>
            wb <span>=</span> xlwt<span>.</span>Workbook<span>(</span><span>)</span>
            sheet <span>=</span> wb<span>.</span>add_sheet<span>(</span><span>'私有云'</span><span>)</span>
            sheet<span>.</span>write<span>(</span>self<span>.</span>row<span>,</span> self<span>.</span>col<span>,</span> <span>"项目名"</span><span>)</span>
            self<span>.</span>col <span>+=</span> <span>1</span>
            sheet<span>.</span>write<span>(</span>self<span>.</span>row<span>,</span> self<span>.</span>col<span>,</span> <span>"域名"</span><span>)</span>
            self<span>.</span>col <span>+=</span> <span>1</span>
            sheet<span>.</span>write<span>(</span>self<span>.</span>row<span>,</span> self<span>.</span>col<span>,</span> <span>"项目链接"</span><span>)</span>
            self<span>.</span>col <span>+=</span> <span>1</span>
            sheet<span>.</span>write<span>(</span>self<span>.</span>row<span>,</span> self<span>.</span>col<span>,</span> <span>"后端地址"</span><span>)</span>
            self<span>.</span>row <span>+=</span> <span>1</span>
            self<span>.</span>col <span>=</span> <span>0</span>

        sheet<span>.</span>write<span>(</span>self<span>.</span>row<span>,</span> self<span>.</span>col<span>,</span> self<span>.</span>project_name<span>)</span>
        self<span>.</span>col <span>+=</span> <span>1</span>
        sheet<span>.</span>write<span>(</span>self<span>.</span>row<span>,</span> self<span>.</span>col<span>,</span> self<span>.</span>domain<span>)</span>
        self<span>.</span>col <span>+=</span> <span>1</span>
        sheet<span>.</span>write<span>(</span>self<span>.</span>row<span>,</span> self<span>.</span>col<span>,</span> self<span>.</span>link<span>)</span>
        self<span>.</span>col <span>+=</span> <span>1</span>
        sheet<span>.</span>write<span>(</span>self<span>.</span>row<span>,</span> self<span>.</span>col<span>,</span> <span>", "</span><span>.</span>join<span>(</span>self<span>.</span>proxy_pass<span>)</span><span>)</span>
        self<span>.</span>row <span>+=</span> <span>1</span>
        self<span>.</span>col <span>=</span> <span>0</span>
        wb<span>.</span>save<span>(</span>excel_filename<span>)</span>


<span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    txt_filename <span>=</span> <span>"私有云项目清单.txt"</span>
    excel_filename <span>=</span> <span>"私有云项目清单.xls"</span>
    s <span>=</span> NginxExcel<span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span>
    nginx <span>=</span> Nginx<span>(</span><span>'/etc/nginx/nginx.conf'</span><span>)</span>
    nginx_list <span>=</span> nginx<span>.</span>servers
    f <span>=</span> <span>open</span><span>(</span>txt_filename<span>,</span> <span>"w+"</span><span>)</span>

    <span>for</span> server <span>in</span> nginx_list<span>:</span>
        <span>for</span> backend <span>in</span> server<span>[</span><span>"backend"</span><span>]</span><span>:</span>
            old_project_name <span>=</span> backend<span>[</span><span>"backend_path"</span><span>]</span>
            new_project_name <span>=</span> re<span>.</span>sub<span>(</span><span>r'/'</span><span>,</span> <span>''</span><span>,</span> old_project_name<span>)</span>
            <span>if</span> server<span>[</span><span>"port"</span><span>]</span> <span>==</span> <span>"80"</span><span>:</span>
                domain <span>=</span> <span>"http://"</span> <span>+</span> server<span>[</span><span>"server_name"</span><span>]</span>
                link <span>=</span> domain <span>+</span> <span>"/"</span> <span>+</span> new_project_name <span>+</span> <span>"/"</span>
            <span>elif</span> server<span>[</span><span>"port"</span><span>]</span> <span>==</span> <span>"443"</span><span>:</span>
                domain <span>=</span> <span>"https://"</span> <span>+</span> server<span>[</span><span>"server_name"</span><span>]</span>
                link <span>=</span> domain <span>+</span> <span>"/"</span> <span>+</span> new_project_name <span>+</span> <span>"/"</span>
            <span>else</span><span>:</span>
                domain <span>=</span> <span>"http://"</span> <span>+</span> server<span>[</span><span>"server_name"</span><span>]</span>
                link <span>=</span> domain <span>+</span> <span>":"</span> <span>+</span> server<span>[</span><span>"port"</span><span>]</span> <span>+</span> <span>"/"</span> <span>+</span> new_project_name <span>+</span> <span>"/"</span>
            f<span>.</span>write<span>(</span><span>"%s %s %s %s\n"</span> <span>%</span> <span>(</span>new_project_name<span>,</span> domain<span>,</span> link<span>,</span> backend<span>[</span><span>"backend_ip"</span><span>]</span><span>)</span><span>)</span>

    f<span>.</span>close<span>(</span><span>)</span>

    f <span>=</span> <span>open</span><span>(</span>txt_filename<span>)</span>
    lines <span>=</span> f<span>.</span>readlines<span>(</span><span>)</span>

    <span>for</span> line <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span>lines<span>)</span><span>)</span><span>:</span>
        s<span>.</span>read_from_txt<span>(</span>txt_filename<span>,</span> line<span>)</span>
        s<span>.</span>write_to_excel<span>(</span>excel_filename<span>)</span>

    f<span>.</span>close<span>(</span><span>)</span>


<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    main<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br></div></div><p>执行脚本，生成Excel表格</p>
<div><pre><code>python3 nginx_excel.py
</code></pre>
<div><span>1</span><br></div></div><p>表格生成在<code>/etc/nginx</code>目录下</p>
<h2 id="监控-activemq-集群状态并自动重启"> 监控 activemq 集群状态并自动重启</h2>
<p>起因：activemq集群，由于私有云底层网路问题，隔一段时间假死一次，集群依赖zookeeper集群，后续将集群方式改为了共享存储的方式</p>
<p>要监控Activemq集群的运行情况，我们就可以通过stomp协议的相关客户端来实现。</p>
<p><strong><code>stomp.py</code>安装</strong></p>
<p>在此我们使用的是stomp协议的python客户端，来实现集群的监控。</p>
<p>支持stomp协议的python客户端，我们使用的是stomp.py这个软件来实现，而stomp.py我们可以在github上来获得。</p>
<p>stomp.py除了可以连接activemq，还可以连接rabbitmq。</p>
<p>stomp.py仓库的github地址为：</p>
<p>https://github.com/jasonrbriggs/stomp.py.git</p>
<p><strong>安装stomp</strong></p>
<div><pre><code>git clone https://github.com/jasonrbriggs/stomp.py.git
cd stomp.py
python setup.py install
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>脚本如下</p>
<div><pre><code><span>#!/usr/bin/env python</span>
<span># coding:utf-8</span>

<span>import</span> time
<span>import</span> paramiko
<span>import</span> stomp

A_IP <span>=</span> <span>"192.168.161.1"</span>
B_IP <span>=</span> <span>"192.168.161.2"</span>
C_IP <span>=</span> <span>"192.168.161.3"</span>
USERNAME <span>=</span> <span>"root"</span>
PASSWROD <span>=</span> <span>"*******"</span>

<span>list</span> <span>=</span> <span>[</span><span>]</span>
now <span>=</span> time<span>.</span>strftime<span>(</span><span>"%Y-%m-%d %H:%M:%S"</span><span>,</span> time<span>.</span>localtime<span>(</span><span>)</span><span>)</span>


<span>class</span> <span>MyParamiko</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> hostip<span>,</span> username<span>,</span> password<span>,</span> port<span>=</span><span>22</span><span>)</span><span>:</span>
        self<span>.</span>hostip <span>=</span> hostip
        self<span>.</span>port <span>=</span> port
        self<span>.</span>username <span>=</span> username
        self<span>.</span>password <span>=</span> password
        self<span>.</span>obj <span>=</span> paramiko<span>.</span>SSHClient<span>(</span><span>)</span>
        self<span>.</span>obj<span>.</span>set_missing_host_key_policy<span>(</span>paramiko<span>.</span>AutoAddPolicy<span>(</span><span>)</span><span>)</span>
        self<span>.</span>obj<span>.</span>connect<span>(</span>self<span>.</span>hostip<span>,</span> self<span>.</span>port<span>,</span> self<span>.</span>username<span>,</span> self<span>.</span>password<span>)</span>

    <span>def</span> <span>run_cmd</span><span>(</span>self<span>,</span> cmd<span>)</span><span>:</span>
        stdin<span>,</span> stdout<span>,</span> stderr <span>=</span> self<span>.</span>obj<span>.</span>exec_command<span>(</span>cmd<span>)</span>
        <span>return</span> stdout<span>.</span>read<span>(</span><span>)</span>

    <span>def</span> <span>close</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>obj<span>.</span>close<span>(</span><span>)</span>


<span>def</span> <span>check_port</span><span>(</span><span>)</span><span>:</span>
    <span>for</span> ip <span>in</span> <span>(</span>A_IP<span>,</span> B_IP<span>,</span> C_IP<span>)</span><span>:</span>
        sshobj <span>=</span> MyParamiko<span>(</span>ip<span>,</span> USERNAME<span>,</span> PASSWROD<span>)</span>
        result <span>=</span> sshobj<span>.</span>run_cmd<span>(</span><span>'netstat -ntpl | grep -c 61613'</span><span>)</span>
        <span>list</span><span>.</span>append<span>(</span>result<span>.</span>decode<span>(</span><span>)</span><span>.</span>strip<span>(</span><span>'\n'</span><span>)</span><span>)</span>
        sshobj<span>.</span>close<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>list</span><span>)</span>


<span>def</span> <span>activemq_listen</span><span>(</span>ip<span>)</span><span>:</span>
    <span>class</span> <span>MyListener</span><span>(</span><span>object</span><span>)</span><span>:</span>
        <span>def</span> <span>on_error</span><span>(</span>self<span>,</span> headers<span>,</span> message<span>)</span><span>:</span>
            <span>print</span><span>(</span>now <span>+</span> <span>' received an error %s'</span> <span>%</span> message<span>)</span>

        <span>def</span> <span>on_message</span><span>(</span>self<span>,</span> headers<span>,</span> message<span>)</span><span>:</span>
            <span>print</span><span>(</span>now <span>+</span> <span>' received a message %s'</span> <span>%</span> message<span>)</span>
    conn <span>=</span> stomp<span>.</span>Connection<span>(</span><span>[</span><span>(</span>ip<span>,</span> <span>61613</span><span>)</span><span>]</span><span>)</span>
    conn<span>.</span>set_listener<span>(</span><span>''</span><span>,</span> MyListener<span>(</span><span>)</span><span>)</span>
    conn<span>.</span>start<span>(</span><span>)</span>
    conn<span>.</span>connect<span>(</span><span>'admin'</span><span>,</span> <span>'admin'</span><span>)</span>
    conn<span>.</span>subscribe<span>(</span>destination<span>=</span><span>'/queue/clay.test.mqtest.v1'</span><span>,</span> <span>id</span><span>=</span><span>1</span><span>,</span> ack<span>=</span><span>'auto'</span><span>)</span>
    conn<span>.</span>send<span>(</span>body<span>=</span><span>'clay test'</span><span>,</span> destination<span>=</span><span>'/queue/clay.test.mqtest.v1'</span><span>)</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    conn<span>.</span>disconnect<span>(</span><span>)</span>


<span>def</span> <span>activemq_restart</span><span>(</span>ip<span>)</span><span>:</span>
    sshobj <span>=</span> MyParamiko<span>(</span>ip<span>,</span> USERNAME<span>,</span> PASSWROD<span>)</span>
    cmd <span>=</span> <span>"ps -ef | grep activemq | grep -v grep | awk '{print $2}'| xargs kill -9;"</span> \
        <span>"export JAVA_HOME=/opt/jdk1.8.0_144;"</span> \
        <span>"/opt/apache-activemq-5.15.9/bin/activemq start"</span>
    result <span>=</span> sshobj<span>.</span>run_cmd<span>(</span>cmd<span>)</span>
    <span>print</span><span>(</span>now <span>+</span> result<span>)</span>
    sshobj<span>.</span>close<span>(</span><span>)</span>


<span>def</span> <span>activmq_monitor</span><span>(</span><span>)</span><span>:</span>
    <span>if</span> <span>list</span> <span>==</span> <span>[</span><span>'1'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>]</span><span>:</span>
        <span>print</span><span>(</span>now <span>+</span> <span>" 第一台机器的61613端口处于监听状态，现在尝试往里面发送消息..."</span><span>)</span>
        <span>try</span><span>:</span>
            activemq_listen<span>(</span>A_IP<span>)</span>
        <span>except</span> stomp<span>.</span>exception<span>.</span>ConnectFailedException<span>:</span>
            <span>print</span><span>(</span>now <span>+</span> <span>" 发送信息失败，请重启Activemq进程..."</span><span>)</span>
            activemq_restart<span>(</span>A_IP<span>)</span>
    <span>elif</span> <span>list</span> <span>==</span> <span>[</span><span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'0'</span><span>]</span><span>:</span>
        <span>print</span><span>(</span>now <span>+</span> <span>" 第二台机器的61613端口处于监听状态，现在尝试往里面发送消息..."</span><span>)</span>
        <span>try</span><span>:</span>
            activemq_listen<span>(</span>B_IP<span>)</span>
        <span>except</span> stomp<span>.</span>exception<span>.</span>ConnectFailedException<span>:</span>
            <span>print</span><span>(</span>now <span>+</span> <span>" 发送信息失败，请重启Activemq进程..."</span><span>)</span>
            activemq_restart<span>(</span>B_IP<span>)</span>
    <span>elif</span> <span>list</span> <span>==</span> <span>[</span><span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'1'</span><span>]</span><span>:</span>
        <span>print</span><span>(</span>now <span>+</span> <span>" 第三台机器的61613端口处于监听状态，现在尝试往里面发送消息..."</span><span>)</span>
        <span>try</span><span>:</span>
            activemq_listen<span>(</span>C_IP<span>)</span>
        <span>except</span> stomp<span>.</span>exception<span>.</span>ConnectFailedException<span>:</span>
            <span>print</span><span>(</span>now <span>+</span> <span>" 发送信息失败，请重启Activemq进程..."</span><span>)</span>
            activemq_restart<span>(</span>C_IP<span>)</span>
    <span>else</span><span>:</span>
        <span>print</span><span>(</span>now <span>+</span> <span>" activemq的61613端口处于异常，现在重启这三台mq..."</span><span>)</span>
        activemq_restart<span>(</span>A_IP<span>)</span>
        activemq_restart<span>(</span>B_IP<span>)</span>
        activemq_restart<span>(</span>C_IP<span>)</span>


<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    check_port<span>(</span><span>)</span>
    activmq_monitor<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br></div></div><p>创建计划任务</p>
<div><pre><code>*/2 * * * * /usr/bin/python3 /root/activemq.py &gt;&gt; /var/log/activemq.log
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">17 IO 模型</title>
    <id>https://clay-wangzhi.com/code/python/python-io-model/</id>
    <link href="https://clay-wangzhi.com/code/python/python-io-model/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_17-io-模型"> 17 IO 模型</h1>
<h2 id="重要概念"> 重要概念</h2>
<h3 id="同步、异步"> 同步、异步</h3>
<p>函数或方法被调用的时候，调用者是否得到<strong>最终结果</strong>的。
直接得到最终结果结果的，就是同步调用；
不直接得到最终结果的，就是异步调用。</p>
<h3 id="阻塞、非阻塞"> 阻塞、非阻塞</h3>
<p>函数或方法调用的时候，是否立刻返回。
立即返回就是非阻塞调用；
不立即返回就是阻塞调用。</p>
<h3 id="区别"> 区别</h3>
<p>同步、异步，与阻塞、非阻塞不相关。
同步、异步强调的是，是否得到（最终的）<strong>结果</strong>；
阻塞、非阻塞强调是时间，是否<strong>等待</strong>。</p>
<p>同步与异步区别在于：调用者是否得到了想要的最终结果。
同步就是一直要执行到返回最终结果；
异步就是直接返回了，但是返回的不是最终结果。调用者不能通过这种调用得到结果，以后可以通过被调用者提供的某种方式（被调用者通知调用者、调用者反复查询、回调），来取回最终结果。</p>
<p>阻塞与非阻塞的区别在于，调用者是否还能干其他事。
阻塞，调用者就只能干等；
非阻塞，调用者可以先去忙会别的，不用一直等。</p>
<h3 id="联系"> 联系</h3>
<p>同步阻塞，我啥事不干，就等你打饭打给我。打到饭是结果，而且我啥事不干一直等，同步加阻塞。
同步非阻塞，我等着你打饭给我，饭没好，我不等，但是我无事可做，反复看饭好了没有。打饭是结果，但是我不一直等。</p>
<p>异步阻塞，我要打饭，你说等叫号，并没有返回饭给我，我啥事不干，就干等着饭好了你叫我。例如，取了号什么不干就等叫自己的号。
异步非阻塞，我要打饭，你给我号，你说等叫号，并没有返回饭给我，我去看电视、玩手机，饭打好了叫我。</p>
<h2 id="io两个阶段"> IO两个阶段</h2>
<p>IO过程分两阶段：
1、数据准备阶段。从设备读取数据到内核空间的缓冲区（淘米，把米放饭锅里煮饭）
2、内核空间复制回用户空间进程缓冲区阶段（盛饭，从内核这个饭锅里面把饭装到碗里来）</p>
<p>系统调用——read函数、recv函数等</p>
<h2 id="同步-io-模型"> 同步 IO 模型</h2>
<p>同步IO模型包括 阻塞IO、非阻塞IO、IO多路复用</p>
<h3 id="阻塞-io"> 阻塞 IO</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/block_io.png" alt="block_io" /></p>
<h3 id="非阻塞-io"> 非阻塞 IO</h3>
<p>进程调用 recvfrom 操作，如果 IO 设备没有准备好，立即返回 ERROR，进程不阻塞。用户可以再次发起系统调用（可以轮询），如果内核已经准备好，就阻塞，然后复制数据到用户空间。</p>
<p>第一阶段数据没有准备好，可以先忙别的，等会再来看看。检查数据是否准备好了的过程是非阻塞的。</p>
<p>第二阶段是阻塞的，即内核空间和用户空间之间复制数据是阻塞的。</p>
<p>淘米、蒸饭我不阻塞等，反复来询问，一直没有拿到饭。盛饭过程我等着你装好饭，但是要等到盛好饭才算完事，这是同步的，结果就是盛好饭。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/unblock-io.png" alt="unblock-io" /></p>
<h3 id="io多路复用"> IO多路复用</h3>
<p>也称 Event-driven IO。</p>
<p>所谓 IO 多路复用，就是同时监控多个 IO，有一个准备好了，就不需要等了开始处理，提高了同时处理 IO 的能力。
select几乎所有操作系统平台都支持，poll是对的select的升级。</p>
<p>epoll，Linux系统内核2.5+开始支持，对select和poll的增强，在监视的基础上，增加回调机制。BSD、
Mac平台有kqueue，Windows有iocp。</p>
<p>以 select 为例，将关注的 IO 操作告诉 select 函数并调用，进程阻塞，内核“监视” select 关注的文件描述符  fd，被关注的任何一个 fd 对应的IO准备好了数据，select 返回。再使用 read 将数据复制到用户进程。</p>
<p>select举例：
食堂供应很多菜（众多的IO），你需要吃某三菜一汤，大师傅（操作系统）说要现做，需要你等，好多人都在等菜，谁先好不知道，你只好等待大师傅叫。你的其中一样菜好了，大师傅叫你，说你点的菜有好的了，你得自己遍历找找看哪一样才好了，请服务员把做好的菜打给你。
epoll是有菜准备好了，大师傅喊你去几号窗口直接打菜，不用自己找菜了。</p>
<p>一般情况下，select 最多能监听1024个 fd（可以修改），但是由于select采用轮询的方式，当管理的 IO 多了，每次都要遍历全部fd，效率低下。
epoll 没有管理的 fd 的上限，且是回调机制，不需遍历，效率很高。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/io-more-road.png" alt="io-more-road" /></p>
<h3 id="信号驱动io"> 信号驱动IO</h3>
<p>进程在 IO 访问时，先通过 sigaction 系统调用，提交一个信号处理函数，立即返回。进程不阻塞。</p>
<p>当内核准备好数据后，产生一个 SIGIO 信号并投递给信号处理函数。可以在此函数中调用 recvfrom 函数
操作数据从内核空间复制到用户空间，这段过程进程阻塞。</p>
<h2 id="异步-io"> 异步 IO</h2>
<p>进程发起异步 IO 请求，立即返回。内核完成 IO 的两个阶段，内核给进程发一个信号。</p>
<p>举例，来打饭，跟大师傅说饭好了叫你，饭菜准备好了，窗口服务员把饭盛好了打电话叫你。两阶段都是异步的。在整个过程中，进程都可以忙别的，等好了才过来。
举例，今天不想出去到饭店吃饭了，点外卖，饭菜在饭店做好了（第一阶段），快递员从饭店送到你家门口（第二阶段）。
Linux 的 aio 的系统调用，内核从版本2.6开始支持</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/io-async.png" alt="io-async" /></p>
<p>前4个都是同步 IO，因为核心操作 recv 函数调用时，进程阻塞直到拿到最终结果为止。</p>
<p>而异步 IO 进程全程不阻塞。</p>
<h2 id="python-中-io多路复用"> Python 中 IO多路复用</h2>
<p>IO多路复用</p>
<ul>
<li>大多数操作系统都支持 select 和 poll</li>
<li>Linux 2.5+ 支持 epoll</li>
<li>BSD、Mac支持kqueue</li>
<li>Solaris 实现了/dev/poll</li>
<li>Windows的IOCP</li>
</ul>
<p>Python 的 select 库实现了 select、poll 系统调用，这个基本上操作系统都支持。对Linux内核2.5+支持了 epoll。</p>
<p>开发中的选择
1、完全跨平台，使用 select、poll。但是性能较差
2、针对不同操作系统自行选择支持的技术，这样做会提高 IO 处理的性能</p>
<p>select 维护一个文件描述符数据结构，单个进程使用有上限，通常是1024，线性扫描这个数据结构。效率低。</p>
<p>pool 和 select 的区别是内部数据结构使用链表，没有这个最大限制，但是依然是线性遍历才知道哪个设备就绪了。
epoll 使用事件通知机制，使用回调机制提高效率。
select/poll 还要从内核空间复制消息到用户空间，而 epoll 通过内核空间和用户空间共享一块内存来减少复制。</p>
<p><strong>selectors 库</strong></p>
<p>3.4 版本提供 selectors 库，高级 IO 复用库。</p>
<div><pre><code>类层次结构︰
BaseSelector
+-- SelectSelector  实现select
+-- PollSelector   实现poll
+-- EpollSelector   实现epoll
+-- DevpollSelector  实现devpoll
+-- KqueueSelector  实现kqueue
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>selectors.DefaultSelector 返回当前平台最有效、性能最高的实现。</p>
<p>但是，由于没有实现 Windows 下的 IOCP，所以，Windows 下只能退化为 select。</p>
<div><pre><code><span># 在selects模块源码最下面有如下代码</span>
<span># Choose the best implementation, roughly:</span>
<span>#    epoll|kqueue|devpoll > poll > select.</span>
<span># select() also can't accept a FD > FD_SETSIZE (usually around 1024)</span>
<span>if</span> <span>'KqueueSelector'</span> <span>in</span> <span>globals</span><span>(</span><span>)</span><span>:</span>
    DefaultSelector <span>=</span> KqueueSelector
<span>elif</span> <span>'EpollSelector'</span> <span>in</span> <span>globals</span><span>(</span><span>)</span><span>:</span>
    DefaultSelector <span>=</span> EpollSelector
<span>elif</span> <span>'DevpollSelector'</span> <span>in</span> <span>globals</span><span>(</span><span>)</span><span>:</span>
    DefaultSelector <span>=</span> DevpollSelector
<span>elif</span> <span>'PollSelector'</span> <span>in</span> <span>globals</span><span>(</span><span>)</span><span>:</span>
    DefaultSelector <span>=</span> PollSelector
<span>else</span><span>:</span>
    DefaultSelector <span>=</span> SelectSelector
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>事件注册</p>
<div><pre><code><span>class</span> <span>SelectSelector</span><span>(</span>_BaseSelectorImpl<span>)</span><span>:</span>
    <span>"""Select-based selector."""</span>
    <span>def</span> <span>register</span><span>(</span>fileobj<span>,</span> events<span>,</span> data<span>=</span><span>None</span><span>)</span> <span>-</span><span>></span> SelectorKey<span>:</span> <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>为 selector 注册一个文件对象，监视它的 IO 事件。返回 <strong>SelectKey</strong> 对象。</li>
<li>fileobj 被监视文件对象，例如socket对象</li>
<li>events 事件，该文件对象必须等待的事件</li>
<li>data 可选的与此文件对象相关联的不透明数据，例如，关联用来存储每个客户端的会话 ID，关联方法。通过这个参数在关注的事件产生后让selector干什么事。</li>
</ul>
<table>
<thead>
<tr>
<th>Event 常量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>EVENT_READ</td>
<td>可读 0b01，内核已经准备好输入设备，可以开始读了</td>
</tr>
<tr>
<td>EVENT_WRITE</td>
<td>可写 0b10，内核准备好了，可以往里写了</td>
</tr>
</tbody>
</table>
<p>selectors.SelectorKey 有4个属性：</p>
<ol>
<li>fileobj 注册的文件对象</li>
<li>fd 文件描述符</li>
<li>events 等待上面的文件描述符的文件对象的事件</li>
<li>data 注册时关联的数据</li>
</ol>
<p><strong>练习：IO 多路复用 TCP Server</strong></p>
<p>完成一个 TCP Server，能够接受客户端请求并回应客户端消息。</p>
<div><pre><code><span>import</span> selectors
<span>import</span> threading
<span>import</span> socket
<span>import</span> time
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

<span># 构建本系统最优Selector</span>
selector <span>=</span> selectors<span>.</span>DefaultSelector<span>(</span><span>)</span>

sock <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span> <span># TCP Server</span>
sock<span>.</span>bind<span>(</span><span>(</span><span>'127.0.0.1'</span><span>,</span> <span>9999</span><span>)</span><span>)</span>
sock<span>.</span>listen<span>(</span><span>)</span>
logging<span>.</span>info<span>(</span>sock<span>)</span>

sock<span>.</span>setblocking<span>(</span><span>False</span><span>)</span> <span># 注意：建议非阻塞</span>

<span># 回调函数，sock的读事件</span>
<span># 形参自定义</span>
<span>def</span> <span>accept</span><span>(</span>sock<span>:</span>socket<span>.</span>socket<span>,</span> mask<span>)</span><span>:</span>
    <span>"""mask: 事件掩码"""</span>
    conn<span>,</span> raddr <span>=</span> sock<span>.</span>accept<span>(</span><span>)</span>
    conn<span>.</span>setblocking<span>(</span><span>False</span><span>)</span> <span># 非阻塞</span>

    logging<span>.</span>info<span>(</span><span>'new client socket {} in accept.'</span><span>.</span><span>format</span><span>(</span>conn<span>)</span><span>)</span>

<span># 注册sock的被关注事件，返回SelectorKey对象</span>
<span># key记录了fileobj, fileobj的fd, events, data</span>
key <span>=</span> selector<span>.</span>register<span>(</span>sock<span>,</span> selectors<span>.</span>EVENT_READ<span>,</span> accept<span>)</span>
logging<span>.</span>info<span>(</span>key<span>)</span>

<span># 开始循环</span>
<span>while</span> <span>True</span><span>:</span>
    <span># 监听注册的对象的事件，发生被关注事件则返回events</span>
    events <span>=</span> selector<span>.</span>select<span>(</span><span>)</span>
    <span>print</span><span>(</span>events<span>)</span> <span># [(key, mask)]</span>
    <span># 表示那个关注的对象的某事件发生了</span>
    <span>for</span> key<span>,</span> mask <span>in</span> events<span>:</span>
        <span># key.data => accept; key.fileobj => sock</span>
        callback <span>=</span> key<span>.</span>data
        callback<span>(</span>key<span>.</span>fileobj<span>,</span> mask<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>上面的代码完成了 Server socket 的读事件的监听。注意，select() 方法会阻塞到监控的对象的等待的事件有发生（监听的读或者写就绪）。</p>
<div><pre><code><span>import</span> selectors
<span>import</span> threading
<span>import</span> socket
<span>import</span> time
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

<span># 构建本系统最优Selector</span>
selector <span>=</span> selectors<span>.</span>DefaultSelector<span>(</span><span>)</span>

sock <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span> <span># TCP Server</span>
sock<span>.</span>bind<span>(</span><span>(</span><span>'127.0.0.1'</span><span>,</span> <span>9999</span><span>)</span><span>)</span>
sock<span>.</span>listen<span>(</span><span>)</span>
logging<span>.</span>info<span>(</span>sock<span>)</span>

sock<span>.</span>setblocking<span>(</span><span>False</span><span>)</span> <span># 注意：建议非阻塞</span>

<span># 回调函数，sock的读事件</span>
<span># 形参自定义</span>
<span>def</span> <span>accept</span><span>(</span>sock<span>:</span>socket<span>.</span>socket<span>,</span> mask<span>)</span><span>:</span>
    <span>"""mask: 事件掩码"""</span>
    conn<span>,</span> raddr <span>=</span> sock<span>.</span>accept<span>(</span><span>)</span>
    conn<span>.</span>setblocking<span>(</span><span>False</span><span>)</span> <span># 非阻塞</span>

    logging<span>.</span>info<span>(</span><span>'new client socket {} in accept.'</span><span>.</span><span>format</span><span>(</span>conn<span>)</span><span>)</span>

    key <span>=</span> selector<span>.</span>register<span>(</span>conn<span>,</span> selectors<span>.</span>EVENT_READ<span>,</span> read<span>)</span>
    logging<span>.</span>info<span>(</span>key<span>)</span>

<span># 回调函数</span>
<span>def</span> <span>read</span><span>(</span>conn<span>:</span>socket<span>.</span>socket<span>,</span> mask<span>)</span><span>:</span>
    data <span>=</span> conn<span>.</span>recv<span>(</span><span>1024</span><span>)</span>
    msg <span>=</span> <span>"Your msg = {} ~~~"</span><span>.</span><span>format</span><span>(</span>data<span>.</span>decode<span>(</span><span>)</span><span>)</span>
    logging<span>.</span>info<span>(</span>msg<span>)</span>
    conn<span>.</span>send<span>(</span>msg<span>.</span>encode<span>(</span><span>)</span><span>)</span>

<span># 注册sock的被关注事件，返回SelectorKey对象</span>
<span># key记录了fileobj, fileobj的fd, events, data</span>
key <span>=</span> selector<span>.</span>register<span>(</span>sock<span>,</span> selectors<span>.</span>EVENT_READ<span>,</span> accept<span>)</span>
logging<span>.</span>info<span>(</span>key<span>)</span>

<span># 开始循环</span>
<span>while</span> <span>True</span><span>:</span>
    <span># 监听注册的对象的事件，发生被关注事件则返回events</span>
    events <span>=</span> selector<span>.</span>select<span>(</span><span>)</span>
    <span>print</span><span>(</span>events<span>)</span> <span># [(key, mask)]</span>
    <span># 表示那个关注的对象的某事件发生了</span>
    <span>for</span> key<span>,</span> mask <span>in</span> events<span>:</span>
        <span># key.data => accept; key.fileobj => sock</span>
        callback <span>=</span> key<span>.</span>data
        callback<span>(</span>key<span>.</span>fileobj<span>,</span> mask<span>)</span>





</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">02 线性数据结构</title>
    <id>https://clay-wangzhi.com/code/python/python-linear-data-structure/</id>
    <link href="https://clay-wangzhi.com/code/python/python-linear-data-structure/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_02-线性数据结构"> 02 线性数据结构</h1>
<h2 id="内建常用数据类型"> 内建常用数据类型</h2>
<ul>
<li>
<p>数值型</p>
<ul>
<li>int、float、complex、bool</li>
</ul>
</li>
<li>
<p>序列 sequence</p>
<ul>
<li>字符串 str、字节序列 bytes、bytearray</li>
<li>列表 list、元组 tuple</li>
</ul>
</li>
<li>
<p>键值对</p>
<ul>
<li>集合 set、字典 dict</li>
</ul>
</li>
</ul>
<h2 id="数值型"> 数值型</h2>
<ul>
<li>int、float、complex、bool  都是class，1、5.0、2+3j 都是对象即实例</li>
<li>int：python3 的 int 就是长整型，且没有大小限制，受限于内存区域的大小</li>
<li>float：由整数部分和小数部分组成。支持十进制和科学计数法表示。C 的双精度型实现</li>
<li>complex：有实数和虚数部分组成，实数和虚数部分都是浮点数，3+4.2J</li>
<li>bool：int 的子类，仅有2个实例 True、False 对应1和0，可以和整数直接运算</li>
</ul>
<h3 id="类型转换"> 类型转换</h3>
<ul>
<li>int、float、complex、bool 也可以当做内建函数对数据进行类型转换</li>
<li>int(x) 返回一个整数</li>
<li>float(x) 返回一个浮点数</li>
<li>complex(x)、complex(x,y) 返回一个复数</li>
<li>bool(x) 返回布尔值，前面讲过False等价的对象</li>
</ul>
<h3 id="整数"> 整数</h3>
<p>math模块的 floor()、ceil() 函数；内建函数 int()、round()；运算符 //</p>
<div><pre><code><span># 整除</span>
<span>print</span><span>(</span><span>3</span><span>//</span><span>2</span><span>,</span> <span>5</span><span>//</span><span>2</span><span>,</span> <span>7</span><span>//</span><span>2</span><span>)</span>
<span>print</span><span>(</span><span>-</span><span>3</span><span>//</span><span>2</span><span>,</span> <span>-</span><span>5</span><span>//</span><span>2</span><span>,</span> <span>-</span><span>7</span><span>//</span><span>2</span><span>)</span>
<span>print</span><span>(</span><span>7</span><span>//</span><span>2</span><span>,</span> <span>7</span><span>//</span><span>-</span><span>2</span><span>,</span> <span>-</span><span>7</span><span>//</span><span>2</span><span>,</span> <span>-</span><span>(</span><span>7</span><span>//</span><span>2</span><span>)</span><span>)</span>
<span># int</span>
<span>print</span><span>(</span><span>'int ------------'</span><span>)</span>
<span>print</span><span>(</span><span>int</span><span>(</span><span>1.4</span><span>)</span><span>,</span> <span>int</span><span>(</span><span>1.5</span><span>)</span><span>,</span> <span>int</span><span>(</span><span>1.6</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>int</span><span>(</span><span>-</span><span>1.4</span><span>)</span><span>,</span> <span>int</span><span>(</span><span>-</span><span>1.5</span><span>)</span><span>,</span> <span>int</span><span>(</span><span>-</span><span>1.6</span><span>)</span><span>)</span>
<span># ceil floor</span>
<span>print</span><span>(</span><span>'ceil floor ------------'</span><span>)</span>
<span>import</span> math
<span>print</span><span>(</span>math<span>.</span>floor<span>(</span><span>2.5</span><span>)</span><span>,</span> math<span>.</span>floor<span>(</span><span>-</span><span>2.5</span><span>)</span><span>)</span>
<span>print</span><span>(</span>math<span>.</span>ceil<span>(</span><span>2.5</span><span>)</span><span>,</span> math<span>.</span>ceil<span>(</span><span>-</span><span>2.5</span><span>)</span><span>)</span>
<span># round</span>
<span>print</span><span>(</span><span>'round ------------'</span><span>)</span>
<span>print</span><span>(</span><span>round</span><span>(</span><span>1.4</span><span>)</span><span>,</span> <span>round</span><span>(</span><span>-</span><span>1.4</span><span>)</span><span>,</span> <span>round</span><span>(</span><span>-</span><span>1.6</span><span>)</span><span>,</span> <span>round</span><span>(</span><span>1.6</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>round</span><span>(</span><span>2.4</span><span>)</span><span>,</span> <span>round</span><span>(</span><span>-</span><span>2.4</span><span>)</span><span>,</span> <span>round</span><span>(</span><span>2.6</span><span>)</span><span>,</span> <span>round</span><span>(</span><span>2.6</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>'round .5 ---------'</span><span>)</span>
<span>print</span><span>(</span><span>round</span><span>(</span><span>0.5</span><span>)</span><span>,</span> <span>round</span><span>(</span><span>1.5</span><span>)</span><span>,</span> <span>round</span><span>(</span><span>2.5</span><span>)</span><span>,</span> <span>round</span><span>(</span><span>3.5</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>round</span><span>(</span><span>-</span><span>0.5</span><span>)</span><span>,</span> <span>round</span><span>(</span><span>-</span><span>1.5</span><span>)</span><span>,</span> <span>round</span><span>(</span><span>-</span><span>2.5</span><span>)</span><span>,</span> <span>round</span><span>(</span><span>-</span><span>3.5</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><ul>
<li>round() 四舍六入五取偶</li>
<li>math.floor()  向下取整</li>
<li>math.ceil()向上取整</li>
<li>int() 取整数部分</li>
<li>// 整除且向下取整</li>
</ul>
<h3 id="常用数值处理函数"> 常用数值处理函数</h3>
<ul>
<li>min()、max()</li>
<li>pow(x,y) 等于 x**y</li>
<li>math.sqrt() 等于 x ** 0.5</li>
<li>进制函数，返回值是字符串
<ul>
<li>bin()、oct()、hex()</li>
</ul>
</li>
<li>math模块
<ul>
<li>math.pi π</li>
<li>math.e 自如常数</li>
<li>math模块中还有对数函数、三角函数等</li>
</ul>
</li>
</ul>
<h2 id="线性数据结构"> 线性数据结构</h2>
<p>线性表</p>
<ul>
<li>线性表（简称表），是一种抽象的数学概念，是一组元素的序列的抽象，它由有穷个元素组成（0
个或任意个）</li>
<li>顺序表：使用一大块连续的内存顺序存储表中的元素，这样实现的表称为顺序表，或称连续表
<ul>
<li>在顺序表中，元素的关系使用顺序表的存储顺序自然地表示</li>
</ul>
</li>
<li>链接表：在存储空间中将分散存储的元素链接起来，这种实现称为链接表，简称链表</li>
</ul>
<p>列表如同地铁站排好的队伍，有序，可以插队、离队，可以索引。</p>
<p>链表如同操场上手拉手的小朋友，有序但排列随意。或者可以想象成一串带线的珠子，随意盘放在桌
上。也可以离队、插队，也可以索引。</p>
<h2 id="列表-list"> 列表 list</h2>
<ul>
<li>一个排列整齐的队伍，Python采用顺序表实现</li>
<li>列表内的个体称作元素，由若干元素组成列表</li>
<li>元素可以是任意对象（数字、字符串、对象、列表等）</li>
<li>列表内元素有顺序，可以使用索引</li>
<li>线性的数据结构</li>
<li>使用 [ ] 表示</li>
<li>列表是可变的</li>
</ul>
<p>列表是非常重要的数据结构，对其内存结构和操作方法必须烂熟于心。</p>
<h3 id="初始化"> 初始化</h3>
<ul>
<li>list() -&gt; new empty list</li>
<li>list(iterable) -&gt;  new list initialized from iterable's items</li>
<li>[]</li>
<li>列表不能一开始就定义大小</li>
</ul>
<div><pre><code>ls1 <span>=</span> <span>[</span><span>]</span>
ls2 <span>=</span> <span>list</span><span>(</span><span>)</span>
ls3 <span>=</span> <span>[</span><span>2</span><span>,</span> <span>'ab'</span><span>,</span> <span>[</span><span>3</span><span>,</span> <span>'abc'</span><span>]</span><span>,</span> <span>(</span><span>5</span><span>,</span> <span>30</span><span>,</span> <span>50</span><span>)</span><span>]</span> <span># 列表是一个容器，元素可以是其它类型</span>
ls4 <span>=</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>5</span><span>)</span><span>)</span> <span># 非常常用的构造方式，将一个可迭代对象转换为一个列表</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="索引"> 索引</h3>
<ul>
<li>索引，也叫下标</li>
<li>正索引：从左至右，从0开始，为列表中每一个元素编号
<ul>
<li>如果列表有元素，索引范围[0, 长度-1]</li>
</ul>
</li>
<li>负索引：从右至左，从-1开始
<ul>
<li>如果列表有元素，索引范围[-长度, -1]</li>
</ul>
</li>
<li>正、负索引不可以超界，否则引发异常IndexError</li>
<li>为了理解方便，可以认为列表是从左至右排列的，左边是头部，右边是尾部，左边是下界，右边是
上界</li>
<li>列表通过索引访问，list[index] ，index就是索引，使用中括号访问</li>
</ul>
<p>使用索引定位访问元素的时间复杂度为O(1)，这是最快的方式，是列表最好的使用方式。</p>
<h3 id="查询"> 查询</h3>
<ul>
<li>index(value,[start,[stop]])
<ul>
<li>通过值value，从指定区间查找列表内的元素是否匹配</li>
<li>匹配第一个就立即返回索引</li>
<li>匹配不到，抛出异常ValueError</li>
</ul>
</li>
<li>count(value)
<ul>
<li>返回列表中匹配value的次数</li>
</ul>
</li>
<li>时间复杂度
<ul>
<li>index和count方法都是O(n)</li>
<li>随着列表数据规模的增大，而效率下降</li>
</ul>
</li>
<li>len() 列表的长度</li>
</ul>
<h3 id="修改"> 修改</h3>
<p>索引定位元素，然后修改。注意索引不能超界</p>
<div><pre><code>ls1 <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>]</span>
ls1<span>[</span><span>2</span><span>]</span> <span>=</span> <span>200</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="增加单个元素"> 增加单个元素</h3>
<ul>
<li>append(object) -&gt; None
<ul>
<li>列表尾部追加元素，返回None</li>
<li>返回None就意味着没有新的列表产生，就地修改</li>
<li>定位时间复杂度是O(1)</li>
</ul>
</li>
<li>insert(index, object) -&gt; None
<ul>
<li>在指定的索引index处插入元素object</li>
<li>返回None就意味着没有新的列表产生，就地修改</li>
<li>定位时间复杂度是O(1)</li>
</ul>
</li>
<li>索引能超上下界吗？
<ul>
<li>超越上界，尾部追加</li>
<li>超越下界，头部追加</li>
</ul>
</li>
</ul>
<h3 id="增加多个元素"> 增加多个元素</h3>
<ul>
<li>
<p>extend(iteratable) -&gt; None</p>
<ul>
<li>将可迭代对象的元素追加进来，返回None</li>
<li>就地修改，本列表自身扩展</li>
</ul>
</li>
<li>
<p>+ -&gt; list</p>
<ul>
<li>连接操作，将两个列表连接起来，产生新的列表，原列表不变</li>
<li>本质上调用的是魔术方法__add__()方法</li>
</ul>
</li>
<li>
<p>* -&gt; list</p>
<ul>
<li>重复操作，将本列表元素重复n次，返回新的列表</li>
</ul>
</li>
</ul>
<p>在Python中一切皆对象，而对象都是引用类型，可以理解为一个地址指针指向这个对象。</p>
<p>但是，字面常量字符串、数值等表现却不像引用类型，暂时可以称为简单类型。</p>
<p>而列表、元组、字典，包括以后学习的类和实例都可以认为是引用类型。</p>
<p>你可以认为简单类型直接存在列表中，而引入类型只是把引用地址存在了列表中。</p>
<h3 id="删除"> 删除</h3>
<ul>
<li>remove(value) -&gt; None
<ul>
<li>从左至右查找第一个匹配value的值，找到就移除该元素，并返回None，否则ValueError</li>
<li>就地修改</li>
</ul>
</li>
<li>pop([index]) -&gt; item
<ul>
<li>不指定索引index，就从列表尾部弹出一个元素</li>
<li>指定索引index，就从索引处弹出一个元素，索引超界抛出IndexError错误</li>
</ul>
</li>
<li>clear() -&gt; None
<ul>
<li>清除列表所有元素，剩下一个空列表</li>
</ul>
</li>
</ul>
<h3 id="in-成员操作"> in 成员操作</h3>
<div><pre><code><span>'a'</span> <span>in</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>]</span>
<span>[</span><span>3</span><span>,</span><span>4</span><span>]</span> <span>in</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>[</span><span>3</span><span>,</span><span>4</span><span>]</span><span>]</span>
<span>for</span> x <span>in</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>]</span><span>:</span>
	<span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="列表复制"> 列表复制</h3>
<div><pre><code>a <span>=</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>4</span><span>)</span><span>)</span>
b <span>=</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>4</span><span>)</span><span>)</span>
<span>print</span><span>(</span>a <span>==</span> b<span>)</span>
c <span>=</span> a
c<span>[</span><span>2</span><span>]</span> <span>=</span> <span>10</span>
<span>print</span><span>(</span>a<span>)</span>
<span>print</span><span>(</span>a <span>==</span> b<span>)</span> <span># 还相等吗？  不相等</span>
<span>print</span><span>(</span>a <span>==</span> c<span>)</span> <span># 相等吗？ 相等</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code>a <span>=</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>4</span><span>)</span><span>)</span>
b <span>=</span> a<span>.</span>copy<span>(</span><span>)</span>
<span>print</span><span>(</span>a <span>==</span> b<span>)</span> <span># 相等</span>
a<span>[</span><span>2</span><span>]</span> <span>=</span> <span>10</span>
<span>print</span><span>(</span>a <span>==</span> b<span>)</span> <span># 不相等</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>a <span>=</span> <span>[</span><span>1</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>,</span> <span>5</span><span>]</span>
b <span>=</span> a<span>.</span>copy<span>(</span><span>)</span>
<span>print</span><span>(</span>a <span>==</span> b<span>)</span> <span># True</span>
a<span>[</span><span>2</span><span>]</span> <span>=</span> <span>10</span>
<span>print</span><span>(</span>a <span>==</span> b<span>)</span> <span># False</span>
a<span>[</span><span>2</span><span>]</span> <span>=</span> b<span>[</span><span>2</span><span>]</span>
<span>print</span><span>(</span>a <span>==</span> b<span>)</span> <span># True</span>
a<span>[</span><span>1</span><span>]</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>100</span>
<span>print</span><span>(</span>a <span>==</span> b<span>)</span> <span># True</span>
<span>print</span><span>(</span>a<span>)</span>
<span>print</span><span>(</span>b<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>列表的内存模型和深浅拷贝</strong></p>
<ul>
<li>shadow copy
<ul>
<li>影子拷贝，也叫浅拷贝。遇到引用类型数据，仅仅复制一个引用而已</li>
</ul>
</li>
<li>deep copy
<ul>
<li>深拷贝，往往会递归复制一定深度</li>
</ul>
</li>
</ul>
<p>一般情况下，大多数语言提供的默认复制行为都是浅拷贝。</p>
<div><pre><code><span>import</span> copy
a <span>=</span> <span>[</span><span>1</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>]</span><span>,</span> <span>4</span><span>]</span>
b <span>=</span> copy<span>.</span>deepcopy<span>(</span>a<span>)</span>
<span>print</span><span>(</span>a <span>==</span> b<span>)</span>
a<span>[</span><span>1</span><span>]</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>100</span>
<span>print</span><span>(</span>a <span>==</span> b<span>)</span> <span># False</span>
<span>print</span><span>(</span>a<span>)</span>
<span>print</span><span>(</span>b<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>Python内建数据类型，内部都实现了 == ，它的意思是内容比较</p>
</blockquote>
<h3 id="python-内存管理"> Python 内存管理</h3>
<p>后续补充</p>
<h2 id="随机数"> 随机数</h2>
<p>random模块</p>
<ul>
<li>randint(a, b) 返回[a, b]之间的整数</li>
<li>randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1。 random.randrange(1,7,2)</li>
<li>choice(seq) 从非空序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中
随机挑选一个整数。random.choice([1,3,5,7])</li>
<li>3.6开始提供choices，一次从样本中随机选择几个，可重复选择，可以指定权重</li>
<li>random.shuffle(list) -&gt;None 就地打乱列表元素</li>
<li>sample(population, k) 从样本空间或总体（序列或者集合类型）中随机取出k个不同的元素，返回
一个新的列表
<ul>
<li>random.sample(['a', 'b', 'c', 'd'], 2)</li>
<li>random.sample(['a', 'a'], 2)</li>
<li>每次从样本空间采样，在这一次中不可以重复抽取同一个元素</li>
</ul>
</li>
</ul>
<div><pre><code><span>import</span> random
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>random<span>.</span>randint<span>(</span><span>1</span><span>,</span> <span>5</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>random<span>.</span>randrange<span>(</span><span>1</span><span>,</span> <span>5</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

x <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>random<span>.</span>choice<span>(</span>x<span>)</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

<span># 观察下面的0和1的比例</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>random<span>.</span>choices<span>(</span><span>[</span><span>0</span><span>,</span> <span>1</span><span>]</span><span>,</span> k<span>=</span><span>6</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>random<span>.</span>choices<span>(</span><span>[</span><span>0</span><span>,</span> <span>1</span><span>]</span><span>,</span> <span>[</span><span>10</span><span>,</span> <span>1</span><span>]</span><span>,</span> k<span>=</span><span>6</span><span>)</span><span>)</span> <span># 10比1权重</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

x <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span>
<span># 采样</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>5</span><span>)</span><span>:</span>
	<span>print</span><span>(</span>random<span>.</span>sample<span>(</span>x<span>,</span> <span>5</span><span>)</span><span>)</span> <span># k能不能是6, 不能</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="元组-tuple"> 元组 tuple</h2>
<ul>
<li>一个有序的元素组成的集合</li>
<li>使用小括号 ( ) 表示</li>
<li>元组是不可变对象</li>
</ul>
<h3 id="初始化-2"> 初始化</h3>
<ul>
<li>tuple() -&gt; empty tuple</li>
<li>tuple(iterable) -&gt; tuple initialized from iterable's items</li>
</ul>
<div><pre><code>t1 <span>=</span> <span>(</span><span>)</span> <span># 空元组</span>
t2 <span>=</span> <span>(</span><span>1</span><span>,</span><span>)</span> <span># 必须有这个逗号</span>
t3 <span>=</span> <span>(</span><span>1</span><span>,</span><span>)</span> <span>*</span> <span>5</span>
t4 <span>=</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span>
t5 <span>=</span> <span>1</span><span>,</span> <span>'a'</span>
t6 <span>=</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span>
t7 <span>=</span> <span>tuple</span><span>(</span><span>)</span> <span># 空元组</span>
t8 <span>=</span> <span>tuple</span><span>(</span><span>range</span><span>(</span><span>5</span><span>)</span><span>)</span>
t9 <span>=</span> <span>tuple</span><span>(</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="索引-2"> 索引</h3>
<p>索引和列表规则一样，不可以超界</p>
<h3 id="查询-2"> 查询</h3>
<p>方法和列表一样，时间复杂度也一样。index、count、len等</p>
<h3 id="增删改"> 增删改</h3>
<p>元组元素的个数在初始化的时候已经定义好了，所以不能为元组增加元素、也不能从中删除元素、也不能修改元素的内容。</p>
<h2 id="字符串-str"> 字符串 str</h2>
<ul>
<li>一个个字符组成的有序的序列，是字符的集合</li>
<li>使用单引号、双引号、三引号引住的字符序列</li>
<li>字符串是不可变对象，是字面常量</li>
</ul>
<p>Python3 起，字符串都是 Unicode 类型</p>
<h3 id="初始化-3"> 初始化</h3>
<div><pre><code>s1 = &#39;string&#39;
s2 = &quot;string2&quot;
s3 = &#39;&#39;&#39;this&#39;s a &quot;String&quot; &#39;&#39;&#39;
s4 = &#39;hello \n magedu.com&#39;
s5 = r&quot;hello \n magedu.com&quot;
s6 = &#39;c:\windows\nt&#39;
s7 = R&quot;c:\windows\nt&quot;
s8 = &#39;c:\windows\\nt&#39;
name = &#39;tom&#39;; age = 20 # python代码写在一行，使用分号隔开，不推荐
s9 = f&#39;{name}, {age}&#39; # 3.6支持f前缀
sql = &quot;&quot;&quot;select * from user where name=&#39;tom&#39; &quot;&quot;&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>r前缀：所有字符都是本来的意思，没有转义
f前缀：3.6开始，使用变量插值</p>
<h3 id="索引-3"> 索引</h3>
<p>字符串是序列，支持下标访问。但不可变，不可以修改元素。</p>
<div><pre><code>sql <span>=</span> <span>"select * from user where name='tom'"</span>
<span>print</span><span>(</span>sql<span>[</span><span>4</span><span>]</span><span>)</span> <span># 字符串'c'</span>
sql<span>[</span><span>4</span><span>]</span> <span>=</span> <span>'o'</span> <span># 不可以</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="连接"> 连接</h3>
<p>+加号</p>
<ul>
<li>将2个字符串连接起来</li>
<li>返回一个新的字符串</li>
</ul>
<p>join方法</p>
<ul>
<li>sep.join(iterable)</li>
<li>使用指定字符串作为分隔符，将可迭代对象中字符串使用这个分隔符拼接起来</li>
<li>可迭代对象必须是字符串</li>
<li>返回一个新的字符串</li>
</ul>
<div><pre><code>x <span>=</span> <span>'ab'</span>
x <span>=</span> x <span>+</span> <span>'cd'</span>
<span>print</span><span>(</span><span>','</span><span>.</span>join<span>(</span>x<span>)</span><span>)</span>
<span>print</span><span>(</span><span>'\t'</span><span>.</span>join<span>(</span>x<span>)</span><span>)</span>
<span>print</span><span>(</span><span>'\n'</span><span>.</span>join<span>(</span>x<span>)</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span><span>.</span>join<span>(</span><span>range</span><span>(</span><span>5</span><span>)</span><span>)</span><span>)</span> <span># 可以吗 不可以，可迭代对象必须是字符串</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="字符查找"> 字符查找</h3>
<p>find、rfind、index、rindex</p>
<p>后续补充</p>
<h3 id="分割"> 分割</h3>
<ul>
<li>split(sep=None, maxsplit=-1) -&gt; list of strings
<ul>
<li>从左至右</li>
<li>sep 指定分割字符串，缺省的情况下空白字符串作为分隔符</li>
<li>maxsplit 指定分割的次数，-1 表示遍历整个字符串</li>
<li>立即返回列表</li>
</ul>
</li>
<li>rsplit(sep=None, maxsplit=-1) -&gt; list of strings
<ul>
<li>从右向左开始切，但是输出的字符串字符不会反</li>
<li>sep 指定分割字符串，缺省的情况下空白字符串作为分隔符</li>
<li>maxsplit 指定分割的次数，-1 表示遍历整个字符串</li>
<li>立即返回列表</li>
</ul>
</li>
<li>splitlines([keepends]) -&gt; list of strings
<ul>
<li>按照行来切分字符串</li>
<li>keepends 指的是是否保留行分隔符</li>
<li>行分隔符包括\n、\r\n、\r等</li>
</ul>
</li>
</ul>
<div><pre><code>s <span>=</span> <span>','</span><span>.</span>join<span>(</span><span>'abcd'</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>split<span>(</span><span>','</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>split<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>split<span>(</span><span>','</span><span>,</span> <span>2</span><span>)</span><span>)</span>  <span># ['a', 'b', 'c,d']</span>

s1 <span>=</span> <span>'\na b \tc\nd\n'</span> <span># 注意下面3个切割的区别</span>
<span>print</span><span>(</span>s1<span>.</span>split<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s1<span>.</span>split<span>(</span><span>' '</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s1<span>.</span>split<span>(</span><span>'\n'</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s1<span>.</span>split<span>(</span><span>'b'</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s1<span>.</span>splitlines<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>partition(sep) -&gt; (head, sep, tail)
<ul>
<li>从左至右，遇到分隔符就把字符串分割成两部分，返回头、分隔符、尾三部分的三元组</li>
<li>如果没有找到分隔符，就返回头、2个空元素的三元组</li>
<li>sep 分割字符串，必须指定</li>
</ul>
</li>
<li>rpartition(sep) -&gt; (head, sep, tail)
<ul>
<li>从右至左，遇到分隔符就把字符串分割成两部分，返回头、分隔符、尾三部分的三元组</li>
<li>如果没有找到分隔符，就返回2个空元素和尾的三元组</li>
</ul>
</li>
</ul>
<div><pre><code>s <span>=</span> <span>','</span><span>.</span>join<span>(</span><span>'abcd'</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>partition<span>(</span><span>','</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>partition<span>(</span><span>'.'</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>rpartition<span>(</span><span>','</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>rpartition<span>(</span><span>'.'</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="替换"> 替换</h3>
<ul>
<li>replace(old, new[, count]) -&gt; str
<ul>
<li>字符串中找到匹配替换为新子串，返回新字符串</li>
<li>count表示替换几次，不指定就是全部替换</li>
</ul>
</li>
</ul>
<div><pre><code>s <span>=</span> <span>','</span><span>.</span>join<span>(</span><span>'abcd'</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>replace<span>(</span><span>','</span><span>,</span> <span>' '</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>replace<span>(</span><span>','</span><span>,</span> <span>' '</span><span>,</span> <span>2</span><span>)</span><span>)</span>
s1 <span>=</span> <span>'www.baidu.edu'</span>
<span>print</span><span>(</span>s1<span>.</span>replace<span>(</span><span>'w'</span><span>,</span> <span>'a'</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s1<span>.</span>replace<span>(</span><span>'ww'</span><span>,</span> <span>'a'</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s1<span>.</span>replace<span>(</span><span>'www'</span><span>,</span> <span>'a'</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="移除"> 移除</h3>
<ul>
<li>strip([chars]) -&gt; str
<ul>
<li>在字符串两端去除指定的字符集chars中的所有字符</li>
<li>如果chars没有指定，去除两端的空白字符</li>
</ul>
</li>
<li>lstrip([chars]) -&gt; str ，从左开始</li>
<li>rstrip([chars]) -&gt; str，从右开始</li>
</ul>
<div><pre><code>s <span>=</span> <span>'\t\r\na b c,d\ne\n\t'</span>
<span>print</span><span>(</span>s<span>.</span>strip<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>strip<span>(</span><span>'\t\n'</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>strip<span>(</span><span>'\t\ne\r'</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>首尾判断</p>
<ul>
<li>endswith(suffix[, start[, end]]) -&gt; bool
<ul>
<li>在指定的区间[start, end)，字符串是否是suffix结尾</li>
</ul>
</li>
<li>startswith(prefix[, start[, end]]) -&gt; bool
<ul>
<li>在指定的区间[start, end)，字符串是否是prefix开头</li>
</ul>
</li>
</ul>
<div><pre><code>s <span>=</span> <span>"www.baidu.edu"</span>
<span>print</span><span>(</span>s<span>.</span>startswith<span>(</span><span>'ww'</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>startswith<span>(</span><span>'i'</span><span>,</span> <span>6</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>startswith<span>(</span><span>'e'</span><span>,</span> <span>9</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>startswith<span>(</span><span>'edu'</span><span>,</span> <span>10</span><span>)</span><span>)</span>
<span>print</span><span>(</span>s<span>.</span>endswith<span>(</span><span>'edu'</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="其他函数"> 其他函数</h3>
<ul>
<li>upper()大写</li>
<li>lower()小写</li>
<li>swapcase() 交换大小写</li>
<li>isalnum() -&gt; bool 是否是字母和数字组成</li>
<li>isalpha() 是否是字母</li>
<li>isdecimal() 是否只包含十进制数字</li>
<li>isdigit() 是否全部数字(0~9)</li>
<li>isidentifier() 是不是字母和下划线开头，其他都是字母、数字、下划线</li>
<li>islower() 是否都是小写</li>
<li>isupper() 是否全部大写</li>
<li>isspace() 是否只包含空白字符</li>
</ul>
<h3 id="格式化"> 格式化</h3>
<p>简单的使用+或者 join 也可以拼接字符串，但是需要先转换数据到字符串后才能拼接。</p>
<p><strong>C 风格 printf-style</strong></p>
<ul>
<li>占位符：使用%和格式字符，例如%s、%d</li>
<li>修饰符：在占位符中还可以插入修饰符，例如%03d</li>
<li>format % values
<ul>
<li>format 是格式字符串，values 是被格式的值</li>
<li>格式字符串和被格式的值之间使用%</li>
<li>values只能是一个对象，可以是一个值，可以是一个元素个数和占位符数目相等的元组，也可以是一个字典</li>
</ul>
</li>
</ul>
<div><pre><code><span>print</span><span>(</span><span>"I am %5d"</span> <span>%</span> <span>(</span><span>20</span><span>,</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>'I like %s.'</span> <span>%</span> <span>'Python'</span><span>)</span>
<span>print</span><span>(</span><span>"%3.2f%% 0x%x %#X"</span> <span>%</span> <span>(</span><span>89.7654</span><span>,</span> <span>10</span><span>,</span> <span>256</span><span>)</span><span>)</span> <span># 宽度为3，小数点后2位</span>
<span>print</span><span>(</span><span>"I am %-5d"</span> <span>%</span> <span>(</span><span>20</span><span>,</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"%(host)s.%(domain)s"</span> <span>%</span> <span>{</span><span>'domain'</span><span>:</span><span>'baidu.com'</span><span>,</span> <span>'host'</span><span>:</span><span>'www'</span><span>}</span><span>)</span> <span># 靠名字对应</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>format函数</strong></p>
<p>Python2.5 之后，字符串类型提供了 format 函数，功能更加强大，鼓励使用。
&quot;{} {xxx}&quot;.format(*args, **kwargs) -&gt; str</p>
<ul>
<li>args是可变的位置参数</li>
<li>kwargs是可变关键字参数，写作a=100</li>
<li>使用花括号作为占位符</li>
<li>{}表示按照顺序匹配位置参数，{n}表示取位置参数索引为n的值</li>
<li>{xxx}表示在关键字参数中搜索名称一致的</li>
<li>{{}} 表示打印花括号</li>
</ul>
<div><pre><code><span># 位置对应</span>
<span>print</span><span>(</span><span>"{}:{}"</span><span>.</span><span>format</span><span>(</span><span>'127.0.0.1'</span><span>,</span> <span>8080</span><span>)</span><span>)</span>
<span># 位置或关键字对应</span>
<span>print</span><span>(</span><span>"{server} {1}:{0}"</span><span>.</span><span>format</span><span>(</span><span>8080</span><span>,</span> <span>'127.0.0.1'</span><span>,</span> server<span>=</span><span>'Web Server Info: '</span><span>)</span><span>)</span>
<span># 访问元素</span>
<span>print</span><span>(</span><span>"{0[0]}.{0[1]}"</span><span>.</span><span>format</span><span>(</span><span>(</span><span>'baidu'</span><span>,</span> <span>'com'</span><span>)</span><span>)</span><span>)</span>
<span># 进制</span>
<span>print</span><span>(</span><span>"{0:d} {0:b} {0:o} {0:x} {0:#X}"</span><span>.</span><span>format</span><span>(</span><span>31</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span># 浮点数</span>
<span>print</span><span>(</span><span>"{}"</span><span>.</span><span>format</span><span>(</span><span>3</span><span>**</span><span>0.5</span><span>)</span><span>)</span> <span># 1.7320508075688772</span>
<span>print</span><span>(</span><span>"{:f}"</span><span>.</span><span>format</span><span>(</span><span>3</span><span>**</span><span>0.5</span><span>)</span><span>)</span> <span># 1.732051，精度默认6</span>
<span>print</span><span>(</span><span>"{:10f}"</span><span>.</span><span>format</span><span>(</span><span>3</span><span>**</span><span>0.5</span><span>)</span><span>)</span> <span># 右对齐，宽度10</span>
<span>print</span><span>(</span><span>"{:2}"</span><span>.</span><span>format</span><span>(</span><span>102.231</span><span>)</span><span>)</span> <span># 宽度为2数字</span>
<span>print</span><span>(</span><span>"{:2}"</span><span>.</span><span>format</span><span>(</span><span>1</span><span>)</span><span>)</span> <span># 宽度为2数字</span>
<span>print</span><span>(</span><span>"{:.2}"</span><span>.</span><span>format</span><span>(</span><span>3</span><span>**</span><span>0.5</span><span>)</span><span>)</span> <span># 1.7 2个数字</span>
<span>print</span><span>(</span><span>"{:.2f}"</span><span>.</span><span>format</span><span>(</span><span>3</span><span>**</span><span>0.5</span><span>)</span><span>)</span> <span># 1.73 小数点后2位</span>
<span>print</span><span>(</span><span>"{:3.2f}"</span><span>.</span><span>format</span><span>(</span><span>3</span><span>**</span><span>0.5</span><span>)</span><span>)</span> <span># 1.73 宽度为3，小数点后2位</span>
<span>print</span><span>(</span><span>"{:20.3f}"</span><span>.</span><span>format</span><span>(</span><span>0.2745</span><span>)</span><span>)</span> <span># 0.275</span>
<span>print</span><span>(</span><span>"{:3.3%}"</span><span>.</span><span>format</span><span>(</span><span>1</span><span>/</span><span>3</span><span>)</span><span>)</span> <span># 33.333%</span>
<span># 注意宽度可以被撑破</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span># 对齐</span>
<span>print</span><span>(</span><span>"{}*{}={}"</span><span>.</span><span>format</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>*</span><span>6</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"{}*{}={:2}"</span><span>.</span><span>format</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>*</span><span>6</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"{1}*{0}={2:3}"</span><span>.</span><span>format</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>*</span><span>6</span><span>)</span><span>)</span> <span># 6*5= 30</span>
<span>print</span><span>(</span><span>"{1}*{0}={2:0>3}"</span><span>.</span><span>format</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>*</span><span>6</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"{}*{}={:#&lt;3}"</span><span>.</span><span>format</span><span>(</span><span>4</span><span>,</span> <span>5</span><span>,</span> <span>20</span><span>)</span><span>)</span> <span># 4*5=20#</span>
<span>print</span><span>(</span><span>"{:#^7}"</span><span>.</span><span>format</span><span>(</span><span>'*'</span> <span>*</span> <span>3</span><span>)</span><span>)</span> <span># ##***##</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="字节序列"> 字节序列</h2>
<p>Python3 引入两个新的类型 bytes、bytearray。</p>
<p>bytes 不可变字节序列；bytearray 是可变字节数组。</p>
<h3 id="编码与解码"> 编码与解码</h3>
<ul>
<li>编码：str =&gt; bytes，将字符串这个字符序列使用指定字符集encode编码为一个个字节组成的序列bytes</li>
<li>解码：bytes 或 bytearray =&gt; str，将一个个字节按照某种指定的字符集解码为一个个字符串组成的字符串</li>
</ul>
<div><pre><code><span>print</span><span>(</span><span>"abc"</span><span>.</span>encode<span>(</span><span>)</span><span>)</span> <span># 缺省为utf-8编码</span>
<span>print</span><span>(</span><span>"啊"</span><span>.</span>encode<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"啊"</span><span>.</span>encode<span>(</span><span>'utf-8'</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"啊"</span><span>.</span>encode<span>(</span><span>'gbk'</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>b'abc'</span><span>.</span>decode<span>(</span><span>'utf8'</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>b'\xb0\xa1'</span><span>.</span>decode<span>(</span><span>'gbk'</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>b'\xe5\x95\x8a'</span><span>.</span>decode<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="ascii"> ASCII</h3>
<p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁
字母的一套单字节编码系统</p>
<p><em><strong>ASCII控制字符</strong></em></p>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>缩写</th>
<th>可以显示的表示法</th>
<th>名称/意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 0000</td>
<td>0</td>
<td>00</td>
<td>NUL</td>
<td>␀</td>
<td>空字符（Null）</td>
</tr>
<tr>
<td>0000 0001</td>
<td>1</td>
<td>01</td>
<td>SOH</td>
<td>␁</td>
<td>标题开始</td>
</tr>
<tr>
<td>0000 0010</td>
<td>2</td>
<td>02</td>
<td>STX</td>
<td>␂</td>
<td>本文开始</td>
</tr>
<tr>
<td>0000 0011</td>
<td>3</td>
<td>03</td>
<td>ETX</td>
<td>␃</td>
<td>本文结束</td>
</tr>
<tr>
<td>0000 0100</td>
<td>4</td>
<td>04</td>
<td>EOT</td>
<td>␄</td>
<td>传输结束</td>
</tr>
<tr>
<td>0000 0101</td>
<td>5</td>
<td>05</td>
<td>ENQ</td>
<td>␅</td>
<td>请求</td>
</tr>
<tr>
<td>0000 0110</td>
<td>6</td>
<td>06</td>
<td>ACK</td>
<td>␆</td>
<td>确认回应</td>
</tr>
<tr>
<td>0000 0111</td>
<td>7</td>
<td>07</td>
<td>BEL</td>
<td>␇</td>
<td>响铃</td>
</tr>
<tr>
<td>0000 1000</td>
<td>8</td>
<td>08</td>
<td>BS</td>
<td>␈</td>
<td>退格</td>
</tr>
<tr>
<td>0000 1001</td>
<td>9</td>
<td>09</td>
<td>HT</td>
<td>␉</td>
<td>水平定位符号</td>
</tr>
<tr>
<td>0000 1010</td>
<td>10</td>
<td>0A</td>
<td>LF</td>
<td>␊</td>
<td>换行键</td>
</tr>
<tr>
<td>0000 1011</td>
<td>11</td>
<td>0B</td>
<td>VT</td>
<td>␋</td>
<td>垂直定位符号</td>
</tr>
<tr>
<td>0000 1100</td>
<td>12</td>
<td>0C</td>
<td>FF</td>
<td>␌</td>
<td>换页键</td>
</tr>
<tr>
<td>0000 1101</td>
<td>13</td>
<td>0D</td>
<td>CR</td>
<td>␍</td>
<td>归位键</td>
</tr>
<tr>
<td>0000 1110</td>
<td>14</td>
<td>0E</td>
<td>SO</td>
<td>␎</td>
<td>取消变换（Shift out）</td>
</tr>
<tr>
<td>0000 1111</td>
<td>15</td>
<td>0F</td>
<td>SI</td>
<td>␏</td>
<td>启用变换（Shift in）</td>
</tr>
<tr>
<td>0001 0000</td>
<td>16</td>
<td>10</td>
<td>DLE</td>
<td>␐</td>
<td>跳出数据通讯</td>
</tr>
<tr>
<td>0001 0001</td>
<td>17</td>
<td>11</td>
<td>DC1</td>
<td>␑</td>
<td>设备控制一（XON 启用软件速度控制）</td>
</tr>
<tr>
<td>0001 0010</td>
<td>18</td>
<td>12</td>
<td>DC2</td>
<td>␒</td>
<td>设备控制二</td>
</tr>
<tr>
<td>0001 0011</td>
<td>19</td>
<td>13</td>
<td>DC3</td>
<td>␓</td>
<td>设备控制三（XOFF 停用软件速度控制）</td>
</tr>
<tr>
<td>0001 0100</td>
<td>20</td>
<td>14</td>
<td>DC4</td>
<td>␔</td>
<td>设备控制四</td>
</tr>
<tr>
<td>0001 0101</td>
<td>21</td>
<td>15</td>
<td>NAK</td>
<td>␕</td>
<td>确认失败回应</td>
</tr>
<tr>
<td>0001 0110</td>
<td>22</td>
<td>16</td>
<td>SYN</td>
<td>␖</td>
<td>同步用暂停</td>
</tr>
<tr>
<td>0001 0111</td>
<td>23</td>
<td>17</td>
<td>ETB</td>
<td>␗</td>
<td>区块传输结束</td>
</tr>
<tr>
<td>0001 1000</td>
<td>24</td>
<td>18</td>
<td>CAN</td>
<td>␘</td>
<td>取消</td>
</tr>
<tr>
<td>0001 1001</td>
<td>25</td>
<td>19</td>
<td>EM</td>
<td>␙</td>
<td>连接介质中断</td>
</tr>
<tr>
<td>0001 1010</td>
<td>26</td>
<td>1A</td>
<td>SUB</td>
<td>␚</td>
<td>替换</td>
</tr>
<tr>
<td>0001 1011</td>
<td>27</td>
<td>1B</td>
<td>ESC</td>
<td>␛</td>
<td>跳出</td>
</tr>
<tr>
<td>0001 1100</td>
<td>28</td>
<td>1C</td>
<td>FS</td>
<td>␜</td>
<td>文件分割符</td>
</tr>
<tr>
<td>0001 1101</td>
<td>29</td>
<td>1D</td>
<td>GS</td>
<td>␝</td>
<td>组群分隔符</td>
</tr>
<tr>
<td>0001 1110</td>
<td>30</td>
<td>1E</td>
<td>RS</td>
<td>␞</td>
<td>记录分隔符</td>
</tr>
<tr>
<td>0001 1111</td>
<td>31</td>
<td>1F</td>
<td>US</td>
<td>␟</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>0111 1111</td>
<td>127</td>
<td>7F</td>
<td>DEL</td>
<td>␡</td>
<td>删除</td>
</tr>
</tbody>
</table>
<p><em><strong>ASCII可显示字符</strong></em></p>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>图形</th>
</tr>
</thead>
<tbody>
<tr>
<td>0010 0000</td>
<td>32</td>
<td>20</td>
<td>（空格）(␠)</td>
</tr>
<tr>
<td>0010 0001</td>
<td>33</td>
<td>21</td>
<td>!</td>
</tr>
<tr>
<td>0010 0010</td>
<td>34</td>
<td>22</td>
<td>&quot;</td>
</tr>
<tr>
<td>0010 0011</td>
<td>35</td>
<td>23</td>
<td>#</td>
</tr>
<tr>
<td>0010 0100</td>
<td>36</td>
<td>24</td>
<td>$</td>
</tr>
<tr>
<td>0010 0101</td>
<td>37</td>
<td>25</td>
<td>%</td>
</tr>
<tr>
<td>0010 0110</td>
<td>38</td>
<td>26</td>
<td>&amp;</td>
</tr>
<tr>
<td>0010 0111</td>
<td>39</td>
<td>27</td>
<td>'</td>
</tr>
<tr>
<td>0010 1000</td>
<td>40</td>
<td>28</td>
<td>(</td>
</tr>
<tr>
<td>0010 1001</td>
<td>41</td>
<td>29</td>
<td>)</td>
</tr>
<tr>
<td>0010 1010</td>
<td>42</td>
<td>2A</td>
<td>*</td>
</tr>
<tr>
<td>0010 1011</td>
<td>43</td>
<td>2B</td>
<td>+</td>
</tr>
<tr>
<td>0010 1100</td>
<td>44</td>
<td>2C</td>
<td>,</td>
</tr>
<tr>
<td>0010 1101</td>
<td>45</td>
<td>2D</td>
<td>-</td>
</tr>
<tr>
<td>0010 1110</td>
<td>46</td>
<td>2E</td>
<td>.</td>
</tr>
<tr>
<td>0010 1111</td>
<td>47</td>
<td>2F</td>
<td>/</td>
</tr>
<tr>
<td>0011 0000</td>
<td>48</td>
<td>30</td>
<td>0</td>
</tr>
<tr>
<td>0011 0001</td>
<td>49</td>
<td>31</td>
<td>1</td>
</tr>
<tr>
<td>0011 0010</td>
<td>50</td>
<td>32</td>
<td>2</td>
</tr>
<tr>
<td>0011 0011</td>
<td>51</td>
<td>33</td>
<td>3</td>
</tr>
<tr>
<td>0011 0100</td>
<td>52</td>
<td>34</td>
<td>4</td>
</tr>
<tr>
<td>0011 0101</td>
<td>53</td>
<td>35</td>
<td>5</td>
</tr>
<tr>
<td>0011 0110</td>
<td>54</td>
<td>36</td>
<td>6</td>
</tr>
<tr>
<td>0011 0111</td>
<td>55</td>
<td>37</td>
<td>7</td>
</tr>
<tr>
<td>0011 1000</td>
<td>56</td>
<td>38</td>
<td>8</td>
</tr>
<tr>
<td>0011 1001</td>
<td>57</td>
<td>39</td>
<td>9</td>
</tr>
<tr>
<td>0011 1010</td>
<td>58</td>
<td>3A</td>
<td>:</td>
</tr>
<tr>
<td>0011 1011</td>
<td>59</td>
<td>3B</td>
<td>;</td>
</tr>
<tr>
<td>0011 1100</td>
<td>60</td>
<td>3C</td>
<td>&lt;</td>
</tr>
<tr>
<td>0011 1101</td>
<td>61</td>
<td>3D</td>
<td>=</td>
</tr>
<tr>
<td>0011 1110</td>
<td>62</td>
<td>3E</td>
<td>&gt;</td>
</tr>
<tr>
<td>0011 1111</td>
<td>63</td>
<td>3F</td>
<td>?</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>图形</th>
</tr>
</thead>
<tbody>
<tr>
<td>0100 0000</td>
<td>64</td>
<td>40</td>
<td>@</td>
</tr>
<tr>
<td>0100 0001</td>
<td>65</td>
<td>41</td>
<td>A</td>
</tr>
<tr>
<td>0100 0010</td>
<td>66</td>
<td>42</td>
<td>B</td>
</tr>
<tr>
<td>0100 0011</td>
<td>67</td>
<td>43</td>
<td>C</td>
</tr>
<tr>
<td>0100 0100</td>
<td>68</td>
<td>44</td>
<td>D</td>
</tr>
<tr>
<td>0100 0101</td>
<td>69</td>
<td>45</td>
<td>E</td>
</tr>
<tr>
<td>0100 0110</td>
<td>70</td>
<td>46</td>
<td>F</td>
</tr>
<tr>
<td>0100 0111</td>
<td>71</td>
<td>47</td>
<td>G</td>
</tr>
<tr>
<td>0100 1000</td>
<td>72</td>
<td>48</td>
<td>H</td>
</tr>
<tr>
<td>0100 1001</td>
<td>73</td>
<td>49</td>
<td>I</td>
</tr>
<tr>
<td>0100 1010</td>
<td>74</td>
<td>4A</td>
<td>J</td>
</tr>
<tr>
<td>0100 1011</td>
<td>75</td>
<td>4B</td>
<td>K</td>
</tr>
<tr>
<td>0100 1100</td>
<td>76</td>
<td>4C</td>
<td>L</td>
</tr>
<tr>
<td>0100 1101</td>
<td>77</td>
<td>4D</td>
<td>M</td>
</tr>
<tr>
<td>0100 1110</td>
<td>78</td>
<td>4E</td>
<td>N</td>
</tr>
<tr>
<td>0100 1111</td>
<td>79</td>
<td>4F</td>
<td>O</td>
</tr>
<tr>
<td>0101 0000</td>
<td>80</td>
<td>50</td>
<td>P</td>
</tr>
<tr>
<td>0101 0001</td>
<td>81</td>
<td>51</td>
<td>Q</td>
</tr>
<tr>
<td>0101 0010</td>
<td>82</td>
<td>52</td>
<td>R</td>
</tr>
<tr>
<td>0101 0011</td>
<td>83</td>
<td>53</td>
<td>S</td>
</tr>
<tr>
<td>0101 0100</td>
<td>84</td>
<td>54</td>
<td>T</td>
</tr>
<tr>
<td>0101 0101</td>
<td>85</td>
<td>55</td>
<td>U</td>
</tr>
<tr>
<td>0101 0110</td>
<td>86</td>
<td>56</td>
<td>V</td>
</tr>
<tr>
<td>0101 0111</td>
<td>87</td>
<td>57</td>
<td>W</td>
</tr>
<tr>
<td>0101 1000</td>
<td>88</td>
<td>58</td>
<td>X</td>
</tr>
<tr>
<td>0101 1001</td>
<td>89</td>
<td>59</td>
<td>Y</td>
</tr>
<tr>
<td>0101 1010</td>
<td>90</td>
<td>5A</td>
<td>Z</td>
</tr>
<tr>
<td>0101 1011</td>
<td>91</td>
<td>5B</td>
<td>[</td>
</tr>
<tr>
<td>0101 1100</td>
<td>92</td>
<td>5C</td>
<td>\</td>
</tr>
<tr>
<td>0101 1101</td>
<td>93</td>
<td>5D</td>
<td>]</td>
</tr>
<tr>
<td>0101 1110</td>
<td>94</td>
<td>5E</td>
<td>^</td>
</tr>
<tr>
<td>0101 1111</td>
<td>95</td>
<td>5F</td>
<td>_</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>图形</th>
</tr>
</thead>
<tbody>
<tr>
<td>0110 0000</td>
<td>96</td>
<td>60</td>
<td>`</td>
</tr>
<tr>
<td>0110 0001</td>
<td>97</td>
<td>61</td>
<td>a</td>
</tr>
<tr>
<td>0110 0010</td>
<td>98</td>
<td>62</td>
<td>b</td>
</tr>
<tr>
<td>0110 0011</td>
<td>99</td>
<td>63</td>
<td>c</td>
</tr>
<tr>
<td>0110 0100</td>
<td>100</td>
<td>64</td>
<td>d</td>
</tr>
<tr>
<td>0110 0101</td>
<td>101</td>
<td>65</td>
<td>e</td>
</tr>
<tr>
<td>0110 0110</td>
<td>102</td>
<td>66</td>
<td>f</td>
</tr>
<tr>
<td>0110 0111</td>
<td>103</td>
<td>67</td>
<td>g</td>
</tr>
<tr>
<td>0110 1000</td>
<td>104</td>
<td>68</td>
<td>h</td>
</tr>
<tr>
<td>0110 1001</td>
<td>105</td>
<td>69</td>
<td>i</td>
</tr>
<tr>
<td>0110 1010</td>
<td>106</td>
<td>6A</td>
<td>j</td>
</tr>
<tr>
<td>0110 1011</td>
<td>107</td>
<td>6B</td>
<td>k</td>
</tr>
<tr>
<td>0110 1100</td>
<td>108</td>
<td>6C</td>
<td>l</td>
</tr>
<tr>
<td>0110 1101</td>
<td>109</td>
<td>6D</td>
<td>m</td>
</tr>
<tr>
<td>0110 1110</td>
<td>110</td>
<td>6E</td>
<td>n</td>
</tr>
<tr>
<td>0110 1111</td>
<td>111</td>
<td>6F</td>
<td>o</td>
</tr>
<tr>
<td>0111 0000</td>
<td>112</td>
<td>70</td>
<td>p</td>
</tr>
<tr>
<td>0111 0001</td>
<td>113</td>
<td>71</td>
<td>q</td>
</tr>
<tr>
<td>0111 0010</td>
<td>114</td>
<td>72</td>
<td>r</td>
</tr>
<tr>
<td>0111 0011</td>
<td>115</td>
<td>73</td>
<td>s</td>
</tr>
<tr>
<td>0111 0100</td>
<td>116</td>
<td>74</td>
<td>t</td>
</tr>
<tr>
<td>0111 0101</td>
<td>117</td>
<td>75</td>
<td>u</td>
</tr>
<tr>
<td>0111 0110</td>
<td>118</td>
<td>76</td>
<td>v</td>
</tr>
<tr>
<td>0111 0111</td>
<td>119</td>
<td>77</td>
<td>w</td>
</tr>
<tr>
<td>0111 1000</td>
<td>120</td>
<td>78</td>
<td>x</td>
</tr>
<tr>
<td>0111 1001</td>
<td>121</td>
<td>79</td>
<td>y</td>
</tr>
<tr>
<td>0111 1010</td>
<td>122</td>
<td>7A</td>
<td>z</td>
</tr>
<tr>
<td>0111 1011</td>
<td>123</td>
<td>7B</td>
<td>{</td>
</tr>
<tr>
<td>0111 1100</td>
<td>124</td>
<td>7C</td>
<td>|</td>
</tr>
<tr>
<td>0111 1101</td>
<td>125</td>
<td>7D</td>
<td>}</td>
</tr>
<tr>
<td>0111 1110</td>
<td>126</td>
<td>7E</td>
<td>~</td>
</tr>
</tbody>
</table>
<p>熟记：</p>
<ol>
<li>
<p>\x00 表中第一项，C语言中的字符串结束符</p>
</li>
<li>
<p>\t \x09 tab字符</p>
</li>
<li>
<p>\r\n \x0d\x0a</p>
</li>
<li>
<p>\x30~\x39 字符0~9，\x31 字符1</p>
</li>
<li>
<p>\x41 65 A</p>
</li>
<li>
<p>\x61 97 a</p>
</li>
</ol>
<p>注意：这里的1指定是字符1，不是数字1
UTF-8、GBK都兼容了ASCII</p>
<h3 id="bytes-初始化"> bytes 初始化</h3>
<ul>
<li>bytes() 空bytes</li>
<li>bytes(int) 指定字节的bytes，被0填充</li>
<li>bytes(iterable_of_ints) -&gt; bytes [0,255]的int组成的可迭代对象</li>
<li>bytes(string, encoding[, errors]) -&gt; bytes 等价于string.encode()</li>
<li>bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer 从一个字节序列或者buffer复制出一个新的不可变的bytes对象</li>
<li>使用b前缀定义
<ul>
<li>只允许基本ASCII使用字符形式 b'abc9'</li>
<li>使用16进制表示 b&quot;\x41\x61&quot;</li>
</ul>
</li>
</ul>
<p>bytes类型和str类型类似，都是不可变类型，操作方法类似。</p>
<div><pre><code><span>print</span><span>(</span><span>b'abcd'</span><span>[</span><span>2</span><span>]</span><span>)</span> <span># 返回int，指定是本字节对应的十进制数</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="bytearrary-初始化"> bytearrary 初始化</h3>
<ul>
<li>bytearray() 空bytearray</li>
<li>bytearray(int) 指定字节的bytearray，被0填充</li>
<li>bytearray(iterable_of_ints) -&gt; bytearray [0,255]的int组成的可迭代对象</li>
<li>bytearray(string, encoding[, errors]) -&gt; bytearray 近似string.encode()，不过返回可变对象</li>
<li>bytearray(bytes_or_buffer) 从一个字节序列或者buffer复制出一个新的可变的bytearray对象</li>
</ul>
<p>b前缀表示的是bytes，不是bytearray类型</p>
<p>由于bytearray类型是可变数组，所以，类似列表。</p>
<ul>
<li>append(int) 尾部追加一个元素</li>
<li>insert(index, int) 在指定索引位置插入元素</li>
<li>extend(iterable_of_ints) 将一个可迭代的整数集合追加到当前bytearray</li>
<li>pop(index=-1) 从指定索引上移除元素，默认从尾部移除</li>
<li>remove(value) 找到第一个value移除，找不到抛ValueError异常</li>
<li>注意：上述方法若需要使用int类型，值在[0, 255]</li>
<li>clear() 清空bytearray</li>
<li>reverse() 翻转bytearray，就地修改</li>
</ul>
<div><pre><code>b <span>=</span> <span>bytearray</span><span>(</span><span>)</span>
b<span>.</span>append<span>(</span><span>97</span><span>)</span>
b<span>.</span>append<span>(</span><span>99</span><span>)</span>
b<span>.</span>insert<span>(</span><span>1</span><span>,</span><span>98</span><span>)</span>
b<span>.</span>extend<span>(</span><span>[</span><span>65</span><span>,</span><span>66</span><span>,</span><span>67</span><span>]</span><span>)</span>
b<span>.</span>remove<span>(</span><span>66</span><span>)</span>
b<span>.</span>pop<span>(</span><span>)</span>
b<span>.</span>reverse<span>(</span><span>)</span>
<span>print</span><span>(</span>b<span>)</span> <span># 输出什么  bytearray(b'Acba')</span>
b<span>.</span>clear<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="线性结构"> 线性结构</h2>
<p>线性结构特征：</p>
<ul>
<li>可迭代 for ... in</li>
<li>有长度，通过len(x)获取，容器</li>
<li>通过整数下标可以访问元素。正索引、负索引
<ul>
<li>可以切片</li>
</ul>
</li>
</ul>
<p>已经学习过的线性结构：list、tuple、str、bytes、bytearray</p>
<h3 id="切片"> 切片</h3>
<div><pre><code>sequence<span>[</span>start<span>:</span>stop<span>]</span>
sequence<span>[</span>start<span>:</span>stop<span>:</span>step<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>通过给定的索引区间获得线性结构的一部分数据</li>
<li>start、stop、step为整数，可以是正整数、负整数、零</li>
<li>start为0时，可以省略</li>
<li>stop为末尾时，可以省略</li>
<li>step为1时，可以省略</li>
<li>切片时，索引超过上界（右边界），就取到末尾；超过下界（左边界），取到开头</li>
</ul>
<div><pre><code>x <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span>
<span>print</span><span>(</span>x<span>[</span><span>:</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>:</span><span>-</span><span>1</span><span>]</span><span>)</span> <span>#</span>
<span>print</span><span>(</span>x<span>[</span><span>0</span><span>:</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>3</span><span>:</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>3</span><span>:</span><span>-</span><span>1</span><span>]</span><span>)</span> <span>#</span>
<span>print</span><span>(</span>x<span>[</span><span>9</span><span>:</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>:</span><span>9</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>9</span><span>:</span><span>-</span><span>1</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>:</span><span>100</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>-</span><span>100</span><span>:</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>4</span><span>:</span><span>-</span><span>2</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>-</span><span>4</span><span>:</span><span>-</span><span>2</span><span>]</span><span>)</span>
<span>print</span><span>(</span><span>'0123456789'</span><span>[</span><span>-</span><span>4</span><span>:</span><span>8</span><span>]</span><span>)</span>
<span>print</span><span>(</span><span>b'0123456789'</span><span>[</span><span>-</span><span>4</span><span>:</span><span>8</span><span>]</span><span>)</span>
<span>print</span><span>(</span><span>bytearray</span><span>(</span><span>b'0123456789'</span><span>)</span><span>[</span><span>-</span><span>10</span><span>:</span><span>5</span><span>]</span><span>)</span>

<span># 步长</span>
x <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span>
<span>print</span><span>(</span>x<span>[</span><span>:</span><span>:</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>:</span><span>:</span><span>2</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>2</span><span>:</span><span>8</span><span>:</span><span>3</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>:</span><span>9</span><span>:</span><span>3</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>1</span><span>:</span><span>:</span><span>3</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>-</span><span>10</span><span>:</span><span>8</span><span>:</span><span>2</span><span>]</span><span>)</span>

<span># 起止和方向</span>
x <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span>
<span>print</span><span>(</span>x<span>[</span><span>-</span><span>10</span><span>:</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>-</span><span>5</span><span>:</span><span>6</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>-</span><span>5</span><span>:</span><span>-</span><span>6</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>6</span><span>:</span><span>5</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>5</span><span>:</span><span>5</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>1</span><span>:</span><span>9</span><span>:</span><span>-</span><span>2</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>:</span><span>:</span><span>-</span><span>2</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>8</span><span>:</span><span>:</span><span>-</span><span>2</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>8</span><span>:</span><span>2</span><span>:</span><span>-</span><span>2</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>8</span><span>:</span><span>-</span><span>10</span><span>:</span><span>2</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>8</span><span>:</span><span>-</span><span>10</span><span>:</span><span>-</span><span>2</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>-</span><span>5</span><span>:</span><span>4</span><span>:</span><span>-</span><span>1</span><span>]</span><span>)</span>
<span>print</span><span>(</span>x<span>[</span><span>-</span><span>5</span><span>:</span><span>5</span><span>:</span><span>-</span><span>1</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>在序列上使用切片[start:stop]，子区间索引范围[start, stop)，相当于从start开始指向stop的方向上获
取数据</p>
<p>默认step为1，表示向右；步长为负数，表示向左</p>
<p>如果子区间方向和步长方向不一致，直接返回当前类型的&quot;空对象&quot;</p>
<p>如果子区间方向和步长方向一致，则从起点间隔步长取值</p>
<table>
<thead>
<tr>
<th>内建函数</th>
<th>函数签名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>id(object)</td>
<td>CPython中返回对象的内存地址<br/>可以用来判断是不是同一个对象</td>
</tr>
</tbody>
</table>
<div><pre><code><span># 使用id看地址，要注意地址回收复用问题</span>
<span>print</span><span>(</span><span>id</span><span>(</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span><span>[</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>]</span><span>)</span><span>)</span>
<span># 上下两句可能内存地址一样，但是上面那个[1,2,3]没有意义，因为它用完之后，引用计数为0了，没人能再次访问到，释放了内存</span>
<span># 如果2个存在在内存中的对象，地址一样一定是同一个对象</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>x <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>]</span>
y <span>=</span> x<span>[</span><span>:</span><span>]</span>
<span>print</span><span>(</span>x<span>,</span> y<span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>x<span>)</span><span>,</span> <span>id</span><span>(</span>y<span>)</span><span>)</span>
x<span>[</span><span>0</span><span>]</span> <span>=</span> <span>100</span>
<span>print</span><span>(</span>x<span>,</span> y<span>)</span>

x <span>=</span> <span>[</span><span>[</span><span>1</span><span>]</span><span>]</span>
y <span>=</span> x<span>[</span><span>:</span><span>]</span>
<span>print</span><span>(</span>x<span>,</span> y<span>)</span>
<span>print</span><span>(</span>x <span>==</span> y<span>)</span> <span># True</span>
<span>print</span><span>(</span><span>id</span><span>(</span>x<span>)</span><span>,</span> <span>id</span><span>(</span>y<span>)</span><span>,</span> x <span>is</span> y<span>)</span> <span># False</span>
x<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>100</span>
<span>print</span><span>(</span>x<span>,</span> y<span>)</span>
<span>print</span><span>(</span>x <span>==</span> y<span>)</span> <span># True</span>
<span>print</span><span>(</span>x <span>is</span> y<span>)</span> <span># False</span>
x<span>[</span><span>0</span><span>]</span> <span>=</span> <span>200</span>
<span>print</span><span>(</span>x <span>==</span> y<span>)</span> <span># False</span>
<span>print</span><span>(</span>x<span>,</span> y<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>上例可知，实际上切片后得到一个全新的对象。 [:] 或 [::] 相当于copy方法。</p>
<h3 id="切片赋值"> 切片赋值</h3>
<ul>
<li>切片操作写在了等号左边</li>
<li>被插入的可迭代对象写在等号右边</li>
</ul>
<div><pre><code>x <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>]</span>
z <span>=</span> <span>None</span>
z <span>=</span> <span>1</span>
z<span>[</span><span>:</span><span>]</span> <span>=</span> x <span># 可以吗 不可以 TypeError: 'int' object does not support item assignment</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code>x <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span>
z <span>=</span> <span>list</span><span>(</span><span>)</span>
z<span>[</span><span>:</span><span>]</span> <span>=</span> x
z<span>[</span><span>1</span><span>:</span><span>2</span><span>]</span> <span>=</span> <span>10</span> <span># 可以吗？ 不可以 TypeError: can only assign an iterable</span>
z<span>[</span><span>1</span><span>:</span><span>2</span><span>]</span> <span>=</span> <span>(</span><span>10</span><span>,</span><span>)</span>
z<span>[</span><span>3</span><span>:</span><span>]</span> <span>=</span> <span>(</span><span>20</span><span>,</span><span>)</span>
z<span>[</span><span>1</span><span>:</span><span>]</span> <span>=</span> <span>(</span><span>40</span><span>,</span> <span>50</span> <span>,</span><span>60</span><span>,</span> <span>70</span><span>)</span>
z<span>[</span><span>1</span><span>:</span><span>-</span><span>1</span><span>]</span> <span>=</span> <span>(</span><span>)</span>
x <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span>
y <span>=</span> <span>[</span><span>]</span>
y<span>[</span><span>:</span><span>]</span> <span>=</span> x
<span>print</span><span>(</span>x <span>==</span> y<span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>x<span>)</span><span>,</span> <span>id</span><span>(</span>y<span>)</span><span>,</span> x <span>is</span> y<span>)</span>
m <span>=</span> x <span># 这一句有什么用？y[:] = x有什么用？</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>m 和 x它们两个变量指向同一个对象。</p>
<p>y=[]、y[:]=x 等价于  z=x[:] ，都是创建x的副本。</p>
<p>切片赋值用作初始化相当于copy，还可以使用。如果用在替换、插入元素，看似语法比较简洁，但是由
于列表是顺序表结构，将会引起数据的挪动，这非常影响性能，应当尽量避免使用。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">11 魔术方法</title>
    <id>https://clay-wangzhi.com/code/python/python-magic/</id>
    <link href="https://clay-wangzhi.com/code/python/python-magic/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_11-魔术方法"> 11 魔术方法</h1>
<h2 id="实例化"> 实例化</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__new__</code></td>
<td>实例化一个对象<br/>该方法需要返回一个值，如果该值不是 cls 的实例，则不会调用 <code>__init__</code><br/>该方法永远都是静态方法</td>
</tr>
</tbody>
</table>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__new__</span><span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span>print</span><span>(</span>cls<span>)</span>
        <span>print</span><span>(</span>args<span>)</span>
        <span>print</span><span>(</span>kwargs<span>)</span>
        <span>#return super().__new__(cls)</span>
        <span>#return 1</span>
        <span>return</span> <span>None</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        
a <span>=</span> A<span>(</span><span>)</span>
<span>print</span><span>(</span>a<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><code>__new__</code> 方法很少使用，即使创建了该方法，也会使用 <code>return super().__new__(cls)</code> 基类object的
<code>__new__</code> 方法来创建实例并返回。</p>
<h2 id="可视化"> 可视化</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__str__</code></td>
<td>str()函数、format()函数、print()函数调用，需要返回对象的字符串表达。如果没<br/>有定义，就去调用<code>__repr__</code> 方法返回字符串表达，如果 <code>__repr__</code> 没有定义，就直接返回对象的内存地址信息</td>
</tr>
<tr>
<td><code>__repr__</code></td>
<td>内建函数repr()对一个对象获取字符串表达。<br/>调用 <code>__repr__</code> 方法返回字符串表达，如果 <code>__repr__</code> 也没有定义，就直接返回 object 的定义就是显示内存地址信息</td>
</tr>
<tr>
<td><code>__bytes__</code></td>
<td>bytes() 函数调用，返回一个对象的 bytes 表达，即返回 bytes 对象</td>
</tr>
</tbody>
</table>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>=</span><span>18</span><span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>age <span>=</span> age

    <span>def</span> <span>__repr__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>'repr: {},{}'</span><span>.</span><span>format</span><span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>age<span>)</span>

    <span>def</span> <span>__str__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>'str: {},{}'</span><span>.</span><span>format</span><span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>age<span>)</span>

    <span>def</span> <span>__bytes__</span><span>(</span>self<span>)</span><span>:</span>
        <span>#return "{} is {}".format(self.name, self.age).encode()</span>
        <span>import</span> json
        <span>return</span> json<span>.</span>dumps<span>(</span>self<span>.</span>__dict__<span>)</span><span>.</span>encode<span>(</span><span>)</span>
    
<span>print</span><span>(</span>A<span>(</span><span>'tom'</span><span>)</span><span>)</span> <span># print函数使用__str__</span>
<span>print</span><span>(</span><span>'{}'</span><span>.</span><span>format</span><span>(</span>A<span>(</span><span>'tom'</span><span>)</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>[</span>A<span>(</span><span>'tom'</span><span>)</span><span>]</span><span>)</span> <span># []使用__str__，但其内部使用__repr__</span>
<span>print</span><span>(</span><span>[</span><span>str</span><span>(</span>A<span>(</span><span>'tom'</span><span>)</span><span>)</span><span>]</span><span>)</span> <span># []使用__str__，其中的元素使用str()函数也调用__str__</span>
<span>print</span><span>(</span><span>bytes</span><span>(</span>A<span>(</span><span>'tom'</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="hash"> hash</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__hash__</code></td>
<td>内建函数 hash() 调用的返回值，返回一个整数。如果定义这个方法该类的实例就<br/>可hash。</td>
</tr>
</tbody>
</table>
<div><pre><code><span>print</span><span>(</span><span>hash</span><span>(</span><span>1</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>hash</span><span>(</span><span>'tom'</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>hash</span><span>(</span><span>(</span><span>'tom'</span><span>,</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>=</span><span>18</span><span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name

    <span>def</span> <span>__hash__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>1</span>

    <span>def</span> <span>__repr__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>name

<span>print</span><span>(</span><span>hash</span><span>(</span>A<span>(</span><span>'tom'</span><span>)</span><span>)</span><span>)</span> <span># 可hash 1</span>
<span>print</span><span>(</span><span>(</span>A<span>(</span><span>'tom'</span><span>)</span><span>,</span> A<span>(</span><span>'tom'</span><span>)</span><span>)</span><span>)</span> <span># (tom, tom)</span>
<span>print</span><span>(</span><span>[</span>A<span>(</span><span>'tom'</span><span>)</span><span>,</span> A<span>(</span><span>'tom'</span><span>)</span><span>]</span><span>)</span> <span># [tom, tom]</span>
<span>print</span><span>(</span><span>'~~~~~~~~~~~~~~~~~~~~'</span><span>)</span>
<span>print</span><span>(</span><span>{</span><span>1</span><span>,</span> <span>1</span><span>}</span><span>)</span> <span># {1}</span>
<span>print</span><span>(</span><span>{</span><span>'tom'</span><span>,</span> <span>'tom'</span><span>}</span><span>)</span> <span># {'tom'}</span>
a1 <span>=</span> A<span>(</span><span>'tom'</span><span>)</span>
a2 <span>=</span> A<span>(</span><span>'tom'</span><span>)</span>
s <span>=</span> <span>{</span>a1<span>,</span> a2<span>}</span> <span># set</span>
<span>print</span><span>(</span>s<span>)</span> <span># 去重了吗 没有 {tom, tom}</span>
<span>print</span><span>(</span><span>hash</span><span>(</span>a1<span>)</span><span>,</span> <span>hash</span><span>(</span>a2<span>)</span><span>)</span> <span># 1, 1</span>
t1 <span>=</span> <span>(</span><span>'tom'</span><span>,</span><span>)</span>
t2 <span>=</span> <span>(</span><span>'tom'</span><span>,</span><span>)</span>
<span>print</span><span>(</span>t1 <span>is</span> t2<span>)</span> <span># 3.7+是True，3.6及以下是False</span>
<span>print</span><span>(</span>t1 <span>==</span> t2<span>)</span> <span># True</span>
<span>print</span><span>(</span><span>{</span>t1<span>,</span> t2<span>}</span><span>,</span> <span>hash</span><span>(</span>t1<span>)</span><span>,</span> <span>hash</span><span>(</span>t2<span>)</span><span>)</span> <span>#(tom,)</span>
<span>print</span><span>(</span><span>{</span><span>(</span><span>'tom'</span><span>,</span><span>)</span><span>,</span> <span>(</span><span>'tom'</span><span>,</span><span>)</span><span>}</span><span>)</span>
<span>print</span><span>(</span><span>{</span><span>'tom'</span><span>,</span> <span>'tom'</span><span>}</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>上例中， A的实例放在set中，它们hash值是相同的，为什么不能去重？
hash值相同就会去重吗？</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>=</span><span>18</span><span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name

    <span>def</span> <span>__hash__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>1</span>

    <span>def</span> <span>__eq__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span> <span># 这个函数作用？</span>
        <span>return</span> self<span>.</span>name <span>==</span> other<span>.</span>name

    <span>def</span> <span>__repr__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>name

<span>print</span><span>(</span><span>hash</span><span>(</span>A<span>(</span><span>'tom'</span><span>)</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>(</span>A<span>(</span><span>'tom'</span><span>)</span><span>,</span> A<span>(</span><span>'tom'</span><span>)</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>[</span>A<span>(</span><span>'tom'</span><span>)</span><span>,</span> A<span>(</span><span>'tom'</span><span>)</span><span>]</span><span>)</span>
<span>print</span><span>(</span><span>'~~~~~~~~~~~~~~~~~~~~'</span><span>)</span>
s <span>=</span> <span>{</span>A<span>(</span><span>'tom'</span><span>)</span><span>,</span> A<span>(</span><span>'tom'</span><span>)</span><span>}</span> <span># set</span>
<span>print</span><span>(</span>s<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__eq__</code></td>
<td>对应==操作符，判断2个对象内容是否相等，返回bool值<br/>定义了这个方法，如果不提供 <code>__hash__</code> 方法，那么实例将不可hash了</td>
</tr>
</tbody>
</table>
<p><code>__hash__</code> 方法只是返回一个hash值作为set的key，但是 去重 ，还需要 <code>__eq__</code> 来判断2个对象是否相等。
hash值相等，只是hash冲突，不能说明两个对象是相等的。</p>
<p>因此，一般来说提供 <code>__hash__</code> 方法是为了作为set或者dict的key，如果 去重 要同时提供 <code>__eq__</code> 方法。</p>
<p>不可 hash 对象 isinstance(p1, collections.Hashable) 一定为 False。
去重 需要提供 <code>__eq__</code> 方法。</p>
<p><strong>思考：</strong>
list类实例为什么不可hash？</p>
<p>源码中有一句 <code>__hash__ = None</code>，也就是如果调用 <code>__hash__ ()</code>相当于None()，一定报错。
所有类都继承object，而这个类是具有 <code>__hash__ ()</code>方法的，如果一个类不能被hash，就把 <code>__hash__</code> 设置为None。</p>
<h2 id="bool"> bool</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__bool__</code></td>
<td>内建函数bool()，或者对象放在逻辑表达式的位置，调用这个函数返回布尔值。<br/>没有定义 <code>__bool__</code> ()，就找 <code>__len__</code> ()返回长度，非0为真。<br/>如果 <code>__len__</code> ()也没有定义，那么所有实例都返回真</td>
</tr>
</tbody>
</table>
<div><pre><code><span>class</span> <span>A</span><span>:</span> <span>pass</span>
a <span>=</span> A<span>(</span><span>)</span>

<span>print</span><span>(</span><span>bool</span><span>(</span>A<span>)</span><span>)</span> <span># True</span>
<span>print</span><span>(</span><span>bool</span><span>(</span>a<span>)</span><span>)</span> <span>#True</span>

<span>class</span> <span>B</span><span>:</span>
    <span>def</span> <span>__bool__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>False</span>

<span>print</span><span>(</span><span>bool</span><span>(</span>B<span>)</span><span>)</span> <span># True</span>
<span>print</span><span>(</span><span>bool</span><span>(</span>B<span>(</span><span>)</span><span>)</span><span>)</span> <span># False</span>

<span>if</span> B<span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'Real B instance'</span><span>)</span>

<span>class</span> <span>C</span><span>:</span>
    <span>def</span> <span>__len__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>0</span>

<span>print</span><span>(</span><span>bool</span><span>(</span>C<span>)</span><span>)</span> <span># True</span>
<span>print</span><span>(</span><span>bool</span><span>(</span>C<span>(</span><span>)</span><span>)</span><span>)</span> <span># False</span>

<span>if</span> C<span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'Real C instance'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="运算符重载"> 运算符重载</h2>
<p>operator 模块提供以下的特殊方法，可以将类的实例使用下面的操作符来操作</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>特殊方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;, &lt;=, ==, &gt;,<br/>&gt;=, !=</td>
<td><code>__lt__</code>,<code>__le__</code>,<code>__eq__</code>,<code>__gt__</code>,<code>__ge__</code>,<code>__ne__</code></td>
<td>比较运算符</td>
</tr>
<tr>
<td>+, -, *, /, %,<br/>//, **,<br/>divmod</td>
<td><code>__add__</code>,<code>__sub__</code>,<code>__mul__</code>,<code>__truediv__</code>,<br/><code>__mod__</code>,<code>__floordiv__</code>,<code>__pow__</code>,<code>__divmod__</code></td>
<td>算数运算符，移位、<br/>位运算也有对应的方<br/>法</td>
</tr>
<tr>
<td>+=, -=, *=,<br/>/=, %=, //=,<br/>**=</td>
<td><code>__iadd__</code>,<code>__isub__</code>,<code>__imul__</code>,<code>__itruediv__</code>,<br/><code>__imod__</code>,<code>__ifloordiv__</code>,<code>__ipow__</code>,</td>
<td></td>
</tr>
</tbody>
</table>
<p>实现自定义类的实例的大小比较（非常重要，排序时使用）</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>=</span><span>18</span><span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>age <span>=</span> age

    <span>def</span> <span>__eq__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>name <span>==</span> other<span>.</span>name <span>and</span> self<span>.</span>age <span>==</span> other<span>.</span>age

    <span>def</span> <span>__gt__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>age <span>></span> other<span>.</span>age

    <span>def</span> <span>__ge__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>age <span>>=</span> other<span>.</span>age

tom <span>=</span> A<span>(</span><span>'tom'</span><span>)</span>
jerry <span>=</span> A<span>(</span><span>'jerry'</span><span>,</span> <span>16</span><span>)</span>
<span>print</span><span>(</span>tom <span>==</span> jerry<span>,</span> tom <span>!=</span> jerry<span>)</span>
<span>print</span><span>(</span>tom <span>></span> jerry<span>,</span> tom <span>&lt;</span> jerry<span>)</span>
<span>print</span><span>(</span>tom <span>>=</span> jerry<span>,</span> tom <span>&lt;=</span> jerry<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><code>__eq__</code> 等于可以推断不等于
<code>__gt__</code> 大于可以推断小于
<code>__ge__</code> 大于等于可以推断小于等于
也就是用3个方法，就可以把所有比较解决了</p>
<p>实现两个学生的成绩差</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> score<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>score <span>=</span> score

tom <span>=</span> A<span>(</span><span>'tom'</span><span>,</span> <span>80</span><span>)</span>
jerry <span>=</span> A<span>(</span><span>'jerry'</span><span>,</span> <span>85</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>score <span>-</span> jerry<span>.</span>score<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> score<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>score <span>=</span> score

    <span>def</span> <span>__sub__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>score <span>-</span> other<span>.</span>score

tom <span>=</span> A<span>(</span><span>'tom'</span><span>,</span> <span>80</span><span>)</span>
jerry <span>=</span> A<span>(</span><span>'jerry'</span><span>,</span> <span>85</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>score <span>-</span> jerry<span>.</span>score<span>)</span>

<span>print</span><span>(</span>tom <span>-</span> jerry<span>)</span>
<span>print</span><span>(</span><span>'~~~~~~~~~~~~~~~~~~~~~~~~~~~'</span><span>)</span>
jerry <span>-=</span> tom <span># 调用什么</span>
<span>print</span><span>(</span>tom<span>)</span>
<span>print</span><span>(</span>jerry<span>)</span> <span># 显示什么 5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> score<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>score <span>=</span> score

    <span>def</span> <span>__sub__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>score <span>-</span> other<span>.</span>score

    <span>def</span> <span>__isub__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
        <span>#return A(self.name, self.score - other.score)</span>
        self<span>.</span>score <span>-=</span> other<span>.</span>score
        <span>return</span> self
    
    <span>def</span> <span>__repr__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>"&lt;A name={}, score={}>"</span><span>.</span><span>format</span><span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>score<span>)</span>

tom <span>=</span> A<span>(</span><span>'tom'</span><span>,</span> <span>80</span><span>)</span>
jerry <span>=</span> A<span>(</span><span>'jerry'</span><span>,</span> <span>85</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>score <span>-</span> jerry<span>.</span>score<span>)</span>
<span>print</span><span>(</span>tom <span>-</span> jerry<span>)</span>
<span>print</span><span>(</span><span>'~~~~~~~~~~~~~~~~~~~~~~~~~~~'</span><span>)</span>
jerry <span>-=</span> tom <span># 调用什么</span>
<span>print</span><span>(</span>tom<span>)</span>
<span>print</span><span>(</span>jerry<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>思考：list的+和+=的区别。tuple呢？</p>
<h2 id="上下文管理"> 上下文管理</h2>
<p>文件 IO 操作可以对文件对象使用上下文管理，使用 with...as 语法。</p>
<div><pre><code><span>with</span> <span>open</span><span>(</span><span>'test'</span><span>)</span> <span>as</span> f<span>:</span>
	<span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>仿照上例写一个自己的类，实现上下文管理</p>
<div><pre><code><span>class</span> <span>Point</span><span>:</span>
	<span>pass</span>

<span>with</span> Point<span>(</span><span>)</span> <span>as</span> p<span>:</span> <span># AttributeError: __exit__</span>
	<span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>提示属性错误，没有 <code>__exit__</code> ，看了需要这个属性
某些版本会显示没有 <code>__enter__</code></p>
<h3 id="上下文管理对象"> 上下文管理对象</h3>
<p>当一个对象同时实现了 <code>__enter__</code>()和 <code>__exit__</code> ()方法，它就属于上下文管理的对象</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__enter__</code></td>
<td>进入与此对象相关的上下文。如果存在该方法，with 语法会把该方法的返回值作<br/>为绑定到 as 子句中指定的变量上</td>
</tr>
<tr>
<td><code>__exit__</code></td>
<td>退出与此对象相关的上下文</td>
</tr>
</tbody>
</table>
<div><pre><code><span>import</span> time

<span>class</span> <span>Point</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'init ~~~~~~~~'</span><span>)</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>'init over'</span><span>)</span>

    <span>def</span> <span>__enter__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'enter ~~~~~~~~'</span><span>)</span>

    <span>def</span> <span>__exit__</span><span>(</span>self<span>,</span> exc_type<span>,</span> exc_val<span>,</span> exc_tb<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'exit ============'</span><span>)</span>

<span>with</span> Point<span>(</span><span>)</span> <span>as</span> p<span>:</span>
    <span>print</span><span>(</span><span>'in with-------------'</span><span>)</span>

    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>'with over'</span><span>)</span>

<span>print</span><span>(</span><span>'=======end=========='</span><span>)</span>

<span># 输出结果为</span>
init <span>~</span><span>~</span><span>~</span><span>~</span><span>~</span><span>~</span><span>~</span><span>~</span>
init over
enter <span>~</span><span>~</span><span>~</span><span>~</span><span>~</span><span>~</span><span>~</span><span>~</span>
<span>in</span> <span>with</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span>
<span>with</span> over
exit <span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>
<span>==</span><span>==</span><span>==</span><span>=</span>end<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>实例化对象的时候，并不会调用enter，进入with语句块调用 <code>__enter__</code> 方法，然后执行语句体，最后离开 with 语句块的时候，调用 <code>__exit__</code> 方法。</p>
<p>with 可以开启一个上下文运行环境，在执行前做一些准备工作，执行后做一些收尾工作。</p>
<p>注意，with并不开启一个新的作用域。</p>
<h3 id="上下文管理的安全性"> 上下文管理的安全性</h3>
<div><pre><code><span>import</span> time

<span>class</span> <span>Point</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'init ~~~~~~~~'</span><span>)</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>'init over'</span><span>)</span>

    <span>def</span> <span>__enter__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'enter ~~~~~~~~'</span><span>)</span>

    <span>def</span> <span>__exit__</span><span>(</span>self<span>,</span> exc_type<span>,</span> exc_val<span>,</span> exc_tb<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'exit ============'</span><span>)</span>

<span>with</span> Point<span>(</span><span>)</span> <span>as</span> p<span>:</span>
    <span>print</span><span>(</span><span>'in with-------------'</span><span>)</span>
    <span>raise</span> Exception<span>(</span><span>'error'</span><span>)</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>'with over'</span><span>)</span>
    
<span>print</span><span>(</span><span>'=======end=========='</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>可以看出在抛出异常的情况下，with的<code>__exit__</code>照样执行，<strong>上下文管理是安全的</strong>。</p>
<h3 id="with-语句"> with 语句</h3>
<div><pre><code><span># t3.py文件中写入下面代码</span>
<span>class</span> <span>Point</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'init'</span><span>)</span>

    <span>def</span> <span>__enter__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'enter'</span><span>)</span>

    <span>def</span> <span>__exit__</span><span>(</span>self<span>,</span> exc_type<span>,</span> exc_val<span>,</span> exc_tb<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'exit'</span><span>)</span>

f <span>=</span> <span>open</span><span>(</span><span>'t3.py'</span><span>)</span>
<span>with</span> f <span>as</span> p<span>:</span>
    <span>print</span><span>(</span>f<span>)</span>
    <span>print</span><span>(</span>p<span>)</span>
    <span>print</span><span>(</span>f <span>is</span> p<span>)</span> <span># 打印什么 True</span>
    <span>print</span><span>(</span>f <span>==</span> p<span>)</span> <span># 打印什么 True</span>

p <span>=</span> f <span>=</span> <span>None</span>
p <span>=</span> Point<span>(</span><span>)</span>
<span>with</span> p <span>as</span> f<span>:</span>
    <span>print</span><span>(</span><span>'in with-------------'</span><span>)</span>
    <span>print</span><span>(</span>p <span>==</span> f<span>)</span>
    <span>print</span><span>(</span><span>'with over'</span><span>)</span>

<span>print</span><span>(</span><span>'=======end=========='</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>问题在于 <code>__enter__</code> 方法上，它将自己的返回值赋给f。修改上例</p>
<div><pre><code><span># t3.py文件中写入下面代码</span>
<span>class</span> <span>Point</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'init'</span><span>)</span>

    <span>def</span> <span>__enter__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'enter'</span><span>)</span>
        <span>return</span> self

    <span>def</span> <span>__exit__</span><span>(</span>self<span>,</span> exc_type<span>,</span> exc_val<span>,</span> exc_tb<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'exit'</span><span>)</span>
p <span>=</span> f <span>=</span> <span>None</span>
p <span>=</span> Point<span>(</span><span>)</span>
<span>with</span> p <span>as</span> f<span>:</span>
    <span>print</span><span>(</span><span>'in with-------------'</span><span>)</span>
    <span>print</span><span>(</span>p <span>==</span> f<span>)</span>
    <span>print</span><span>(</span><span>'with over'</span><span>)</span>

<span>print</span><span>(</span><span>'=======end=========='</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>with 语法，会调用 with 后的对象的<code>__enter__</code>方法，如果有 as，则将该方法的返回值赋给 as 子句的变量</p>
<p>上例，可以等价为<code>f = p.__enter__()</code></p>
<h3 id="上下文应用场景"> 上下文应用场景</h3>
<ol>
<li>增强功能
在代码执行的前后增加代码，以增强其功能。类似装饰器的功能。</li>
<li>资源管理
打开了资源需要关闭，例如文件对象、网络连接、数据库连接等</li>
<li>权限验证
在执行代码之前，做权限的验证，在<code>__enter__</code> 中处理</li>
</ol>
<h3 id="生成器函数"> 生成器函数</h3>
<div><pre><code><span># 生成器函数 # 调用后返回什么呢？生成器对象（生成器表达式、生成器函数），惰性求值</span>
<span># 在一个函数定义中，出现了yield语句，此函数就是生成器函数</span>
<span>def</span> <span>foo</span><span>(</span><span>)</span><span>:</span>
	<span>while</span> <span>True</span><span>:</span>
		<span>yield</span> <span>1</span>
<span># 无限可迭代对象</span>
f <span>=</span> foo<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="contextlib-contextmanager"> contextlib.contextmanager</h3>
<p>contextlib.contextmanager 它是一个装饰器实现上下文管理，装饰一个函数，而不用像类一样实现<code>__enter__</code> 和 <code>__exit__</code> 方法。</p>
<p>对下面的函数有要求：必须有yield，也就是这个函数必须返回一个生成器，且只有yield一个值。</p>
<p>也就是这个装饰器接收一个生成器对象作为参数。</p>
<div><pre><code><span>import</span> contextlib

<span>@contextlib<span>.</span>contextmanager</span>
<span>def</span> <span>foo</span><span>(</span><span>)</span><span>:</span> <span>#</span>
    <span>print</span><span>(</span><span>'enter'</span><span>)</span> <span># 相当于__enter__()</span>
    <span>yield</span> <span># yield 5，yield的值只能有一个，相当于作为__enter__方法的返回值</span>
    <span>print</span><span>(</span><span>'exit'</span><span>)</span> <span># 相当于__exit__()</span>

<span>with</span> foo<span>(</span><span>)</span> <span>as</span> f<span>:</span>
    <span>#raise Exception()</span>
    <span>print</span><span>(</span>f<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>f 接收 yield 语句的返回值。</p>
<p>上面的程序看似不错但是，增加一个异常试一试，发现不能保证 exit 的执行，怎么办？
增加 try finally。</p>
<div><pre><code><span>import</span> contextlib

<span>@contextlib<span>.</span>contextmanager</span>
<span>def</span> <span>foo</span><span>(</span><span>)</span><span>:</span> <span>#</span>
    <span>print</span><span>(</span><span>'enter'</span><span>)</span> <span># 相当于__enter__()</span>
    <span>try</span><span>:</span>
        <span>yield</span> <span># yield 5，yield的值只能有一个，相当于作为__enter__方法的返回值</span>
    <span>finally</span><span>:</span>
        <span>print</span><span>(</span><span>'exit'</span><span>)</span> <span># 相当于__exit__()</span>

<span>with</span> foo<span>(</span><span>)</span> <span>as</span> f<span>:</span>
    <span>raise</span> Exception<span>(</span><span>)</span>
    <span>print</span><span>(</span>f<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上例这么做有什么意义呢？
当 yield 发生处为生成器函数增加了上下文管理。这是为函数增加上下文机制的方式。</p>
<ul>
<li>把 yield 之前的当做<code>__enter__</code>方法执行</li>
<li>把 yield 之后的当做<code>__exit__</code>方法执行</li>
<li>把 yield 的值作为<code>__enter__</code>的返回值</li>
</ul>
<p>练习：为add函数计时</p>
<div><pre><code><span>import</span> contextlib
<span>import</span> datetime
<span>import</span> time

<span>@contextlib<span>.</span>contextmanager</span>
<span>def</span> <span>timeit</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'enter'</span><span>)</span>
    start <span>=</span> datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span>
    <span>try</span><span>:</span>
        <span>yield</span>
    <span>finally</span><span>:</span>
        <span>print</span><span>(</span><span>'exit'</span><span>)</span>
        delta <span>=</span> <span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span> <span>-</span> start<span>)</span><span>.</span>total_seconds<span>(</span><span>)</span>
        <span>print</span><span>(</span><span>'delta = {}'</span><span>.</span><span>format</span><span>(</span>delta<span>)</span><span>)</span>

<span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>return</span> x <span>+</span> y

<span>with</span> timeit<span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>add<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><strong>总结</strong></p>
<p>如果业务逻辑简单可以使用函数加 contextlib.contextmanager 装饰器方式，如果业务复杂，用类的方
式加 <code>__enter__</code> 和 <code>__exit__</code> 方法方便。</p>
<h2 id="反射概念"> 反射概念</h2>
<p>概述</p>
<p>运行时，runtime，区别于编译时，指的是程序被加载到内存中执行的时候。
反射，reflection，指的是运行时获取类型定义信息。
一个对象能够在运行时，像照镜子一样，反射出其类型信息。
简单说，在Python中，能够通过一个对象，找出其type、class、attribute 或 method 的能力，称为反射或者自省。
具有反射能力的函数有 type()、isinstance()、callable()、dir()、getattr() 等</p>
<table>
<thead>
<tr>
<th>内建函数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>getattr(object, name[, default])</td>
<td>通过name返回object的属性值。当属性不存在，将使用default返回，如果<br/>没有default，则抛出AttributeError。name必须为字符串</td>
</tr>
<tr>
<td>setattr(object, name, value)</td>
<td>object的属性存在，则覆盖，不存在，新增</td>
</tr>
<tr>
<td>hasattr(object, name)</td>
<td>判断对象是否有这个名字的属性，name必须为字符串</td>
</tr>
</tbody>
</table>
<div><pre><code><span>class</span> <span>Point</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>,</span> y<span>)</span><span>:</span>
        self<span>.</span>x <span>=</span> x
        self<span>.</span>y <span>=</span> y

p1 <span>=</span> Point<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
<span>print</span><span>(</span>p1<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>为上面 Point 类增加打印的方法</p>
<div><pre><code><span>class</span> <span>Point</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>,</span> y<span>)</span><span>:</span>
        self<span>.</span>x <span>=</span> x
        self<span>.</span>y <span>=</span> y

p1 <span>=</span> Point<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
<span>print</span><span>(</span>p1<span>)</span>
<span>print</span><span>(</span>p1<span>.</span>x<span>,</span> p1<span>.</span>y<span>)</span>
<span>print</span><span>(</span><span>getattr</span><span>(</span>p1<span>,</span> <span>'x'</span><span>)</span><span>,</span> <span>getattr</span><span>(</span>p1<span>,</span> <span>'y'</span><span>)</span><span>)</span>
<span>setattr</span><span>(</span>p1<span>,</span> <span>'x'</span><span>,</span> <span>10</span><span>)</span>
<span>setattr</span><span>(</span>Point<span>,</span> <span>'__str__'</span><span>,</span> <span>lambda</span> self<span>:</span> <span>"&lt;Point {},{}>"</span><span>.</span><span>format</span><span>(</span>self<span>.</span>x<span>,</span> self<span>.</span>y<span>)</span><span>)</span>
<span>print</span><span>(</span>p1<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>反射相关的魔术方法
<code>__getattr__()</code> 、 <code>__setattr__()</code> 、 <code>__delattr__()</code> 这三个魔术方法，分别测试这三个方法</p>
<h3 id="getattr"> <code>__getattr__()</code></h3>
<div><pre><code><span>class</span> <span>Point</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>,</span> y<span>)</span><span>:</span>
        self<span>.</span>x <span>=</span> x
        self<span>.</span>y <span>=</span> y

    <span>def</span> <span>__getattr__</span><span>(</span>self<span>,</span> item<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'getattr~~~'</span><span>)</span>
        <span>print</span><span>(</span>item<span>)</span>
        <span>return</span> <span>100</span>

p1 <span>=</span> Point<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
<span>print</span><span>(</span>p1<span>.</span>x<span>)</span>
<span>print</span><span>(</span>p1<span>.</span>y<span>)</span>
<span>print</span><span>(</span>p1<span>.</span>z<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>实例属性查找顺序为：</p>
<p><code>__instance.__dict__ --&gt; instance.__class__.__dict__ --&gt; 继承的祖先类（直到object）的__dict__ --&gt; 找不到 --&gt; 调用__getattr__()</code></p>
<h3 id="setattr"> <code>__setattr__()</code></h3>
<div><pre><code><span>class</span> <span>Point</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>,</span> y<span>)</span><span>:</span>
        self<span>.</span>x <span>=</span> x
        self<span>.</span>y <span>=</span> y

    <span>def</span> <span>__getattr__</span><span>(</span>self<span>,</span> item<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'getattr~~~'</span><span>)</span>
        <span>print</span><span>(</span>item<span>)</span>
        <span>return</span> <span>100</span>

    <span>def</span> <span>__setattr__</span><span>(</span>self<span>,</span> key<span>,</span> value<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'setattr~~~, {}={}'</span><span>.</span><span>format</span><span>(</span>key<span>,</span> value<span>)</span><span>)</span>

p1 <span>=</span> Point<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
<span>print</span><span>(</span>p1<span>.</span>x<span>)</span>
<span>print</span><span>(</span>p1<span>.</span>y<span>)</span>
<span>print</span><span>(</span>p1<span>.</span>__dict__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>p1 的实例字典里面什么都没有，而且访问x和y属性的时候竟然访问到了<code>__getattr__()</code>，为什么？</p>
<div><pre><code><span>class</span> <span>Point</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>,</span> y<span>)</span><span>:</span>
        self<span>.</span>x <span>=</span> x
        self<span>.</span>y <span>=</span> y

    <span>def</span> <span>__getattr__</span><span>(</span>self<span>,</span> item<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'getattr~~~'</span><span>)</span>
        <span>print</span><span>(</span>item<span>)</span>
        <span>return</span> <span>100</span>

    <span>def</span> <span>__setattr__</span><span>(</span>self<span>,</span> key<span>,</span> value<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'setattr~~~, {}={}'</span><span>.</span><span>format</span><span>(</span>key<span>,</span> value<span>)</span><span>)</span>
        self<span>.</span>__dict__<span>[</span>key<span>]</span> <span>=</span> value
        <span># setattr(self, key, value) # 对吗 不对，self会产生递归</span>

p1 <span>=</span> Point<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
<span>print</span><span>(</span>p1<span>.</span>x<span>)</span>
<span>print</span><span>(</span>p1<span>.</span>y<span>)</span>
<span>print</span><span>(</span>p1<span>.</span>__dict__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><code>__setattr__()</code> 方法，可以拦截对实例属性的增加、修改操作，如果要设置生效，需要自己操作实例
的 <code>__dict__</code> 。</p>
<h3 id="delattr"> <code>__delattr__()</code></h3>
<div><pre><code><span>class</span> <span>Point</span><span>:</span>
    Z <span>=</span> <span>100</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>,</span> y<span>)</span><span>:</span>
        self<span>.</span>x <span>=</span> x
        self<span>.</span>y <span>=</span> y

    <span>def</span> <span>__delattr__</span><span>(</span>self<span>,</span> item<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'delattr, {}'</span><span>.</span><span>format</span><span>(</span>item<span>)</span><span>)</span>

p1 <span>=</span> Point<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
<span>del</span> p1<span>.</span>x
<span>del</span> p1<span>.</span>y
<span>del</span> p1<span>.</span>Z
<span>print</span><span>(</span>p1<span>.</span>__dict__<span>)</span>
<span>print</span><span>(</span>Point<span>.</span>__dict__<span>)</span>
<span>del</span> Point<span>.</span>Z
<span>print</span><span>(</span>Point<span>.</span>__dict__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>通过实例删除属性，就会尝试调用该魔术方法。</p>
<h2 id="getattribute"> <code>__getattribute__</code></h2>
<div><pre><code><span>class</span> <span>Point</span><span>:</span>
    Z <span>=</span> <span>100</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>,</span> y<span>)</span><span>:</span>
        self<span>.</span>x <span>=</span> x
        self<span>.</span>y <span>=</span> y


p1 <span>=</span> Point<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
<span>print</span><span>(</span>p1<span>.</span>x<span>,</span> p1<span>.</span>y<span>)</span>
<span>print</span><span>(</span>Point<span>.</span>Z<span>,</span> p1<span>.</span>Z<span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

<span># 为Point类增加__getattribute__，观察变化</span>
<span>class</span> <span>Point</span><span>:</span>
    Z <span>=</span> <span>100</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>,</span> y<span>)</span><span>:</span>
        self<span>.</span>x <span>=</span> x
        self<span>.</span>y <span>=</span> y

    <span>def</span> <span>__getattribute__</span><span>(</span>self<span>,</span> item<span>)</span><span>:</span>
        <span>print</span><span>(</span>item<span>)</span>

p1 <span>=</span> Point<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
<span>print</span><span>(</span>p1<span>.</span>x<span>,</span> p1<span>.</span>y<span>)</span>
<span>print</span><span>(</span>Point<span>.</span>Z<span>,</span> p1<span>.</span>Z<span>)</span>
<span>print</span><span>(</span>p1<span>.</span>__dict__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>实例的所有的属性访问，第一个都会调用 <code>__getattribute__</code> 方法，它阻止了属性的查找，该方法应该返回（计算后的）值或者抛出一个 AttributeError 异常。</p>
<ul>
<li>它的return值将作为属性查找的结果。</li>
<li>如果抛出AttributeError异常，则会直接调用 <code>__getattr__</code>方法，因为表示属性没有找到。</li>
</ul>
<div><pre><code>
<span>class</span> <span>Point</span><span>:</span>
    Z <span>=</span> <span>100</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>,</span> y<span>)</span><span>:</span>
        self<span>.</span>x <span>=</span> x
        self<span>.</span>y <span>=</span> y

    <span>def</span> <span>__getattr__</span><span>(</span>self<span>,</span> item<span>)</span><span>:</span>
        <span>return</span> <span>'missing {}'</span><span>.</span><span>format</span><span>(</span>item<span>)</span>

    <span>def</span> <span>__getattribute__</span><span>(</span>self<span>,</span> item<span>)</span><span>:</span>
        <span># print(item)</span>
        <span># raise AttributeError('Not Found')</span>
        <span># return self.__dict__[item] # 不能用，会产生递归</span>
        <span># pass</span>
        <span># return object.__getattribute__(self, item)</span>
        <span>return</span> <span>super</span><span>(</span><span>)</span><span>.</span>__getattribute__<span>(</span>item<span>)</span>

p1 <span>=</span> Point<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
<span>print</span><span>(</span>p1<span>.</span>x<span>,</span> p1<span>.</span>y<span>)</span>
<span>print</span><span>(</span>Point<span>.</span>Z<span>,</span> p1<span>.</span>Z<span>)</span>
<span>print</span><span>(</span>p1<span>.</span>__dict__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><code>__getattribute__</code> 方法中为了避免在该方法中无限的递归，它的实现应该永远调用基类的同名方法以访问需要的任何属性，例如 <code>object.__getattribute__(self, name)</code>。</p>
<p>注意，除非你明确地知道 <code>__getattribute__</code> 方法用来做什么，否则不要使用它。</p>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>魔术方法</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__getattr__()</code></td>
<td>当通过搜索实例、实例的类及祖先类查不到属性，就会调用此方法</td>
</tr>
<tr>
<td><code>__setattr__()</code></td>
<td>通过 <code>.</code>访问实例属性，进行增加、修改都要调用它</td>
</tr>
<tr>
<td><code>__delattr__()</code></td>
<td>当通过实例来删除属性时调用此方法</td>
</tr>
<tr>
<td><code>__getattribute__()</code></td>
<td>实例所有的属性调用都从这个方法开始</td>
</tr>
</tbody>
</table>
<p>实例属性查找顺序：</p>
<p><code>实例调用__getattribute__() --&gt; instance.__dict__ --&gt; instance.__class__.__dict__ --&gt; 继承的祖先类（直到object）的__dict__ --&gt; 调用__getattr__()</code></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">10 继承多态和Mixin</title>
    <id>https://clay-wangzhi.com/code/python/python-oo-inher-pol/</id>
    <link href="https://clay-wangzhi.com/code/python/python-oo-inher-pol/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_10-继承多态和mixin"> 10 继承多态和Mixin</h1>
<h2 id="继承基本概念"> 继承基本概念</h2>
<p>面向对象三要素之一，继承 Inheritance</p>
<p>人类和猫类都继承自动物类。
个体继承自父母，继承了父母的一部分特征，但也可以有自己的个性。
在面向对象的世界中，从父类继承，就可以直接拥有父类的属性和方法，这样可减少代码冗余、多复用。子类也可以定义自己的属性和方法。</p>
<p>看一个不用继承的例子</p>
<div><pre><code><span>class</span> <span>Animal</span><span>:</span>
    <span>def</span> <span>shout</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Animal shouts'</span><span>)</span>

a <span>=</span> Animal<span>(</span><span>)</span>
a<span>.</span>shout<span>(</span><span>)</span>

<span>class</span> <span>Cat</span><span>:</span>
    <span>def</span> <span>shout</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Cat shouts'</span><span>)</span>

c <span>=</span> Cat<span>(</span><span>)</span>
c<span>.</span>shout<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面的2个类虽然有关系，但是定义时并没有建立这种关系，而是各自完成定义。
动物类和猫类都会叫，但是它们的叫法有区别，所以分别定义。</p>
<div><pre><code><span>class</span> <span>Animal</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>_name <span>=</span> name

    <span>def</span> <span>shout</span><span>(</span>self<span>)</span><span>:</span> <span># 一个通用的叫方法</span>
        <span>print</span><span>(</span><span>'{} shouts'</span><span>.</span><span>format</span><span>(</span>self<span>.</span>__class__<span>.</span>__name__<span>)</span><span>)</span>

    <span>@property</span>
    <span>def</span> <span>name</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>_name

a <span>=</span> Animal<span>(</span><span>'monster'</span><span>)</span>
a<span>.</span>shout<span>(</span><span>)</span>

<span>class</span> <span>Cat</span><span>(</span>Animal<span>)</span><span>:</span>
    <span>pass</span>

cat <span>=</span> Cat<span>(</span><span>'garfield'</span><span>)</span>
cat<span>.</span>shout<span>(</span><span>)</span>
<span>print</span><span>(</span>cat<span>.</span>name<span>)</span>

<span>class</span> <span>Dog</span><span>(</span>Animal<span>)</span><span>:</span>
    <span>pass</span>

dog <span>=</span> Dog<span>(</span><span>'ahuang'</span><span>)</span>
dog<span>.</span>shout<span>(</span><span>)</span>
<span>print</span><span>(</span>dog<span>.</span>name<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>上例可以看出，通过继承，猫类、狗类不用写代码，直接继承了父类的属性和方法。</p>
<p><strong>继承</strong>
class Cat(Animal) 这种形式就是从父类继承，括号中写上继承的类的列表。
继承可以让子类从父类获取特征（属性和方法）</p>
<p><strong>父类</strong>
Animal就是Cat的父类，也称为基类、超类。</p>
<p><strong>子类</strong>
Cat就是Animal的子类，也称为派生类。</p>
<h2 id="类继承的定义"> 类继承的定义</h2>
<p>格式如下</p>
<div><pre><code><span>class</span> 子类名<span>(</span>基类<span>1</span><span>[</span><span>,</span>基类<span>2</span><span>,</span><span>.</span><span>.</span><span>.</span><span>]</span><span>)</span><span>:</span>
	语句块
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果类定义时，没有基类列表，等同于继承自 object 。在 Python3 中，object 类是所有对象的根基类。</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
	<span>pass</span>
<span># 等价于</span>
<span>class</span> <span>A</span><span>(</span><span>object</span><span>)</span><span>:</span>
	<span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注意，上例在 Python2 中，两种写法是不同的。</p>
<p>Python 支持多继承，继承也可以多级。</p>
<p>查看继承的特殊属性和方法有</p>
<table>
<thead>
<tr>
<th>特殊属性和方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>_<em>bases</em>_</td>
<td>类的基类元组</td>
</tr>
<tr>
<td>_<em>base</em>_</td>
<td>类的基类元组的第一项</td>
</tr>
<tr>
<td>_<em>mro</em>_</td>
<td>显示方法查找顺序，基类的元组</td>
</tr>
<tr>
<td>mro()方法</td>
<td>同上，返回列表</td>
</tr>
<tr>
<td>_<em>subclasses</em>_()</td>
<td>类的子类列表</td>
</tr>
</tbody>
</table>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>pass</span>

<span>print</span><span>(</span>A<span>.</span>__base__<span>)</span>
<span>print</span><span>(</span>A<span>.</span>__bases__<span>)</span>
<span>print</span><span>(</span><span>)</span>
<span>print</span><span>(</span>A<span>.</span>mro<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span>A<span>.</span>__mro__<span>)</span>
<span>print</span><span>(</span><span>int</span><span>.</span>__subclasses__<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>bool</span><span>.</span>mro<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="python-不通版本的类"> Python 不通版本的类</h2>
<p>Python2.2之前类是没有共同的祖先的，之后，引入object类，它是所有类的共同祖先类 object。
Python2 中为了兼容，分为古典类（旧式类）和新式类。
Python3 中全部都是新式类。
新式类都是继承自 object的，新式类可以使用super。</p>
<div><pre><code><span># 以下代码在Python2.x中运行</span>
<span># 古典类（旧式类）</span>
<span>class</span> <span>A</span><span>:</span> <span>pass</span>
<span># 新式类</span>
<span>class</span> <span>B</span><span>(</span><span>object</span><span>)</span><span>:</span> <span>pass</span>
<span>print</span><span>(</span><span>dir</span><span>(</span>A<span>)</span><span>)</span>
<span>print</span><span>(</span><span>dir</span><span>(</span>B<span>)</span><span>)</span>
<span>print</span><span>(</span>A<span>.</span>__bases__<span>)</span>
<span>print</span><span>(</span>B<span>.</span>__bases__<span>)</span>
<span># 古典类</span>
a <span>=</span> A<span>(</span><span>)</span>
<span>print</span><span>(</span>a<span>.</span>__class__<span>)</span>
<span>print</span><span>(</span><span>type</span><span>(</span>a<span>)</span><span>)</span> <span># &lt;type 'instance'></span>
<span># 新式类</span>
b <span>=</span> B<span>(</span><span>)</span>
<span>print</span><span>(</span>b<span>.</span>__class__<span>)</span>
<span>print</span><span>(</span><span>type</span><span>(</span>b<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="继承中的访问控制"> 继承中的访问控制</h2>
<div><pre><code><span>class</span> <span>Animal</span><span>:</span>
    __a <span>=</span> <span>10</span>
    _b <span>=</span> <span>20</span>
    c <span>=</span> <span>30</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>__d <span>=</span> <span>40</span>
        self<span>.</span>_e <span>=</span> <span>50</span>
        self<span>.</span>f <span>=</span> <span>60</span>
        self<span>.</span>__a <span>+=</span> <span>1</span>

    <span>def</span> <span>showa</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span>self<span>.</span>__a<span>)</span>
        <span>print</span><span>(</span>self<span>.</span>__class__<span>.</span>__a<span>)</span>

    <span>def</span> <span>__showb</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span>self<span>.</span>_b<span>)</span>
        <span>print</span><span>(</span>self<span>.</span>__a<span>)</span>
        <span>print</span><span>(</span>self<span>.</span>__class__<span>.</span>__a<span>)</span>

<span>class</span> <span>Cat</span><span>(</span>Animal<span>)</span><span>:</span>
    __a <span>=</span> <span>100</span>
    _b <span>=</span> <span>200</span>

c <span>=</span> Cat<span>(</span><span>)</span>
c<span>.</span>showa<span>(</span><span>)</span> <span># 11 10</span>
c<span>.</span>_Animal__showb<span>(</span><span>)</span> <span># 200, 11, 10</span>
<span>print</span><span>(</span>c<span>.</span>c<span>)</span> <span># 30</span>
<span>print</span><span>(</span>c<span>.</span>_Animal__d<span>)</span> <span>#40</span>
<span>print</span><span>(</span>c<span>.</span>_e<span>,</span> c<span>.</span>f<span>,</span> c<span>.</span>_Animal__a<span>)</span> <span># 50,60,11</span>
<span>print</span><span>(</span>c<span>.</span>_Animal__a<span>,</span> c<span>.</span>_Cat__a<span>)</span> <span># 11 100</span>
<span>print</span><span>(</span>c<span>.</span>__dict__<span>)</span> <span>#</span>
<span>print</span><span>(</span>c<span>.</span>__class__<span>.</span>__dict__<span>.</span>keys<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>从父类继承，自己没有的，就可以到父类中找。</p>
<p>私有的都是不可以访问的，但是本质上依然是改了名称放在这个属性所在类或实例的__dict__中。</p>
<p>知道这个新名称就可以直接找到这个隐藏的变量，这是个黑魔法技巧，慎用。</p>
<p><strong>总结</strong>
继承时，公有成员，子类和实例都可以随意访问；私有成员被隐藏，子类和实例不可直接访问，但私有变量所在的类内的方法中可以访问这个私有变量。</p>
<p>Python通过自己一套实现，实现和其它语言一样的面向对象的继承机制。</p>
<p><strong>实例属性查找顺序</strong></p>
<p><code>实例的__dict__</code> → <code>类__dict__</code> →如果有继承→ <code>父类 __dict__</code>
如果搜索这些地方后没有找到就会抛异常，先找到就立即返回了。</p>
<h2 id="方法的重写、覆盖override"> 方法的重写、覆盖override</h2>
<div><pre><code><span>class</span> <span>Animal</span><span>:</span>
    <span>def</span> <span>shout</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Animal shouts'</span><span>)</span>

<span>class</span> <span>Cat</span><span>(</span>Animal<span>)</span><span>:</span>
    <span># 覆盖了父类方法</span>
    <span>def</span> <span>shout</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'miao'</span><span>)</span>

a <span>=</span> Animal<span>(</span><span>)</span>
a<span>.</span>shout<span>(</span><span>)</span>
c <span>=</span> Cat<span>(</span><span>)</span>
c<span>.</span>shout<span>(</span><span>)</span>
<span>print</span><span>(</span>a<span>.</span>__dict__<span>)</span>
<span>print</span><span>(</span>c<span>.</span>__dict__<span>)</span>
<span>print</span><span>(</span>Animal<span>.</span>__dict__<span>)</span>
<span>print</span><span>(</span>Cat<span>.</span>__dict__<span>)</span>
<span># Animal shouts</span>
<span># miao</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>Cat中能否覆盖自己的方法吗？
Cat中能否对父类方法做个增强，不需要完全重写？</p>
<div><pre><code><span>class</span> <span>Animal</span><span>:</span>
    <span>def</span> <span>shout</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Animal shout'</span><span>)</span>
        
<span>class</span> <span>Cat</span><span>(</span>Animal<span>)</span><span>:</span>
    <span># 覆盖了父类方法</span>
    <span>def</span> <span>shout</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'miao'</span><span>)</span>
    <span># 覆盖了自身的方法，显式调用了父类的方法</span>
    <span>def</span> <span>shout</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>super</span><span>(</span><span>)</span><span>)</span>
        <span>print</span><span>(</span><span>super</span><span>(</span>Cat<span>,</span> self<span>)</span><span>)</span>

        <span>super</span><span>(</span><span>)</span><span>.</span>shout<span>(</span><span>)</span>
        <span>super</span><span>(</span>Cat<span>,</span> self<span>)</span><span>.</span>shout<span>(</span><span>)</span> <span># 等价于super()</span>
        self<span>.</span>__class__<span>.</span>__base__<span>.</span>shout<span>(</span>self<span>)</span> <span># 不推荐</span>
a <span>=</span> Animal<span>(</span><span>)</span>
a<span>.</span>shout<span>(</span><span>)</span>
c <span>=</span> Cat<span>(</span><span>)</span>
c<span>.</span>shout<span>(</span><span>)</span>
<span>print</span><span>(</span>a<span>.</span>__dict__<span>)</span>
<span>print</span><span>(</span>c<span>.</span>__dict__<span>)</span>
<span>print</span><span>(</span>Animal<span>.</span>__dict__<span>)</span>
<span>print</span><span>(</span>Cat<span>.</span>__dict__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>super()可以访问到父类的类属性。
静态方法和类方法，是特殊的方法，也是类属性，所以访问方式一样。</p>
<h2 id="继承时使用初始化"> 继承时使用初始化</h2>
<p>先看下面一段代码，有没有问题</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> a<span>)</span><span>:</span>
        self<span>.</span>a <span>=</span> a

<span>class</span> <span>B</span><span>(</span>A<span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> b<span>,</span> c<span>)</span><span>:</span>
        self<span>.</span>b <span>=</span> b
        self<span>.</span>c <span>=</span> c
    <span>def</span> <span>printv</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span>self<span>.</span>b<span>)</span>
        <span>print</span><span>(</span>self<span>.</span>a<span>)</span> <span># 出错吗？ 出错，没定义</span>

f <span>=</span> B<span>(</span><span>200</span><span>,</span> <span>300</span><span>)</span>
<span>print</span><span>(</span>f<span>.</span>__class__<span>.</span>__bases__<span>)</span>
f<span>.</span>printv<span>(</span><span>)</span>
<span>print</span><span>(</span>f<span>.</span>__dict__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>上例代码可知：</p>
<p>如果类B定义时声明继承自类A，则在类B中<code>__bases__</code>中是可以看到类A。
但是这和是否调用类A的构造方法是两回事。</p>
<p>如果B中调用了父类A的构造方法，就可以拥有父类的属性了。如何理解这一句话呢？
观察B的实例 f 的<code>__dict__</code>中的属性。</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> a<span>,</span> d<span>=</span><span>10</span><span>)</span><span>:</span>
        self<span>.</span>a <span>=</span> a
        self<span>.</span>__d <span>=</span> d

<span>class</span> <span>B</span><span>(</span>A<span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> b<span>,</span> c<span>)</span><span>:</span>
        A<span>.</span>__init__<span>(</span>self<span>,</span> b <span>+</span> c<span>,</span> b <span>-</span> c<span>)</span>
        self<span>.</span>b <span>=</span> b
        self<span>.</span>c <span>=</span> c
    <span>def</span> <span>printv</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span>self<span>.</span>b<span>)</span>
        <span>print</span><span>(</span>self<span>.</span>a<span>)</span> <span># 出错吗？</span>

f <span>=</span> B<span>(</span><span>200</span><span>,</span> <span>300</span><span>)</span>
<span>print</span><span>(</span>f<span>.</span>__class__<span>.</span>__bases__<span>)</span>
f<span>.</span>printv<span>(</span><span>)</span>
<span>print</span><span>(</span>f<span>.</span>__dict__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>作为好的习惯，如果父类定义了<code>__init__</code>方法，你就该在子类的<code>__init__</code>中调用它。
那么，子类什么时候自动调用父类的<code>__init__</code>方法呢？
示例1</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>a1 <span>=</span> <span>'a1'</span>
        self<span>.</span>__a2 <span>=</span> <span>'a2'</span>
<span>print</span><span>(</span><span>'init in A'</span><span>)</span>
<span>class</span> <span>B</span><span>(</span>A<span>)</span><span>:</span>
    <span>pass</span>
b <span>=</span> B<span>(</span><span>)</span>
<span>print</span><span>(</span>b<span>.</span>__dict__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>B实例的初始化会自动调用基类A的<code>__init__</code>方法</p>
<p>示例2</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>a1 <span>=</span> <span>'a1'</span>
        self<span>.</span>__a2 <span>=</span> <span>'a2'</span>
		<span>print</span><span>(</span><span>'init in A'</span><span>)</span>
        
<span>class</span> <span>B</span><span>(</span>A<span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>b1 <span>=</span> <span>'b1'</span>
		<span>print</span><span>(</span><span>'init in B'</span><span>)</span>
        
b <span>=</span> B<span>(</span><span>)</span>
<span>print</span><span>(</span>b<span>.</span>__dict__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>B实例一旦定义了初始化<code>__init__</code>方法，就不会自动调用父类的初始化<code>__init__</code>方法，需要手动调用。</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>a1 <span>=</span> <span>'a1'</span>
        self<span>.</span>__a2 <span>=</span> <span>'a2'</span>
        <span>print</span><span>(</span><span>'init in A'</span><span>)</span>

<span>class</span> <span>B</span><span>(</span>A<span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        <span>#super().__init__()</span>
        <span>#super(B, self).__init__()</span>
        self<span>.</span>b1 <span>=</span> <span>'b1'</span>
        <span>print</span><span>(</span><span>'init in B'</span><span>)</span>
        A<span>.</span>__init__<span>(</span>self<span>)</span>
        
b <span>=</span> B<span>(</span><span>)</span>
<span>print</span><span>(</span>b<span>.</span>__dict__<span>)</span> <span># 注意__a2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong>总结</strong></p>
<ul>
<li>如果在子类中覆盖了父类的<code>__init__</code>方法，那么在子类的<code>__init__</code>方法中，应该显式调用父类的<code>__init__</code>方法</li>
<li>Python中并不限制在子类的<code>__init__</code>方法中调用父类的<code>__init__</code>方法的位置，但一般都应该尽早的调用</li>
<li>推荐使用 <code>super().__init__()</code>或<code>super(B, self).__init__()</code></li>
</ul>
<h2 id="单继承"> 单继承</h2>
<p>上面的例子中，类的继承列表中只有一个类，这种继承称为单一继承。</p>
<p>OCP 原则：多用“继承”、少修改</p>
<p>继承的用途：在子类上实现对基类的增强，实现多态</p>
<h2 id="多态"> 多态</h2>
<p>在面向对象中，父类、子类通过继承联系在一起，如果可以通过一套方法，就可以实现不同表现，就是多态。多态的前提：继承、覆盖</p>
<h2 id="多继承"> 多继承</h2>
<p>一个类继承自多个类就是多继承，它将具有多个类的特征。</p>
<h3 id="多继承弊端"> 多继承弊端</h3>
<p>多继承很好的模拟了世界，因为事物很少是单一继承，但是舍弃简单，必然引入复杂性，带来了冲突。</p>
<p>如同一个孩子继承了来自父母双方的特征。那么到底眼睛像爸爸还是妈妈呢？孩子究竟该像谁多一点呢？</p>
<p>多继承的实现会导致编译器设计的复杂度增加，所以有些高级编程语言舍弃了类的多继承。</p>
<p>C++支持多继承；Java舍弃了多继承。</p>
<p>Java中，一个类可以实现多个接口，一个接口也可以继承多个接口。Java的接口很纯粹，只是方法的声明，继承者必须实现这些方法，就具有了这些能力，就能干什么。</p>
<p>多继承可能会带来二义性，例如，猫和狗都继承自动物类，现在如果一个类多继承了猫和狗类，猫和狗都有shout方法，子类究竟继承谁的shout呢？</p>
<p>解决方案
实现多继承的语言，要解决二义性，深度优先或者广度优先。</p>
<h3 id="python多继承实现"> Python多继承实现</h3>
<div><pre><code><span>class</span> <span>className</span><span>(</span>基类<span>1</span>， 基类<span>2</span><span>[</span><span>,</span><span>.</span><span>.</span><span>.</span><span>]</span><span>)</span><span>:</span>
    类体
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/inher.png" alt="inher" /></p>
<p>左图是多继承（菱形继承），右图是单一继承</p>
<p>多继承带来路径选择问题，究竟继承哪个父类的特征呢</p>
<p>Python使用 MRO（method resolution order方法解析顺序）解决基类搜索顺序问题。</p>
<ul>
<li>历史原因，MRO有三个搜索算法：
<ul>
<li>经典算法，按照定义从左到右，深度优先策略。2.2版本之前
左图的MRO是MyClass,D,B,A,C,A</li>
<li>新式类算法，是经典算法的升级，深度优先，重复的只保留最后一个。2.2版本
左图的MRO是MyClass,D,B,C,A,object</li>
<li>C3算法，在类被创建出来的时候，就计算出一个MRO有序列表。2.3之后支持，Python3唯一支持的算法
左图中的MRO是MyClass,D,B,C,A,object的列表
C3算法解决多继承的二义性</li>
</ul>
</li>
</ul>
<p>经典算法有很大的问题，如果C中有方法覆盖了A的方法，也不会访问到C的方法，因为先访问A的（深度优先）。</p>
<p>新式类算法，依然采用了深度优先，解决了重复问题，但是同经典算法一样，没有解决继承的单调性。</p>
<p>C3算法，解决了继承的单调性，它阻止创建之前版本产生二义性的代码。求得的MRO 本质是为了线性化，且确定了顺序。</p>
<p>单调性：假设有A、B、C三个类，C的mro是[C, A, B]，那么C的子类的mro中，A、B的顺序一致就是单调的。</p>
<h3 id="多继承的缺点"> 多继承的缺点</h3>
<p>当类很多且继承复杂的情况下，继承路径太多，很难说清什么样的继承路径。</p>
<p>Python语法是允许多继承，但Python代码是解释执行，只有执行到的时候，才发现错误。
团队协作开发，如果引入多继承，那代码很有可能不可控。</p>
<p>不管编程语言是否支持多继承，都应当避免多继承。</p>
<p>Python的面向对象，我们看到的太灵活了，太开放了，所以要团队守规矩。</p>
<h2 id="mixin"> Mixin</h2>
<p>在Python的很多类的实现中，都可以看到一个Mixin的名字，这种类是什么呢？</p>
<p>类有下面的继承关系</p>
<p>文档Document类是其他所有文档类的抽象基类；
Word、Pdf类是Document的子类。</p>
<p>需求：为Document子类提供打印能力</p>
<p>思路：
1、在Document中提供print方法
假设已经有了下面3个类</p>
<div><pre><code><span>class</span> <span>Document</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> content<span>)</span><span>:</span>
        self<span>.</span>content <span>=</span> content
    <span>def</span> <span>print</span><span>(</span>self<span>)</span><span>:</span> <span># 抽象方法</span>
        <span>raise</span> NotImplementedError<span>(</span><span>)</span>
    
<span>class</span> <span>Word</span><span>(</span>Document<span>)</span><span>:</span> <span>pass</span> <span># 其他功能略去</span>
<span>class</span> <span>Pdf</span><span>(</span>Document<span>)</span><span>:</span> <span>pass</span> <span># 其他功能略去</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>基类提供的方法可以不具体实现，因为它未必适合子类的打印，子类中需要覆盖重写。</p>
<p>基类中只定义，不实现的方法，称为“抽象方法”。在Python中，如果采用这种方式定义的抽象方法，子类可以不实现，直到子类使用该方法的时候才报错。</p>
<p>print算是一种能力 —— 打印功能，不是所有的Document的子类都需要的，所有，从这个角度出发，上面的基类Document设计有点问题。</p>
<p>2、需要打印的子类上增加</p>
<p>如果在现有子类Word或Pdf上直接增加，虽然可以，却违反了OCP的原则，所以可以继承后增加打印功能。</p>
<div><pre><code><span>class</span> <span>Document</span><span>:</span> <span># 第三方库，不允许修改</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> content<span>)</span><span>:</span>
        self<span>.</span>content <span>=</span> content
<span>class</span> <span>Word</span><span>(</span>Document<span>)</span><span>:</span> <span>pass</span> <span># 第三方库，不允许修改</span>
<span>class</span> <span>Pdf</span><span>(</span>Document<span>)</span><span>:</span> <span>pass</span> <span># 第三方库，不允许修改</span>
<span># 单继承</span>
<span>class</span> <span>PrintableWord</span><span>(</span>Word<span>)</span><span>:</span>
    <span>def</span> <span>print</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span>self<span>.</span>content<span>)</span>

<span>print</span><span>(</span>PrintableWord<span>.</span>__dict__<span>)</span>
<span>print</span><span>(</span>PrintableWord<span>.</span>mro<span>(</span><span>)</span><span>)</span>
pw <span>=</span> PrintableWord<span>(</span><span>'test string'</span><span>)</span>
pw<span>.</span><span>print</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>看似不错，如果需要还要提供其他能力，如何继承？</p>
<p>例如，如果该类用于网络，还应具备序列化的能力，在类上就应该实现序列化。</p>
<p>可序列化还可能分为使用pickle、json、messagepack等。</p>
<p>这个时候发现，为了</p>
<p>增加一种能力，就要增加一次继承，类可能太多了，继承的方式不是很好了。</p>
<p>功能太多，A类需要某几样功能，B类需要另几样功能，它们需要的是多个功能的自由组合，继承实现很繁琐。</p>
<p>3、Mixin</p>
<p>先看代码</p>
<div><pre><code><span>class</span> <span>Document</span><span>:</span> <span># 第三方库，不允许修改</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> content<span>)</span><span>:</span>
        self<span>.</span>content <span>=</span> content
<span>class</span> <span>Word</span><span>(</span>Document<span>)</span><span>:</span> <span>pass</span> <span># 第三方库，不允许修改</span>
<span>class</span> <span>Pdf</span><span>(</span>Document<span>)</span><span>:</span> <span>pass</span> <span># 第三方库，不允许修改</span>
<span>class</span> <span>PrintableMixin</span><span>:</span>
    <span>def</span> <span>print</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span>self<span>.</span>content<span>,</span> <span>'Mixin'</span><span>)</span>
<span>class</span> <span>PrintableWord</span><span>(</span>PrintableMixin<span>,</span> Word<span>)</span><span>:</span> <span>pass</span>

<span>print</span><span>(</span>PrintableWord<span>.</span>__dict__<span>)</span>
<span>print</span><span>(</span>PrintableWord<span>.</span>mro<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>Mixin就是其它类混合进来，同时带来了类的属性和方法。</p>
<p><strong>Mixin类</strong></p>
<p>Mixin 本质上就是多继承实现的。</p>
<p>Mixin 体现的是一种组合的设计模式。</p>
<p>在面向对象的设计中，一个复杂的类，往往需要很多功能，而这些功能由来自不同的类提供，这就需要很多的类组合在一起。</p>
<p>从设计模式的角度来说，多组合，少继承。</p>
<p>Mixin 类的使用原则</p>
<ul>
<li>Mixin类中不应该显式的出现<code>__init__</code>初始化方法</li>
<li>Mixin 类通常不能独立工作，因为它是准备混入别的类中的部分功能实现</li>
<li>Mixin 类是类，也可以继承，其祖先类也应是 Mixin 类</li>
</ul>
<p>使用时，<strong>Mixin 类通常在继承列表的第一个位置</strong>，例如 <code>class PrintableWord(PrintableMixin, Word): pass</code></p>
<p>Mixin 类和装饰器，都可以实现对类的增强，这两种方式都可以使用，看个人喜好。</p>
<p>如果还需要继承就得使用 Mixin 类的方式。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">09 面向对象-封装</title>
    <id>https://clay-wangzhi.com/code/python/python-oo-package/</id>
    <link href="https://clay-wangzhi.com/code/python/python-oo-package/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_09-面向对象-封装"> 09 面向对象-封装</h1>
<h2 id="面向对象"> 面向对象</h2>
<p>什么是面向对象呢？</p>
<p>一种认识世界、分析世界的方法论。将万事万物抽象为各种对象。</p>
<p><strong>类 class</strong></p>
<p>类是抽象的概念，是万事万物的抽象，是一类事物的共同特征的集合。
用计算机语言来描述<strong>类</strong>，是<strong>属性</strong>和<strong>方法</strong>的集合。</p>
<p><strong>对象 instance、object</strong></p>
<p>对象是类的具象，是一个实体。
对于我们每个人这个个体，都是抽象概念人类的不同的实体。</p>
<p>举例：略</p>
<p><strong>属性</strong>：对对象状态的抽象，用数据结构来描述。</p>
<p><strong>操作</strong>：对对象行为的抽象，用操作名和实现该操作的方法来描述。</p>
<p>哲学</p>
<ul>
<li>一切皆对象</li>
<li>对象是数据和操作的封装</li>
<li>对象是对立的，但是对象之间可以相互作用</li>
<li>目前OOP是最接近人类认知的编程范式</li>
</ul>
<h2 id="面向对象3要素"> 面向对象3要素</h2>
<ol>
<li>封装
<ul>
<li>组装：将数据和操作组装到一起。</li>
<li>隐藏数据：对外只暴露一些接口，通过接口访问对象。</li>
</ul>
</li>
<li>集成
<ul>
<li>多复用，继承来的就不用自己写了</li>
<li>多继承少修改，OCP（Open-closed Principle），使用继承来改变，来体现个性</li>
</ul>
</li>
<li>多态
<ul>
<li>面向对象编程最灵活的地方，动态绑定</li>
</ul>
</li>
</ol>
<h2 id="封装"> 封装</h2>
<p>封装就是定义类，将属性和操作组织在类中</p>
<h3 id="python-类定义"> Python 类定义</h3>
<div><pre><code><span>class</span> <span>ClassName</span><span>:</span>
    语句块
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol>
<li>必须使用 class 关键字</li>
<li>类名强烈建议使用<strong>大驼峰</strong>命名方式，即每个单词首字母大写。其本质就是一个标识符</li>
<li>类定义完成后，就产生了一个<strong>类对象</strong>，绑定到了标识符 ClassName 上</li>
</ol>
<p>举例</p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>"""A Example Class"""</span>
    x <span>=</span> <span>'abc'</span> <span># 类属性</span>
    
    <span>def</span> <span>showme</span><span>(</span>self<span>)</span><span>:</span> <span># 方法，也是属性</span>
        <span>return</span> __class__<span>.</span>__name__ <span># 返回类的名称</span>
  
<span>print</span><span>(</span>Person<span>)</span>
<span>print</span><span>(</span>Person<span>.</span>__name__<span>)</span> <span># 类名字</span>
<span>print</span><span>(</span>Person<span>.</span>__doc__<span>)</span> <span># 类文档</span>
<span>print</span><span>(</span>Person<span>.</span>showme<span>)</span> <span># 类属性</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="类及类属性"> 类及类属性</h3>
<ul>
<li>类对象：类也是对象，类的定义执行后会生成一个类对象</li>
<li>类属性：类定义中的变量和类中定义的方法都是类的属性。上例中类 Person 的 x 和 showme</li>
<li>类变量：属性也是标识符，也是变量。上例中类 Person 的 x 和 showme</li>
</ul>
<p>Person 中， x、foo 都是类的属性，<code>__name__</code>、<code>__doc__</code>是类的特殊属性</p>
<p>showme 方法是类的属性，如果吃是人类的方法，但是每一个具体的人才能吃东西，也就是说吃是人的实例能调用的方法。</p>
<p>showme 是方法method，本质上就是普通的函数对象 function，它一般要求至少有一个参数。第一个形式参数可以是 self（self 只是个惯用标识符，可以换名字），这个参数位置就留给了 self。</p>
<p><strong>self 指代当前实例本身</strong></p>
<h2 id="实例化"> 实例化</h2>
<div><pre><code>a <span>=</span> Person<span>(</span><span>)</span> <span># 实例化</span>
</code></pre>
<div><span>1</span><br></div></div><p>使用上面的语法，在类对象名称后面加上一个括号，就调用类的实例化方法，完成实例化。
实例化就真正创建一个改类的对象（实例 instance）。例如</p>
<div><pre><code>tom <span>=</span> Person<span>(</span><span>)</span> <span># 不同的实例</span>
jerry <span>=</span> Person<span>(</span><span>)</span> <span># 不用的实例</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面的 tom、jerry 都是 Person 类的实例，通过实例化生成了2个不同的实例。</p>
<p>通常，每次实例化后获得的实例，是不同的实例，即使是使用同样的参数实例化，也得到不一样的对象。</p>
<p>Python 类实例化后，会自动调用<code>__init__</code>方法。这个方式第一个形式参数必须留给 self, 其他形式参数随意。</p>
<p><strong>构造的2个阶段</strong></p>
<p>确切地讲，<code>tom = Person()</code>过程分为2个阶段：实例化和初始化。</p>
<p><strong><code>__init__</code>方法</strong></p>
<p>有些人把 Python 的<code>__init__</code>方法称为构造方法或构造器。</p>
<p>Person() 实例化后，要初始化，要调用的是<code>__init__(self)</code>方法，可以不定义，如果没有定义会在实例化后<strong>隐式</strong>调用其父类的。</p>
<p>作用：对实例进行初始化</p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'init~~~~'</span><span>)</span>
     
<span>print</span><span>(</span>Person<span>)</span> <span># 不会调用__init__</span>
<span>print</span><span>(</span>Person<span>(</span><span>)</span><span>)</span> <span># 会调用__init__</span>
tom <span>=</span> Person<span>(</span><span>)</span> <span># 会调用__init__</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>初始化函数可以多个参数，请注意第一位置必须是 self， 例如<code>__init__(self, name, age)</code></p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'init~~~~'</span><span>)</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>age <span>=</span> age
    
    <span>def</span> <span>showage</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"{} is {}."</span><span>.</span><span>format</span><span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>age<span>)</span><span>)</span>
       
   
tom <span>=</span> Person<span>(</span><span>'Tom'</span><span>,</span> <span>20</span><span>)</span> 
<span>print</span><span>(</span>tom<span>.</span>name<span>,</span> tom<span>.</span>age<span>)</span>
tom<span>.</span>showage<span>(</span><span>)</span>
jerry <span>=</span> Person<span>(</span><span>'Jerry'</span><span>,</span> <span>18</span><span>)</span>
<span>print</span><span>(</span>jerry<span>.</span>name<span>,</span> jerry<span>.</span>age<span>)</span>
jerry<span>.</span>age <span>+=</span> <span>1</span>
<span>print</span><span>(</span>jerry<span>.</span>name<span>,</span> jerry<span>.</span>age<span>)</span>
jerry<span>.</span>showage<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><blockquote>
<p>注意： <code>__init__()</code>方法不能有返回值，也就是只能是 return None</p>
</blockquote>
<p><strong>实例对象 instance</strong></p>
<p>上例中，类 Person 实例化后获得一个该类的实例，就是实例对象</p>
<p><code>__init__</code>方法的第一参数 self 就是指代某一个实例自身。</p>
<p>执行<code>Person('Tom', 20)</code>时，调用<code>__init__()</code>方法。self.name 就是 tom 对象的 name，name 是保存在了 tom 对象上，而不是 Person 类上，称为 实例变量。</p>
<p>类实例化后，得到一个实例对象，调用方法时采用 tomc.showage() 的方式，但是 showage 方法的形参需要一个形参 self, 我们并没有提供，并没有报错，为什么？</p>
<p><strong>方法绑定</strong></p>
<p>采用 tom.showage() 的方式调用，实例对象会绑定到方法上。这个 self 就是 tom，指向 当前调用改方法的实例本身。</p>
<p>tom.showage() 调用时，会把方法的调用者 tom 实例作为第一参数 self 的实参输入<code>__init__()</code>方法。</p>
<p><strong>self</strong></p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>1</span><span>,</span> <span>'self in init = {}'</span><span>.</span><span>format</span><span>(</span><span>id</span><span>(</span>self<span>)</span><span>)</span><span>)</span>

    <span>def</span> <span>showme</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>2</span><span>,</span> <span>'self in showme = {}'</span><span>.</span><span>format</span><span>(</span><span>id</span><span>(</span>self<span>)</span><span>)</span><span>)</span>

tom <span>=</span> Person<span>(</span><span>)</span>
<span>print</span><span>(</span><span>3</span><span>,</span> <span>'tom = {}'</span><span>.</span><span>format</span><span>(</span><span>id</span><span>(</span>tom<span>)</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>
tom<span>.</span>showme<span>(</span><span>)</span>

<span># 打印结果为</span>
<span>1</span> self <span>in</span> init <span>=</span> <span>2921507816448</span>
<span>3</span> tom <span>=</span> <span>2921507816448</span>
<span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span>
<span>2</span> self <span>in</span> showme <span>=</span> <span>2921507816448</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上例说明，self 就是调用者， 就是 tom 对应的实例对象。</p>
<p>self 这个形参标识符的名字只是一个惯例，它可以修改，但是请不要修改，否则影响代码的可读性。</p>
<h3 id="实例变量和类变量"> 实例变量和类变量</h3>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    age <span>=</span> <span>3</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name

tom <span>=</span> Person<span>(</span><span>'tom'</span><span>)</span>
jerry <span>=</span> Person<span>(</span><span>'Jerry'</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>name<span>,</span> tom<span>.</span>age<span>)</span>
<span>print</span><span>(</span>jerry<span>.</span>name<span>,</span> jerry<span>.</span>age<span>)</span>
<span>print</span><span>(</span>Person<span>.</span>age<span>)</span>

Person<span>.</span>age <span>=</span> <span>30</span>
<span>print</span><span>(</span>Person<span>.</span>age<span>,</span> tom<span>.</span>age<span>,</span> jerry<span>.</span>age<span>)</span>

<span># 运行结果</span>
tom <span>3</span>
Jerry <span>3</span>
<span>3</span>
<span>30</span> <span>30</span> <span>30</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ul>
<li>实例变量是每一个实例自己的变量，是自己独有的</li>
<li>类变量是类的变量，是类的所有实例共享的属性或方法</li>
</ul>
<h3 id="特殊属性"> 特殊属性</h3>
<table>
<thead>
<tr>
<th>特殊属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__name__</code></td>
<td>对象名</td>
</tr>
<tr>
<td><code>__class__</code></td>
<td>对象的类型</td>
</tr>
<tr>
<td><code>__dict__</code></td>
<td>对象的属性的字典</td>
</tr>
<tr>
<td><code>__qualname__</code></td>
<td>类的限定名</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：Python中每一种对象都拥有不同的属性。函数是对象，类是对象，类的实例也是对象。</p>
</blockquote>
<h3 id="属性本质"> 属性本质</h3>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    age <span>=</span> <span>3</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name

<span>print</span><span>(</span><span>'----类----'</span><span>)</span>
<span>print</span><span>(</span>Person<span>.</span>__class__<span>,</span><span>type</span><span>(</span>Person<span>)</span><span>,</span> Person<span>.</span>__class__ <span>is</span> <span>type</span><span>(</span>Person<span>)</span><span>)</span> <span># 类型</span>
<span>print</span><span>(</span><span>sorted</span><span>(</span>Person<span>.</span>__dict__<span>.</span>items<span>(</span><span>)</span><span>)</span><span>,</span> end<span>=</span><span>'\n\n'</span><span>)</span> <span># 类字典</span>

tom <span>=</span> Person<span>(</span><span>'tom'</span><span>)</span>
<span>print</span><span>(</span><span>'----通过实例访问类----'</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>__class__<span>,</span> <span>type</span><span>(</span>tom<span>)</span><span>,</span> tom<span>.</span>__class__ <span>is</span> <span>type</span><span>(</span>tom<span>)</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>__class__<span>.</span>__name__<span>,</span> <span>type</span><span>(</span>tom<span>)</span><span>.</span>__name__<span>)</span>
<span>print</span><span>(</span><span>sorted</span><span>(</span>tom<span>.</span>__class__<span>.</span>__dict__<span>.</span>items<span>(</span><span>)</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>'----实例自己的属性----'</span><span>)</span>
<span>print</span><span>(</span><span>sorted</span><span>(</span>tom<span>.</span>__dict__<span>.</span>items<span>(</span><span>)</span><span>)</span><span>)</span>  <span># 实例的字典</span>

<span># 结果为</span>
<span>-</span><span>-</span><span>-</span><span>-</span>类<span>-</span><span>-</span><span>-</span><span>-</span>
<span>&lt;</span><span>class</span> <span>'type'</span><span>></span> <span>&lt;</span><span>class</span> <span>'type'</span><span>></span> <span>True</span>
<span>[</span><span>(</span><span>'__dict__'</span><span>,</span> <span>&lt;</span>attribute <span>'__dict__'</span> of <span>'Person'</span> objects<span>></span><span>)</span><span>,</span> <span>(</span><span>'__doc__'</span><span>,</span> <span>None</span><span>)</span><span>,</span> <span>(</span><span>'__init__'</span><span>,</span> <span>&lt;</span>function Person<span>.</span>__init__ at <span>0x000001E279A8BB80</span><span>></span><span>)</span><span>,</span> <span>(</span><span>'__module__'</span><span>,</span> <span>'__main__'</span><span>)</span><span>,</span> <span>(</span><span>'__weakref__'</span><span>,</span> <span>&lt;</span>attribute <span>'__weakref__'</span> of <span>'Person'</span> objects<span>></span><span>)</span><span>,</span> <span>(</span><span>'age'</span><span>,</span> <span>3</span><span>)</span><span>]</span>

<span>-</span><span>-</span><span>-</span><span>-</span>通过实例访问类<span>-</span><span>-</span><span>-</span><span>-</span>
<span>&lt;</span><span>class</span> <span>'__main__.Person'</span><span>></span> <span>&lt;</span><span>class</span> <span>'__main__.Person'</span><span>></span> <span>True</span>
Person Person
<span>[</span><span>(</span><span>'__dict__'</span><span>,</span> <span>&lt;</span>attribute <span>'__dict__'</span> of <span>'Person'</span> objects<span>></span><span>)</span><span>,</span> <span>(</span><span>'__doc__'</span><span>,</span> <span>None</span><span>)</span><span>,</span> <span>(</span><span>'__init__'</span><span>,</span> <span>&lt;</span>function Person<span>.</span>__init__ at <span>0x000001E279A8BB80</span><span>></span><span>)</span><span>,</span> <span>(</span><span>'__module__'</span><span>,</span> <span>'__main__'</span><span>)</span><span>,</span> <span>(</span><span>'__weakref__'</span><span>,</span> <span>&lt;</span>attribute <span>'__weakref__'</span> of <span>'Person'</span> objects<span>></span><span>)</span><span>,</span> <span>(</span><span>'age'</span><span>,</span> <span>3</span><span>)</span><span>]</span>
<span>-</span><span>-</span><span>-</span><span>-</span>实例自己的属性<span>-</span><span>-</span><span>-</span><span>-</span>
<span>[</span><span>(</span><span>'name'</span><span>,</span> <span>'tom'</span><span>)</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>上例中，可以看到类属性保存在类的<code>__dict__</code>中，实例属性保存在实例的<code>__dict__</code>中，如果从实例访问类的属性，也可以借助<code>__class__</code>找到所属的类，再通过类来访问类属性，例如<code>tom.__class__.age</code></p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    age <span>=</span> <span>3</span>
    height <span>=</span> <span>170</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>=</span><span>18</span><span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>age <span>=</span> age

tom <span>=</span> Person<span>(</span><span>'Tom'</span><span>)</span> <span># 实例化、初始化</span>
jerry <span>=</span> Person<span>(</span><span>'Jerry'</span><span>,</span> <span>20</span><span>)</span>

Person<span>.</span>age <span>=</span> <span>30</span>
<span>print</span><span>(</span><span>1</span><span>,</span> Person<span>.</span>age<span>,</span> tom<span>.</span>age<span>,</span> jerry<span>.</span>age<span>)</span> <span># 3, 18, 20</span>

<span>print</span><span>(</span><span>2</span><span>,</span> Person<span>.</span>height<span>,</span> tom<span>.</span>height<span>,</span> jerry<span>.</span>height<span>)</span> <span># 170, 170, 170</span>
jerry<span>.</span>height <span>=</span> <span>175</span>
<span>print</span><span>(</span><span>3</span><span>,</span> Person<span>.</span>height<span>,</span> tom<span>.</span>height<span>,</span> jerry<span>.</span>height<span>)</span> <span># 170, 170, 175</span>

tom<span>.</span>height <span>+=</span> <span>10</span>
<span>print</span><span>(</span><span>4</span><span>,</span> Person<span>.</span>height<span>,</span> tom<span>.</span>height<span>,</span> jerry<span>.</span>height<span>)</span> <span># 170, 180, 175</span>

Person<span>.</span>height <span>+=</span> <span>15</span>
<span>print</span><span>(</span><span>5</span><span>,</span> Person<span>.</span>height<span>,</span> tom<span>.</span>height<span>,</span> jerry<span>.</span>height<span>)</span> <span># 185, 180, 175</span>

Person<span>.</span>weight <span>=</span> <span>70</span>
<span>print</span><span>(</span><span>6</span><span>,</span> Person<span>.</span>weight<span>,</span> tom<span>.</span>weight<span>,</span> jerry<span>.</span>weight<span>)</span> <span># 70, 70, 70</span>

<span>print</span><span>(</span><span>7</span><span>,</span> tom<span>.</span>__dict__<span>[</span><span>'height'</span><span>]</span><span>)</span> <span># 180</span>
<span>print</span><span>(</span><span>8</span><span>,</span> tom<span>.</span>__dict__<span>[</span><span>'weight'</span><span>]</span><span>)</span> <span># error</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><strong>总结</strong></p>
<ul>
<li>是类的，也是这个类所有实例的，其 实例都可以访问到</li>
<li>是实例的，就是这个实例自己的，通过类访问不到</li>
<li>类变量是属于类的变量，这个类的所有实例可以共享这个变量</li>
</ul>
<p>对象（实例或类）可以动态的给自己增加一个属性（赋值即定义一个新属性）。这也是动态语言的特性。</p>
<p><code>实例.__dict__[变量名]</code>和<code>实例.变量</code>都可以访问到实例自己的属性（注意这两种访问是有本质区别的）</p>
<p>对实例访问来说，实例的同名变量会<strong>隐藏</strong>掉类变量，或者说是覆盖了这个类变量。但是注意类变量还在那里，并没有真正被覆盖。</p>
<p><strong>实例属性的查找顺序</strong></p>
<p>指的是实例使用<code>.点号</code>来访问属性，会先找自己的<code>__dict__</code>，如果没有，然后通过属性<code>__class__</code>找到自己的类，再去类的<code>__dict__</code>中找</p>
<blockquote>
<p>注意：如果实例使用<code>__dict__[变量名]</code>访问变量，将不会按照上面的查找顺序找变量了，这是指明使用字典的 key 查找，不是属性查找</p>
</blockquote>
<p>一般来说，<strong>类变量可使用全大写来命名</strong></p>
<h3 id="类方法和静态方法"> 类方法和静态方法</h3>
<p>前面的例子中定义的<code>__init__</code>等方法，这些方法本身都是类的属性，第一个参数必须是 self，而 self 必须指向一个对象，也就是类实例化之后，由实例来调用这个方法。</p>
<p><strong>普通函数</strong></p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>def</span> <span>normal_function</span><span>(</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'普通的函数'</span><span>)</span>

    <span>def</span> <span>method</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'方法'</span><span>)</span>

<span># 调用</span>
Person<span>.</span>normal_function<span>(</span><span>)</span> <span># 正常调用</span>
<span>print</span><span>(</span>Person<span>(</span><span>)</span><span>.</span>normal_function<span>)</span> <span># 可以， 没调用</span>
<span># print(Person().normal_function()) # 不可以，多传了一个参数</span>
<span>print</span><span>(</span>Person<span>.</span>__dict__<span>)</span> <span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>Person.normal_function()</p>
<p>可以放在类中定义，因为这个方法只是被 Person 这个类管理的一个普通的函数， normal_function 是 Person 的一个属性而已。</p>
<p>由于 normal_function 在定义的时候没有指定形参 self，不能用 Person().normal_method() 调用。
原因是，Person() 是实例，实例调用的时候，由于做了实例绑定，那么就需要 normal_method 的第一个形参来接受绑定的实例。</p>
<blockquote>
<p>注意：虽然语法是对的，但是，没人会这么用，也就是<strong>禁止</strong>这么写</p>
</blockquote>
<p><strong>类方法</strong></p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>@classmethod</span>
    <span>def</span> <span>class_method</span><span>(</span>cls<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'类方法'</span><span>)</span>
        <span>print</span><span>(</span><span>"{0}'s name = {0.__name__}"</span><span>.</span><span>format</span><span>(</span>cls<span>)</span><span>)</span>
        cls<span>.</span>HEIGHT <span>=</span> <span>170</span>

<span># 调用</span>
Person<span>.</span>class_method<span>(</span><span>)</span>
Person<span>(</span><span>)</span><span>.</span>class_method<span>(</span><span>)</span>
<span>print</span><span>(</span>Person<span>.</span>__dict__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>在类定义中，使用 @classmethod 装饰器修饰的方法</li>
<li>必须至少有一个参数，且第一个参数留给了 cls, cls 指代调用者即类对象自身</li>
<li>cls 这个标识符可以是任意合法名称，但是为了易读，请不要修改</li>
<li>通过 cls 可以直接操作类的属性</li>
</ul>
<p>通过类、实例都可以非常方便地调用类方法。 classmethod 装饰器 内存 将类或提取实例的 类 注入到类方法的第一个参数中。</p>
<blockquote>
<p>注意：无法通过 cls 操作类的实例</p>
</blockquote>
<p><strong>静态方法</strong></p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    HEIGHT <span>=</span> <span>180</span>

    <span>@staticmethod</span>
    <span>def</span> <span>static_method</span><span>(</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'静态方法'</span><span>)</span>
        <span>print</span><span>(</span>Person<span>.</span>HEIGHT<span>)</span>

<span># 调用</span>
Person<span>.</span>static_method<span>(</span><span>)</span>
Person<span>(</span><span>)</span><span>.</span>static_method<span>(</span><span>)</span>
<span>print</span><span>(</span>Person<span>.</span>__dict__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li>在类定义中，使用 @staticmethod 装饰器修饰的方法</li>
<li>调用时，不会隐式的传入参数</li>
</ul>
<p>通过类、实例都可以调用静态方法，不会像普通方式、类方法那样注入参数。</p>
<p>静态方法，只表明这个方法属于这个名词空间。函数归在一起，方便组织管理</p>
<p><strong>方法的调用</strong></p>
<p>类可以定义这么多种方法，究竟如何调用他们？</p>
<p>类几乎可以调用所有内部定义的方法，但是调用普通的方法时会报错，原因是第一参数应该是累的实例。</p>
<p>实例也几乎可以调用所有的方法，普通的函数 的调用一般不可能出现，因为原则上不允许这么定义。</p>
<p>总结：</p>
<ul>
<li>类除了普通方法都可以调用</li>
<li>普通方法需要对象的实例作为第一参数</li>
<li>实例可以调用所有类中定义的方法（包括类方法、静态方法），普通方法传入实例自身，静态方法和类方法内部都要使用实例的类</li>
</ul>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>def</span> <span>method</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"{}"</span><span>.</span><span>format</span><span>(</span>self<span>)</span><span>)</span>
        <span>print</span><span>(</span><span>"{}"</span><span>.</span><span>format</span><span>(</span>__class__<span>)</span><span>)</span>
        <span>print</span><span>(</span><span>"{}"</span><span>.</span><span>format</span><span>(</span>__class__<span>.</span>__name__<span>)</span><span>)</span>
        <span>print</span><span>(</span><span>"{}"</span><span>.</span><span>format</span><span>(</span>__name__<span>)</span><span>)</span>

tom <span>=</span> Person<span>(</span><span>)</span>
tom<span>.</span>method<span>(</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>
Person<span>.</span>method<span>(</span><span>1</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

Person<span>.</span>method<span>(</span>tom<span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

tom<span>.</span>__class__<span>.</span>method<span>(</span>tom<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>tom.method() 调用的时候，会绑定实例，调用 method 方法是，实例 tom 会注入到 method 中，这样第一参数就满足了。</p>
<p>Person.method() ，使用类调用，不会有实例绑定，调用 method 方法时，就缺少了第一参数，可以手动的填入。</p>
<h3 id="访问控制"> 访问控制</h3>
<p><strong>私有（Private） 成员</strong></p>
<p>在 Python 中，在类变量或实例变量前使用两个下划线的变量，称为私有成员，包括私有属性、私有方法。</p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>=</span><span>18</span><span>)</span><span>:</span>
        self<span>.</span>a <span>=</span> <span>'1'</span>
        self<span>.</span>__name <span>=</span> name
        self<span>.</span>__age <span>=</span> age

    <span>def</span> <span>__showage</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span>self<span>.</span>__age<span>)</span>

<span>print</span><span>(</span>Person<span>.</span>__name<span>)</span>  <span># 都不可以调用</span>
<span>print</span><span>(</span>Person<span>.</span>__showage<span>)</span>
tom <span>=</span> Person<span>(</span><span>'tom'</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>__name<span>)</span>
<span>print</span><span>(</span>tom<span>.</span>__showage<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>在类的定义范围内，使用前置双下划线的标识符，在类外部不能直接访问。</p>
<p><strong>私有成员本质</strong></p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>=</span><span>18</span><span>)</span><span>:</span>
        self<span>.</span>__name <span>=</span> name
        self<span>.</span>__age <span>=</span> age

    <span>def</span> <span>__showage</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span>self<span>.</span>__age<span>)</span>

<span>print</span><span>(</span>Person<span>.</span>__dict__<span>)</span>
tom <span>=</span> Person<span>(</span><span>'tom'</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>__dict__<span>)</span>
<span># 结果如下</span>
<span>{</span><span>'__module__'</span><span>:</span> <span>'__main__'</span><span>,</span> <span>'__init__'</span><span>:</span> <span>&lt;</span>function Person<span>.</span>__init__ at <span>0x0000029B2B86BB80</span><span>></span><span>,</span> <span>'_Person__showage'</span><span>:</span> <span>&lt;</span>function Person<span>.</span>__showage at <span>0x0000029B2B86BC10</span><span>></span><span>,</span> <span>'__dict__'</span><span>:</span> <span>&lt;</span>attribute <span>'__dict__'</span> of <span>'Person'</span> objects<span>></span><span>,</span> <span>'__weakref__'</span><span>:</span> <span>&lt;</span>attribute <span>'__weakref__'</span> of <span>'Person'</span> objects<span>></span><span>,</span> <span>'__doc__'</span><span>:</span> <span>None</span><span>}</span>
<span>{</span><span>'_Person__name'</span><span>:</span> <span>'tom'</span><span>,</span> <span>'_Person__age'</span><span>:</span> <span>18</span><span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>打开类字典和实例字典，一目了然，都被悄悄的改了名称，所以使用定义的名字就访问不了了。</p>
<p>名称都被前置了<code>_类名</code>前缀。</p>
<p>如果知道了改后的名称，照样可以访问，就绕过了Python做的限制。</p>
<blockquote>
<p>Python就没有真正的私有成员！但是请遵守这个约定，不要在类外面访问类私有或者实例的私有成员。因为类的作用就是封装，私有成员就是要被隐藏的数据或方法。</p>
</blockquote>
<p><strong>保护成员</strong></p>
<p>在类变量或实例变量前使用一个下划线的变量，称为保护成员。</p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>=</span><span>18</span><span>)</span><span>:</span>
        self<span>.</span>_name <span>=</span> name
        self<span>.</span>_age <span>=</span> age

    <span>def</span> <span>_showage</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span>self<span>.</span>_age<span>)</span>

<span>print</span><span>(</span>Person<span>.</span>__dict__<span>)</span>
tom <span>=</span> Person<span>(</span><span>'Tom'</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>__dict__<span>)</span>
tom<span>.</span>_showage<span>(</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>_name<span>,</span> tom<span>.</span>_age<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>保护成员不是 Python 中定义的，是 Python 编程者自我约定俗称的，请遵守这个约定。</p>
<p><strong>总结</strong></p>
<p>在 Python 中使用 _单下划线或者__双下划线来表示一个成员被保护或者私有化隐藏起来。</p>
<p>但是，不管使用什么样的访问控制，都不能真正的阻止用户修改类的成员。Python 中没有绝对的安全的保护成员或者私有成员。</p>
<p>因此，前导的下划线只是一种警告或者提醒，请遵守这个约定。</p>
<p>在 Pycharm 中，已经对访问私有、保护成员访问的时候不会直接提示，就是一种善意的提醒。</p>
<h3 id="属性装饰器"> 属性装饰器</h3>
<p>一般好的设计是：把实例的某些属性保护起来，不让外部直接访问，外部使用 getter 读取属性和 setter 方法设置属性。</p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>_name <span>=</span> name

    <span>def</span> <span>name</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>_name

    <span>def</span> <span>set_name</span><span>(</span>self<span>,</span>value<span>)</span><span>:</span>
        self<span>.</span>_name <span>=</span> value

tom <span>=</span> Person<span>(</span><span>'Tom'</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>name<span>(</span><span>)</span><span>)</span>
tom<span>.</span>set_name<span>(</span><span>'Jerry'</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>name<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>Python 提供了 property 装饰器，简化调用。</p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>_name <span>=</span> name

    <span>@property</span>
    <span>def</span> <span>name</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>_name

    <span>@name<span>.</span>setter</span>
    <span>def</span> <span>name</span><span>(</span>self<span>,</span>value<span>)</span><span>:</span>
        self<span>.</span>_name <span>=</span> value

    <span>@name<span>.</span>deleter</span>
    <span>def</span> <span>name</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'del name'</span><span>)</span>

tom <span>=</span> Person<span>(</span><span>'Tom'</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>name<span>)</span>
tom<span>.</span>name <span>=</span> <span>'Jerry'</span>
<span>print</span><span>(</span>tom<span>.</span>name<span>)</span>
<span>del</span> tom<span>.</span>name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>特别注意：使用 property 装饰器的时候这三个方法同名</p>
<p>property 装饰器</p>
<ul>
<li>后面跟的函数名就是以后的属性名。它就是getter。这个必须有，有了它至少是只读属性</li>
<li>setter 装饰器
<ul>
<li>与属性名同名，且接收2个参数，第一个是 self， 第二个是将要赋值的值。有了它，属性可写</li>
</ul>
</li>
<li>deleter 装饰器
<ul>
<li>可以控制是否删除属性。很少用</li>
</ul>
</li>
<li>property 装饰器必须在前，setter、deleter 装饰器在后</li>
<li>property 装饰器能通过简单的方式，把对方法的操作编程对属性的访问，并起到了一定隐藏效果</li>
</ul>
<p>其他方法</p>
<div><pre><code><span>class</span> <span>Person</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>_name <span>=</span> name

    <span>def</span> <span>get_name</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>_name

    <span>def</span> <span>set_name</span><span>(</span>self<span>,</span> value<span>)</span><span>:</span>
        self<span>.</span>_name <span>=</span> value

    <span>def</span> <span>del_name</span><span>(</span>self<span>)</span><span>:</span>
        <span># del self._name</span>
        <span>print</span><span>(</span><span>'del name'</span><span>)</span>

    name <span>=</span> <span>property</span><span>(</span>get_name<span>,</span> set_name<span>,</span> del_name<span>)</span>

tom <span>=</span> Person<span>(</span><span>'Tom'</span><span>)</span>
<span>print</span><span>(</span>tom<span>.</span>name<span>)</span>
tom<span>.</span>name <span>=</span> <span>'Jerry'</span>
<span>print</span><span>(</span>tom<span>.</span>name<span>)</span>
<span>del</span> tom<span>.</span>name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>这种定义方式，适合 get_name、set_name、del_name 还可以单独使用，即可以当方法使用。</p>
<h3 id="封装总结"> 封装总结</h3>
<p>面向对象的三要素之一，封装 Encapsulation</p>
<p>封装</p>
<ul>
<li>将数据和操作组织到类中，即属性和方法</li>
<li>将数据隐藏起来，给使用者提供操作（方法）。使用者通过操作就可以获取或者修改数据。getter 和 setter</li>
<li>通过访问控制，暴露适当的数据和操作给用户，该隐藏的隐藏起来，例如保护成员和私有成员。</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">07 序列化和反序列化</title>
    <id>https://clay-wangzhi.com/code/python/python-serialize/</id>
    <link href="https://clay-wangzhi.com/code/python/python-serialize/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_07-序列化和反序列化"> 07 序列化和反序列化</h1>
<h2 id="csv"> csv</h2>
<h3 id="csv-文件简介"> csv 文件简介</h3>
<p>参看 RFC 4180
http://www.ietf.org/rfc/rfc4180.txt</p>
<p>逗号分隔值Comma-Separated Values。
CSV 是一个被行分隔符、列分隔符划分成行和列的文本文件。
CSV 不指定字符编码。</p>
<p>行分隔符为\r\n，最后一行可以没有换行符
列分隔符常为逗号或者制表符。
每一行称为一条记录record</p>
<p>字段可以使用双引号括起来，也可以不使用。如果字段中出现了双引号、逗号、换行符必须使用双引号
括起来。如果字段的值是双引号，使用两个双引号表示一个转义。</p>
<p>表头可选，和字段列对齐就行了。</p>
<h3 id="csv-模块"> csv 模块</h3>
<p><code>reader(csvfile, dialect='excel', **fmtparams)</code>
返回reader对象，是一个行<strong>迭代器</strong>。</p>
<p>默认使用excel方言，如下：</p>
<ul>
<li>delimiter 列分隔符,逗号</li>
<li>lineterminator 行分隔符\r\n</li>
<li>quotechar 字段的引用符号，缺省为 &quot; 双引号</li>
<li>双引号的处理
<ul>
<li>doublequote 双引号的处理，默认为True。如果碰到数据中有双引号，而quotechar也是双引号，True则使用2个双引号表示，False表示使用转义字符将作为双引号的前缀</li>
<li>escapechar 一个转义字符，默认为None</li>
<li>writer = csv.writer(f, doublequote=False, escapechar='@') 遇到双引号，则必须提供转义字符</li>
</ul>
</li>
<li>quoting 指定双引号的规则
<ul>
<li>QUOTE_ALL 所有字段</li>
<li>QUOTE_MINIMAL特殊字符字段，Excel方言使用该规则</li>
<li>QUOTE_NONNUMERIC非数字字段</li>
<li>QUOTE_NONE都不使用引号。</li>
</ul>
</li>
</ul>
<p><code>writer(csvfile, dialect='excel', **fmtparams)</code>
返回DictWriter的实例。
主要方法有writerow、writerows。</p>
<p><code>writerow(iterable)</code></p>
<div><pre><code><span>import</span> csv
rows <span>=</span> <span>[</span>
    <span>(</span><span>'id'</span><span>,</span> <span>'name'</span><span>,</span> <span>'age'</span><span>,</span> <span>'comment'</span><span>)</span><span>,</span>
    <span>[</span><span>1</span><span>,</span> <span>'tom'</span><span>,</span> <span>20</span><span>,</span> <span>'tom'</span><span>]</span><span>,</span>
    <span>(</span><span>2</span><span>,</span> <span>'jerry'</span><span>,</span> <span>18</span><span>,</span> <span>'jerry'</span><span>)</span><span>,</span>
    <span>(</span><span>3</span><span>,</span> <span>'justin'</span><span>,</span> <span>22</span><span>,</span> <span>'just\t"in'</span><span>)</span><span>,</span>
    <span>"abcdefgh"</span><span>,</span>
    <span>(</span><span>(</span><span>1</span><span>,</span><span>)</span><span>,</span> <span>2</span><span>,</span> <span>[</span><span>3</span><span>]</span><span>)</span>
<span>]</span>

<span># newline=''，表示写入时，不要做\n的替换，那么输出就是\r\n</span>
<span>with</span> <span>open</span><span>(</span><span>'o:/test.csv'</span><span>,</span> <span>'w+'</span><span>,</span> encoding<span>=</span><span>'utf-8'</span><span>,</span> newline<span>=</span><span>''</span><span>)</span> <span>as</span> f<span>:</span>
    writer <span>=</span> csv<span>.</span>writer<span>(</span>f<span>)</span>
    writer<span>.</span>writerow<span>(</span>rows<span>[</span><span>0</span><span>]</span><span>)</span>
    writer<span>.</span>writerows<span>(</span>rows<span>[</span><span>1</span><span>:</span><span>]</span><span>)</span>
    
<span># newline=''，表示读取时，也不做\n的替换</span>
<span>with</span> <span>open</span><span>(</span><span>'o:/test.csv'</span><span>,</span> encoding<span>=</span><span>'utf-8'</span><span>,</span> newline<span>=</span><span>''</span><span>)</span> <span>as</span> f<span>:</span>
    reader <span>=</span> csv<span>.</span>reader<span>(</span>f<span>)</span> <span># 行迭代器</span>
    <span>print</span><span>(</span><span>next</span><span>(</span>reader<span>)</span><span>)</span>
    <span>print</span><span>(</span><span>next</span><span>(</span>reader<span>)</span><span>)</span>
    <span>for</span> line <span>in</span> reader<span>:</span>
        <span>print</span><span>(</span>line<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="ini-文件处理"> ini 文件处理</h2>
<p>略</p>
<h2 id="序列化和反序列化"> 序列化和反序列化</h2>
<h3 id="为什么要序列化"> 为什么要序列化</h3>
<p>内存中的字典、列表、集合以及各种对象，如何保存到一个文件中？</p>
<p>如果是自己定义的类的实例，如何保存到一个文件中？</p>
<p>如何从文件中读取数据，并让它们在内存中再次恢复成自己对应的类的实例？</p>
<p>要设计一套协议，按照某种规则，把内存中数据保存到文件中。文件是一个字节序列，所以必须把数据转换成字节序列，输出到文件。这就是序列化。</p>
<p>反之，从文件的字节序列恢复到内存并且还是原来的类型，就是反序列化。</p>
<h3 id="定义"> 定义</h3>
<p>serialization 序列化
将内存中对象存储下来，把它变成一个个字节。-&gt; 二进制</p>
<p>deserialization 反序列化
将文件的一个个字节恢复成内存中对象。&lt;- 二进制</p>
<p>序列化保存到文件就是持久化。
可以将数据序列化后持久化，或者网络传输；也可以将从文件中或者网络接收到的字节序列反序列化。</p>
<p>Python 提供了pickle 库。</p>
<h3 id="pickle"> pickle</h3>
<p>Python中的序列化、反序列化模块。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>dumps</td>
<td>对象序列化为bytes对象</td>
</tr>
<tr>
<td>dump</td>
<td>对象序列化到文件对象，就是存入文件</td>
</tr>
<tr>
<td>loads</td>
<td>从bytes对象反序列化</td>
</tr>
<tr>
<td>load</td>
<td>对象反序列化，从文件读取数据</td>
</tr>
</tbody>
</table>
<div><pre><code><span>import</span> pickle

filename <span>=</span> <span>'o:/ser'</span>

<span># 序列化后看到什么</span>
i <span>=</span> <span>99</span>
c <span>=</span> <span>'c'</span>
l <span>=</span> <span>list</span><span>(</span><span>'123'</span><span>)</span>
d <span>=</span> <span>{</span><span>'a'</span><span>:</span><span>127</span><span>,</span> <span>'b'</span><span>:</span><span>'abc'</span><span>,</span> <span>'c'</span><span>:</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span><span>}</span>

<span># 序列化</span>
<span>with</span> <span>open</span><span>(</span>filename<span>,</span> <span>'wb'</span><span>)</span> <span>as</span> f<span>:</span>
    pickle<span>.</span>dump<span>(</span>i<span>,</span> f<span>)</span>
    pickle<span>.</span>dump<span>(</span>c<span>,</span> f<span>)</span>
    pickle<span>.</span>dump<span>(</span>l<span>,</span> f<span>)</span>
    pickle<span>.</span>dump<span>(</span>d<span>,</span> f<span>)</span>

<span># 反序列化</span>
<span>with</span> <span>open</span><span>(</span>filename<span>,</span> <span>'rb'</span><span>)</span> <span>as</span> f<span>:</span>
    <span>print</span><span>(</span>f<span>.</span>read<span>(</span><span>)</span><span>,</span> f<span>.</span>seek<span>(</span><span>0</span><span>)</span><span>)</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>4</span><span>)</span><span>:</span>
        x <span>=</span> pickle<span>.</span>load<span>(</span>f<span>)</span>
        <span>print</span><span>(</span>x<span>,</span> <span>type</span><span>(</span>x<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="序列化应用"> 序列化应用</h3>
<p>一般来说，本地序列化的情况，应用较少。大多数场景都应用在网络传输中。
将数据序列化后通过网络传输到远程节点，远程服务器上的服务将接收到的数据反序列化后，就可以使用了。
但是，要注意一点，远程接收端，反序列化时必须有对应的数据类型，否则就会报错。尤其是自定义
类，必须远程得有一致的定义。</p>
<p>现在，大多数项目，都不是单机的，也不是单服务的，需要多个程序之间配合。需要通过网络将数据传送到其他节点上去，这就需要大量的序列化、反序列化过程。</p>
<p>但是，问题是，Python程序之间可以都用pickle解决序列化、反序列化，如果是跨平台、跨语言、跨协议pickle就不太适合了，就需要公共的协议。例如XML、Json、Protocol Buffer、msgpack等。</p>
<p>不同的协议，效率不同、学习曲线不同，适用不同场景，要根据不同的情况分析选型。</p>
<h2 id="json"> Json</h2>
<p>SON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript
1999年ES3 的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。
http://json.org/
https://www.json.org/json-zh.html</p>
<h3 id="json的数据类型"> Json的数据类型</h3>
<p><strong>值</strong></p>
<p>双引号引起来的字符串、数值、true和false、null、对象、数组，这些都是值</p>
<p><strong>字符串</strong></p>
<p>由双引号包围起来的任意字符的组合，可以有转义字符。</p>
<p><strong>数值</strong>
有正负，有整数、浮点数。</p>
<p><strong>对象</strong>
无序的键值对的集合
格式: {key1:value1, ... ,keyn:valulen}
key必须是一个字符串，需要双引号包围这个字符串。
value可以是任意合法的值。</p>
<p><strong>数组</strong></p>
<p>有序的值的集合
格式：[val1,...,valn]</p>
<p>实例</p>
<div><pre><code>{
  &quot;person&quot;: [
    {
      &quot;name&quot;: &quot;tom&quot;,
      &quot;age&quot;: 18
    },
    {
      &quot;name&quot;: &quot;jerry&quot;,
      &quot;age&quot;: 16
    }
  ],
  &quot;total&quot;: 2
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="json-模块"> json 模块</h3>
<p><strong>python 与json</strong></p>
<p>Python支持少量内建数据类型到Json类型的转换。</p>
<table>
<thead>
<tr>
<th>Python 类型</th>
<th>Json 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>True</td>
<td>true</td>
</tr>
<tr>
<td>False</td>
<td>false</td>
</tr>
<tr>
<td>None</td>
<td>null</td>
</tr>
<tr>
<td>str</td>
<td>string</td>
</tr>
<tr>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>list</td>
<td>array</td>
</tr>
<tr>
<td>dict</td>
<td>object</td>
</tr>
</tbody>
</table>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>Python 类型</th>
<th>Json 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>dumps</td>
<td>json 编码</td>
</tr>
<tr>
<td>dump</td>
<td>json 编码并存入文件</td>
</tr>
<tr>
<td>loads</td>
<td>json 解码</td>
</tr>
<tr>
<td>load</td>
<td>json 解码，从文件读取数据</td>
</tr>
</tbody>
</table>
<div><pre><code><span>import</span> json

d <span>=</span> <span>{</span><span>'name'</span><span>:</span><span>'Tom'</span><span>,</span> <span>'age'</span><span>:</span><span>20</span><span>,</span> <span>'interest'</span><span>:</span><span>(</span><span>'music'</span><span>,</span> <span>'movie'</span><span>)</span><span>,</span> <span>'class'</span><span>:</span><span>[</span><span>'python'</span><span>]</span><span>}</span>
j <span>=</span> json<span>.</span>dumps<span>(</span>d<span>)</span>
<span>print</span><span>(</span>j<span>,</span> <span>type</span><span>(</span>j<span>)</span><span>)</span> <span># 请注意引号、括号的变化，注意数据类型的变化</span>

d1 <span>=</span> json<span>.</span>loads<span>(</span>j<span>)</span>
<span>print</span><span>(</span>d1<span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>d<span>)</span><span>,</span> <span>id</span><span>(</span>d1<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>一般 json 编码的数据很少落地，数据都是通过网络传输。传输的时候，要考虑压缩它。</p>
<p>本质上来说它就是个文本，就是个字符串。</p>
<p>json 很简单，几乎编程语言都支持 json，所以应用范围十分广泛。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">16 SocketServer</title>
    <id>https://clay-wangzhi.com/code/python/python-socketserver/</id>
    <link href="https://clay-wangzhi.com/code/python/python-socketserver/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_16-socketserver"> 16 SocketServer</h1>
<p>socket 编程过于底层，编程虽然有套路，但是想要写出健壮的代码还是比较困难的，所以很多语言都对 socket 底层 API 进行封装，Python 的封装就是 socketserver 模块。它是网络服务编程框架，便于企业级快速开发。</p>
<h2 id="类的继承关系"> 类的继承关系</h2>
<div><pre><code>+------------+
| BaseServer |
+------------+
      |
      v
+-----------+        +------------------+
| TCPServer |-------&gt;| UnixStreamServer |
+-----------+        +------------------+
      |
      v
+-----------+        +--------------------+
| UDPServer |-------&gt;| UnixDatagramServer |
+-----------+        +--------------------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>SocketServer简化了网络服务器的编写。</p>
<p>它有4个同步类：</p>
<ul>
<li>TCPServer</li>
<li>UDPServer</li>
<li>UnixStreamServer</li>
<li>UnixDatagramServer。</li>
</ul>
<p>2个 Mixin 类：ForkingMixIn 和 ThreadingMixIn 类，用来支持异步。由此得到</p>
<ul>
<li>class ForkingUDPServer(ForkingMixIn, UDPServer): pass</li>
<li>class ForkingTCPServer(ForkingMixIn, TCPServer): pass</li>
<li>class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass</li>
<li>class ThreadingTCPServer(ThreadingMixIn, TCPServer): pass</li>
</ul>
<p>fork是创建多进程，thread是创建多线程。
fork需要操作系统支持，Windows不支持。</p>
<h2 id="编程接口"> 编程接口</h2>
<div><pre><code>socketserver.BaseServer(server_address, RequestHandlerClass)
</code></pre>
<div><span>1</span><br></div></div><p>需要提供服务器绑定的地址信息，和用于处理请求的 RequestHandlerClass 类。</p>
<p>RequestHandlerClass 类必须是 BaseRequestHandler 类的子类，在 BaseServer 中代码如下：</p>
<div><pre><code><span># BaseServer代码</span>
<span>class</span> <span>BaseServer</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> server_address<span>,</span> RequestHandlerClass<span>)</span><span>:</span>
        <span>"""Constructor. May be extended, do not override.可扩展不可覆盖"""</span>
        self<span>.</span>server_address <span>=</span> server_address
        self<span>.</span>RequestHandlerClass <span>=</span> RequestHandlerClass <span># 请求处理类</span>
        self<span>.</span>__is_shut_down <span>=</span> threading<span>.</span>Event<span>(</span><span>)</span>
        self<span>.</span>__shutdown_request <span>=</span> <span>False</span>
    <span>def</span> <span>finish_request</span><span>(</span>self<span>,</span> request<span>,</span> client_address<span>)</span><span>:</span> <span># 处理请求的方法</span>
        <span>"""Finish one request by instantiating RequestHandlerClass."""</span>
        self<span>.</span>RequestHandlerClass<span>(</span>request<span>,</span> client_address<span>,</span> self<span>)</span> <span>#RequestHandlerClass构造</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>BaseRequestHandler类</strong></p>
<p>它是和用户连接的用户请求处理类的基类，定义为</p>
<div><pre><code>BaseRequestHandler(request, client_address, server)
</code></pre>
<div><span>1</span><br></div></div><p>服务端 Server 实例接收用户请求后，最后会实例化这个类。
它被初始化时，送入3个构造参数：request, client_address, server自身
以后就可以在 BaseRequestHandler 类的实例上使用以下属性：</p>
<ul>
<li>self.request是和客户端的连接的socket对象</li>
<li>self.server是TCPServer实例本身</li>
<li>self.client_address是客户端地址</li>
</ul>
<p>这个类在初始化的时候，它会依次调用3个方法。子类可以覆盖这些方法。</p>
<div><pre><code><span># BaseRequestHandler要子类覆盖的方法</span>
<span>class</span> <span>BaseRequestHandler</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> request<span>,</span> client_address<span>,</span> server<span>)</span><span>:</span>
        self<span>.</span>request <span>=</span> request
        self<span>.</span>client_address <span>=</span> client_address
        self<span>.</span>server <span>=</span> server
        self<span>.</span>setup<span>(</span><span>)</span>
        <span>try</span><span>:</span>
            self<span>.</span>handle<span>(</span><span>)</span>
        <span>finally</span><span>:</span>
            self<span>.</span>finish<span>(</span><span>)</span>
            
    <span>def</span> <span>setup</span><span>(</span>self<span>)</span><span>:</span> <span># 每一个连接初始化</span>
        <span>pass</span>
    
    <span>def</span> <span>handle</span><span>(</span>self<span>)</span><span>:</span> <span># 每一次请求处理</span>
        <span>pass</span>
    
    <span>def</span> <span>finish</span><span>(</span>self<span>)</span><span>:</span> <span># 每一个连接清理</span>
        <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>测试代码</p>
<div><pre><code><span>import</span> threading
<span>import</span> socketserver

<span>class</span> <span>MyHandler</span><span>(</span>socketserver<span>.</span>BaseRequestHandler<span>)</span><span>:</span>
    <span>def</span> <span>handle</span><span>(</span>self<span>)</span><span>:</span>
        <span># super().handle() # 可以不调用，父类handle什么都没有做</span>
        <span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>
        <span>print</span><span>(</span>self<span>.</span>server<span>)</span> <span># 服务</span>
        <span>print</span><span>(</span>self<span>.</span>request<span>)</span> <span># 服务端负责客户端连接请求的socket对象</span>
        <span>print</span><span>(</span>self<span>.</span>__dict__<span>)</span>
        <span>print</span><span>(</span>self<span>.</span>server<span>.</span>__dict__<span>)</span> <span># 能看到负责accept的socket</span>

        <span>print</span><span>(</span>threading<span>.</span><span>enumerate</span><span>(</span><span>)</span><span>)</span>
        <span>print</span><span>(</span>threading<span>.</span>current_thread<span>(</span><span>)</span><span>)</span>
        <span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

addr <span>=</span> <span>(</span><span>'127.0.0.1'</span><span>,</span> <span>9999</span><span>)</span>
server <span>=</span> socketserver<span>.</span>ThreadingTCPServer<span>(</span>addr<span>,</span> MyHandler<span>)</span> <span># 注意参数是MyHandler类</span>
<span>#server.handle_request() # 一次行</span>
server<span>.</span>serve_forever<span>(</span><span>)</span> <span># 永久循环执行</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>测试结果说明，handle 方法相当于 socket 的 recv 方法。
每个不同的连接上的请求过来后，生成这个连接的 socket 对象即 self.request，客户端地址是 self.client_address。</p>
<p>问题
测试过程中，上面代码，连接后立即断开了，为什么？
怎样才能客户端和服务器端长时间连接？</p>
<div><pre><code><span>import</span> threading
<span>import</span> socketserver
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

<span>class</span> <span>MyHandler</span><span>(</span>socketserver<span>.</span>BaseRequestHandler<span>)</span><span>:</span>
    <span>def</span> <span>handle</span><span>(</span>self<span>)</span><span>:</span>
        <span># super().handle() # 可以不调用，父类handle什么都没有做</span>
        <span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>
        <span>print</span><span>(</span>self<span>.</span>server<span>)</span> <span># 服务</span>
        <span>print</span><span>(</span>self<span>.</span>request<span>)</span> <span># 服务端负责客户端连接请求的socket对象</span>
        <span>print</span><span>(</span>self<span>.</span>client_address<span>)</span> <span># 客户端地址</span>
        <span>print</span><span>(</span>self<span>.</span>__dict__<span>)</span>
        <span>print</span><span>(</span>self<span>.</span>server<span>.</span>__dict__<span>)</span> <span># 能看到负责accept的socket</span>

        <span>print</span><span>(</span>threading<span>.</span><span>enumerate</span><span>(</span><span>)</span><span>)</span>
        <span>print</span><span>(</span>threading<span>.</span>current_thread<span>(</span><span>)</span><span>)</span>
        <span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>3</span><span>)</span><span>:</span>
            data <span>=</span> self<span>.</span>request<span>.</span>recv<span>(</span><span>1024</span><span>)</span>
            logging<span>.</span>info<span>(</span>data<span>)</span>
        logging<span>.</span>info<span>(</span><span>'====end===='</span><span>)</span>

addr <span>=</span> <span>(</span><span>'127.0.0.1'</span><span>,</span> <span>9999</span><span>)</span>
server <span>=</span> socketserver<span>.</span>ThreadingTCPServer<span>(</span>addr<span>,</span> MyHandler<span>)</span> <span># 注意参数是MyHandler类</span>
<span>#server.handle_request() # 一次行</span>
server<span>.</span>serve_forever<span>(</span><span>)</span> <span># 永久循环执行</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>将ThreadingTCPServer换成TCPServer，同时连接2个客户端观察效果。</p>
<p>ThreadingTCPServer是异步的，可以同时处理多个连接。</p>
<p>TCPServer是同步的，一个连接处理完了，即一个连接的handle方法执行完了，才能处理另一个连接，且<strong>只有主线程</strong>。
总结
创建服务器需要几个步骤：</p>
<ol>
<li>从BaseRequestHandler类派生出子类，并覆盖其handle()方法来创建请求处理程序类，此方法将处理传入请求</li>
<li>实例化一个服务器类，传参服务器的地址和请求处理类</li>
<li>调用服务器实例的handle_request()或serve_forever()方法</li>
<li>调用server_close()关闭套接字</li>
</ol>
<h2 id="实现-echoserver"> 实现 EchoServer</h2>
<p>顾名思义，Echo，来什么消息回显什么消息
客户端发来什么信息，返回什么信息</p>
<div><pre><code><span>import</span> threading
<span>import</span> socketserver

<span>class</span> <span>Handler</span><span>(</span>socketserver<span>.</span>BaseRequestHandler<span>)</span><span>:</span>
    <span>def</span> <span>setup</span><span>(</span>self<span>)</span><span>:</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>setup<span>(</span><span>)</span>
        self<span>.</span>event <span>=</span> threading<span>.</span>Event<span>(</span><span>)</span>

    <span>def</span> <span>finish</span><span>(</span>self<span>)</span><span>:</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>finish<span>(</span><span>)</span>
        self<span>.</span>event<span>.</span><span>set</span><span>(</span><span>)</span>

    <span>def</span> <span>handle</span><span>(</span>self<span>)</span><span>:</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>handle<span>(</span><span>)</span>
        <span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>
        <span>while</span> <span>not</span> self<span>.</span>event<span>.</span>is_set<span>(</span><span>)</span><span>:</span>
            data <span>=</span> self<span>.</span>request<span>.</span>recv<span>(</span><span>1024</span><span>)</span><span>.</span>decode<span>(</span><span>)</span>
            <span>print</span><span>(</span>data<span>)</span>
            msg <span>=</span> <span>'{} {}'</span><span>.</span><span>format</span><span>(</span>self<span>.</span>client_address<span>,</span> data<span>)</span><span>.</span>encode<span>(</span><span>)</span>
            self<span>.</span>request<span>.</span>send<span>(</span>msg<span>)</span>

server <span>=</span> socketserver<span>.</span>ThreadingTCPServer<span>(</span><span>(</span><span>'127.0.0.1'</span><span>,</span> <span>9999</span><span>)</span><span>,</span> Handler<span>)</span>
<span>print</span><span>(</span>server<span>)</span>
threading<span>.</span>Thread<span>(</span>target<span>=</span>server<span>.</span>serve_forever<span>,</span> name<span>=</span><span>'EchoServer'</span><span>,</span> daemon<span>=</span><span>True</span><span>)</span><span>.</span>start<span>(</span><span>)</span>

<span>while</span> <span>True</span><span>:</span>
    cmd <span>=</span> <span>input</span><span>(</span><span>'>>'</span><span>)</span>
    <span>if</span> cmd <span>==</span> <span>'quit'</span><span>:</span>
        server<span>.</span>server_close<span>(</span><span>)</span>
        <span>break</span>
    <span>print</span><span>(</span>threading<span>.</span><span>enumerate</span><span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h2 id="总结"> 总结</h2>
<p>为每一个连接提供 RequestHandlerClass 类实例，依次调用 setup、handle、finish 方法，且使用了try...finally结构保证 finish 方法一定能被调用。这些方法依次执行完成，如果想维持这个连接和客户端通信，就需要 handle 函数中使用循环。</p>
<p>socketserver 模块提供的不同的类，但是编程接口是一样的，即使是多进程、多线程的类也是一样，大大减少了编程的难度。
将 socket 编程简化，只需要程序员关注数据处理本身，实现 Handler 类就行了。这种风格在 Python 十分常见。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">15 TCP 编程</title>
    <id>https://clay-wangzhi.com/code/python/python-tcp-pg/</id>
    <link href="https://clay-wangzhi.com/code/python/python-tcp-pg/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_15-tcp-编程"> 15 TCP 编程</h1>
<h2 id="socket介绍"> Socket介绍</h2>
<p><strong>Socket 套接字</strong>。Socket是一种通用的网络编程接口，和网络层次没有一一对应的关系。</p>
<p>Python 中标准库中提供了 socket 模块。socket 模块中也提供了 socket 类，实现了对底层接口的封装，
socket 模块是非常底层的接口库。</p>
<p>socke类定义为</p>
<div><pre><code>socket<span>(</span>self<span>,</span> family<span>=</span>AF_INET<span>,</span> <span>type</span><span>=</span>SOCK_STREAM<span>,</span> proto<span>=</span><span>0</span><span>,</span> fileno<span>=</span><span>None</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>协议族</strong>
AF表示Address Family，用于socket()第一个参数</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>AF_INET</td>
<td>IPV4</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>IPV6</td>
</tr>
<tr>
<td>AF_UNIX</td>
<td>Unix Domain Socket，windows没有</td>
</tr>
</tbody>
</table>
<p><strong>Socket 类型</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOCK_STREAM</td>
<td>SOCK_STREAM</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>无连接的数据报文套接字。UDP协议</td>
</tr>
</tbody>
</table>
<p>TCP 协议是流协议，也就是一大段数据看做字节流，一段段持续发送这些字节。</p>
<p>UDP 协议是数据报协议，每一份数据封在一个单独的数据报中，一份一份发送数据。</p>
<p><strong>socket 常用方法</strong></p>
<p>socket 类创建出 socket 对象，这个对象常用方法如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>socket.recv(bufsize[, flags])</strong></td>
<td>获取数据。默认是阻塞的方式</td>
</tr>
<tr>
<td><strong>socket.recvfrom(bufsize[, flags])</strong></td>
<td>获取数据，返回一个二元组(bytes, address)</td>
</tr>
<tr>
<td>socket.recv_into(buffer[, nbytes[,flags]])</td>
<td>获取到nbytes的数据后，存储到buffer中。如果nbytes没有指定或0，将buffer大小的数据存入buffer中。返回接收的字节数。</td>
</tr>
<tr>
<td>socket.recvfrom_into(buffer[, nbytes[,flags]])</td>
<td>获取数据，返回一个二元组(bytes, address)到buffer中</td>
</tr>
<tr>
<td><strong>socket.send(bytes[, flags])</strong></td>
<td>TCP发送数据</td>
</tr>
<tr>
<td>socket.sendall(bytes[, flags])</td>
<td>TCP发送全部数据，成功返回None</td>
</tr>
<tr>
<td><strong>socket.sendto(string[,flag],address)</strong></td>
<td>UDP发送数据</td>
</tr>
<tr>
<td>socket.sendfile(file, offset=0,count=None)</td>
<td>发送一个文件直到EOF，使用高性能的os.sendfile机制，返回发送的字节数。如果win下不支持sendfile，或者不是普通文件，使用send()发送文件。offset告诉起始位置。3.5版本开始</td>
</tr>
<tr>
<td><strong>socket.getpeername()</strong></td>
<td>返回连接套接字的远程地址。返回值通常是元组<br/>(ipaddr,port)</td>
</tr>
<tr>
<td><strong>socket.getsockname()</strong></td>
<td>返回套接字自己的地址。通常是一个元组<br/>(ipaddr,port)</td>
</tr>
<tr>
<td>socket.setblocking(flag)</td>
<td>如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常</td>
</tr>
<tr>
<td>socket.settimeout(value)</td>
<td>设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</td>
</tr>
<tr>
<td>socket.setsockopt(level,optname,value)</td>
<td>设置套接字选项的值。比如缓冲区大小。太多了，<br/>去看文档。不同系统，不同版本都不尽相同</td>
</tr>
</tbody>
</table>
<h2 id="tcp-编程"> TCP 编程</h2>
<p>Socket 编程，是完成一端和另一端通信的，注意一般来说这两端分别处在不同的进程中，也就是说网络通信是一个进程发消息到另外一个进程。</p>
<p>我们写代码的时候，每一个 socket 对象只表示了其中的一端。</p>
<p>从业务角度来说，这两端从角色上分为：</p>
<ul>
<li>主动发送请求的一端，称为客户端 Client</li>
<li>被动接受请求并回应的一端，称为服务端 Server</li>
</ul>
<p>这种编程模式也称为 C/S 编程。</p>
<h3 id="服务器端编程步骤"> 服务器端编程步骤</h3>
<ul>
<li>创建 Socket 对象</li>
<li>绑定 IP 地址 Address 和端口 Port。bind() 方法
IPv4 地址为一个二元组('IP地址字符串', Port)</li>
<li>开始监听，将在指定的 IP 的端口上监听。listen()方法</li>
<li>获取用于传送数据的 Socket 对象
socket.accept() -&gt; (socket object, address info)
accept 方法阻塞等待客户端建立连接，返回一个新的 Socket 对象和客户端地址的二元组地址是远程客户端的地址，IPv4 中它是一个二元组(clientaddr, port)
<ul>
<li>接收数据
recv(bufsize[, flags]) 使用缓冲区接收数据</li>
<li>发送数据
send(bytes) 发送数据</li>
</ul>
</li>
</ul>
<div><pre><code>Server端开发
socket对象 --&gt; bind((IP, PORT)) --&gt; listen --&gt; accept --&gt; close
                                                |--&gt; recv or send --&gt; close
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/tcp-server.png" alt="tcp-server" /></p>
<h3 id="socket-初识"> socket 初识</h3>
<div><pre><code><span>import</span> socket

s <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span> <span># 创建socket对象</span>
s<span>.</span>bind<span>(</span><span>(</span><span>'127.0.0.1'</span><span>,</span> <span>9999</span><span>)</span><span>)</span> <span># 一个地址和端口二元组</span>
s<span>.</span>listen<span>(</span><span>)</span> <span># 开始监听，等待客户端连接到来，准备accept</span>

<span># 接入一个到来的连接</span>
s1<span>,</span> info <span>=</span> s<span>.</span>accept<span>(</span><span>)</span> <span># 阻塞，直到和客户端成功建立连接，返回一个新的socket对象和客户端地址</span>
<span>print</span><span>(</span><span>type</span><span>(</span>s1<span>)</span><span>,</span> <span>type</span><span>(</span>info<span>)</span><span>)</span>
<span>print</span><span>(</span>s1<span>)</span>
<span>print</span><span>(</span>info<span>)</span>
sockname <span>=</span> s1<span>.</span>getsockname<span>(</span><span>)</span>
peername <span>=</span> s1<span>.</span>getpeername<span>(</span><span>)</span>
<span>print</span><span>(</span><span>type</span><span>(</span>sockname<span>)</span><span>,</span> sockname<span>)</span> <span># 本地地址</span>
<span>print</span><span>(</span><span>type</span><span>(</span>peername<span>)</span><span>,</span> peername<span>)</span> <span># 对端地址</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

<span># 使用缓冲区获取数据</span>
data <span>=</span> s1<span>.</span>recv<span>(</span><span>1024</span><span>)</span> <span># 阻塞</span>
<span>print</span><span>(</span><span>type</span><span>(</span>data<span>)</span><span>,</span> data<span>)</span>
s1<span>.</span>send<span>(</span><span>b'baidu.com ack'</span><span>)</span> <span># bytes</span>
s1<span>.</span>close<span>(</span><span>)</span> <span># 关闭</span>

<span># 接入另外一个连接</span>
s2<span>,</span> info <span>=</span> s<span>.</span>accept<span>(</span><span>)</span> <span># 阻塞</span>
data <span>=</span> s2<span>.</span>recv<span>(</span><span>1024</span><span>)</span>
<span>print</span><span>(</span>info<span>,</span> data<span>)</span>
s2<span>.</span>send<span>(</span><span>b'hello python ack'</span><span>)</span>
s2<span>.</span>close<span>(</span><span>)</span> <span># 关闭</span>
s<span>.</span>close<span>(</span><span>)</span> <span># 关闭</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>上例 accept 和 recv 是阻塞的，主线程经常被阻塞住而不能工作。怎么办？</p>
<p>查看监听端口</p>
<div><pre><code>windows 命令
# netstat -an -p tcp | findstr 9999

linux命令
# netstat -tanl | grep 9999
# ss -tanl | grep 9999
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="实战-写一个群聊程序"> 实战——写一个群聊程序</h3>
<p><strong>需求分析</strong>
聊天工具是 CS 程序，C 是每一个客户端 client，S 是服务器端 server。</p>
<p>服务器应该具有的功能：</p>
<ol>
<li>启动服务，包括绑定地址和端口，并监听</li>
<li>建立连接，能和多个客户端建立连接</li>
<li>接收不同用户的信息</li>
<li>分发，将接收的某个用户的信息转发到已连接的所有客户端</li>
<li>停止服务</li>
<li>记录连接的客户端</li>
</ol>
<p><strong>代码实现</strong>
服务端应该设计为一个类</p>
<div><pre><code><span>import</span> socket

<span>class</span> <span>ChatServer</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> ip<span>,</span> port<span>)</span><span>:</span> <span># 启动服务</span>
        self<span>.</span>sock <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span>
        self<span>.</span>addr <span>=</span> <span>(</span>ip<span>,</span> port<span>)</span>
    
    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span> <span># 启动监听</span>
        <span>pass</span>
    
    <span>def</span> <span>accept</span><span>(</span>self<span>)</span><span>:</span> <span># 多人连接</span>
        <span>pass</span>
    
    <span>def</span> <span>recv</span><span>(</span>self<span>)</span><span>:</span> <span># 接收客户端数据</span>
        <span>pass</span>
    
    <span>def</span> <span>stop</span><span>(</span>self<span>)</span><span>:</span> <span># 停止服务</span>
        <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>在此基础上，扩展完成</p>
<div><pre><code><span>import</span> threading
<span>import</span> datetime
<span>import</span> socket
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

<span>class</span> <span>ChatServer</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> ip<span>=</span><span>'127.0.0.1'</span><span>,</span> port<span>=</span><span>9999</span><span>)</span><span>:</span> <span># 启动服务</span>
        self<span>.</span>sock <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span>
        self<span>.</span>addr <span>=</span> <span>(</span>ip<span>,</span> port<span>)</span>
        self<span>.</span>clients <span>=</span> <span>{</span><span>}</span> <span># 客户端</span>

    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span> <span># 启动监听</span>
        self<span>.</span>sock<span>.</span>bind<span>(</span>self<span>.</span>addr<span>)</span> <span># 绑定</span>
        self<span>.</span>sock<span>.</span>listen<span>(</span><span>)</span> <span># 监听</span>
        <span># accept会阻塞主线程，所以开一个新线程</span>
        threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>accept<span>(</span><span>)</span><span>)</span><span>.</span>start<span>(</span><span>)</span>

    <span>def</span> <span>accept</span><span>(</span>self<span>)</span><span>:</span> <span># 多人连接</span>
        <span>while</span> <span>True</span><span>:</span>
            sock<span>,</span> client <span>=</span> self<span>.</span>sock<span>.</span>accept<span>(</span><span>)</span> <span># 阻塞</span>
            self<span>.</span>clients<span>[</span>client<span>]</span> <span>=</span> sock <span># 添加到客户端字典</span>
            <span># 准备接收数据，recv是阻塞的，开启新的线程</span>
            threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>recv<span>,</span> args<span>=</span><span>(</span>sock<span>,</span> client<span>)</span><span>)</span><span>.</span>start<span>(</span><span>)</span>


    <span>def</span> <span>recv</span><span>(</span>self<span>,</span> sock<span>:</span>socket<span>.</span>socket<span>,</span> client<span>)</span><span>:</span> <span># 接收客户端数据</span>
        <span>while</span> <span>True</span><span>:</span>
            data <span>=</span> sock<span>.</span>recv<span>(</span><span>1024</span><span>)</span> <span># 阻塞到数据到来</span>
            msg <span>=</span> <span>"{:%Y/%m/%d %H:%M:%S} {} {}\n{}\n"</span><span>.</span><span>format</span><span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span><span>,</span> <span>*</span>client<span>,</span> data<span>.</span>decode<span>(</span><span>)</span><span>)</span>
            logging<span>.</span>info<span>(</span>msg<span>)</span>
            msg <span>=</span> msg<span>.</span>encode<span>(</span><span>)</span>
            <span>for</span> s <span>in</span> self<span>.</span>clients<span>.</span>values<span>(</span><span>)</span><span>:</span>
                s<span>.</span>send<span>(</span>msg<span>)</span>


    <span>def</span> <span>stop</span><span>(</span>self<span>)</span><span>:</span> <span># 停止服务</span>
        <span>for</span> s <span>in</span> self<span>.</span>clients<span>.</span>values<span>(</span><span>)</span><span>:</span>
            s<span>.</span>close<span>(</span><span>)</span>
        self<span>.</span>sock<span>.</span>close<span>(</span><span>)</span>

cs <span>=</span> ChatServer<span>(</span><span>)</span>
cs<span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>基本功能完成，但是有问题。使用Event改进。先实现单独聊，然后改成群聊</p>
<div><pre><code><span>import</span> threading
<span>import</span> datetime
<span>import</span> socket
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

<span>class</span> <span>ChatServer</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> ip<span>=</span><span>'127.0.0.1'</span><span>,</span> port<span>=</span><span>9999</span><span>)</span><span>:</span> <span># 启动服务</span>
        self<span>.</span>sock <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span>
        self<span>.</span>addr <span>=</span> <span>(</span>ip<span>,</span> port<span>)</span>
        self<span>.</span>clients <span>=</span> <span>{</span><span>}</span> <span># 客户端</span>
        self<span>.</span>event <span>=</span> threading<span>.</span>Event<span>(</span><span>)</span>

    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span> <span># 启动监听</span>
        self<span>.</span>sock<span>.</span>bind<span>(</span>self<span>.</span>addr<span>)</span> <span># 绑定</span>
        self<span>.</span>sock<span>.</span>listen<span>(</span><span>)</span> <span># 监听</span>
        <span># accept会阻塞主线程，所以开一个新线程</span>
        threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>accept<span>)</span><span>.</span>start<span>(</span><span>)</span>

    <span>def</span> <span>accept</span><span>(</span>self<span>)</span><span>:</span> <span># 多人连接</span>
        <span>while</span> <span>not</span> self<span>.</span>event<span>.</span>is_set<span>(</span><span>)</span><span>:</span>
            sock<span>,</span> client <span>=</span> self<span>.</span>sock<span>.</span>accept<span>(</span><span>)</span> <span># 阻塞</span>
            self<span>.</span>clients<span>[</span>client<span>]</span> <span>=</span> sock <span># 添加到客户端字典</span>
            <span># 准备接收数据，recv是阻塞的，开启新的线程</span>
            threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>recv<span>,</span> args<span>=</span><span>(</span>sock<span>,</span> client<span>)</span><span>)</span><span>.</span>start<span>(</span><span>)</span>


    <span>def</span> <span>recv</span><span>(</span>self<span>,</span> sock<span>:</span>socket<span>.</span>socket<span>,</span> client<span>)</span><span>:</span> <span># 接收客户端数据</span>
        <span>while</span> <span>not</span> self<span>.</span>event<span>.</span>is_set<span>(</span><span>)</span><span>:</span>
            data <span>=</span> sock<span>.</span>recv<span>(</span><span>1024</span><span>)</span> <span># 阻塞到数据到来</span>
            msg <span>=</span> <span>"{:%Y/%m/%d %H:%M:%S} {} {}\n{}\n"</span><span>.</span><span>format</span><span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span><span>,</span> <span>*</span>client<span>,</span> data<span>.</span>decode<span>(</span><span>)</span><span>)</span>
            logging<span>.</span>info<span>(</span>msg<span>)</span>
            msg <span>=</span> msg<span>.</span>encode<span>(</span><span>)</span>
            <span>for</span> s <span>in</span> self<span>.</span>clients<span>.</span>values<span>(</span><span>)</span><span>:</span>
                s<span>.</span>send<span>(</span>msg<span>)</span>


    <span>def</span> <span>stop</span><span>(</span>self<span>)</span><span>:</span> <span># 停止服务</span>
        <span>for</span> s <span>in</span> self<span>.</span>clients<span>.</span>values<span>(</span><span>)</span><span>:</span>
            s<span>.</span>close<span>(</span><span>)</span>
        self<span>.</span>sock<span>.</span>close<span>(</span><span>)</span>

cs <span>=</span> ChatServer<span>(</span><span>)</span>
cs<span>.</span>start<span>(</span><span>)</span>

<span>while</span> <span>True</span><span>:</span>
    cmd <span>=</span> <span>input</span><span>(</span><span>'>>'</span><span>)</span><span>.</span>strip<span>(</span><span>)</span>
    <span>if</span> cmd <span>==</span> <span>'quit'</span><span>:</span>
        cs<span>.</span>stop<span>(</span><span>)</span>
        threading<span>.</span>Event<span>(</span><span>)</span><span>.</span>wait<span>(</span><span>3</span><span>)</span>
        <span>break</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>这一版基本能用了，测试通过。但是还有要完善的地方。
例如各种异常的判断，客户端断开连接后字典中的移除客户端数据等。</p>
<p><strong>客户端主动断开带来的问题</strong></p>
<p>服务端知道自己何时断开，如果客户端断开，服务器不知道。（客户端主动断开，服务端recv会得到一个空串）
所以，好的做法是，客户端断开发出特殊消息通知服务器端断开连接。但是，如果客户端主动断开，服务端主动发送一个空消息，超时返回异常，捕获异常并清理连接。
即使为客户端提供了断开命令，也不能保证客户端会使用它断开连接。但是还是要增加这个退出功能。</p>
<p>增加客户端退出命令</p>
<div><pre><code><span>import</span> threading
<span>import</span> datetime
<span>import</span> socket
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

<span>class</span> <span>ChatServer</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> ip<span>=</span><span>'127.0.0.1'</span><span>,</span> port<span>=</span><span>9999</span><span>)</span><span>:</span> <span># 启动服务</span>
        self<span>.</span>sock <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span>
        self<span>.</span>addr <span>=</span> <span>(</span>ip<span>,</span> port<span>)</span>
        self<span>.</span>clients <span>=</span> <span>{</span><span>}</span> <span># 客户端</span>
        self<span>.</span>event <span>=</span> threading<span>.</span>Event<span>(</span><span>)</span>

    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span> <span># 启动监听</span>
        self<span>.</span>sock<span>.</span>bind<span>(</span>self<span>.</span>addr<span>)</span> <span># 绑定</span>
        self<span>.</span>sock<span>.</span>listen<span>(</span><span>)</span> <span># 监听</span>
        <span># accept会阻塞主线程，所以开一个新线程</span>
        threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>accept<span>)</span><span>.</span>start<span>(</span><span>)</span>

    <span>def</span> <span>accept</span><span>(</span>self<span>)</span><span>:</span> <span># 多人连接</span>
        <span>while</span> <span>not</span> self<span>.</span>event<span>.</span>is_set<span>(</span><span>)</span><span>:</span>
            sock<span>,</span> client <span>=</span> self<span>.</span>sock<span>.</span>accept<span>(</span><span>)</span> <span># 阻塞</span>
            self<span>.</span>clients<span>[</span>client<span>]</span> <span>=</span> sock <span># 添加到客户端字典</span>
            <span># 准备接收数据，recv是阻塞的，开启新的线程</span>
            threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>recv<span>,</span> args<span>=</span><span>(</span>sock<span>,</span> client<span>)</span><span>)</span><span>.</span>start<span>(</span><span>)</span>


    <span>def</span> <span>recv</span><span>(</span>self<span>,</span> sock<span>:</span>socket<span>.</span>socket<span>,</span> client<span>)</span><span>:</span> <span># 接收客户端数据</span>
        <span>while</span> <span>not</span> self<span>.</span>event<span>.</span>is_set<span>(</span><span>)</span><span>:</span>
            data <span>=</span> sock<span>.</span>recv<span>(</span><span>1024</span><span>)</span> <span># 阻塞到数据到来</span>
            msg <span>=</span> data<span>.</span>decode<span>(</span><span>)</span><span>.</span>strip<span>(</span><span>)</span>
            <span>if</span> msg <span>==</span> <span>'quit'</span> <span>or</span> msg <span>==</span> <span>''</span><span>:</span> <span># 主动断开得到空串</span>
                self<span>.</span>clients<span>.</span>pop<span>(</span>client<span>)</span>
                sock<span>.</span>close<span>(</span><span>)</span>
                logging<span>.</span>info<span>(</span><span>'{} quits'</span><span>.</span><span>format</span><span>(</span>client<span>)</span><span>)</span>
                <span>break</span>
            msg <span>=</span> <span>"{:%Y/%m/%d %H:%M:%S} {} {}\n{}\n"</span><span>.</span><span>format</span><span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span><span>,</span> <span>*</span>client<span>,</span> data<span>.</span>decode<span>(</span><span>)</span><span>)</span>
            logging<span>.</span>info<span>(</span>msg<span>)</span>
            msg <span>=</span> msg<span>.</span>encode<span>(</span><span>)</span>
            <span>for</span> s <span>in</span> self<span>.</span>clients<span>.</span>values<span>(</span><span>)</span><span>:</span>
                s<span>.</span>send<span>(</span>msg<span>)</span>


    <span>def</span> <span>stop</span><span>(</span>self<span>)</span><span>:</span> <span># 停止服务</span>
        self<span>.</span>event<span>.</span><span>set</span><span>(</span><span>)</span>
        <span>for</span> s <span>in</span> self<span>.</span>clients<span>.</span>values<span>(</span><span>)</span><span>:</span>
            s<span>.</span>close<span>(</span><span>)</span>
        self<span>.</span>sock<span>.</span>close<span>(</span><span>)</span>

cs <span>=</span> ChatServer<span>(</span><span>)</span>
cs<span>.</span>start<span>(</span><span>)</span>

<span>while</span> <span>True</span><span>:</span>
    cmd <span>=</span> <span>input</span><span>(</span><span>'>>'</span><span>)</span><span>.</span>strip<span>(</span><span>)</span>
    <span>if</span> cmd <span>==</span> <span>'quit'</span><span>:</span>
        cs<span>.</span>stop<span>(</span><span>)</span>
        threading<span>.</span>Event<span>(</span><span>)</span><span>.</span>wait<span>(</span><span>3</span><span>)</span>
        <span>break</span>
    logging<span>.</span>info<span>(</span>threading<span>.</span><span>enumerate</span><span>(</span><span>)</span><span>)</span> <span># 用来观察断开后线程的变化</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><p>程序还有瑕疵，但是业务功能基本完成了</p>
<p><strong>线程安全</strong>
由于 GIL 和内置数据结构的读写原子性，单独操作字典的某一项 item 是安全的。但是遍历过程是线程不安全的，遍历中有可能被打断，其他线程如果对字典元素进行增加、弹出，都会影响字典的 size ，就会抛出异常。所以还是要加锁 Lock。出错测试代码如下</p>
<div><pre><code><span>import</span> threading
<span>import</span> time
<span>import</span> random
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

global_dict <span>=</span> <span>{</span><span>}</span>

<span>def</span> <span>additem</span><span>(</span>d<span>:</span><span>dict</span><span>)</span><span>:</span>
    count <span>=</span> <span>1</span>
    <span>while</span> <span>True</span><span>:</span>
        d<span>[</span>count<span>]</span> <span>=</span> random<span>.</span>randint<span>(</span><span>100</span><span>,</span><span>110</span><span>)</span> <span># kv 对一直增加</span>
        count <span>+=</span> <span>1</span>
        time<span>.</span>sleep<span>(</span><span>0.001</span><span>)</span>

<span>def</span> <span>iterdict</span><span>(</span>d<span>:</span><span>dict</span><span>)</span><span>:</span>
    <span>while</span> <span>True</span><span>:</span>
        <span>for</span> k<span>,</span>v <span>in</span> d<span>.</span>items<span>(</span><span>)</span><span>:</span> <span># 遍历</span>
            logging<span>.</span>info<span>(</span>k<span>,</span> v<span>)</span>
            d<span>[</span>k<span>]</span> <span>=</span> random<span>.</span>randint<span>(</span><span>1</span><span>,</span> <span>10</span><span>)</span>

a <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>additem<span>,</span> args<span>=</span><span>(</span>global_dict<span>,</span><span>)</span><span>,</span> daemon<span>=</span><span>True</span><span>)</span>
i <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>iterdict<span>,</span> args<span>=</span><span>(</span>global_dict<span>,</span><span>)</span><span>,</span> daemon<span>=</span><span>True</span><span>)</span>

a<span>.</span>start<span>(</span><span>)</span>
i<span>.</span>start<span>(</span><span>)</span>

<span>while</span> <span>True</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    logging<span>.</span>info<span>(</span>threading<span>.</span><span>enumerate</span><span>(</span><span>)</span><span>)</span>

    <span>if</span> threading<span>.</span>active_count<span>(</span><span>)</span> <span>&lt;=</span> <span>2</span><span>:</span>
        keys <span>=</span> <span>list</span><span>(</span>global_dict<span>.</span>keys<span>(</span><span>)</span><span>)</span>
        logging<span>.</span>info<span>(</span>keys<span>)</span>
        logging<span>.</span>info<span>(</span><span>len</span><span>(</span>keys<span>)</span><span>)</span>
        logging<span>.</span>info<span>(</span><span>'='</span> <span>*</span> <span>30</span><span>)</span>
        <span>break</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>加锁后的代码如下</p>
<div><pre><code><span>import</span> threading
<span>import</span> datetime
<span>import</span> socket
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

<span>class</span> <span>ChatServer</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> ip<span>=</span><span>'127.0.0.1'</span><span>,</span> port<span>=</span><span>9999</span><span>)</span><span>:</span> <span># 启动服务</span>
        self<span>.</span>sock <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span>
        self<span>.</span>addr <span>=</span> <span>(</span>ip<span>,</span> port<span>)</span>
        self<span>.</span>clients <span>=</span> <span>{</span><span>}</span> <span># 客户端</span>
        self<span>.</span>event <span>=</span> threading<span>.</span>Event<span>(</span><span>)</span>
        self<span>.</span>lock <span>=</span> threading<span>.</span>Lock<span>(</span><span>)</span>

    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span> <span># 启动监听</span>
        self<span>.</span>sock<span>.</span>bind<span>(</span>self<span>.</span>addr<span>)</span> <span># 绑定</span>
        self<span>.</span>sock<span>.</span>listen<span>(</span><span>)</span> <span># 监听</span>
        <span># accept会阻塞主线程，所以开一个新线程</span>
        threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>accept<span>)</span><span>.</span>start<span>(</span><span>)</span>

    <span>def</span> <span>accept</span><span>(</span>self<span>)</span><span>:</span> <span># 多人连接</span>
        <span>while</span> <span>not</span> self<span>.</span>event<span>.</span>is_set<span>(</span><span>)</span><span>:</span>
            sock<span>,</span> client <span>=</span> self<span>.</span>sock<span>.</span>accept<span>(</span><span>)</span> <span># 阻塞</span>
            <span>with</span> self<span>.</span>lock<span>:</span>
                self<span>.</span>clients<span>[</span>client<span>]</span> <span>=</span> sock <span># 添加到客户端字典</span>
            <span># 准备接收数据，recv是阻塞的，开启新的线程</span>
            threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>recv<span>,</span> args<span>=</span><span>(</span>sock<span>,</span> client<span>)</span><span>)</span><span>.</span>start<span>(</span><span>)</span>


    <span>def</span> <span>recv</span><span>(</span>self<span>,</span> sock<span>:</span>socket<span>.</span>socket<span>,</span> client<span>)</span><span>:</span> <span># 接收客户端数据</span>
        <span>while</span> <span>not</span> self<span>.</span>event<span>.</span>is_set<span>(</span><span>)</span><span>:</span>
            data <span>=</span> sock<span>.</span>recv<span>(</span><span>1024</span><span>)</span> <span># 阻塞到数据到来</span>
            msg <span>=</span> data<span>.</span>decode<span>(</span><span>)</span><span>.</span>strip<span>(</span><span>)</span>
            <span>if</span> msg <span>==</span> <span>'quit'</span> <span>or</span> msg <span>==</span> <span>''</span><span>:</span> <span># 主动断开得到空串</span>
                <span>with</span> self<span>.</span>lock<span>:</span>
                    self<span>.</span>clients<span>.</span>pop<span>(</span>client<span>)</span>
                    sock<span>.</span>close<span>(</span><span>)</span>
                logging<span>.</span>info<span>(</span><span>'{} quits'</span><span>.</span><span>format</span><span>(</span>client<span>)</span><span>)</span>
                <span>break</span>
            msg <span>=</span> <span>"{:%Y/%m/%d %H:%M:%S} {} {}\n{}\n"</span><span>.</span><span>format</span><span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span><span>,</span> <span>*</span>client<span>,</span> data<span>.</span>decode<span>(</span><span>)</span><span>)</span>
            logging<span>.</span>info<span>(</span>msg<span>)</span>
            msg <span>=</span> msg<span>.</span>encode<span>(</span><span>)</span>
            <span>with</span> self<span>.</span>lock<span>:</span>
                <span>for</span> s <span>in</span> self<span>.</span>clients<span>.</span>values<span>(</span><span>)</span><span>:</span>
                    s<span>.</span>send<span>(</span>msg<span>)</span>


    <span>def</span> <span>stop</span><span>(</span>self<span>)</span><span>:</span> <span># 停止服务</span>
        self<span>.</span>event<span>.</span><span>set</span><span>(</span><span>)</span>
        <span>with</span> self<span>.</span>lock<span>:</span>
            <span>for</span> s <span>in</span> self<span>.</span>clients<span>.</span>values<span>(</span><span>)</span><span>:</span>
                s<span>.</span>close<span>(</span><span>)</span>
        self<span>.</span>sock<span>.</span>close<span>(</span><span>)</span>

cs <span>=</span> ChatServer<span>(</span><span>)</span>
cs<span>.</span>start<span>(</span><span>)</span>

<span>while</span> <span>True</span><span>:</span>
    cmd <span>=</span> <span>input</span><span>(</span><span>'>>'</span><span>)</span><span>.</span>strip<span>(</span><span>)</span>
    <span>if</span> cmd <span>==</span> <span>'quit'</span><span>:</span>
        cs<span>.</span>stop<span>(</span><span>)</span>
        threading<span>.</span>Event<span>(</span><span>)</span><span>.</span>wait<span>(</span><span>3</span><span>)</span>
        <span>break</span>
    logging<span>.</span>info<span>(</span>threading<span>.</span><span>enumerate</span><span>(</span><span>)</span><span>)</span> <span># 用来观察断开后线程的变化</span>
    logging<span>.</span>info<span>(</span>cs<span>.</span>clients<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><p>也可以把 recv 和 accept 线程设置为 daemon 线程。</p>
<h3 id="makefile"> MakeFile</h3>
<div><pre><code>socket<span>.</span>makefile<span>(</span>mode<span>=</span><span>'r'</span><span>,</span> buffering<span>=</span><span>None</span><span>,</span> <span>*</span><span>,</span> encoding<span>=</span><span>None</span><span>,</span> errors<span>=</span><span>None</span><span>,</span>newline<span>=</span><span>None</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>创建一个与该套接字相关连的文件对象，将recv方法看做读方法，将send方法看做写方法。</p>
<div><pre><code><span># 使用makefile简单例子</span>
<span>import</span> socket

server <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span>
server<span>.</span>bind<span>(</span><span>(</span><span>'127.0.0.1'</span><span>,</span> <span>9999</span><span>)</span><span>)</span>
server<span>.</span>listen<span>(</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

s<span>,</span> _ <span>=</span> server<span>.</span>accept<span>(</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>
f <span>=</span> s<span>.</span>makefile<span>(</span>mode<span>=</span><span>'rw'</span><span>)</span>

line <span>=</span> f<span>.</span>read<span>(</span><span>10</span><span>)</span> <span># 按行读取要使用readline方法</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>
<span>print</span><span>(</span>line<span>)</span>
f<span>.</span>write<span>(</span><span>'return your msg: {}'</span><span>.</span><span>format</span><span>(</span>line<span>)</span><span>)</span>
f<span>.</span>flush<span>(</span><span>)</span>

f<span>.</span>close<span>(</span><span>)</span>
<span>print</span><span>(</span>f<span>.</span>closed<span>,</span> s<span>.</span>_closed<span>)</span>
s<span>.</span>close<span>(</span><span>)</span>
<span>print</span><span>(</span>f<span>.</span>closed<span>,</span> s<span>.</span>_closed<span>)</span>

server<span>.</span>close<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>makefile练习</strong>
使用makefile改写群聊类</p>
<div><pre><code><span>import</span> threading
<span>import</span> datetime
<span>import</span> socket
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

<span>class</span> <span>ChatServer</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> ip<span>=</span><span>'127.0.0.1'</span><span>,</span> port<span>=</span><span>9999</span><span>)</span><span>:</span> <span># 启动服务</span>
        self<span>.</span>sock <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span>
        self<span>.</span>addr <span>=</span> <span>(</span>ip<span>,</span> port<span>)</span>
        self<span>.</span>clients <span>=</span> <span>{</span><span>}</span> <span># 客户端</span>
        self<span>.</span>event <span>=</span> threading<span>.</span>Event<span>(</span><span>)</span>
        self<span>.</span>lock <span>=</span> threading<span>.</span>Lock<span>(</span><span>)</span>

    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span> <span># 启动监听</span>
        self<span>.</span>sock<span>.</span>bind<span>(</span>self<span>.</span>addr<span>)</span> <span># 绑定</span>
        self<span>.</span>sock<span>.</span>listen<span>(</span><span>)</span> <span># 监听</span>
        <span># accept会阻塞主线程，所以开一个新线程</span>
        threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>accept<span>)</span><span>.</span>start<span>(</span><span>)</span>

    <span>def</span> <span>accept</span><span>(</span>self<span>)</span><span>:</span> <span># 多人连接</span>
        <span>while</span> <span>not</span> self<span>.</span>event<span>.</span>is_set<span>(</span><span>)</span><span>:</span>
            sock<span>,</span> client <span>=</span> self<span>.</span>sock<span>.</span>accept<span>(</span><span>)</span> <span># 阻塞</span>
            f <span>=</span> sock<span>.</span>makefile<span>(</span><span>'rw'</span><span>)</span>
            <span>with</span> self<span>.</span>lock<span>:</span>
                self<span>.</span>clients<span>[</span>client<span>]</span> <span>=</span> f<span>,</span> sock <span># 添加到客户端字典</span>
            <span># 准备接收数据，recv是阻塞的，开启新的线程</span>
            threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>recv<span>,</span> args<span>=</span><span>(</span>f<span>,</span> client<span>)</span><span>)</span><span>.</span>start<span>(</span><span>)</span>


    <span>def</span> <span>recv</span><span>(</span>self<span>,</span> f<span>,</span> client<span>)</span><span>:</span> <span># 接收客户端数据</span>
        <span>while</span> <span>not</span> self<span>.</span>event<span>.</span>is_set<span>(</span><span>)</span><span>:</span>
            data <span>=</span> f<span>.</span>readline<span>(</span><span>)</span> <span># 阻塞等一行来，换行符</span>
            msg <span>=</span> data<span>.</span>strip<span>(</span><span>)</span>
            <span>if</span> msg <span>==</span> <span>'quit'</span> <span>or</span> msg <span>==</span> <span>''</span><span>:</span> <span># 主动断开得到空串</span>
                <span>with</span> self<span>.</span>lock<span>:</span>
                    _<span>,</span> sock <span>=</span> self<span>.</span>clients<span>.</span>pop<span>(</span>client<span>)</span>
                    sock<span>.</span>close<span>(</span><span>)</span>
                    f<span>.</span>close<span>(</span><span>)</span>
                logging<span>.</span>info<span>(</span><span>'{} quits'</span><span>.</span><span>format</span><span>(</span>client<span>)</span><span>)</span>
                <span>break</span>
            msg <span>=</span> <span>"{:%Y/%m/%d %H:%M:%S} {} {}\n{}\n"</span><span>.</span><span>format</span><span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span><span>,</span> <span>*</span>client<span>,</span> data<span>)</span>
            logging<span>.</span>info<span>(</span>msg<span>)</span>
            <span>with</span> self<span>.</span>lock<span>:</span>
                <span>for</span> ff<span>,</span> _ <span>in</span> self<span>.</span>clients<span>.</span>values<span>(</span><span>)</span><span>:</span>
                    ff<span>.</span>write<span>(</span>msg<span>)</span>
                    ff<span>.</span>flush<span>(</span><span>)</span>


    <span>def</span> <span>stop</span><span>(</span>self<span>)</span><span>:</span> <span># 停止服务</span>
        self<span>.</span>event<span>.</span><span>set</span><span>(</span><span>)</span>
        <span>with</span> self<span>.</span>lock<span>:</span>
            <span>for</span> f<span>,</span> s <span>in</span> self<span>.</span>clients<span>.</span>values<span>(</span><span>)</span><span>:</span>
                s<span>.</span>close<span>(</span><span>)</span>
                f<span>.</span>close<span>(</span><span>)</span>
        self<span>.</span>sock<span>.</span>close<span>(</span><span>)</span>

cs <span>=</span> ChatServer<span>(</span><span>)</span>
cs<span>.</span>start<span>(</span><span>)</span>

<span>while</span> <span>True</span><span>:</span>
    cmd <span>=</span> <span>input</span><span>(</span><span>'>>'</span><span>)</span><span>.</span>strip<span>(</span><span>)</span>
    <span>if</span> cmd <span>==</span> <span>'quit'</span><span>:</span>
        cs<span>.</span>stop<span>(</span><span>)</span>
        threading<span>.</span>Event<span>(</span><span>)</span><span>.</span>wait<span>(</span><span>3</span><span>)</span>
        <span>break</span>
    logging<span>.</span>info<span>(</span>threading<span>.</span><span>enumerate</span><span>(</span><span>)</span><span>)</span> <span># 用来观察断开后线程的变化</span>
    logging<span>.</span>info<span>(</span>cs<span>.</span>clients<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div><p>上例完成了基本功能，但是，如果网络异常，或者 readline 出现异常，就不会从 clients 中移除作废的 socket。可以使用异常处理解决这个问题。</p>
<p><strong>ChatServer实验用完整代码</strong>
注意，这个代码为实验用，代码中瑕疵还有很多。Socket太底层了，实际开发中很少使用这么底层的接口。</p>
<p>增加一些异常处理。</p>
<div><pre><code><span>import</span> threading
<span>import</span> datetime
<span>import</span> socket
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

<span>class</span> <span>ChatServer</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> ip<span>=</span><span>'127.0.0.1'</span><span>,</span> port<span>=</span><span>9999</span><span>)</span><span>:</span> <span># 启动服务</span>
        self<span>.</span>sock <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span>
        self<span>.</span>addr <span>=</span> <span>(</span>ip<span>,</span> port<span>)</span>
        self<span>.</span>clients <span>=</span> <span>{</span><span>}</span> <span># 客户端</span>
        self<span>.</span>event <span>=</span> threading<span>.</span>Event<span>(</span><span>)</span>
        self<span>.</span>lock <span>=</span> threading<span>.</span>Lock<span>(</span><span>)</span>

    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span> <span># 启动监听</span>
        self<span>.</span>sock<span>.</span>bind<span>(</span>self<span>.</span>addr<span>)</span> <span># 绑定</span>
        self<span>.</span>sock<span>.</span>listen<span>(</span><span>)</span> <span># 监听</span>
        <span># accept会阻塞主线程，所以开一个新线程</span>
        threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>accept<span>)</span><span>.</span>start<span>(</span><span>)</span>

    <span>def</span> <span>accept</span><span>(</span>self<span>)</span><span>:</span> <span># 多人连接</span>
        <span>while</span> <span>not</span> self<span>.</span>event<span>.</span>is_set<span>(</span><span>)</span><span>:</span>
            sock<span>,</span> client <span>=</span> self<span>.</span>sock<span>.</span>accept<span>(</span><span>)</span> <span># 阻塞</span>
            f <span>=</span> sock<span>.</span>makefile<span>(</span><span>'rw'</span><span>)</span>
            <span>with</span> self<span>.</span>lock<span>:</span>
                self<span>.</span>clients<span>[</span>client<span>]</span> <span>=</span> f<span>,</span> sock <span># 添加到客户端字典</span>
            <span># 准备接收数据，recv是阻塞的，开启新的线程</span>
            threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>recv<span>,</span> args<span>=</span><span>(</span>f<span>,</span> client<span>)</span><span>)</span><span>.</span>start<span>(</span><span>)</span>


    <span>def</span> <span>recv</span><span>(</span>self<span>,</span> f<span>,</span> client<span>)</span><span>:</span> <span># 接收客户端数据</span>
        <span>while</span> <span>not</span> self<span>.</span>event<span>.</span>is_set<span>(</span><span>)</span><span>:</span>
            <span>try</span><span>:</span>
                data <span>=</span> f<span>.</span>readline<span>(</span><span>)</span> <span># 阻塞等一行来，换行符</span>
            <span>except</span> Exception <span>as</span> e<span>:</span>
                logging<span>.</span>error<span>(</span>e<span>)</span>
                data <span>=</span> <span>'quit'</span>

            msg <span>=</span> data<span>.</span>strip<span>(</span><span>)</span>
            <span>if</span> msg <span>==</span> <span>'quit'</span> <span>or</span> msg <span>==</span> <span>''</span><span>:</span> <span># 主动断开得到空串</span>
                <span>with</span> self<span>.</span>lock<span>:</span>
                    _<span>,</span> sock <span>=</span> self<span>.</span>clients<span>.</span>pop<span>(</span>client<span>)</span>
                    sock<span>.</span>close<span>(</span><span>)</span>
                    f<span>.</span>close<span>(</span><span>)</span>
                logging<span>.</span>info<span>(</span><span>'{} quits'</span><span>.</span><span>format</span><span>(</span>client<span>)</span><span>)</span>
                <span>break</span>
            msg <span>=</span> <span>"{:%Y/%m/%d %H:%M:%S} {} {}\n{}\n"</span><span>.</span><span>format</span><span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span><span>,</span> <span>*</span>client<span>,</span> data<span>)</span>
            logging<span>.</span>info<span>(</span>msg<span>)</span>
            <span>with</span> self<span>.</span>lock<span>:</span>
                <span>for</span> ff<span>,</span> _ <span>in</span> self<span>.</span>clients<span>.</span>values<span>(</span><span>)</span><span>:</span>
                    ff<span>.</span>write<span>(</span>msg<span>)</span>
                    ff<span>.</span>flush<span>(</span><span>)</span>


    <span>def</span> <span>stop</span><span>(</span>self<span>)</span><span>:</span> <span># 停止服务</span>
        self<span>.</span>event<span>.</span><span>set</span><span>(</span><span>)</span>
        <span>with</span> self<span>.</span>lock<span>:</span>
            <span>for</span> f<span>,</span> s <span>in</span> self<span>.</span>clients<span>.</span>values<span>(</span><span>)</span><span>:</span>
                s<span>.</span>close<span>(</span><span>)</span>
                f<span>.</span>close<span>(</span><span>)</span>
        self<span>.</span>sock<span>.</span>close<span>(</span><span>)</span>

<span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    cs <span>=</span> ChatServer<span>(</span><span>)</span>
    cs<span>.</span>start<span>(</span><span>)</span>

    <span>while</span> <span>True</span><span>:</span>
        cmd <span>=</span> <span>input</span><span>(</span><span>'>>'</span><span>)</span><span>.</span>strip<span>(</span><span>)</span>
        <span>if</span> cmd <span>==</span> <span>'quit'</span><span>:</span>
            cs<span>.</span>stop<span>(</span><span>)</span>
            threading<span>.</span>Event<span>(</span><span>)</span><span>.</span>wait<span>(</span><span>3</span><span>)</span>
            <span>break</span>
        logging<span>.</span>info<span>(</span>threading<span>.</span><span>enumerate</span><span>(</span><span>)</span><span>)</span> <span># 用来观察断开后线程的变化</span>
        logging<span>.</span>info<span>(</span>cs<span>.</span>clients<span>)</span>

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    main<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br></div></div><h3 id="tcp客户端编程"> TCP客户端编程</h3>
<p><strong>客户端编程步骤</strong></p>
<ul>
<li>创建 Socket 对象
连接到远端服务端的 ip 和 port，connect() 方法</li>
<li>传输数据
<ul>
<li>使用send、recv方法发送、接收数据</li>
</ul>
</li>
<li>关闭连接，释放资源</li>
</ul>
<div><pre><code><span>import</span> socket

client <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span>
ipaddr <span>=</span> <span>(</span><span>'127.0.0.1'</span><span>,</span> <span>9999</span><span>)</span>
client<span>.</span>connect<span>(</span>ipaddr<span>)</span> <span># 直接连接服务器</span>

client<span>.</span>send<span>(</span><span>b'abcd\n'</span><span>)</span>
data <span>=</span> client<span>.</span>recv<span>(</span><span>1024</span><span>)</span> <span># 阻塞等待</span>
<span>print</span><span>(</span>data<span>)</span>

client<span>.</span>close<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>开始编写客户端类</p>
<div><pre><code><span>import</span> socket
<span>import</span> threading
<span>import</span> datetime
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

<span>class</span> <span>ChatClient</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> ip<span>=</span><span>'127.0.0.1'</span><span>,</span> port<span>=</span><span>9999</span><span>)</span><span>:</span>
        self<span>.</span>sock <span>=</span> socket<span>.</span>socket<span>(</span><span>)</span>
        self<span>.</span>addr <span>=</span> <span>(</span>ip<span>,</span> port<span>)</span>
        self<span>.</span>event <span>=</span> threading<span>.</span>Event<span>(</span><span>)</span>

    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span> <span># 启动对远端服务器的连接</span>
        self<span>.</span>sock<span>.</span>connect<span>(</span>self<span>.</span>addr<span>)</span>
        self<span>.</span>send<span>(</span><span>"I'm ready."</span><span>)</span>
        <span># 准备接收数据，recv是阻塞的，开启新的线程</span>
        threading<span>.</span>Thread<span>(</span>target<span>=</span>self<span>.</span>recv<span>,</span> name<span>=</span><span>"recv"</span><span>)</span><span>.</span>start<span>(</span><span>)</span>

    <span>def</span> <span>recv</span><span>(</span>self<span>)</span><span>:</span> <span># 接收服务端的数据</span>
        <span>while</span> <span>not</span> self<span>.</span>event<span>.</span>is_set<span>(</span><span>)</span><span>:</span>
            <span>try</span><span>:</span>
                data <span>=</span> self<span>.</span>sock<span>.</span>recv<span>(</span><span>1024</span><span>)</span> <span># 阻塞</span>
            <span>except</span> Exception <span>as</span> e<span>:</span>
                logging<span>.</span>error<span>(</span>e<span>)</span>
                <span>break</span>
            msg <span>=</span> <span>"{:%Y/%m/%d %H:%M:%S} {}:{}\n{}\n"</span><span>.</span><span>format</span><span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span><span>,</span> <span>*</span>self<span>.</span>addr<span>,</span> data<span>.</span>strip<span>(</span><span>)</span><span>)</span>
            logging<span>.</span>info<span>(</span>msg<span>)</span>
    <span>def</span> <span>send</span><span>(</span>self<span>,</span> msg<span>:</span><span>str</span><span>)</span><span>:</span>
        data <span>=</span> <span>"{}\n"</span><span>.</span><span>format</span><span>(</span>msg<span>.</span>strip<span>(</span><span>)</span><span>)</span><span>.</span>encode<span>(</span><span>)</span> <span># 服务端需要一个换行符</span>
        self<span>.</span>sock<span>.</span>send<span>(</span>data<span>)</span>

    <span>def</span> <span>stop</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>sock<span>.</span>close<span>(</span><span>)</span>
        self<span>.</span>event<span>.</span>wait<span>(</span><span>3</span><span>)</span>
        self<span>.</span>event<span>.</span><span>set</span><span>(</span><span>)</span>
        logging<span>.</span>info<span>(</span><span>'Client stops'</span><span>)</span>

<span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    cc <span>=</span> ChatClient<span>(</span><span>)</span>
    cc<span>.</span>start<span>(</span><span>)</span>
    <span>while</span> <span>True</span><span>:</span>
        cmd <span>=</span> <span>input</span><span>(</span><span>'>>>'</span><span>)</span>
        <span>if</span> cmd<span>.</span>strip<span>(</span><span>)</span> <span>==</span> <span>'quit'</span><span>:</span>
            cc<span>.</span>stop<span>(</span><span>)</span>
            <span>break</span>
        cc<span>.</span>send<span>(</span>cmd<span>)</span> <span># 发送消息</span>

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    main<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p>同样，这样的客户端还是有些问题的，仅用于测试。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">13 线程同步</title>
    <id>https://clay-wangzhi.com/code/python/python-thread-sync/</id>
    <link href="https://clay-wangzhi.com/code/python/python-thread-sync/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_13-线程同步"> 13 线程同步</h1>
<h2 id="线程同步概念"> 线程同步概念</h2>
<p>线程同步，线程间协同，通过某种技术，让一个线程访问某些数据时，其他线程不能访问这些数据，直到该线程完成对数据的操作。</p>
<h2 id="event"> Event</h2>
<p>Event 事件，是线程间通信机制中最简单的实现，使用一个内部的标记 flag，通过 flag 的 True 或 False 的变化来进行操作。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>set()</td>
<td>标记设置为True</td>
</tr>
<tr>
<td>clear()</td>
<td>标记设置为False</td>
</tr>
<tr>
<td>is_set()</td>
<td>标记是否为True</td>
</tr>
<tr>
<td>wait(timeout=None)</td>
<td>设置等待标记为True的时长，None为无限等待。等到返回True，未等到超时了返回False</td>
</tr>
</tbody>
</table>
<p><strong>练习</strong></p>
<p>老板雇佣了一个工人，让他生产杯子，老板一直等着这个工人，直到生产了10个杯子</p>
<div><pre><code><span># 下面的代码是否能够完成功能？</span>
<span>from</span> threading <span>import</span> Event<span>,</span> Thread
<span>import</span> logging
<span>import</span> time

FORMAT <span>=</span> <span>'%(asctime)s %(threadName)s %(thread)s %(message)s'</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

cups <span>=</span> <span>[</span><span>]</span>
flag <span>=</span> <span>False</span>

<span>def</span> <span>boss</span><span>(</span><span>)</span><span>:</span>
    logging<span>.</span>info<span>(</span><span>"I'm boss, waiting for U"</span><span>)</span>
    <span>while</span> <span>True</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>if</span> flag<span>:</span>
            <span>break</span>
    logging<span>.</span>info<span>(</span><span>'Good Job.'</span><span>)</span>

<span>def</span> <span>worker</span><span>(</span>count<span>=</span><span>10</span><span>)</span><span>:</span>
    logging<span>.</span>info<span>(</span><span>'I am working for U'</span><span>)</span>

    <span>while</span> <span>True</span><span>:</span>
        logging<span>.</span>info<span>(</span><span>'make 1 cup'</span><span>)</span>
        time<span>.</span>sleep<span>(</span><span>0.5</span><span>)</span>
        cups<span>.</span>append<span>(</span><span>1</span><span>)</span>
        <span>if</span> <span>len</span><span>(</span>cups<span>)</span> <span>>=</span> count<span>:</span>
            flag <span>=</span> <span>True</span>
            <span>break</span>
    logging<span>.</span>info<span>(</span><span>'I finished my job. cups={}'</span><span>.</span><span>format</span><span>(</span>cups<span>)</span><span>)</span>

b <span>=</span> Thread<span>(</span>target<span>=</span>boss<span>,</span> name<span>=</span><span>'boss'</span><span>)</span>
w <span>=</span> Thread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker'</span><span>)</span>
b<span>.</span>start<span>(</span><span>)</span>
w<span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>上面代码基本能够完成，但上面代码问题有：</p>
<ul>
<li>bug，应该将worker中的flag定义为global就可解决</li>
<li>老板一直要不停的查询worker的状态变化</li>
</ul>
<div><pre><code><span># 下面的代码是否能够完成功能？</span>
<span>from</span> threading <span>import</span> Event<span>,</span> Thread
<span>import</span> logging
<span>import</span> time

FORMAT <span>=</span> <span>'%(asctime)s %(threadName)s %(thread)s %(message)s'</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

cups <span>=</span> <span>[</span><span>]</span>
flag <span>=</span> <span>False</span>

<span>def</span> <span>boss</span><span>(</span>event<span>:</span>Event<span>)</span><span>:</span>
    logging<span>.</span>info<span>(</span><span>"I'm boss, waiting for U"</span><span>)</span>
    event<span>.</span>wait<span>(</span><span>)</span> <span># 阻塞等待</span>
    logging<span>.</span>info<span>(</span><span>'Good Job.'</span><span>)</span>

<span>def</span> <span>worker</span><span>(</span>event<span>:</span>Event <span>,</span>count<span>=</span><span>10</span><span>)</span><span>:</span>
    logging<span>.</span>info<span>(</span><span>'I am working for U'</span><span>)</span>

    <span>while</span> <span>True</span><span>:</span>
        logging<span>.</span>info<span>(</span><span>'make 1 cup'</span><span>)</span>
        time<span>.</span>sleep<span>(</span><span>0.5</span><span>)</span>
        cups<span>.</span>append<span>(</span><span>1</span><span>)</span>
        <span>if</span> <span>len</span><span>(</span>cups<span>)</span> <span>>=</span> count<span>:</span>
            event<span>.</span><span>set</span><span>(</span><span>)</span>
            <span>break</span>
    logging<span>.</span>info<span>(</span><span>'I finished my job. cups={}'</span><span>.</span><span>format</span><span>(</span>cups<span>)</span><span>)</span>

event <span>=</span> Event<span>(</span><span>)</span>
b <span>=</span> Thread<span>(</span>target<span>=</span>boss<span>,</span> name<span>=</span><span>'boss'</span><span>,</span> args<span>=</span><span>(</span>event<span>,</span><span>)</span><span>)</span>
w <span>=</span> Thread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker'</span><span>,</span> args<span>=</span><span>(</span>event<span>,</span><span>)</span><span>)</span>
b<span>.</span>start<span>(</span><span>)</span>
w<span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p><strong>总结</strong></p>
<p>需要使用同一个 Event 对象的标记 flag。
谁 wait 就是等到 flag 变为 True，或等到超时返回 False。
不限制等待者的个数，通知所有等待者。</p>
<p><strong>wait 的使用</strong></p>
<div><pre><code><span>def</span> <span>worker</span><span>(</span>event<span>:</span>Event <span>,</span>count<span>=</span><span>10</span><span>)</span><span>:</span>
    logging<span>.</span>info<span>(</span><span>'I am working for U'</span><span>)</span>

    <span>while</span> <span>not</span> event<span>.</span>wait<span>(</span><span>0.5</span><span>)</span><span>:</span> <span># 使用 wait 阻塞等待</span>
        logging<span>.</span>info<span>(</span><span>'make 1 cup'</span><span>)</span>
        cups<span>.</span>append<span>(</span><span>1</span><span>)</span>
        <span>if</span> <span>len</span><span>(</span>cups<span>)</span> <span>>=</span> count<span>:</span>
            event<span>.</span><span>set</span><span>(</span><span>)</span>
            <span># break</span>
    logging<span>.</span>info<span>(</span><span>'I finished my job. cups={}'</span><span>.</span><span>format</span><span>(</span>cups<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="lock"> Lock</h2>
<ul>
<li>Lock 类是 mutex 互斥锁</li>
<li>一旦一个线程获得锁，其它试图获取锁的线程将被阻塞，只到拥有锁的线程释放锁</li>
<li>凡是存在共享资源争抢的地方都可以使用锁，从而保证只有一个使用者可以完全使用这个资源。</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>acquire(blocking=True, timeout=-1)</td>
<td>默认阻塞，阻塞可以设置超时时间。非阻塞时，timeout禁<br/>止设置。<br/>成功获取锁，返回True，否则返回False</td>
</tr>
<tr>
<td>release()</td>
<td>释放锁。可以从任何线程调用释放。<br/>已上锁的锁，会被重置为unlocked<br/>未上锁的锁上调用，抛RuntimeError异常。</td>
</tr>
</tbody>
</table>
<p>锁的基本使用</p>
<div><pre><code><span>import</span> threading
<span>import</span> time

lock <span>=</span> threading<span>.</span>Lock<span>(</span><span>)</span> <span># 互斥 mutex</span>

lock<span>.</span>acquire<span>(</span><span>)</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span><span>30</span><span>)</span>

<span>def</span> <span>worker</span><span>(</span>l<span>:</span>threading<span>.</span>Lock<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'worker start'</span><span>,</span> threading<span>.</span>current_thread<span>(</span><span>)</span><span>)</span>
    l<span>.</span>acquire<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>'worker done'</span><span>,</span> threading<span>.</span>current_thread<span>(</span><span>)</span><span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
    threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>"w{}"</span><span>.</span><span>format</span><span>(</span>i<span>)</span><span>,</span>
                     args<span>=</span><span>(</span>lock<span>,</span><span>)</span><span>,</span> daemon<span>=</span><span>True</span><span>)</span><span>.</span>start<span>(</span><span>)</span>

<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>

<span>while</span> <span>True</span><span>:</span>
    cmd <span>=</span> <span>input</span><span>(</span><span>">>>"</span><span>)</span>
    <span>if</span> cmd <span>==</span> <span>'r'</span><span>:</span> <span># 按 r 后枚举所有线程查看</span>
        lock<span>.</span>release<span>(</span><span>)</span>
        <span>print</span><span>(</span><span>'released one locker'</span><span>)</span>
    <span>elif</span> cmd <span>==</span> <span>'quit'</span><span>:</span>
        lock<span>.</span>release<span>(</span><span>)</span>
        <span>break</span>
    <span>else</span><span>:</span>
        <span>print</span><span>(</span>threading<span>.</span><span>enumerate</span><span>(</span><span>)</span><span>)</span>
        <span>print</span><span>(</span>lock<span>.</span>locked<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>上例可以看出不管在哪一个线程中，只要对一个已经上锁的锁发起阻塞地请求，该线程就会阻塞。</p>
<p><strong>练习</strong>
订单要求生产1000个杯子，组织10个工人生产。请忽略老板，关注工人生成杯子</p>
<div><pre><code><span>from</span> threading <span>import</span> Thread<span>,</span> Lock
<span>import</span> time
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

cups <span>=</span> <span>[</span><span>]</span>

<span>def</span> <span>worker</span><span>(</span>count<span>=</span><span>1000</span><span>)</span><span>:</span>
    logging<span>.</span>info<span>(</span><span>"I'm working"</span><span>)</span>
    <span>while</span> <span>True</span><span>:</span>
        <span>if</span> <span>len</span><span>(</span>cups<span>)</span> <span>>=</span> count<span>:</span>
            <span>break</span>
        time<span>.</span>sleep<span>(</span><span>0.0001</span><span>)</span>
        cups<span>.</span>append<span>(</span><span>1</span><span>)</span>
    logging<span>.</span>info<span>(</span><span>'I finished my job. cups = {}'</span><span>.</span><span>format</span><span>(</span><span>len</span><span>(</span>cups<span>)</span><span>)</span><span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>11</span><span>)</span><span>:</span>
    t <span>=</span> Thread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>"w{}"</span><span>.</span><span>format</span><span>(</span>i<span>)</span><span>,</span> args<span>=</span><span>(</span><span>1000</span><span>,</span><span>)</span><span>)</span>
    t<span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>从上例的运行结果看出，多线程调度，导致了判断失效，多生产了杯子。
如何修改解决这个问题？加锁
上例使用锁实现如下：</p>
<div><pre><code><span>from</span> threading <span>import</span> Thread<span>,</span> Lock
<span>import</span> time
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

cups <span>=</span> <span>[</span><span>]</span>
lock <span>=</span> Lock<span>(</span><span>)</span> <span># 锁</span>

<span>def</span> <span>worker</span><span>(</span>count<span>=</span><span>1000</span><span>)</span><span>:</span>
    logging<span>.</span>info<span>(</span><span>"I'm working"</span><span>)</span>
    <span>while</span> <span>True</span><span>:</span>
        lock<span>.</span>acquire<span>(</span><span>)</span> <span># 获取锁</span>

        <span>if</span> <span>len</span><span>(</span>cups<span>)</span> <span>>=</span> count<span>:</span>
            lock<span>.</span>release<span>(</span><span>)</span> <span># 1</span>
            <span>break</span>
        <span># lock.release() # 2</span>
        time<span>.</span>sleep<span>(</span><span>0.0001</span><span>)</span>
        cups<span>.</span>append<span>(</span><span>1</span><span>)</span>
        lock<span>.</span>release<span>(</span><span>)</span> <span># 3</span>
    logging<span>.</span>info<span>(</span><span>'I finished my job. cups = {}'</span><span>.</span><span>format</span><span>(</span><span>len</span><span>(</span>cups<span>)</span><span>)</span><span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>11</span><span>)</span><span>:</span>
    t <span>=</span> Thread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>"w{}"</span><span>.</span><span>format</span><span>(</span>i<span>)</span><span>,</span> args<span>=</span><span>(</span><span>1000</span><span>,</span><span>)</span><span>)</span>
    t<span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="锁分析"> 锁分析</h3>
<p><strong>位置2分析</strong></p>
<ul>
<li>假设某一个瞬间，有一个工作线程A获取了锁，len(cups)正好有999个，然后就释放了锁，可以继续执行下面的语句，生产一个杯子，这地方不阻塞，但是正好杯子也没有生产完。锁释放后，其他线程就可以获得锁，线程B获得了锁，发现len(cups)也是999个，然后释放锁，然后也可以去生产一个杯子。锁释放后，其他的线也可能获得锁。就说A和B线程都认为是999个，都会生产一个杯子，那么实际上最后一定会超出1000个。</li>
<li>假设某个瞬间一个线程获得锁，然后发现杯子到了1000个，没有释放锁就直接break了，由于其他线程还在阻塞等待锁释放，这就成了死锁了。</li>
</ul>
<p><strong>位置3分析</strong></p>
<ul>
<li>获得锁的线程发现是999，有资格生产杯子，生产一个，释放锁，看似很完美</li>
<li>问题在于，获取锁的线程发现杯子有1000个，直接break，没释放锁离开了，死锁了</li>
</ul>
<p>位置1分析</p>
<ul>
<li>如果线程获得锁，发现是1000，break前释放锁，没问题
问题在于，A线程获得锁后，发现小于1000，继续执行，其他线程获得锁全部阻塞。A线程再次执行循环后，自己也阻塞了。死锁了。</li>
</ul>
<p>问题：究竟怎样加锁才正确呢？</p>
<p>要在位置1和位置3同时加release。</p>
<h3 id="上下文支持"> 上下文支持</h3>
<p>锁是典型必须释放的，Python提供了上下文支持。查看Lock类的上下文方法，<code>__enter__</code>方法返回bool表示是否获得锁，<code>__exit__</code>方法中释放锁。</p>
<p>由此上例可以修改为</p>
<div><pre><code><span>from</span> threading <span>import</span> Thread<span>,</span> Lock
<span>import</span> time
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

cups <span>=</span> <span>[</span><span>]</span>
lock <span>=</span> Lock<span>(</span><span>)</span> <span># 锁</span>

<span>def</span> <span>worker</span><span>(</span>count<span>=</span><span>1000</span><span>)</span><span>:</span>
    logging<span>.</span>info<span>(</span><span>"I'm working"</span><span>)</span>
    <span>while</span> <span>True</span><span>:</span>
        <span>with</span> lock<span>:</span>
            <span>if</span> <span>len</span><span>(</span>cups<span>)</span> <span>>=</span> count<span>:</span>
                <span>break</span>
            time<span>.</span>sleep<span>(</span><span>0.0001</span><span>)</span>
            cups<span>.</span>append<span>(</span><span>1</span><span>)</span>
    logging<span>.</span>info<span>(</span><span>'I finished my job. cups = {}'</span><span>.</span><span>format</span><span>(</span><span>len</span><span>(</span>cups<span>)</span><span>)</span><span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>11</span><span>)</span><span>:</span>
    t <span>=</span> Thread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>"w{}"</span><span>.</span><span>format</span><span>(</span>i<span>)</span><span>,</span> args<span>=</span><span>(</span><span>1000</span><span>,</span><span>)</span><span>)</span>
    t<span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>感觉一下正确得到结果了吗？感觉到了执行速度了吗？慢了还是快了，为什么？</p>
<h3 id="锁的应用场景"> 锁的应用场景</h3>
<p>锁适用于访问和修改同一个共享资源的时候，即读写同一个资源的时候。</p>
<p>如果全部都是读取同一个共享资源需要锁吗？
不需要。因为这时可以认为共享资源是不可变的，每一次读取它都是一样的值，所以不用加锁</p>
<p>使用锁的注意事项：</p>
<ul>
<li>少用锁，必要时用锁。使用了锁，多线程访问被锁的资源时，就成了串行，要么排队执行，要么争抢执行
举例，高速公路上车并行跑，可是到了省界只开放了一个收费口，过了这个口，车辆依然可以在多车道上一起跑。过收费口的时候，如果排队一辆辆过，加不加锁一样效率相当，但是一旦出现争抢，就必须加锁一辆辆过。注意，不管加不加锁，只要是一辆辆过，效率就下降了。</li>
<li>加锁时间越短越好，不需要就立即释放锁</li>
<li>一定要避免死锁</li>
</ul>
<p>不使用锁，有了效率，但是结果是错的。
使用了锁，效率低下，但是结果是对的。
所以，我们是为了效率要错误结果呢？还是为了对的结果，让计算机去计算吧</p>
<h3 id="非阻塞锁使用"> 非阻塞锁使用</h3>
<div><pre><code><span>from</span> threading <span>import</span> Thread<span>,</span> Lock
<span>import</span> time
<span>import</span> logging

FORMAT <span>=</span> <span>"%(asctime)s %(threadName)s %(thread)d %(message)s"</span>
logging<span>.</span>basicConfig<span>(</span><span>format</span><span>=</span>FORMAT<span>,</span> level<span>=</span>logging<span>.</span>INFO<span>)</span>

lock <span>=</span> Lock<span>(</span><span>)</span>

<span>def</span> <span>worker</span><span>(</span>l<span>:</span>Lock<span>)</span><span>:</span>
    <span>while</span> <span>True</span><span>:</span>
        flag <span>=</span> l<span>.</span>acquire<span>(</span><span>False</span><span>)</span>
        <span># flag = l.acquire()</span>
        <span>if</span> flag<span>:</span>
            logging<span>.</span>info<span>(</span><span>'do sth.'</span><span>)</span>
            time<span>.</span>sleep<span>(</span><span>2</span><span>)</span> <span># 拿到锁做事情</span>
            l<span>.</span>release<span>(</span><span>)</span>
        <span>else</span><span>:</span>
            logging<span>.</span>info<span>(</span><span>'try again'</span><span>)</span> <span># 没拿到锁，重试</span>
            time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>5</span><span>)</span><span>:</span>
    Thread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span><span>f"w-</span><span><span>{</span>i<span>}</span></span><span>"</span></span><span>,</span> args<span>=</span><span>(</span>lock<span>,</span><span>)</span><span>)</span><span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="queue的线程安全"> Queue的线程安全</h2>
<p>标准库queue模块，提供FIFO的Queue、LIFO的队列、优先队列。</p>
<p>Queue类是线程安全的，适用于同一进程内多线程间安全的交换数据。内部使用了Lock和Condition。</p>
<p>特别注意下面的代码在多线程中使用</p>
<div><pre><code><span>import</span> queue

q <span>=</span> queue<span>.</span>Queue<span>(</span><span>8</span><span>)</span>

<span>if</span> q<span>.</span>qsize<span>(</span><span>)</span> <span>==</span> <span>7</span><span>:</span>
    <span>print</span><span>(</span>q<span>)</span>
    q<span>.</span>put<span>(</span><span>)</span> <span># 上下两句可能被打断</span>

<span>if</span> q<span>.</span>qsize<span>(</span><span>)</span> <span>==</span> <span>1</span><span>:</span>
    <span>print</span><span>(</span>q<span>)</span>
    q<span>.</span>get<span>(</span><span>)</span> <span># 未必会成功</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果不加锁，是不可能获得准确的大小的，因为你刚读取到了一个大小，还没有取走数据，就有可能被其他线程改了。
Queue 类的 size 虽然加了锁，但是，依然不能保证立即 get、put 就能成功，因为读取大小和 get、put 方法是分开的。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">12 线程</title>
    <id>https://clay-wangzhi.com/code/python/python-thread/</id>
    <link href="https://clay-wangzhi.com/code/python/python-thread/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_12-线程"> 12 线程</h1>
<h2 id="并发"> 并发</h2>
<p><strong>并发和并行区别</strong></p>
<p>并行，parallel
同时做某些事，可以互不干扰的同一个时刻做几件事</p>
<p>并发，concurrency
也是同时做某些事，但是强调，一个时段内有事情要处理。</p>
<p>举例
高速公路的车道，双向4车道，所有车辆（数据）可以互不干扰的在自己的车道上奔跑（传输）。
在同一个时刻，每条车道上可能同时有车辆在跑，是同时发生的概念，这是并行。
在一段时间内，有这么多车要通过，这是并发。</p>
<p>并行不过是使用水平扩展方式解决并发的一种手段而已。</p>
<h2 id="进程和线程"> 进程和线程</h2>
<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>
<p>进程和程序的关系：程序是源代码编译后的文件，而这些文件存放在磁盘上。当程序被操作系统加载到内存中，就是进程，进程中存放着指令和数据（资源）。一个程序的执行实例就是一个进程。它也是线程的容器。</p>
<p>Linux进程有父进程、子进程，Windows的进程是平等关系。</p>
<p>在实现了线程的操作系统中，线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>
<p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。
一个标准的线程由线程ID，当前指令指针(PC）、寄存器集合和堆、栈组成。</p>
<p>在许多系统中，创建一个线程比创建一个进程快10-100倍。</p>
<h3 id="进程、线程的理解"> 进程、线程的理解</h3>
<p>现代操作系统提出进程的概念，每一个进程都认为自己独占所有的计算机硬件资源。
进程就是独立的王国，进程间不可以随便的共享数据。
线程就是省份，同一个进程内的线程可以共享进程的资源，每一个线程拥有自己独立的堆栈。</p>
<h3 id="线程的状态"> 线程的状态</h3>
<ul>
<li>就绪（Ready）：线程能够运行，但在等待被调度。可能线程刚刚创建启动，或刚刚从阻塞中恢复，或者被其他线程抢占</li>
<li>运行（Running）：线程正在运行</li>
<li>阻塞（Blocked）：线程等待外部事件发生而无法运行，如 I/O 操作</li>
<li>终止（Terminated）：线程完成，或退出，或被取消</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/thread.png" alt="thread" /></p>
<p><strong>python 中的进程和线程</strong></p>
<p>运行程序会启动一个解释器进程，线程共享一个解释器进程。</p>
<h2 id="python的线程开发"> Python的线程开发</h2>
<p>Python 的线程开发使用标准库 threading。</p>
<p>进程靠线程执行代码，至少有一个<strong>主线程</strong>，其它线程是工作线程。
主线程是第一个启动的线程。</p>
<p>父线程：如果线程A中启动了一个线程B，A就是B的父线程。
子线程：B就是A的子线程。</p>
<h3 id="thread类"> Thread类</h3>
<div><pre><code><span># 签名</span>
<span>def</span> <span>__init__</span><span>(</span>self<span>,</span> group<span>=</span><span>None</span><span>,</span> target<span>=</span><span>None</span><span>,</span> name<span>=</span><span>None</span><span>,</span> args<span>=</span><span>(</span><span>)</span><span>,</span> kwargs<span>=</span><span>None</span><span>,</span> <span>*</span><span>,</span> daemon<span>=</span><span>None</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><table>
<thead>
<tr>
<th>参数名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>线程调用的对象，就是目标函数</td>
</tr>
<tr>
<td>name</td>
<td>为线程起个名字</td>
</tr>
<tr>
<td>args</td>
<td>为目标函数传递实参，元组</td>
</tr>
<tr>
<td>kwargs</td>
<td>为目标函数关键字传参，字典</td>
</tr>
</tbody>
</table>
<h3 id="线程启动"> 线程启动</h3>
<div><pre><code><span>import</span> threading

<span># 最简单的线程程序</span>
<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
	<span>print</span><span>(</span><span>"I'm working"</span><span>)</span>
	<span>print</span><span>(</span><span>'Fineshed'</span><span>)</span>
    
t <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker'</span><span>)</span> <span># 线程对象</span>
t<span>.</span>start<span>(</span><span>)</span> <span># 启动</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>通过threading.Thread创建一个线程对象，target是目标函数，可以使用name为线程指定名称。
但是线程没有启动，需要调用start方法。</p>
<p>线程之所以执行函数，是因为线程中就是要执行代码的，而最简单的代码封装就是函数，所以还是函数调用。
函数执行完，线程也就退出了。
那么，如果不让线程退出，或者让线程一直工作怎么办呢？</p>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    <span>while</span> <span>True</span><span>:</span> <span># for i in range(10):</span>
        time<span>.</span>sleep<span>(</span><span>0.5</span><span>)</span>
        <span>print</span><span>(</span><span>"I'm working"</span><span>)</span>
    <span>print</span><span>(</span><span>'Fineshed'</span><span>)</span>
    
t <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker'</span><span>)</span> <span># 线程对象</span>
t<span>.</span>start<span>(</span><span>)</span> <span># 启动</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="线程退出"> 线程退出</h3>
<p>Python没有提供线程退出的方法，线程在下面情况时退出
1、线程函数内语句执行完毕
2、线程函数中抛出未处理的异常</p>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>0.5</span><span>)</span>
        <span>if</span> i <span>></span> <span>5</span><span>:</span>
            <span>#break # 终止循环</span>
            <span>#return # 函数返回</span>
            <span>raise</span> RuntimeError <span># 抛异常</span>
    	<span>print</span><span>(</span><span>'I am working'</span><span>)</span>
    <span>print</span><span>(</span><span>'finished'</span><span>)</span>
    
t <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker'</span><span>)</span>
t<span>.</span>start<span>(</span><span>)</span>
<span>print</span><span>(</span><span>'='</span> <span>*</span> <span>30</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>Python的线程没有优先级、没有线程组的概念，也不能被销毁、停止、挂起，那也就没有恢复、中断了。</p>
<h3 id="线程的传参"> 线程的传参</h3>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
	<span>print</span><span>(</span><span>'{} + {} = {}'</span><span>.</span><span>format</span><span>(</span>x<span>,</span> y<span>,</span> x <span>+</span> y<span>,</span> threading<span>.</span>current_thread<span>(</span><span>)</span><span>.</span>ident<span>)</span><span>)</span>
    
t1 <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>add<span>,</span> name<span>=</span><span>'add'</span><span>,</span> args<span>=</span><span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span><span>)</span>
t1<span>.</span>start<span>(</span><span>)</span>
time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>

t2 <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>add<span>,</span> name<span>=</span><span>'add'</span><span>,</span> args<span>=</span><span>(</span><span>6</span><span>,</span><span>)</span><span>,</span> kwargs<span>=</span><span>{</span><span>'y'</span><span>:</span><span>7</span><span>}</span><span>)</span>
t2<span>.</span>start<span>(</span><span>)</span>
time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>

t3 <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>add<span>,</span> name<span>=</span><span>'add'</span><span>,</span> kwargs<span>=</span><span>{</span><span>'x'</span><span>:</span><span>8</span><span>,</span> <span>'y'</span><span>:</span><span>9</span><span>}</span><span>)</span>
t3<span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>线程传参和函数传参没什么区别，本质上就是函数传参。</p>
<h3 id="threading-的属性和方法"> threading 的属性和方法</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>current_thread()</td>
<td>返回当前线程对象</td>
</tr>
<tr>
<td>main_thread()</td>
<td>返回主线程对象</td>
</tr>
<tr>
<td>active_count()</td>
<td>当前处于alive状态的线程个数</td>
</tr>
<tr>
<td>enumerate()</td>
<td>返回所有活着的线程的列表，不包括已经终止的线程和未开始的线程</td>
</tr>
<tr>
<td>get_ident()</td>
<td>返回当前线程的ID，非0整数</td>
</tr>
</tbody>
</table>
<p>active_count、enumerate 方法返回的值还包括主线程。</p>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>def</span> <span>showtreadinfo</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'current thread = {}\nmain thread = {}\nactive count = {}'</span><span>.</span><span>format</span><span>(</span>
    threading<span>.</span>current_thread<span>(</span><span>)</span><span>,</span> threading<span>.</span>main_thread<span>(</span><span>)</span><span>,</span> threading<span>.</span>active_count<span>(</span><span>)</span>
    <span>)</span><span>)</span>
    
<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    showtreadinfo<span>(</span><span>)</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>5</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>'i am working'</span><span>)</span>
    <span>print</span><span>(</span><span>'finished'</span><span>)</span>
    
t <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker'</span><span>)</span> <span># 线程对象</span>
showtreadinfo<span>(</span><span>)</span>
time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
t<span>.</span>start<span>(</span><span>)</span> <span># 启动</span>
<span>print</span><span>(</span><span>'===end==='</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="thread-实例的属性和方法"> Thread 实例的属性和方法</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>只是一个名字，只是个标识，名称可以重名。getName()、setName() 获取、设置这个名词</td>
</tr>
<tr>
<td>ident</td>
<td>线程ID，它是非0整数。线程启动后才会有ID，否则为None。线程退出，此ID依旧可以访问。此ID可以重复使用</td>
</tr>
<tr>
<td>is_alive()</td>
<td>返回线程是否活着</td>
</tr>
</tbody>
</table>
<p>注意：线程的name这是一个名称，可以重复；ID必须唯一，但可以在线程退出后再利用。</p>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>5</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>'i am working'</span><span>)</span>
    <span>print</span><span>(</span><span>'finished'</span><span>)</span>

t <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker'</span><span>)</span> <span># 线程对象</span>
<span>print</span><span>(</span>t<span>.</span>name<span>,</span> t<span>.</span>ident<span>)</span>
time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
t<span>.</span>start<span>(</span><span>)</span> <span># 启动</span>

<span>print</span><span>(</span><span>'===end==='</span><span>)</span>

<span>while</span> <span>True</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span>'{} {} {}'</span><span>.</span><span>format</span><span>(</span>t<span>.</span>name<span>,</span> t<span>.</span>ident<span>,</span>
    <span>'alive'</span> <span>if</span> t<span>.</span>is_alive<span>(</span><span>)</span> <span>else</span> <span>'dead'</span><span>)</span><span>)</span>
    <span>if</span> <span>not</span> t<span>.</span>is_alive<span>(</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'{} restart'</span><span>.</span><span>format</span><span>(</span>t<span>.</span>name<span>)</span><span>)</span>
        t<span>.</span>start<span>(</span><span>)</span> <span># 线程重启？？ 报错 线程只可以启动一次</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>start()</td>
<td>启动线程。每一个线程必须且只能执行该方法一次</td>
</tr>
<tr>
<td>run()</td>
<td>运行线程函数</td>
</tr>
</tbody>
</table>
<p>为了演示，派生一个Thread的子类</p>
<p><strong>start  方法</strong></p>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>5</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>'i am working'</span><span>)</span>
    <span>print</span><span>(</span><span>'finished'</span><span>)</span>

<span>class</span> <span>MyThread</span><span>(</span>threading<span>.</span>Thread<span>)</span><span>:</span>
    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'start~~~~'</span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>start<span>(</span><span>)</span>
        
    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'run~~~~~~'</span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>run<span>(</span><span>)</span>

t <span>=</span> MyThread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker'</span><span>)</span>
t<span>.</span>start<span>(</span><span>)</span>

<span># 运行结果</span>
start<span>~</span><span>~</span><span>~</span><span>~</span>
run<span>~</span><span>~</span><span>~</span><span>~</span><span>~</span><span>~</span>
i am working
i am working
i am working
i am working
i am working
finished
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p><strong>run 方法</strong></p>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>5</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>'i am working'</span><span>)</span>
    <span>print</span><span>(</span><span>'finished'</span><span>)</span>

<span>class</span> <span>MyThread</span><span>(</span>threading<span>.</span>Thread<span>)</span><span>:</span>
    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'start~~~~'</span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>start<span>(</span><span>)</span>

    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'run~~~~~~'</span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>run<span>(</span><span>)</span>

t <span>=</span> MyThread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker'</span><span>)</span>
<span># t.start()</span>
t<span>.</span>run<span>(</span><span>)</span> <span># 也不可执行多次</span>

<span># 运行结果</span>
run<span>~</span><span>~</span><span>~</span><span>~</span><span>~</span><span>~</span>
i am working
i am working
i am working
i am working
i am working
finished
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>start() 方法会调用 run() 方法，而 run() 方法可以运行函数。
这两个方法看似功能重复了，这么看来留一个方法就可以了。是这样吗？</p>
<p><strong>start和run的区别</strong></p>
<p>在线程函数中，增加打印线程的名字的语句，看看能看到什么信息。</p>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>threading<span>.</span><span>enumerate</span><span>(</span><span>)</span><span>)</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>5</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>'i am working'</span><span>)</span>
    <span>print</span><span>(</span><span>'finished'</span><span>)</span>

<span>class</span> <span>MyThread</span><span>(</span>threading<span>.</span>Thread<span>)</span><span>:</span>
    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'start~~~~'</span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>start<span>(</span><span>)</span>

    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'run~~~~~~'</span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>run<span>(</span><span>)</span>

t <span>=</span> MyThread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker'</span><span>)</span>
t<span>.</span>start<span>(</span><span>)</span>
<span># t.run() # 分别执行start或者run方法</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>使用start方法启动线程，启动了一个新的线程，名字叫做worker运行。但是使用run方法的，并没有启动新的线程，就是在主线程中调用了一个普通的函数而已。</p>
<p>因此，启动线程请使用start方法，且对于这个线程来说，start方法只能调用一次。（设置_started属性实现）</p>
<h2 id="多线程"> 多线程</h2>
<p>顾名思义，多个线程，一个进程中如果有多个线程运行，就是多线程，实现一种并发。</p>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    t <span>=</span> threading<span>.</span>current_thread<span>(</span><span>)</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>5</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>'i am working'</span><span>,</span> t<span>.</span>name<span>,</span> t<span>.</span>ident<span>)</span>
    <span>print</span><span>(</span><span>'finished'</span><span>)</span>
    
<span>class</span> <span>MyThread</span><span>(</span>threading<span>.</span>Thread<span>)</span><span>:</span>
    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'start~~~~'</span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>start<span>(</span><span>)</span>
        
    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'run~~~~~~'</span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>run<span>(</span><span>)</span>
    
t1 <span>=</span> MyThread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker1'</span><span>)</span>
t2 <span>=</span> MyThread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker2'</span><span>)</span>
t1<span>.</span>start<span>(</span><span>)</span>
t2<span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>可以看到 worker1 和 worker2 交替执行，改成 run 方法试试看</p>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    t <span>=</span> threading<span>.</span>current_thread<span>(</span><span>)</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>5</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>'i am working'</span><span>,</span> t<span>.</span>name<span>,</span> t<span>.</span>ident<span>)</span>
    <span>print</span><span>(</span><span>'finished'</span><span>)</span>
    
<span>class</span> <span>MyThread</span><span>(</span>threading<span>.</span>Thread<span>)</span><span>:</span>
    <span>def</span> <span>start</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'start~~~~'</span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>start<span>(</span><span>)</span>
        
    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'run~~~~~~'</span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>run<span>(</span><span>)</span>
    
t1 <span>=</span> MyThread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker1'</span><span>)</span>
t2 <span>=</span> MyThread<span>(</span>target<span>=</span>worker<span>,</span> name<span>=</span><span>'worker2'</span><span>)</span>
<span># t1.start()</span>
<span># t2.start()</span>
t1<span>.</span>run<span>(</span><span>)</span>
t2<span>.</span>run<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>没有开新的线程，这就是普通函数调用，所以执行完 t1.run() ，然后执行 t2.run() ，这里就不是多线程。
当使用 start 方法启动线程后，进程内有多个活动的线程并行的工作，就是多线程。</p>
<p>一个进程中至少有一个线程，并作为程序的入口，这个线程就是主线程。
一个进程至少有一个主线程。
其他线程称为工作线程。</p>
<h2 id="线程安全"> 线程安全</h2>
<p>多线程执行一段代码，不会产生不确定的结果，那这段代码就是线程安全的。</p>
<p>多线程在运行过程中，由于共享同一进程中的数据，多线程并发使用同一个数据，那么数据就有可能被相互修改，从而导致某些时刻无法确定这个数据的值，最终随着多线程运行，运行结果不可预期，这就是线程不安全。</p>
<h2 id="deamon-线程"> deamon 线程</h2>
<p>注：有人翻译成后台线程，也有人翻译成守护线程。</p>
<p>Python中，构造线程的时候，可以设置daemon属性，这个属性必须在start方法前设置好。</p>
<div><pre><code><span># 源码Thread的__init__方法中</span>
<span>if</span> daemon <span>is</span> <span>not</span> <span>None</span><span>:</span>
	self<span>.</span>_daemonic <span>=</span> daemon <span># 用户设定bool值</span>
<span>else</span><span>:</span>
	self<span>.</span>_daemonic <span>=</span> current_thread<span>(</span><span>)</span><span>.</span>daemon
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>线程daemon属性，如果设定就是用户的设置，否则就取当前线程的daemon值。
主线程是non-daemon线程，即daemon = False。</p>
<div><pre><code><span>class</span> <span>_MainThread</span><span>(</span>Thread<span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
    	Thread<span>.</span>__init__<span>(</span>self<span>,</span> name<span>=</span><span>"MainThread"</span><span>,</span> daemon<span>=</span><span>False</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>import</span> time
<span>import</span> threading

<span>def</span> <span>foo</span><span>(</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>5</span><span>)</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>20</span><span>)</span><span>:</span>
    	<span>print</span><span>(</span>i<span>)</span>
        
<span># 主线程是non-daemon线程</span>
t <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>foo<span>,</span> daemon<span>=</span><span>False</span><span>)</span>
t<span>.</span>start<span>(</span><span>)</span>

<span>print</span><span>(</span><span>'Main Thread Exits'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>发现线程t依然执行，主线程已经执行完，但是一直等着线程 t。
修改为  t = threading.Thread(target=foo, daemon=True)  试一试，结果程序立即结束了，进程根本没有等daemon 线程t。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>daemon 属性</td>
<td>表示线程是否是daemon线程，这个值必须在start()之前设置，否则引发<br/>RuntimeError异常</td>
</tr>
<tr>
<td>isDaemon()</td>
<td>是否是daemon线程</td>
</tr>
<tr>
<td>setDaemon()</td>
<td>设置为daemon线程，必须在start方法之前设置</td>
</tr>
</tbody>
</table>
<p>看一个例子，，看看主线程何时结束 daemon 线程</p>
<div><pre><code><span>import</span> time
<span>import</span> threading

<span>def</span> <span>worker</span><span>(</span>name<span>,</span> timeout<span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span>timeout<span>)</span>
    <span>print</span><span>(</span><span>'{} working'</span><span>.</span><span>format</span><span>(</span>name<span>)</span><span>)</span>
    
<span># 主线程 是non-daemon线程</span>
t1 <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>,</span> args<span>=</span><span>(</span><span>'t1'</span><span>,</span> <span>5</span><span>)</span><span>,</span> daemon<span>=</span><span>True</span><span>)</span> <span># 调换5和10看看效果</span>
t1<span>.</span>start<span>(</span><span>)</span>

t2 <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>,</span> args<span>=</span><span>(</span><span>'t2'</span><span>,</span> <span>10</span><span>)</span><span>,</span> daemon<span>=</span><span>False</span><span>)</span>
t2<span>.</span>start<span>(</span><span>)</span>

<span>print</span><span>(</span><span>'Main Thread Exits'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>上例说明，如果除主线程之外还有 non-daemon 线程的时候，主线程退出时，进程也不会杀掉所有 daemon 线程，直到所有 non-daemon 线程全部结束，如果还有 daemon 线程，主线程需要退出（主线程退出也可以理解为最后一个non-daemon线程也要退出了），进程会结束所有 daemon 线程，程序退出。</p>
<p><strong>总结</strong></p>
<ul>
<li>线程具有一个daemon属性，可以手动设置为True或False，也可以不设置，则取默认值None</li>
<li>如果不设置daemon，就取当前线程的daemon来设置它</li>
<li>主线程是non-daemon线程，即daemon = False</li>
<li>从主线程创建的所有线程的不设置daemon属性，则默认都是daemon = False，也就是non-daemon线程</li>
<li>Python程序在没有活着的non-daemon线程运行时，程序退出，也就是除主线程之外剩下的只能都是daemon线程，主线程才能退出，否则主线程就只能等待</li>
</ul>
<h2 id="join-方法"> join 方法</h2>
<p>先看一个简单的例子，看看效果</p>
<div><pre><code><span>import</span> time
<span>import</span> threading

<span>def</span> <span>worker</span><span>(</span>name<span>,</span> timeout<span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span>timeout<span>)</span>
    <span>print</span><span>(</span><span>'{} working'</span><span>.</span><span>format</span><span>(</span>name<span>)</span><span>)</span>
    
t1 <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>,</span> args<span>=</span><span>(</span><span>'t1'</span><span>,</span> <span>3</span><span>)</span><span>,</span> daemon<span>=</span><span>True</span><span>)</span>
t1<span>.</span>start<span>(</span><span>)</span>
t1<span>.</span>join<span>(</span><span>)</span><span># 设置join，取消join对比一下</span>

<span>print</span><span>(</span><span>'Main Thread Exits'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>使用了 join 方法后，当前线程阻塞了，daemon 线程执行完了，主线程才退出了。</p>
<div><pre><code><span>import</span> time
<span>import</span> threading

<span>def</span> <span>worker</span><span>(</span>name<span>,</span> timeout<span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span>timeout<span>)</span>
    <span>print</span><span>(</span><span>'{} working'</span><span>.</span><span>format</span><span>(</span>name<span>)</span><span>)</span>
    
t1 <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>,</span> args<span>=</span><span>(</span><span>'t1'</span><span>,</span> <span>10</span><span>)</span><span>,</span> daemon<span>=</span><span>True</span><span>)</span>
t1<span>.</span>start<span>(</span><span>)</span>
t1<span>.</span>join<span>(</span><span>2</span><span>)</span>
<span>print</span><span>(</span><span>'~~~~~~~~~~~'</span><span>)</span>
t1<span>.</span>join<span>(</span><span>2</span><span>)</span>
<span>print</span><span>(</span><span>'~~~~~~~~~~~'</span><span>)</span>

<span>print</span><span>(</span><span>'Main Thread Exits'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><code>join(timeout=None)</code></p>
<ul>
<li>join 方法是线程的标准方法之一</li>
<li>一个线程中调用另一个线程的 join 方法，调用者将被阻塞，直到被调用线程终止，或阻塞超时</li>
<li>一个线程可以被 join 多次</li>
<li>timeout 参数指定调用者等待多久，没有设置超时，就一直等到被调用线程结束</li>
<li>调用谁的 join 方法，就是 join 谁，就要等谁</li>
</ul>
<h2 id="daemon线程应用场景"> daemon线程应用场景</h2>
<p>主要应用场景有：</p>
<ol>
<li>后台任务。如发送心跳包、监控，这种场景最多</li>
<li>主线程工作才有用的线程。如主线程中维护这公共的资源，主线程已经清理了，准备退出，而工作线程使用这些资源工作也没有意义了，一起退出最合适</li>
<li>随时可以被终止的线程</li>
</ol>
<p>如果主线程退出，想所有其它工作线程一起退出，就使用daemon=True来创建工作线程。
比如，开启一个线程定时判断WEB服务是否正常工作，主线程退出，工作线程也没有必须存在了，应该随着主线程退出一起退出。这种daemon线程一旦创建，就可以忘记它了，只用关心主线程什么时候退出就行了。</p>
<p>daemon线程，简化了程序员手动关闭线程的工作。</p>
<h2 id="threading-local-类"> threading.local 类</h2>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    x <span>=</span> <span>0</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>100</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>0.0001</span><span>)</span>
        x <span>+=</span> <span>1</span>
    <span>print</span><span>(</span>threading<span>.</span>current_thread<span>(</span><span>)</span><span>,</span> x<span>)</span>
    
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
	threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>)</span><span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>上例使用多线程，每个线程完成不同的计算任务。
x是局部变量，可以看出每一个线程的x是独立的，互不干扰的，为什么？</p>
<p>能否改造成使用全局变量完成？</p>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>x <span>=</span> <span>0</span>

<span># 全局对象</span>
global_data <span>=</span> A<span>(</span><span>)</span>

<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    global_data<span>.</span>x <span>=</span> <span>0</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>100</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>0.0001</span><span>)</span>
        global_data<span>.</span>x <span>+=</span> <span>1</span>
    <span>print</span><span>(</span>threading<span>.</span>current_thread<span>(</span><span>)</span><span>,</span> global_data<span>.</span>x<span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
    threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>)</span><span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>上例虽然使用了全局对象，但是线程之间互相干扰，导致了不期望的结果。<strong>线程不安全</strong>。</p>
<p>能不能既使用全局对象，还能保持每个线程使用不同的数据呢？</p>
<p>python 提供 threading.local 类，将这个类实例化得到一个全局对象，但是不同的线程使用这个对象存储的数据其他线程看不见。</p>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span># 全局对象</span>
global_data <span>=</span> threading<span>.</span>local<span>(</span><span>)</span>

<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    global_data<span>.</span>x <span>=</span> <span>0</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>100</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>0.0001</span><span>)</span>
        global_data<span>.</span>x <span>+=</span> <span>1</span>
    <span>print</span><span>(</span>threading<span>.</span>current_thread<span>(</span><span>)</span><span>,</span> global_data<span>.</span>x<span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
    threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>)</span><span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>结果显示和使用局部变量的效果一样。</p>
<p>再看 threading.local 的例子</p>
<div><pre><code><span>import</span> threading

X <span>=</span> <span>'abc'</span>
global_data <span>=</span> threading<span>.</span>local<span>(</span><span>)</span> <span># 注意这个对象所处的线程</span>
global_data<span>.</span>x <span>=</span> <span>100</span>

<span>print</span><span>(</span>global_data<span>,</span> <span>type</span><span>(</span>global_data<span>)</span><span>,</span> global_data<span>.</span>x<span>)</span>
<span>def</span> <span>worker</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>X<span>)</span>
    <span>print</span><span>(</span>global_data<span>)</span>
    <span>print</span><span>(</span>global_data<span>.</span>x<span>)</span>
    <span>print</span><span>(</span><span>'in worker'</span><span>)</span>
    
worker<span>(</span><span>)</span> <span># 普通函数调用</span>
<span>print</span><span>(</span><span>'-'</span> <span>*</span> <span>30</span><span>)</span>
threading<span>.</span>Thread<span>(</span>target<span>=</span>worker<span>)</span><span>.</span>start<span>(</span><span>)</span> <span># 启动一个线程</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>从运行结果来看，另起一个线程打印 global_data.x 出错了。</p>
<p><code>AttributeError: '_thread._local' object has no attribute 'x'</code></p>
<p>但是，global_data 打印没有出错，说明看到 global_data，但是 global_data 中的 x 看不到，这个 x 不能跨线程。
threading.local类构建了一个大字典，存放所有线程相关的字典，定义如下：
<code>{ id(Thread) -&gt; (ref(Thread), thread-local dict) }</code></p>
<p>每一线程实例的 id 为 key，元组为 value。</p>
<p>value中2部分为，线程对象引用，每个线程自己的字典。</p>
<blockquote>
<p>本质</p>
<p>运行时，threading.local 实例处在不同的线程中，就从大字典中找到当前线程相关键值对中的字典，覆盖threading.local 实例的 <code>__dict__</code> 。</p>
<p>这样就可以在不同的线程中，安全地使用线程独有的数据，做到了线程间数据隔离，如同本地变量一样安全。</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Python 学习笔记</title>
    <id>https://clay-wangzhi.com/code/python/</id>
    <link href="https://clay-wangzhi.com/code/python/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="python-学习笔记"> Python 学习笔记</h1>
<p>Hello Python~</p>
<h1 id="summary"> Summary</h1>
<ul>
<li><a href="./python-basic-grammar.html">01 Python基础语法</a></li>
<li><a href="./python-linear-data-structure.html">02 线性数据结构</a></li>
<li><a href="./python-ha-tables-analytic-expre.html">03 哈希表和解析式</a></li>
<li><a href="./python-function.html">04 函数</a></li>
<li><a href="./python-decorator.html">05 装饰器</a></li>
<li><a href="./python-dir-file-pro.html">06 目录文件处理</a></li>
<li><a href="./python-serialize.html">07 序列化和反序列化</a></li>
<li><a href="./python-exception.html">08 异常处理</a></li>
<li><a href="./python-oo-package.html">09 面向对象-封装</a></li>
<li><a href="./python-oo-inher-pol.html">10 继承多态和Mixin</a></li>
<li><a href="./python-magic.html">11 魔术方法</a></li>
<li><a href="./python-thread.html">12 线程</a></li>
<li><a href="./python-thread-sync.html">13 线程同步</a></li>
<li><a href="./python-gil-multiprocessing.html">14 多进程</a></li>
<li><a href="./python-tcp-pg.html">15 TCP 编程</a></li>
<li><a href="./python-socketserver.html">16 SocketServer</a></li>
<li><a href="./python-io-model.html">17 IO 模型</a></li>
<li><a href="./python-instance.html">18 python实例</a></li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">附录 F. I/O 与 I/O 重定向详细介绍</title>
    <id>https://clay-wangzhi.com/code/shell/appendix/F_io_and_redirection/</id>
    <link href="https://clay-wangzhi.com/code/shell/appendix/F_io_and_redirection/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="附录-f-i-o-与-i-o-重定向详细介绍"> 附录 F. I/O 与 I/O 重定向详细介绍</h1>
<p>一个指令会预期前三个文件描述符可用。第一个， <em>fd 0</em> (标准输入， <code>stdin</code>) 用于读取。其他两个 (<em>fd 1</em>, <code>stdout</code> 和 <em>fd 2</em>, <code>stderr</code>) 用于写入。</p>
<p>每个指令都关联着一个 <code>stdin</code>, <code>stdout</code> 和 <code>stderr</code> 。<strong><code>ls 2&gt;&amp;1</code></strong> 意味着临时将 ls 的 <code>stderr</code> 连接到与 Shell 的 <code>stdout</code> 一样的「资源」。</p>
<p>按照惯例，指令从 fd 0 (<code>stdin</code>) 读取输入，正常输出打印到 fd 1 (<code>stdin</code>)，错误输出打印到 fd 2 (<code>stderr</code>)。如果这三个文件描述符有一个没被打开，你可能会碰上问题：</p>
<div><pre><code>bash$ <span>cat</span> /etc/passwd <span>>&amp;</span>-
cat: standard output: Bad <span>file</span> descriptor
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>例如，当 <strong>xterm</strong> 运行，它首先自我初始化。在运行用户的 Shell 之前， <strong>xterm</strong> 会打开终端设备 (/dev/pts/<n> 或类似) 三次。</p>
<p>此时 Bash 继承这三个文件描述符，且每个 Bash 运行的指令 (子进程) 因此继承它们，除非你重定向它们。重定向意味着重设一个文件描述符到另一个文件 (或者管道，或任何有权限的东西)。文件描述符可以本地重设 (对于一个指令、指令组、子 Shell、while / case / for 循环等)，或者，对余下的 Shell 会话全局重设 (通过 exec)。</p>
<p><code>ls &gt; /dev/null</code> 意味着在其文件描述符 1 连接到 <code>/dev/null</code> 的情况下运行 <strong>ls</strong> 。</p>
<div><pre><code>bash$ <span>lsof</span> -a -p <span>$$</span> -d0,1,2
COMMAND PID     <span>USER</span>   FD   TYPE DEVICE SIZE NODE NAME
 <span>bash</span>    <span>363</span> bozo        0u   CHR  <span>136,1</span>         <span>3</span> /dev/pts/1
 <span>bash</span>    <span>363</span> bozo        1u   CHR  <span>136,1</span>         <span>3</span> /dev/pts/1
 <span>bash</span>    <span>363</span> bozo        2u   CHR  <span>136,1</span>         <span>3</span> /dev/pts/1


bash$ <span>exec</span> <span><span>2</span>></span> /dev/null
bash$ <span>lsof</span> -a -p <span>$$</span> -d0,1,2
COMMAND PID     <span>USER</span>   FD   TYPE DEVICE SIZE NODE NAME
 <span>bash</span>    <span>371</span> bozo        0u   CHR  <span>136,1</span>         <span>3</span> /dev/pts/1
 <span>bash</span>    <span>371</span> bozo        1u   CHR  <span>136,1</span>         <span>3</span> /dev/pts/1
 <span>bash</span>    <span>371</span> bozo        2w   CHR    <span>1,3</span>       <span>120</span> /dev/null


bash$ <span>bash</span> -c <span>'lsof -a -p <span>$$</span> -d0,1,2'</span> <span>|</span> <span>cat</span>
COMMAND PID <span>USER</span>   FD   TYPE DEVICE SIZE NODE NAME
 <span>lsof</span>    <span>379</span> root    0u   CHR  <span>136,1</span>         <span>3</span> /dev/pts/1
 <span>lsof</span>    <span>379</span> root    1w  FIFO    <span>0,0</span>      <span>7118</span> pipe
 <span>lsof</span>    <span>379</span> root    2u   CHR  <span>136,1</span>         <span>3</span> /dev/pts/1


bash$ <span>echo</span> <span>"<span><span>$(</span><span>bash</span> -c <span>'lsof -a -p <span>$$</span> -d0,1,2'</span> <span><span>2</span>></span><span>&amp;1</span><span>)</span></span>"</span>
COMMAND PID <span>USER</span>   FD   TYPE DEVICE SIZE NODE NAME
 <span>lsof</span>    <span>426</span> root    0u   CHR  <span>136,1</span>         <span>3</span> /dev/pts/1
 <span>lsof</span>    <span>426</span> root    1w  FIFO    <span>0,0</span>      <span>7520</span> pipe
 <span>lsof</span>    <span>426</span> root    2w  FIFO    <span>0,0</span>      <span>7520</span> pipe
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="练习"> 练习</h2>
<p>分析以下脚本。</p>
<div><pre><code><span>#! /usr/bin/env bash</span>

<span>mkfifo</span> /tmp/fifo1 /tmp/fifo2
<span>while</span> <span>read</span> a<span>;</span> <span>do</span> <span>echo</span> <span>"FIFO1: <span>$a</span>"</span><span>;</span> <span>done</span> <span>&lt;</span> /tmp/fifo1 <span>&amp;</span> <span>exec</span> <span><span>7</span>></span> /tmp/fifo1
<span>exec</span> <span><span>8</span>></span> <span>></span><span>(</span><span>while</span> <span>read</span> a<span>;</span> <span>do</span> <span>echo</span> <span>"FD8: <span>$a</span>, to fd7"</span><span>;</span> <span>done</span> <span>></span><span>&amp;7</span><span>)</span>

<span>exec</span> <span><span>3</span>></span><span>&amp;1</span>
<span>(</span>
 <span>(</span>
  <span>(</span>
   <span>while</span> <span>read</span> a<span>;</span> <span>do</span> <span>echo</span> <span>"FIFO2: <span>$a</span>"</span><span>;</span> <span>done</span> <span>&lt;</span> /tmp/fifo2 <span>|</span> <span>tee</span> /dev/stderr <span>\</span>
   <span>|</span> <span>tee</span> /dev/fd/4 <span>|</span> <span>tee</span> /dev/fd/5 <span>|</span> <span>tee</span> /dev/fd/6 <span>></span><span>&amp;7</span> <span>&amp;</span> <span>exec</span> <span><span>3</span>></span> /tmp/fifo2

   <span>echo</span> 1st, to stdout
   <span>sleep</span> <span>1</span>
   <span>echo</span> 2nd, to stderr <span>></span><span>&amp;2</span>
   <span>sleep</span> <span>1</span>
   <span>echo</span> 3rd, to fd <span>3</span> <span>></span><span>&amp;3</span>
   <span>sleep</span> <span>1</span>
   <span>echo</span> 4th, to fd <span>4</span> <span>></span><span>&amp;4</span>
   <span>sleep</span> <span>1</span>
   <span>echo</span> 5th, to fd <span>5</span> <span>></span><span>&amp;5</span>
   <span>sleep</span> <span>1</span>
   <span>echo</span> 6th, through a pipe <span>|</span> <span>sed</span> <span>'s/.*/PIPE: &amp;, to fd 5/'</span> <span>></span><span>&amp;5</span>
   <span>sleep</span> <span>1</span>
   <span>echo</span> 7th, to fd <span>6</span> <span>></span><span>&amp;6</span>
   <span>sleep</span> <span>1</span>
   <span>echo</span> 8th, to fd <span>7</span> <span>></span><span>&amp;7</span>
   <span>sleep</span> <span>1</span>
   <span>echo</span> 9th, to fd <span>8</span> <span>></span><span>&amp;8</span>

  <span>)</span> <span><span>4</span>></span><span>&amp;1</span> <span>></span><span>&amp;3</span> <span><span>3</span>>&amp;</span>- <span>|</span> <span>while</span> <span>read</span> a<span>;</span> <span>do</span> <span>echo</span> <span>"FD4: <span>$a</span>"</span><span>;</span> <span>done</span> <span><span>1</span>></span><span>&amp;3</span> <span><span>5</span>>&amp;</span>- <span><span>6</span>>&amp;</span>-
 <span>)</span> <span><span>5</span>></span><span>&amp;1</span> <span>></span><span>&amp;3</span> <span>|</span> <span>while</span> <span>read</span> a<span>;</span> <span>do</span> <span>echo</span> <span>"FD5: <span>$a</span>"</span><span>;</span> <span>done</span> <span><span>1</span>></span><span>&amp;3</span> <span><span>6</span>>&amp;</span>-
<span>)</span> <span><span>6</span>></span><span>&amp;1</span> <span>></span><span>&amp;3</span> <span>|</span> <span>while</span> <span>read</span> a<span>;</span> <span>do</span> <span>echo</span> <span>"FD6: <span>$a</span>"</span><span>;</span> <span>done</span> <span><span>3</span>>&amp;</span>-

<span>rm</span> -f /tmp/fifo1 /tmp/fifo2


<span># 对每个指令和子 Shell，猜猜哪个 fd 指向什么。</span>
<span># 祝你好运！</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">附录 T. ASCII 表</title>
    <id>https://clay-wangzhi.com/code/shell/appendix/T_ascii_table/</id>
    <link href="https://clay-wangzhi.com/code/shell/appendix/T_ascii_table/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="附录-t-ascii-表"> 附录 T. ASCII 表</h1>
<p>传统上，这类书的附录会有一个 ASCII 表。但本书不会。取而代之的是这些生成一张完整 ASCII 表的简短脚本。</p>
<p>例 T-1. 一个生成 ASCII 表的脚本</p>
<div><pre><code><span>#!/bin/bash</span>
<span># ascii.sh</span>
<span># ver. 0.2, reldate 26 Aug 2008</span>
<span># Patched by ABS Guide author.</span>

<span># Original script by Sebastian Arming.</span>
<span># Used with permission (thanks!).</span>

<span>exec</span> <span>></span>ASCII.txt         <span>#  Save stdout to file,</span>
                        <span>#+ as in the example scripts</span>
                        <span>#+ reassign-stdout.sh and upperconv.sh.</span>

<span>MAXNUM</span><span>=</span><span>256</span>
<span><span>COLUMNS</span></span><span>=</span><span>5</span>
<span>OCT</span><span>=</span><span>8</span>
<span>OCTSQU</span><span>=</span><span>64</span>
<span>LITTLESPACE</span><span>=</span>-3
<span>BIGSPACE</span><span>=</span>-5

<span>i</span><span>=</span><span>1</span> <span># Decimal counter</span>
<span>o</span><span>=</span><span>1</span> <span># Octal counter</span>

<span>while</span> <span>[</span> <span>"<span>$i</span>"</span> -lt <span>"<span>$MAXNUM</span>"</span> <span>]</span><span>;</span> <span>do</span>  <span># We don't have to count past 400 octal.</span>
        <span>paddi</span><span>=</span><span>"    <span>$i</span>"</span>
        <span>echo</span> -n <span>"<span>${paddi<span>:</span> $BIGSPACE}</span>  "</span>       <span># Column spacing.</span>
        <span>paddo</span><span>=</span><span>"00<span>$o</span>"</span>
<span>#       echo -ne "\\${paddo: $LITTLESPACE}"   # Original.</span>
        <span>echo</span> -ne <span>"<span title="\\">\\</span>0<span>${paddo<span>:</span> $LITTLESPACE}</span>"</span>  <span># Fixup.</span>
<span>#                   ^</span>
        <span>echo</span> -n <span>"     "</span>
        <span>if</span> <span><span>((</span> i <span>%</span> $COLUMNS <span>==</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>       <span># New line.</span>
           <span>echo</span>
        <span>fi</span>
        <span><span>((</span>i<span>++</span><span>,</span> o<span>++</span><span>))</span></span>
        <span># The octal notation for 8 is 10, and 64 decimal is 100 octal.</span>
        <span><span>((</span> i <span>%</span> $OCT <span>==</span> <span>0</span><span>))</span></span>    <span>&amp;&amp;</span> <span><span>((</span>o<span>+</span><span>=</span><span>2</span><span>))</span></span>
        <span><span>((</span> i <span>%</span> $OCTSQU <span>==</span> <span>0</span><span>))</span></span> <span>&amp;&amp;</span> <span><span>((</span>o<span>+</span><span>=</span><span>20</span><span>))</span></span>
<span>done</span>

<span>exit</span> <span>$?</span>

<span># Compare this script with the "pr-asc.sh" example.</span>
<span># This one handles "unprintable" characters.</span>

<span># Exercise:</span>
<span># Rewrite this script to use decimal numbers, rather than octal.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>例 T-2. 另一个 ASCII 表脚本</p>
<div><pre><code><span>#!/bin/bash</span>
<span># Script author: Joseph Steinhauser</span>
<span># Lightly edited by ABS Guide author, but not commented.</span>
<span># Used in ABS Guide with permission.</span>

<span>#-------------------------------------------------------------------------</span>
<span>#-- File:  ascii.sh    Print ASCII chart, base 10/8/16         (JETS-2012)</span>
<span>#-------------------------------------------------------------------------</span>
<span>#-- Usage: ascii [oct|dec|hex|help|8|10|16]</span>
<span>#--</span>
<span>#-- This script prints out a summary of ASCII char codes from Zero to 127.</span>
<span>#-- Numeric values may be printed in Base10, Octal, or Hex.</span>
<span>#--</span>
<span>#-- Format Based on: /usr/share/lib/pub/ascii with base-10 as default.</span>
<span>#-- For more detail, man ascii . . .</span>
<span>#-------------------------------------------------------------------------</span>

<span>[</span> -n <span>"<span>$BASH_VERSION</span>"</span> <span>]</span> <span>&amp;&amp;</span> <span>shopt</span> -s extglob

<span>case</span> <span>"<span>$1</span>"</span> <span>in</span>
   oct<span>|</span><span>[</span>Oo<span>]</span>?<span>(</span><span>[</span>Cc<span>]</span><span>[</span>Tt<span>]</span><span>)</span><span>|</span><span>8</span><span>)</span>       <span>Obase</span><span>=</span>Octal<span>;</span>  <span>Numy</span><span>=</span>3o<span>;</span><span>;</span>
   hex<span>|</span><span>[</span>Hh<span>]</span>?<span>(</span><span>[</span>Ee<span>]</span><span>[</span>Xx<span>]</span><span>)</span><span>|</span><span>16</span><span>|</span><span>[</span>Xx<span>]</span><span>)</span> <span>Obase</span><span>=</span>Hex<span>;</span>    <span>Numy</span><span>=</span>2X<span>;</span><span>;</span>
   <span>help</span><span>|</span>?<span>(</span>-<span>)</span><span>[</span>h?<span>]</span><span>)</span>        <span>sed</span> -n <span>'2,/^[ ]*$/p'</span> <span>$0</span><span>;</span><span>exit</span><span>;</span><span>;</span>
   code<span>|</span><span>[</span>Cc<span>]</span><span>[</span>Oo<span>]</span><span>[</span>Dd<span>]</span><span>[</span>Ee<span>]</span><span>)</span>sed -n <span>'/case/,<span>$p</span>'</span>   <span>$0</span><span>;</span><span>exit</span><span>;</span><span>;</span>
   *<span>)</span> <span>Obase</span><span>=</span>Decimal
<span>esac</span> <span># CODE is actually shorter than the chart!</span>

<span>printf</span> <span>"<span title="\t">\t</span><span title="\t">\t</span>## <span>$Obase</span> ASCII Chart ##<span title="\n">\n</span><span title="\n">\n</span>"</span><span>;</span> <span>FM1</span><span>=</span><span>"|%0<span>${Numy<span>:-</span>3d}</span>"</span><span>;</span> <span>LD</span><span>=</span>-1

<span>AB</span><span>=</span><span>"nul soh stx etx eot enq ack bel bs tab nl vt np cr so si dle"</span>
<span>AD</span><span>=</span><span>"dc1 dc2 dc3 dc4 nak syn etb can em sub esc fs gs rs us sp"</span>

<span>for</span> <span>TOK</span> <span>in</span> <span>$AB</span> <span>$AD</span><span>;</span> <span>do</span> ABR<span>[</span><span><span>$((</span>LD<span>+</span><span>=</span><span>1</span><span>))</span></span><span>]</span><span>=</span><span>$TOK</span><span>;</span> <span>done</span><span>;</span>
ABR<span>[</span><span>127</span><span>]</span><span>=</span>del

<span>IDX</span><span>=</span><span>0</span>
<span>while</span> <span>[</span> <span>$IDX</span> -le <span>127</span> <span>]</span> <span>&amp;&amp;</span> <span>CHR</span><span>=</span><span>"<span>${ABR<span>[</span>$IDX<span>]</span>}</span>"</span>
   <span>do</span> <span><span>((</span>${#CHR}<span>))</span></span><span>&amp;&amp;</span> <span>FM2</span><span>=</span><span>'%-3s'</span><span>||</span> <span>FM2</span><span>=</span><span><span>`</span><span>printf</span> <span>'<span title="\\">\\</span><span title="\\">\\</span>%o  '</span> $IDX<span>`</span></span>
      <span>printf</span> <span>"<span>$FM1</span> <span>$FM2</span>"</span> <span>"<span>$IDX</span>"</span> <span>$CHR</span><span>;</span> <span><span>((</span> <span>(</span>IDX<span>+</span><span>=</span><span>1</span><span>)</span><span>%</span><span>8</span><span>))</span></span><span>||</span><span>echo</span> <span>'|'</span>
   <span>done</span>

<span>exit</span> <span>$?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>例 T-3. 第三个 ASCII 表脚本，使用 <em>awk</em></p>
<div><pre><code><span>#!/bin/bash</span>
<span># ASCII table script, using awk.</span>
<span># Author: Joseph Steinhauser</span>
<span># Used in ABS Guide with permission.</span>


<span>#-------------------------------------------------------------------------</span>
<span>#-- File:  ascii     Print ASCII chart, base 10/8/16         (JETS-2010)</span>
<span>#-------------------------------------------------------------------------</span>
<span>#-- Usage: ascii [oct|dec|hex|help|8|10|16]</span>
<span>#--</span>
<span>#-- This script prints a summary of ASCII char codes from Zero to 127.</span>
<span>#-- Numeric values may be printed in Base10, Octal, or Hex (Base16).</span>
<span>#--</span>
<span>#-- Format Based on: /usr/share/lib/pub/ascii with base-10 as default.</span>
<span>#-- For more detail, man ascii</span>
<span>#-------------------------------------------------------------------------</span>

<span>[</span> -n <span>"<span>$BASH_VERSION</span>"</span> <span>]</span> <span>&amp;&amp;</span> <span>shopt</span> -s extglob

<span>case</span> <span>"<span>$1</span>"</span> <span>in</span>
   oct<span>|</span><span>[</span>Oo<span>]</span>?<span>(</span><span>[</span>Cc<span>]</span><span>[</span>Tt<span>]</span><span>)</span><span>|</span><span>8</span><span>)</span>       <span>Obase</span><span>=</span>Octal<span>;</span>  <span>Numy</span><span>=</span>3o<span>;</span><span>;</span>
   hex<span>|</span><span>[</span>Hh<span>]</span>?<span>(</span><span>[</span>Ee<span>]</span><span>[</span>Xx<span>]</span><span>)</span><span>|</span><span>16</span><span>|</span><span>[</span>Xx<span>]</span><span>)</span> <span>Obase</span><span>=</span>Hex<span>;</span>    <span>Numy</span><span>=</span>2X<span>;</span><span>;</span>
   <span>help</span><span>|</span>?<span>(</span>-<span>)</span><span>[</span>h?<span>]</span><span>)</span>        <span>sed</span> -n <span>'2,/^[ ]*$/p'</span> <span>$0</span><span>;</span><span>exit</span><span>;</span><span>;</span>
   code<span>|</span><span>[</span>Cc<span>]</span><span>[</span>Oo<span>]</span><span>[</span>Dd<span>]</span><span>[</span>Ee<span>]</span><span>)</span>sed -n <span>'/case/,<span>$p</span>'</span>   <span>$0</span><span>;</span><span>exit</span><span>;</span><span>;</span>
   *<span>)</span> <span>Obase</span><span>=</span>Decimal
<span>esac</span>
<span>export</span> Obase   <span># CODE is actually shorter than the chart!</span>

<span>awk</span> <span>'BEGIN{print "<span title="\n">\n</span><span title="\t">\t</span><span title="\t">\t</span>## "ENVIRON["Obase"]" ASCII Chart ##<span title="\n">\n</span>"
           ab="soh,stx,etx,eot,enq,ack,bel,bs,tab,nl,vt,np,cr,so,si,dle,"
           ad="dc1,dc2,dc3,dc4,nak,syn,etb,can,em,sub,esc,fs,gs,rs,us,sp"
           split(ab ad,abr,",");abr[0]="nul";abr[127]="del";
           fm1="|%0'</span>"<span>${Numy<span>:-</span> 4d}</span><span>"' %-3s"</span>
           for<span>(</span>idx<span>=</span><span>0</span><span>;</span>idx<span>&lt;</span><span>128</span><span>;</span>idx++<span>)</span><span>{</span>fmt<span>=</span>fm1 <span>(</span>++colz%8?<span>""</span><span>:</span><span>"|<span title="\n">\n</span>"</span><span>)</span>
           printf<span>(</span>fmt,idx,<span>(</span>idx <span>in</span> abr<span>)</span>?abr<span>[</span>idx<span>]</span>:sprintf<span>(</span><span>"%c"</span>,idx<span>))</span><span>}</span> <span>}</span>'

<span>exit</span> <span>$?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第一章 为什么使用shell编程</title>
    <id>https://clay-wangzhi.com/code/shell/part1/01_shell_programming/</id>
    <link href="https://clay-wangzhi.com/code/shell/part1/01_shell_programming/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第一章-为什么使用shell编程"> 第一章 为什么使用shell编程</h1>
<blockquote>
<p>没有任何一种程序设计语言是完美的，甚至没有一个最好的语言。只有在特定环境下适合的语言。</p>
<p>—— Herbert Mayer</p>
</blockquote>
<p>无论你是否打算真正编写shell脚本，只要你想要在一定程度上熟悉系统管理，了解掌握shell脚本的相关知识都是非常有必要的。例如Linux系统在启动的时候会执行<code>/etc/rc.d</code>目录下的shell脚本来恢复系统配置和准备服务。详细了解这些启动脚本对分析系统行为大有益处，何况，你很有可能会去修改它们呢。</p>
<p>编写shell脚本并不困难，shell脚本由许多小的部分组成，而其中只有数量相当少的与shell本身特性，操作和选项<sup></sup>有关的部分才需要去学习。Shell语法非常简单朴素，很像是在命令行中调用和连接工具，你只需遵循很少一部分的&quot;规则&quot;就可以了。大部分短小的脚本通常在第一次就可以正常工作，即使是一个稍长一些的脚本，调试起来也十分简单。</p>
<blockquote>
<p>在个人计算机发展的早期，BASIC语言让计算机专业人士能够在早期的微机上编写程序。几十年后，Bash脚本可以让所有仅对Linux或UNIX系统有初步了解的用户在现代计算机上做同样的事。</p>
<p>我们现在已经可以做出一些又小又快的单板机，比如<a href="http://www.raspberrypi.org/" target="_blank" rel="noopener noreferrer">树莓派</a>。Bash脚本提供了一种发掘这些有趣设备潜力的方式。</p>
</blockquote>
<p>使用shell脚本构建一个复杂应用原型（prototype），不失为是一种虽有缺陷但非常快速的方式。在项目开发初期，使用脚本实现部分功能往往显得十分有用。在使用C/C++，Java，Perl或Python编写最终代码前，可以使用shell脚本测试，修补应用结构，提前发现重大缺陷。</p>
<p>Shell脚本与经典的UINX哲学相似，将复杂的任务划分为简单的子任务，将组件与工具连接起来。许多人认为比起新一代功能强大、高度集成的语言，例如Perl，shell脚本至少是一种在美学上更加令人愉悦的解决问题的方式，Perl试图做到面面俱到，但你必须强迫自己改变思维方式适应它。</p>
<p>Herbert Mayer曾说：“有用的语言需要数组、指针以及构建数据结构的通用机制”。如果依据这些标准，那shell脚本距“有用”还差得很远，甚至是“无用”的。</p>
<h3 id="什么时候不应该使用shell脚本"> 什么时候不应该使用shell脚本</h3>
<ul>
<li>资源密集型的任务，尤其是对速度有要求（如排序、散列、递归<sup></sup>等）</li>
<li>需要做大量的数学运算，例如浮点数运算，高精度运算或者复数运算（使用C++或FORTRAN代替）</li>
<li>有跨平台需求（使用C或者Java代替）</li>
<li>必须使用结构化编程的复杂应用（如变量类型检查、函数原型等）</li>
<li>影响系统全局的关键性任务</li>
<li>对安全性有高要求，需要保证系统的完整性以及阻止入侵、破解、恶意破坏</li>
<li>项目包含有连锁依赖关系的组件</li>
<li>需要大量的文件操作（Bash只能访问连续的文件，并且是以一种非常笨拙且低效的逐行访问的方式进行的）</li>
<li>需要使用多维数组</li>
<li>需要使用如链表、树等数据结构</li>
<li>需要产生或操作图像和图形用户接口（GUI）</li>
<li>需要直接访问系统硬件或外部设备</li>
<li>需要使用端口或套接字输入输出端口（Socket I/O）</li>
<li>需要使用库或旧程序的接口</li>
<li>私有或闭源的项目（Shell脚本直接将源代码公开，所有人都可以看到）</li>
</ul>
<p>如果你的应用满足上述任意一条，你可以考虑使用更加强大的脚本语言，如Perl，Tcl，Python，Ruby等，或考虑使用编译型语言，如C，C++或Java等。即使如此，在开发阶段使用shell脚本建立应用原型也是十分有用的。</p>
<p>我们接下来将使用Bash。Bash是&quot;Bourne-Again shell&quot;的首字母缩略词<sup></sup>，Bash来源于Stephen Bourne开发的Bourne shell（sh）。如今Bash已成为了大部分UNIX衍生版中shell脚本事实上的标准。本书所涉及的大部分概念在其他shell中也是适用的，例如Korn Shell，Bash从它当中继承了一部分的特性<sup></sup>；又如C Shell及其变体（需要注意的是，1993年10月Tom Christiansen在<a href="http://www.faqs.org/faqs/unix-faq/shell/csh-whynot/" target="_blank" rel="noopener noreferrer">Usenet帖子</a>中指出，因C Shell内部固有的问题，不推荐使用C Shell编程）</p>
<p>接下来的部分将是一些编写shell脚本的指导。这些指导很大程度上依赖于实例来阐述shell的特性。本书所有的例子都能够正常工作，并在尽可能的范围内进行过测试，其中的一部分已经运用在实际生产生活中。读者们可以使用这些在存档中的例子（文件名为<code>scriptname.sh</code>或<code>scriptname.bash</code>）<sup></sup>，赋予它们可执行权限（<code>chmod u+rx scriptname</code>），然后执行它们看看会发生什么。如果<a href="http://bash.deta.in/abs-guide-latest.tar.bz2" target="_blank" rel="noopener noreferrer">存档</a>不可用，读者朋友也可以从本书的HTML或者PDF版本中复制粘贴代码出来。需要注意的是，在部分例子中使用了一些暂时还未被解释的特性，这需要读者暂时跳过它们。</p>
<p>除特别说明，本书所有例子均由<a href="mailto:thegrendel.abs@gmail.com">本书作者</a>编写。</p>
<blockquote>
<p>His countenance was bold and bashed not.</p>
<p>—— Edmund Spenser</p>
</blockquote>
<hr>
<section>
<ol>
<li id="footnote1"><p>这些操作和选项被称为内建命令（builtin），是shell的内部特征。 </p>
</li>
<li id="footnote2"><p>虽然递归可以在shell脚本中实现，但是它的效率很低且实现起来很复杂、不具有美感。 </p>
</li>
<li id="footnote3"><p>首字母缩略词是由每一个单词的首字母拼接而成的易读的代替短语。这不是一个好习惯，通常会引起一些不必要的麻烦。 </p>
</li>
<li id="footnote4"><p>ksh88中的许多特性，甚至一些ksh93的特性都被合并到Bash中了。 </p>
</li>
<li id="footnote5"><p>按照惯例，用户编写的Bourne shell脚本应该在文件名后加上<code>.sh</code>的扩展名。而那些系统脚本，比如在<code>/etc/rc.d</code>中的脚本通常不遵循这种规范。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">2.1 调用一个脚本</title>
    <id>https://clay-wangzhi.com/code/shell/part1/02_1_invoking_the_script/</id>
    <link href="https://clay-wangzhi.com/code/shell/part1/02_1_invoking_the_script/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_2-1-调用一个脚本"> 2.1 调用一个脚本</h1>
<p>写完一个脚本以后，你可以通过<code>sh scriptname</code>或<code>bash scriptname</code>来调用它（不推荐使用<code>sh &lt;scriptname</code>调用脚本，因为这会禁用脚本从标准输入（stdin）读入数据）。更方便的方式是使用<code>chmod</code>命令使脚本可以被直接执行。</p>
<p>执行命令：</p>
<p><code>chmod 555 scriptname</code>（给予所有用户读取/执行的权限）</p>
<p>或</p>
<p><code>chmod +rx scriptname</code>（给予所有用户读取/执行的权限）</p>
<p><code>chmod u+rx scriptname</code>（仅给予脚本所有者读取/执行的权限）</p>
<p>当脚本的权限被设置好后，你就可以直接使用<code>./scriptname</code>[^3]进行调用测试了。如果脚本文件以sha-bang开头，那么它将自动调用指定的命令解释器运行脚本。</p>
<p>完成调试与测试后，你可能会将脚本文件移至<code>/usr/local/bin</code>（使用root权限）中，使脚本可以被所有用户调用。这时你可以直接在命令行中输入<code>scriptname [ENTER]</code>执行脚本。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">2.2 牛刀小试</title>
    <id>https://clay-wangzhi.com/code/shell/part1/02_2_preliminary_exercises/</id>
    <link href="https://clay-wangzhi.com/code/shell/part1/02_2_preliminary_exercises/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_2-2-牛刀小试"> 2.2 牛刀小试</h1>
<ol>
<li>系统管理员通常会写一些脚本来完成自动化工作。试举例说明使用脚本的便利之处。</li>
<li>请尝试写一个脚本。调用脚本，会打印当前系统时间和日期，所有已登录的用户和系统运行时间。并将这些信息保存到一个日志文件中。</li>
</ol>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第二章 和Sha-Bang（#!）一起出发</title>
    <id>https://clay-wangzhi.com/code/shell/part1/02_starting_off_with_a_sha_bang/</id>
    <link href="https://clay-wangzhi.com/code/shell/part1/02_starting_off_with_a_sha_bang/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第二章-和sha-bang-一起出发"> 第二章 和Sha-Bang（#!）一起出发</h1>
<blockquote>
<p>Shell编程声名显赫</p>
<p>—— Larry Wall</p>
</blockquote>
<h3 id="本章目录"> 本章目录</h3>
<ul>
<li><a href="./02_1_invoking_the_script.html">2.1 调用一个脚本</a></li>
<li><a href="./02_2_preliminary_exercises.html">2.2 牛刀小试</a></li>
</ul>
<hr>
<p>一个最简单的脚本其实就是将一连串系统命令存储在一个文件中。最起码，它能帮你省下重复输入这一连串命令的功夫。</p>
<p>样例 2-1. <em>cleanup</em>：清理<code>/var/log</code>目录下的日志文件</p>
<div><pre><code><span># Cleanup</span>
<span># 请使用root权限执行</span>

<span>cd</span> /var/log
<span>cat</span> /dev/null <span>></span> messages
<span>cat</span> /dev/null <span>></span> wtmp
<span>echo</span> <span>"Log files cleaned up."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这支脚本仅仅是一些可以很容易从终端或控制台输入的命令的集合罢了，没什么特殊的地方。将命令放在脚本中的好处是，你不用再一遍遍重复输入这些命令啦。脚本成了一支<em>程序</em>、一款<em>工具</em>，它可以很容易的被修改或为特殊需求定制。</p>
<p>样例 2-2. <em>cleanup</em>：改进的清理脚本</p>
<div><pre><code><span>#!/bin/bash</span>
<span># Bash脚本标准起始行。</span>

<span># Cleanup, version 2</span>

<span># 请使用root权限执行。</span>
<span># 这里可以插入代码来打印错误信息，并在未使用root权限时退出。</span>

<span>LOG_DIR</span><span>=</span>/var/log
<span># 使用变量比硬编码（hard-coded）更合适</span>
<span>cd</span> <span>$LOG_DIR</span>

<span>cat</span> /dev/null <span>></span> messages
<span>cat</span> /dev/null <span>></span> wtmp


<span>echo</span> <span>"Logs cleaned up."</span>

<span>exit</span> <span># 正确终止脚本的方式。</span>
     <span># 不带参数的exit返回上一条指令的运行结果。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>现在我们看到了一个真正意义上的脚本! 让我们继续前进...</p>
<p>样例 2-3. <em>cleanup</em>：改良、通用版</p>
<div><pre><code><span>#!/bin/bash</span>
<span># Cleanup, version 3</span>

<span># 注意：</span>
<span># --------</span>
<span># 此脚本涉及到许多后边才会解释的特性。</span>
<span># 当你阅读完整本书的一半以后，理解它们就没有任何困难了。</span>


<span>LOG_DIR</span><span>=</span>/var/log
<span>ROOT_UID</span><span>=</span><span>0</span>     <span># UID为0的用户才拥有root权限。</span>
<span><span>LINES</span></span><span>=</span><span>50</span>       <span># 默认保存messages日志文件行数。</span>
<span>E_XCD</span><span>=</span><span>86</span>       <span># 无法切换工作目录的错误码。</span>
<span>E_NOTROOT</span><span>=</span><span>87</span>   <span># 非root权限用户执行的错误码。</span>



<span># 请使用root权限运行。</span>
<span>if</span> <span>[</span> <span>"<span>$UID</span>"</span> -ne <span>"<span>$ROOT_UID</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"Must be root to run this script."</span>
  <span>exit</span> <span>$E_NOTROOT</span>
<span>fi</span>

<span>if</span> <span>[</span> -n <span>"<span>$1</span>"</span> <span>]</span>
<span># 测试命令行参数（保存行数）是否为空</span>
<span>then</span>
  <span>lines</span><span>=</span><span>$1</span>
<span>else</span>
  <span>lines</span><span>=</span><span>$LINES</span> <span># 如果为空则使用默认设置</span>
<span>fi</span>


<span>#  Stephane Chazelas 建议使用如下方法检查命令行参数，</span>
<span>#  但是这已经超出了此阶段教程的范围。</span>
<span>#</span>
<span>#    E_WRONGARGS=85  # Non-numerical argument (bad argument format).</span>
<span>#    case "$1" in</span>
<span>#    ""      ) lines=50;;</span>
<span>#    *[!0-9]*) echo "Usage: `basename $0` lines-to-cleanup";</span>
<span>#     exit $E_WRONGARGS;;</span>
<span>#    *       ) lines=$1;;</span>
<span>#    esac</span>
<span>#</span>
<span>#* 在第十一章“循环与分支”中会对此作详细的阐述。</span>


<span>cd</span> <span>$LOG_DIR</span>

<span>if</span> <span>[</span> <span><span>`</span><span>pwd</span><span>`</span></span> <span>!=</span> <span>"<span>$LOG_DIR</span>"</span> <span>]</span>  <span># 也可以这样写 if [ "$PWD" != "$LOG_DIR" ]</span>
                            <span># 检查工作目录是否为 /var/log ?</span>
<span>then</span>
  <span>echo</span> <span>"Can't change to <span>$LOG_DIR</span>"</span>
  <span>exit</span> <span>$E_XCD</span>
<span>fi</span>  <span># 在清理日志前，二次确认是否在正确的工作目录下。</span>

<span># 更高效的写法：</span>
<span>#</span>
<span># cd /var/log || {</span>
<span>#   echo "Cannot change to necessary directory." >&amp;2</span>
<span>#   exit $E_XCD;</span>
<span># }</span>


<span>tail</span> -n <span>$lines</span> messages <span>></span> mesg.temp <span># 保存messages日志文件最后一部分</span>
<span>mv</span> mesg.temp messages              <span># 替换系统日志文件以达到清理目的</span>

<span>#  cat /dev/null > messages</span>
<span>#* 我们不需要使用这个方法了，上面的方法更安全</span>

<span>cat</span> /dev/null <span>></span> wtmp  <span>#  ': > wtmp' 与 '> wtmp' 有同样的效果</span>
<span>echo</span> <span>"Log files cleaned up."</span>
<span>#  注意在/var/log目录下的其他日志文件不会被这个脚本清除</span>

<span>exit</span> <span>0</span>
<span>#  返回0表示脚本运行成功</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><p>也许你并不希望清空全部的系统日志，这个脚本保留了messages日志的最后一部分。随着学习的深入，你将明白更多提高脚本运行效率的方法。</p>
<hr>
<p>脚本起始行<em>sha-bang</em>（#!）<sup></sup>告诉系统这个脚本文件需要使用指定的命令解释器来执行。#!实际上是一个占两字节<sup></sup>的<em>幻数</em>（magic number）,幻数可以用来标识特殊的文件类型，在这里则是标记可执行shell脚本（你可以在终端中输入<code>man magic</code>了解更多信息）。紧随#!的是一个路径名。此路径指向用来解释此脚本的程序，它可以是shell，可以是程序设计语言，也可以是实用程序。这个解释器从头（#!的下一行）开始执行整个脚本的命令，同时忽略注释。<sup></sup></p>
<div><pre><code>#!/bin/sh
#!/bin/bash
#!/usr/bin/perl
#!/usr/bin/tcl
#!/bin/sed -f
#!/bin/awk -f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面每一条脚本起始行都调用了不同的解释器，比如<code>/bin/sh</code>调用了系统默认shell（Linux系统中默认是bash）<sup></sup>。大部分UNIX商业发行版中默认的是Bourne shell，即<code>#!/bin/sh</code>。你可以以牺牲Bash特性为代价，在非Linux的机器上运行sh脚本。当然，脚本得遵循POSIX<sup></sup> sh标准。</p>
<p>需要注意的是<code>#!</code>后的路径必须正确，否则当你运行脚本时只会得到一条错误信息，通常是&quot;Command not found.&quot;<sup></sup></p>
<p>当脚本仅包含一些通用的系统命令而不使用shell内部指令时，可以省略<code>#!</code>。第三个例子需要<code>#!</code>是因为当对变量赋值时，例如<code>lines=50</code>，使用了与shell特性相关的结构<sup></sup>。再重复一次，<code>#!/bin/sh</code>调用的是系统默认shell解释器，在Linux系统中默认为<code>/bin/bash</code>。</p>
<p>这个例子鼓励读者使用模块化的方式编写脚本，并在平时记录和收集一些在以后可能会用到的代码模板。最终你将拥有一个相当丰富易用的代码库。以下的代码可以用来测试脚本被调用时的参数数量是否正确。</p>
<div><pre><code><span>E_WRONG_ARGS</span><span>=</span><span>85</span>
<span>script_parameters</span><span>=</span><span>"-a -h -m -z"</span>
                 <span># -a = all, -h = help 等等</span>

<span>if</span> <span>[</span> <span>$#</span> -ne <span>$Number_of_expected_args</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"Usage: <span><span>`</span><span>basename</span> $0<span>`</span></span> <span>$script_parameters</span>"</span>
  <span># `basename $0` 是脚本的文件名</span>
  <span>exit</span> <span>$E_WRONG_ARGS</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>大多数情况下，你会针对特定的任务编写脚本。本章的第一个脚本就是这样。然后你也许会泛化（generalize）脚本使其能够适应更多相似的任务，比如用变量代替硬编码，用函数代替重复代码。</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>在文献中更常见的形式是she-bang或者sh-bang。它们都来源于词汇sharp(#)和bang(!)的连接。 </p>
</li>
<li id="footnote2"><p>一些UNIX的衍生版（基于4.2 BSD）声称他们使用四字节的幻数，在#!后增加一个空格，即<code>#! /bin/sh</code>。而<a href="http://www.in-ulm.de/~mascheck/various/shebang/#details" target="_blank" rel="noopener noreferrer">Sven Mascheck</a>指出这是虚构的。 </p>
</li>
<li id="footnote3"><p>命令解释器首先将会解释#!这一行，而因为#!以#打头，因此解释器将其视作注释。起始行作为调用解释器的作用已经完成了。</p><p>事实上即使脚本中含有不止一个#!,bash也会将除第一个`#!`以外的解释为注释。</p><pre>#!/bin/bash<br/><br/>echo "Part 1 of script."<br/>a=1<br/><br/>#!/bin/bash<br/># 这并不会启动新的脚本<br/><br/>echo "Part 2 of script."<br/>echo $a  # $a的值仍旧为1</pre>
 </li>
<li id="footnote4"><p>这里允许使用一些技巧。</p><pre>#!/bin/rm<br/># 自我删除的脚本<br/><br/># 当你运行这个脚本，除了这个脚本本身消失以外并不会发生什么。<br/><br/>WHATEVER=85<br/><br/>echo "This line will never print (betcha!)."<br/><br/>exit $WHATEVER  # 这没有任何关系。脚本将不会从这里退出。<br/>                # 尝试在脚本终止后打印echo $a。<br/>                # 得到的值将会是0而不是85.</pre>当然你也可以建立一个起始行是`#!/bin/more`的README文件，并且使它可以执行。结果就是这个文件成为了一个可以打印本身的文件。（查看样例 19-3，使用`cat`命令的here document也许是一个更好的选择）
 </li>
<li id="footnote5"><p>可移植操作系统接口（POSIX）尝试标准化类UNIX操作系统。POSIX规范可以在<a href="http://www.opengroup.org/onlinepubs/007904975/toc.htm" target="_blank" rel="noopener noreferrer">Open Group site</a>中查看。 </p>
</li>
<li id="footnote6"><p>为了避免这种情况的发生，可以使用<code>#!/bin/env bash</code>作为起始行。这在bash不在<code>/bin</code>的UNIX系统中会有效果。 </p>
</li>
<li id="footnote7"><p>如果bash是系统默认shell，那么脚本并不一定需要#!作为起始行。但是当你在其他的shell中运行脚本，例如tcsh，则需要使用#!。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第一部分 初见Shell</title>
    <id>https://clay-wangzhi.com/code/shell/part1/</id>
    <link href="https://clay-wangzhi.com/code/shell/part1/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第一部分-初见shell"> 第一部分 初见Shell</h1>
<blockquote>
<p><em>脚本：文章；书面文档</em></p>
<p><em>——韦伯斯特字典1913年版</em></p>
</blockquote>
<p>Shell是一种命令解释器，它不仅分离了用户层与操作系统内核，更是一门强大的编程语言。我们称为shell编写的程序为脚本（script）。脚本是一种易于使用的工具，它能够将系统调用、工具软件、实用程序（utility）和已编译的二进制文件联系在一起构建程序。实际上，shell脚本可以调用所有的UNIX命令、实用程序以及工具软件。如果你觉得这还不够，使用像<code>test</code>命令和循环结构这样的shell内建命令能够让脚本更加灵活强大。Shell脚本特别适合完成系统管理任务和那些不需要复杂结构性语言实现的重复工作。</p>
<h3 id="内容目录"> 内容目录</h3>
<ul>
<li><a href="./01_shell_programming.html">1. 为什么使用shell编程</a></li>
<li><a href="./02_starting_off_with_a_sha_bang.html">2. 和Sha-Bang（#!）一起出发</a>
<ul>
<li><a href="./02_1_invoking_the_script.html">2.1 调用一个脚本</a></li>
<li><a href="./02_2_preliminary_exercises.html">2.2 牛刀小试</a></li>
</ul>
</li>
</ul>
<p>原著链接：http://tldp.org/LDP/abs/html/</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第三章 特殊字符</title>
    <id>https://clay-wangzhi.com/code/shell/part2/03_special_characters/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/03_special_characters/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第三章-特殊字符"> 第三章 特殊字符</h1>
<p>是什么让一个字符变得<em>特殊</em>呢？如果一个字符不仅具有<em>字面</em>意义，而且具有<em>元意（meta-meaning）</em>，我们就称它为特殊字符。特殊字符同命令和关键词（keywords）一样，是bash脚本的组成部分。</p>
<p>你在脚本或其他地方都能够找到特殊字符。</p>
<h3 id=""> #</h3>
<p>注释符。如果一行脚本的开头是#（除了#!），那么代表这一行是注释，不会被执行。</p>
<div><pre><code><span># 这是一行注释</span>
</code></pre>
<div><span>1</span><br></div></div><p>注释也可能会在一行命令结束之后出现。</p>
<div><pre><code><span>echo</span> <span>"A comment will follow."</span> <span># 这儿可以写注释</span>
<span>#                            ^ 注意在#之前有空格</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>注释也可以出现在一行开头的空白符（whitespace）之后。</p>
<div><pre><code>	<span># 这个注释前面存在着一个制表符（tab）</span>
</code></pre>
<div><span>1</span><br></div></div><p>注释甚至可以嵌入到管道命令（pipe）之中。</p>
<div><pre><code><span>initial</span><span>=</span><span>(</span> <span><span>`</span><span>cat</span> <span>"<span>$startfile</span>"</span> <span>|</span> <span>sed</span> -e <span>'/#/d'</span> <span>|</span> <span>tr</span> -d <span>'<span title="\n">\n</span>'</span> <span>|</span><span>\</span>
<span># 删除所有带'#'注释符号的行</span>
           <span>sed</span> -e <span>'s/\./\. /g'</span> -e <span>'s/_/_ /g'</span><span>`</span></span> <span>)</span>
<span># 摘录自脚本 life.sh</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="notice" /> 命令不能写在同一行注释之后。因为没有任何方法可以结束注释(仅支持单行注释)，为了让新命令正常执行，另起一行写吧。</p>
</blockquote>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 当然，在<code>echo</code>语句中被引用或被转义的#不会被认为是注释。同样，在某些参数替换式或常量表达式中的#也不会被认为是注释。</p>
</blockquote>
<div><pre><code><span>echo</span> <span>"The # here does not begin a comment."</span>
<span>echo</span> <span>'The # here does not begin a comment.'</span>
<span>echo</span> The <span>\</span># here does not begin a comment.
<span>echo</span> The <span># here begins a comment.</span>

<span>echo</span> <span>${<span>PATH</span><span>#</span>*<span>:</span>}</span>       <span># 参数替换而非注释</span>
<span>echo</span> <span><span>$((</span> <span>2</span>#<span>101011</span> <span>))</span></span>  <span># 进制转换而非注释</span>

<span># 感谢S.C.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>因为引用符和转义符（&quot; ' \）转义了#。</p>
<p>一些模式匹配操作同样使用了#。</p>
<h3 id="-2"> ;</h3>
<p>命令分隔符[分号]。允许在同一行内放置两条或更多的命令。</p>
<div><pre><code><span>echo</span> hello<span>;</span> <span>echo</span> there

<span>if</span> <span>[</span> -x <span>"<span>$filename</span>"</span> <span>]</span><span>;</span> <span>then</span>    <span>#  注意在分号以后有一个空格</span>
<span>#+                   ^^</span>
  <span>echo</span> <span>"File <span>$filename</span> exists."</span><span>;</span> <span>cp</span> <span>$filename</span> <span>$filename</span>.bak
<span>else</span>   <span>#                       ^^</span>
  <span>echo</span> <span>"File <span>$filename</span> not found."</span><span>;</span> <span>touch</span> <span>$filename</span>
<span>fi</span><span>;</span> <span>echo</span> <span>"File test complete."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注意有时候&quot;;&quot;需要被转义才能正常工作。</p>
<h3 id="-3"> ;;</h3>
<p><code>case</code>条件语句终止符[双分号]。</p>
<div><pre><code><span>case</span> <span>"<span>$variable</span>"</span> <span>in</span>
  abc<span>)</span>  <span>echo</span> <span>"\<span>$variable</span> = abc"</span> <span>;</span><span>;</span>
  xyz<span>)</span>  <span>echo</span> <span>"\<span>$variable</span> = xyz"</span> <span>;</span><span>;</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="-4"> ;;&amp;, ;&amp;</h3>
<p><code>case</code>条件语句终止符（Bash4+ 版本）。</p>
<h3 id="-5"> .</h3>
<p>句点命令[句点]。等价于<code>source</code>命令（查看样例 15-22）。这是一个bash的内建命令。</p>
<h3 id="-6"> .</h3>
<p>句点可以作为文件名的一部分。如果它在文件名开头，那说明此文件是隐藏文件。使用不带参数的<code>ls</code>命令不会显示隐藏文件。</p>
<div><pre><code>bash$ touch .hidden-file
bash$ ls -l
total 10
 -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook
	
	
bash$ ls -al
total 14
 drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
 drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
 -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>当句点出现在目录中时，单个句点代表当前工作目录，两个句点代表上级目录。</p>
<div><pre><code>bash$ pwd
/home/bozo/projects

bash$ cd .
bash$ pwd
/home/bozo/projects

bash$ cd ..
bash$ pwd
/home/bozo/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>句点通常代表文件移动的目的地（目录），下式代表的是当前目录。</p>
<div><pre><code>bash$ cp /home/bozo/current_work/junk/* .
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>复制所有的“垃圾文件”到<code>当前目录</code></p>
</blockquote>
<h3 id="-7"> .</h3>
<p>句点匹配符。在<em>正则表达式</em>中，点号意味着匹配任意单个字符。</p>
<h3 id="-8"> &quot;</h3>
<p>部分引用[双引号]。在字符串中保留大部分特殊字符。详细内容将在<a href="./05_quoting.html">第五章</a>介绍。</p>
<h3 id="-9"> '</h3>
<p>全引用[单引号]。在字符串中保留所有的特殊字符。是部分引用的强化版。详细内容将在<a href="./05_quoting.html">第五章</a>介绍。</p>
<h3 id="-10"> ,</h3>
<p>逗号运算符。逗号运算符<sup></sup>将一系列的算术表达式串联在一起。算术表达式依次被执行，但只返回最后一个表达式的值。</p>
<div><pre><code><span>let</span> <span>"t2 = <span><span>((</span>a <span>=</span> <span>9</span><span>,</span> <span>15</span> <span>/</span> <span>3</span><span>))</span></span>"</span>
<span># a被赋值为9，t2被赋值为15 / 3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>逗号运算符也可以用来连接字符串。</p>
<div><pre><code><span>for</span> <span>file</span> <span>in</span> /<span>{</span>,usr/<span>}</span>bin/*calc
<span>#             ^    在 /bin 与 /usr/bin 目录中</span>
<span>#+                 找到所有的以"calc"结尾的可执行文件</span>
<span>do</span>
        <span>if</span> <span>[</span> -x <span>"<span>$file</span>"</span> <span>]</span>
        <span>then</span>
          <span>echo</span> <span>$file</span>
        <span>fi</span>
<span>done</span>

<span># /bin/ipcalc</span>
<span># /usr/bin/kcalc</span>
<span># /usr/bin/oidcalc</span>
<span># /usr/bin/oocalc</span>

<span># 感谢Rory Winston提供的执行结果</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="-11"> ,, ,</h3>
<p>在参数替换中进行小写字母转换（Bash4 新增）。</p>
<h3 id="-12"> \</h3>
<p>转义符[反斜杠]。转义某字符的标志。</p>
<p><code>\x</code>转义了字符x。双引号&quot;&quot;内的X与单引号内的X具有同样的效果。
转义符也可以用来转义&quot;与'，使它们表达其字面含义。</p>
<p>第五章将更加深入的解释转义字符。</p>
<h3 id="-13"> /</h3>
<p>文件路径分隔符[正斜杠]。起分割路径的作用。（比如 <code>/home/bozo/projects/Makefile</code>）</p>
<p>它也在算术运算中充当除法运算符。</p>
<h3 id="-14"> `</h3>
<p>命令替换符。<code>`command`</code>结构可以使得命令的输出结果赋值给一个变量。通常也被称作后引号（backquotes）或反引号（backticks）。</p>
<h3 id="-15"> :</h3>
<p>空命令[冒号]。它在shell中等价于&quot;NOP&quot;（即no op，空操作）与shell内建命令true有同样的效果。它本身也是Bash的内建命令之一，返回值是true（0）。</p>
<div><pre><code><span>:</span>
<span>echo</span> <span>$?</span>   <span># 返回0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在无限循环中的应用：</p>
<div><pre><code><span>while</span> <span>:</span>
<span>do</span>
   operation-1
   operation-2
   <span>..</span>.
   operation-n
<span>done</span>

<span># 等价于</span>
<span>#    while true</span>
<span>#    do</span>
<span>#      ...</span>
<span>#    done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>可在 <code>if/then</code> 中充当占位符：</p>
<div><pre><code><span>if</span> condition
<span>then</span> <span>:</span>   <span># 什么都不做，跳出判断执行下一条语句</span>
<span>else</span>
   take-some-action
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在二元操作中作占位符: 查看<em>样例 8-2</em>或<em>默认参数</em>部分。</p>
<div><pre><code><span>:</span> <span>${username=`whoami`}</span>
<span># ${username=`whoami`}   如果没有:就会报错</span>
<span>#                        除非 "username" 是系统命令或内建命令</span>

<span>:</span> <span>${1?"Usage<span>:</span> $0 ARGUMENT"}</span>     <span># 摘自样例脚本 "usage-message.sh"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>查看<em>样例 19-10</em>了解空命令在here document中作为占位符的情况。</p>
<p>使用参数替换为字符串变量赋值（查看<em>样例 10-7</em>）。</p>
<div><pre><code><span>:</span> <span>${<span>HOSTNAME</span>?}</span> <span>${<span>USER</span>?}</span> <span>${MAIL?}</span>
<span>#  如果其中一个或多个必要的环境变量没有被设置</span>
<span>#  将会打印错误</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>查看<em>变量扩展</em>或<em>字符串替换</em>章节了解空命令在其中的作用。</p>
<p>与<code>&gt;</code>重定向操作符结合，可以在不改变文件权限的情况下清空文件。如果文件不存在，那么将创建这个文件。</p>
<div><pre><code><span>:</span> <span>></span> data.xxx   <span># 文件 "data.xxx" 已被清空</span>

<span># 与 cat /dev/null >data.xxx 作用相同</span>
<span># 但是此操作不会产生一个新进程，因为 ":" 是shell内建命令。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>也可查看<em>样例 16-15</em>。</p>
<p>与<code>&gt;&gt;</code>重定向操作符结合，将不会清空任何已存在的文件（<code>: &gt;&gt; target_file</code>）。如果文件不存在，将创建这个文件。</p>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 以上操作仅适用于普通文件，不适用于管道、符号链接和特殊文件。</p>
</blockquote>
<p>空命令可以用来作为一行注释的开头，尽管我们并不推荐这么做。使用 # 可以使解释器关闭该行的错误检测，所以几乎所有的内容都可以出现在注释#中。使用空命令却不是这样的：</p>
<div><pre><code><span>:</span> 这一行注释将会产生一个错误，<span>(</span> <span>if</span> <span>[</span> <span>$x</span> -eq <span>3</span><span>]</span> <span>)</span>。
</code></pre>
<div><span>1</span><br></div></div><p>:也可以作为一个域分隔符，比如在<code>/etc/passwd</code>和 <code>$PATH</code> 变量中。</p>
<div><pre><code>bash$ echo $PATH
/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>将冒号作为函数名也是可以的。</p>
<div><pre><code>:<span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"The name of this function is "</span><span>$FUNCNAME</span><span>" "</span>
  <span># 为什么要使用冒号作函数名？</span>
  <span># 这是一种混淆代码的方法......</span>
<span>}</span>

<span>:</span>

<span># 函数名是 :</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这种写法并不具有可移植性，也不推荐使用。事实上，在Bash的最近的版本更新中已经禁用了这种用法。但我们还可以使用*下划线 _*来替代。</p>
<p>冒号也可以作为非空函数的占位符。</p>
<div><pre><code><span>not_empty</span> <span>(</span><span>)</span>
<span>{</span>
  <span>:</span>
<span>}</span> <span># 含有空指令，这并不是一个空函数。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="-16"> !</h3>
<p>取反（或否定）操作符[感叹号]。! 操作符反转已执行的命令的返回状态（查看<em>样例 6-2</em>）。它同时可以反转测试操作符的意义，例如可以将相等（=）反转成不等（!=）。它是一个Bash关键词。</p>
<p>在一些特殊场景下，它也会出现在间接变量引用中。</p>
<p>在另外一些特殊场景下，即在命令行下可以使用 ! 调用Bash的历史记录（<em>附录 L</em>）。需要注意的是，在脚本中，这个机制是被禁用的。</p>
<h3 id="-17"> *</h3>
<p>通配符[星号]。在文件匹配（globbing）操作时扩展文件名。如果它独立出现，则匹配该目录下的所有文件。</p>
<div><pre><code>bash$ echo *
abs-book.sgml add-drive.sh agram.sh alias.sh
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在<em>正则表达式</em>中表示匹配任意多个（包括0）前个字符。</p>
<h3 id="-18"> *</h3>
<p>算术运算符。在进行算术运算时，表示乘法运算。</p>
<p>** 双星号可以表示乘方运算或扩展文件匹配。</p>
<h3 id="-19"> ?</h3>
<p>测试操作符[问号]。在一些特定的语句中，? 表示一个条件测试。</p>
<p>在一个双圆括号结构中，? 可以表示一个类似C语言风格的三元（trinary）运算符的一个组成部分。<sup></sup></p>
<p><code>condition?result-if-true:result-if-false</code></p>
<div><pre><code><span><span>((</span> var0 <span>=</span> var1<span>&lt;</span><span>98</span><span>?</span><span>9</span><span>:</span><span>21</span> <span>))</span></span>
<span>#不要加空格，紧挨着写</span>

<span>#等价于</span>
<span># if [ "$var1" -lt 98 ]</span>
<span># then</span>
<span>#   var0=9</span>
<span># else</span>
<span>#   var0=21</span>
<span># fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>在参数替换表达式中，? 用来测试一个变量是否已经被赋值。</p>
<h3 id="-20"> ?</h3>
<p>通配符。它在进行文件匹配（globbing）时以单字符通配符扩展文件名。
在<em>扩展正则表达式</em>中匹配一个单字符。</p>
<h3 id="-21"> $</h3>
<p>取值符号[钱字符]，用来进行变量替换（即取出变量的内容）。</p>
<div><pre><code><span>var1</span><span>=</span><span>5</span>
<span>var2</span><span>=</span>23skidoo

<span>echo</span> <span>$var1</span>     <span># 5</span>
<span>echo</span> <span>$var2</span>     <span># 23skidoo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果在变量名前有 $，则表示此变量的值。</p>
<h3 id="-22"> $</h3>
<p>行结束符[EOF]。
在<em>正则表达式</em>中，$ 匹配行尾字符串。</p>
<h3 id="-23"> ${}</h3>
<p>参数替换。</p>
<h3 id="-24"> $'...'</h3>
<p>引用字符串扩展。这个结构将转义八进制或十六进制的值转换成ASCII<sup></sup>或Unicode字符。</p>
<h3 id="-25"> $*, $@</h3>
<p>位置参数。</p>
<h3 id="-26"> $?</h3>
<p>返回状态变量。此变量保存一个命令、一个函数或该脚本自身的返回状态。</p>
<h3 id="-27"> $$</h3>
<p>进程ID变量。此变量保存该运行脚本的进程ID<sup></sup>。</p>
<h3 id="-28"> ()</h3>
<p>命令组。</p>
<p><code>(a=hello; echo $a)</code></p>
<p><img src="http://tldp.org/LDP/abs/images/important.gif" alt="notice" /> 通过括号执行一系列命令会产生一个子shell（subshell）。
括号中的变量，即在子shell中的变量，在脚本的其他部分是不可见的。父进程脚本不能访问子进程（子shell）所创建的变量。</p>
<div><pre><code><span>a</span><span>=</span><span>123</span>
<span>(</span> <span>a</span><span>=</span><span>321</span><span>;</span> <span>)</span>

<span>echo</span> <span>"a = <span>$a</span>"</span>   <span># a = 123</span>
<span># 在括号中的 "a" 就像个局部变量。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>数组初始化。</p>
<div><pre><code><span>Array</span><span>=</span><span>(</span>element1 element2 element3<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="xxx-yyy-zzz"> {xxx,yyy,zzz,...}</h3>
<p>花括号扩展结构。</p>
<div><pre><code><span>echo</span> <span>\</span>"<span>{</span>These,words,are,quoted<span>}</span><span>\</span>"   <span># " 将作为单词的前缀和后缀</span>
<span># "These" "words" "are" "quoted"</span>


<span>cat</span> <span>{</span>file1,file2,file3<span>}</span> <span>></span> combined_file
<span># 将 file1, file2 与 file3 拼接在一起后写入 combined_file 中。</span>

<span>cp</span> file22.<span>{</span>txt,backup<span>}</span>
<span># 将 "file22.txt" 拷贝为 "file22.backup"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这个命令可以作用于花括号内由逗号分隔的文件描述列表。<sup></sup> 文件名扩展（匹配）作用于大括号间的各个文件。</p>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="notice" /> 除非被引用或被转义，否则空白符不应在花括号中出现。</p>
<div><pre><code><span>echo</span> <span>{</span>file1,file2<span>}</span><span>\</span> :<span>{</span><span>\</span> A,<span>" B"</span>,<span>' C'</span><span>}</span>
file1 <span>:</span> A file1 <span>:</span> B file1 <span>:</span> C file2 <span>:</span> A file2 <span>:</span> B file2 <span>:</span> C
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="a-z"> {a..z}</h3>
<p>扩展的花括号扩展结构。</p>
<div><pre><code><span>echo</span> <span>{</span>a<span>..</span>z<span>}</span> <span>#  a b c d e f g h i j k l m n o p q r s t u v w x y z</span>
<span># 输出 a 到 z 之间所有的字母。</span>
	
<span>echo</span> <span>{</span><span>0</span><span>..</span><span>3</span><span>}</span> <span># 0 1 2 3</span>
<span># 输出 0 到 3 之间所有的数字。</span>


<span>base64_charset</span><span>=</span><span>(</span> <span>{</span>A<span>..</span>Z<span>}</span> <span>{</span>a<span>..</span>z<span>}</span> <span>{</span><span>0</span><span>..</span><span>9</span><span>}</span> + / <span>=</span> <span>)</span>
<span># 使用扩展花括号初始化一个数组。</span>
<span># 摘自 vladz 编写的样例脚本 "base64.sh"。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>Bash第三版中引入了 {a..z} 扩展的花括号扩展结构。</p>
<h3 id="-29"> {}</h3>
<p>代码块[花括号]，又被称作内联组（inline group）。它实际上创建了一个匿名函数（anonymous function），即没有名字的函数。但是，不同于那些“标准”函数，代码块内的变量在脚本的其他部分仍旧是可见的。</p>
<div><pre><code>bash$ { local a;
              a=123; }
bash: local: can only be used in a
function
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>a</span><span>=</span><span>123</span>
<span>{</span> <span>a</span><span>=</span><span>321</span><span>;</span> <span>}</span>
<span>echo</span> <span>"a = <span>$a</span>"</span>   <span># a = 321   (代码块内赋值)</span>

<span># 感谢S.C.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码块可以经由I/O重定向进行输入或输出。</p>
<p><strong>样例 3-1. 代码块及I/O重定向</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span># 读取文件 /etc/fstab</span>

<span>File</span><span>=</span>/etc/fstab

<span>{</span>
<span>read</span> line1
<span>read</span> line2
<span>}</span> <span>&lt;</span> <span>$File</span>

<span>echo</span> <span>"First line in <span>$File</span> is:"</span>
<span>echo</span> <span>"<span>$line1</span>"</span>
<span>echo</span>
<span>echo</span> <span>"Second line in <span>$File</span> is:"</span>
<span>echo</span> <span>"<span>$line2</span>"</span>

<span>exit</span> <span>0</span>

<span># 你知道如何解析剩下的行吗？</span>
<span># 提示：使用 awk 或...</span>
<span># Hans-Joerg Diers 建议：使用Bash的内建命令 set。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><strong>样例 3-2. 将代码块的输出保存至文件中</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span># rpm-check.sh</span>

<span># 查询一个rpm文件的文件描述、包含文件列表，以及是否可以被安装。</span>
<span># 将输出保存至文件。</span>
<span>#</span>
<span># 这个脚本使用代码块来描述。</span>

<span>SUCCESS</span><span>=</span><span>0</span>
<span>E_NOARGS</span><span>=</span><span>65</span>

<span>if</span> <span>[</span> -z <span>"<span>$1</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"Usage: <span><span>`</span><span>basename</span> $0<span>`</span></span> rpm-file"</span>
  <span>exit</span> <span>$E_NOARGS</span>
<span>fi</span>  

<span>{</span> <span># 代码块起始</span>
  <span>echo</span>
  <span>echo</span> <span>"Archive Description:"</span>
  <span>rpm</span> -qpi <span>$1</span>       <span># 查询文件描述。</span>
  <span>echo</span>
  <span>echo</span> <span>"Archive Listing:"</span>
  <span>rpm</span> -qpl <span>$1</span>       <span># 查询文件列表。</span>
  <span>echo</span>
  <span>rpm</span> -i --test <span>$1</span>  <span># 查询是否可以被安装。</span>
  <span>if</span> <span>[</span> <span>"<span>$?</span>"</span> -eq <span>$SUCCESS</span> <span>]</span>
  <span>then</span>
    <span>echo</span> <span>"<span>$1</span> can be installed."</span>
  <span>else</span>
    <span>echo</span> <span>"<span>$1</span> cannot be installed."</span>
  <span>fi</span>  
  <span>echo</span>              <span># 代码块结束。</span>
<span>}</span> <span>></span> <span>"<span>$1</span>.test"</span>       <span># 输出重定向至文件。</span>

<span>echo</span> <span>"Results of rpm test in file <span>$1</span>.test"</span>

<span># rpm各项参数的具体含义可查看man文档</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 与由圆括号包裹起来的命令组不同，由花括号包裹起来的代码块不产生子进程。<sup></sup></p>
<p>也可以使用非标准的 for 循环语句来遍历代码块。</p>
<h3 id="-30"> {}</h3>
<p>文本占位符。在 <code>xargs -i</code> 后作为输出的占位符使用。</p>
<div><pre><code><span>ls</span> <span>.</span> <span>|</span> <span>xargs</span> -i -t <span>cp</span> ./<span>{</span><span>}</span> <span>$1</span>
<span>#            ^^         ^^</span>

<span># 摘自 "ex42.sh" (copydir.sh)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="-31"> {} ;</h3>
<p>路径名。通常在 <code>find</code> 命令中使用，但这不是shell的内建命令。</p>
<blockquote>
<p>定义：路径名是包含完整路径的文件名，例如<code>/home/bozo/Notes/Thursday/schedule.txt</code>。我们通常又称之为绝对路径。</p>
</blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 在执行<code>find -exec</code>时最后需要加上<code>;</code>，但是分号需要被转义以保证其不会被shell解释。</p>
<h3 id="-32"> [ ]</h3>
<p>测试。在 [ ] 之间填写测试表达式。值得注意的是，[ 是shell内建命令 <code>test</code> 的一个组成部分，而不是外部命令 <code>/usr/bin/test</code> 的链接。</p>
<h3 id="-33"> [[ ]]</h3>
<p>测试。在 [[ ]] 之间填写测试表达式。相比起单括号测试 （[ ]），它更加的灵活。它是一个shell的关键字。</p>
<p>详情查看<em>关于 [[ ]] 结构的讨论</em>。</p>
<h3 id="-34"> [ ]</h3>
<p>数组元素。在数组中，可以使用中括号的偏移量来用来访问数组中的每一个元素。</p>
<div><pre><code>Array<span>[</span><span>1</span><span>]</span><span>=</span>slot_1
<span>echo</span> <span>${Array<span>[</span>1<span>]</span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="-35"> [ ]</h3>
<p>字符集、字符范围。
在<em>正则表达式</em>中，中括号用来匹配指定字符集或字符范围内的任意字符。</p>
<h3 id="-36"> $[ ... ]</h3>
<p>整数扩展符。在 $[ ] 中可以计算整数的算术表达式。</p>
<div><pre><code><span>a</span><span>=</span><span>3</span>
<span>b</span><span>=</span><span>7</span>

<span>echo</span> $<span>[</span><span>$a</span>+<span>$b</span><span>]</span>   <span># 10</span>
<span>echo</span> $<span>[</span><span>$a</span>*<span>$b</span><span>]</span>   <span># 21</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="-37"> (( ))</h3>
<p>整数扩展符。在 (( )) 中可以计算整数的算术表达式。</p>
<p>详情查看<em>关于 (( ... )) 结构的讨论</em>。</p>
<h3 id="-38"> &gt; &amp;&gt; &gt;&amp; &gt;&gt; &lt; &lt;&gt;</h3>
<p>重定向。</p>
<p><code>scriptname &gt;filename</code> 将脚本 <em>scriptname</em> 的输出重定向到 <em>filename</em> 中。如果文件存在，那么覆盖掉文件内容。</p>
<p><code>command &amp;&gt;filename</code> 将命令 <em>command</em> 的标准输出(stdout) 和标准错误输出(stderr) 重定向到 <em>filename</em>。</p>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 重定向在用于清除测试条件的输出时特别有效。例如测试一个特定的命令是否存在。</p>
<div><pre><code>bash$ type bogus_command &amp;&gt;/dev/null


bash$ echo $?
1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>或写在脚本中：</p>
<div><pre><code><span>command_test</span> <span>(</span><span>)</span> <span>{</span> <span>type</span> <span>"<span>$1</span>"</span> <span>&amp;></span>/dev/null<span>;</span> <span>}</span>
<span>#                                      ^</span>
 
<span>cmd</span><span>=</span>rmdir            <span># 存在的命令。</span>
command_test <span>$cmd</span><span>;</span> <span>echo</span> <span>$?</span>   <span># 返回0</span>


<span>cmd</span><span>=</span>bogus_command    <span># 不存在的命令。</span>
command_test <span>$cmd</span><span>;</span> <span>echo</span> <span>$?</span>   <span># 返回1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>command &gt;&amp;2</code> 将命令的标准输出重定向至标准错误输出。</p>
<p><code>scriptname &gt;&gt;filename</code> 将脚本 <em>scriptname</em> 的输出追加到 <em>filename</em> 文件末尾。如果文件不存在，那么将创建这个文件。</p>
<p><code>[i]&lt;&gt;filename</code> 打开文件 <em>filename</em> 用来读写，并且分配一个文件描述符<em>i</em>指向它。如果文件不存在，那么将创建这个文件。</p>
<p>进程替换：
<code>(command)&gt;</code>
<code>&lt;(command)</code></p>
<p>在某些情况下， &quot;&lt;&quot; 与 &quot;&gt;&quot; 将用作字符串比较。</p>
<p>在另外一些情况下， &quot;&lt;&quot; 与 &quot;&gt;&quot; 将用作数字比较。详情查看<em>样例 16-9</em>。</p>
<h3 id="-39"> &lt;&lt;</h3>
<p>在here document中进行重定向。</p>
<h3 id="-40"> &lt;&lt;&lt;</h3>
<p>在here string中进行重定向。</p>
<h3 id="-41"> &lt;, &gt;</h3>
<p>ASCII码比较。</p>
<div><pre><code><span>veg1</span><span>=</span>carrots
<span>veg2</span><span>=</span>tomatoes

<span>if</span> <span>[</span><span>[</span> <span>"veg1"</span> <span>&lt;</span> <span>"veg2"</span> <span>]</span><span>]</span>
<span>then</span>
  <span>echo</span> <span>"Although <span>$veg1</span> precede <span>$veg2</span> in the dictionary,"</span>
  <span>echo</span> -n <span>"this does not necessarily imply anything "</span>
  <span>echo</span> <span>"about my culinary preferences."</span>
<span>else</span>
  <span>echo</span> <span>"What kind of dictionary are you using, anyhow?"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="-42"> &lt;, &gt;</h3>
<p><em>正则表达式</em>中的单词边界（word boundary）。</p>
<div><pre><code>bash$ grep &#39;\&lt;the\&gt;&#39; textfile
</code></pre>
<div><span>1</span><br></div></div><h3 id="-43"> |</h3>
<p>管道（pipe）。管道可以将上一个命令的输出作为下一个命令的输入，或者直接输出到shell中。管道是一种可以将一系列命令连接在一起的绝妙方式。</p>
<div><pre><code><span>echo</span> <span>ls</span> -l <span>|</span> <span>sh</span>
<span>#  将 "echo ls -l" 的结果输出到shell中，</span>
<span>#  与直接输入 "ls -l" 的结果相同。</span>


<span>cat</span> *.lst <span>|</span> <span>sort</span> <span>|</span> <span>uniq</span>
<span># 将所有后缀名为 lst 的文件合并后排序，接着删掉所有重复行。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>管道是一种在进程间通信的典型方法。它将一个进程的输出作为另一个进程的输入。举一个经典的例子，像 <code>cat</code> 或者 <code>echo</code> 这样的命令，可以通过管道将它们产生的数据流导入到过滤器（filter）中。过滤器是可以用来处理输入流的命令。<sup></sup></p>
<p><code>cat $filename1 $filename2 | grep $search_word</code></p>
<p>查看<a href="http://www.faqs.org/faqs/unix-faq/faq/part3/" target="_blank" rel="noopener noreferrer">UNIX FAQ第三章</a>获取更多关于使用UNIX管道的信息。</p>
</blockquote>
<p>命令的输出同样可以通过管道输入到脚本中。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># uppercase.sh : 将所有输入变成大写</span>

<span>tr</span> <span>'a-z'</span> <span>'A-Z'</span>
<span>#  为了防止产生单字符文件名，</span>
<span>#  必须使用单引号引用字符范围。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>现在，让我们将 <code>ls -l</code> 的输出通过管道导入到脚本中。</p>
<div><pre><code>bash$ ls -l | ./uppercase.sh
 -RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
 -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
 -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 在管道中，每一个进程的输出必须作为下个进程的输入被正确读入，如果不这样，数据流会被阻塞（block），管道就无法按照预期正常工作。</p>
<div><pre><code><span>cat</span> file1 file2 <span>|</span> <span>ls</span> -l <span>|</span> <span>sort</span>
<span># "cat file1 file2" 的输出会消失。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>管道是在一个子进程中运行的，因此它并不能修改父进程脚本中的变量。</p>
<div><pre><code><span>variable</span><span>=</span><span>"initial_value"</span>
<span>echo</span> <span>"new_value"</span> <span>|</span> <span>read</span> variable
<span>echo</span> <span>"variable = <span>$variable</span>"</span>     <span># variable = initial_value</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果管道中的任意一个命令意外中止了，管道将会提前中断，我们称其为<em>管道破裂</em>(Broken Pipe)。出现这种情况，系统将发送一个 <code>SIGPIPE</code> 信号。</p>
<h3 id="-44"> &gt;|</h3>
<p>强制重定向。即使在 <code>noclobber</code> 选项被设置的情况下，重定向也会覆盖已存在的文件。</p>
<h3 id="-45"> ||</h3>
<p>或（OR）逻辑运算符。在测试结构中，任意一个测试条件为真，整个表达式为真。返回 0（成功标志位）。</p>
<h3 id="-46"> &amp;</h3>
<p>后台运行操作符。如果命令后带&amp;，那么此命令将转至后台运行。</p>
<div><pre><code>bash$ sleep 10 &amp;
[1] 850
[1]+  Done                    sleep 10
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在脚本中，命令甚至循环都可以在后台运行。</p>
<p><strong>样例 3-3. 在后台运行的循环</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span># background-loop.sh</span>

<span>for</span> <span>i</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span> <span>8</span> <span>9</span> <span>10</span>            <span># 第一个循环</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$i</span> "</span>
<span>done</span> <span>&amp;</span> <span># 这个循环在后台运行。</span>
       <span># 有时会在第二个循环结之后才执行此后台循环。</span>

<span>echo</span>   <span># 此'echo' 有时不显示</span>

<span>for</span> <span>i</span> <span>in</span> <span>11</span> <span>12</span> <span>13</span> <span>14</span> <span>15</span> <span>16</span> <span>17</span> <span>18</span> <span>19</span> <span>20</span>   <span># 第二个循环</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$i</span> "</span>
<span>done</span>

<span>echo</span>   <span># 此'echo' 有时不显示</span>

<span># ======================================================</span>

<span># 脚本期望输出结果：</span>
<span># 1 2 3 4 5 6 7 8 9 10</span>
<span># 11 12 13 14 15 16 17 18 19 20</span>

<span># 一些情况下可能会输出：</span>
<span># 11 12 13 14 15 16 17 18 19 20</span>
<span># 1 2 3 4 5 6 7 8 9 10 bozo $</span>
<span># 第二个 'echo' 没有被执行，为什么？</span>

<span># 另外一些情况下可能会输出：</span>
<span># 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</span>
<span># 第一个 'echo' 没有被执行，为什么？</span>

<span># 非常罕见的情况下，可能会输出：</span>
<span># 11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20</span>
<span># 前台循环抢占（preempt）了后台循环。</span>

<span>exit</span> <span>0</span>

<span>#  Nasimuddin Ansari 建议：在第6行和第14行的</span>
<span>#  echo -n "$i " 后增加 sleep 1，</span>
<span>#  会得到许多有趣的结果。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="notice" /> 脚本在后台执行命令时可能因为等待键盘事件被挂起。幸运的是，有一套方案可以解决这个问题。</p>
<h3 id="-47"> &amp;&amp;</h3>
<p>与（AND）逻辑操作符。在测试结构中，所有测试条件都为真，表达式才为真，返回 0（成功标志位）。</p>
<h3 id="-48"> -</h3>
<p>选项与前缀。它可以作为命令的选项标志，也可以作为一个操作符的前缀，也可以作为在参数代换中作为默认参数的前缀。</p>
<p><code>COMMAND -[Option1][Option2][..]</code></p>
<p><code>ls -al</code></p>
<p><code>sort -dfu $filename</code></p>
<div><pre><code><span>if</span> <span>[</span> <span>$file1</span> -ot <span>$file2</span> <span>]</span>
<span>then</span> <span>#      ^</span>
  <span>echo</span> <span>"File <span>$file1</span> is older than <span>$file2</span>."</span>
<span>fi</span>

<span>if</span> <span>[</span> <span>"<span>$a</span>"</span> -eq <span>"<span>$b</span>"</span> <span>]</span>
<span>then</span> <span>#    ^</span>
  <span>echo</span> <span>"<span>$a</span> is equal to <span>$b</span>."</span>
<span>fi</span>

<span>if</span> <span>[</span> <span>"<span>$c</span>"</span> -eq <span>24</span> -a <span>"<span>$d</span>"</span> -eq <span>47</span> <span>]</span>
<span>then</span> <span>#    ^              ^</span>
  <span>echo</span> <span>"<span>$c</span> equals 24 and <span>$d</span> equals 47."</span>
<span>fi</span>


<span>param2</span><span>=</span><span>${param1<span>:-</span>$DEFAULTVAL}</span>
<span>#               ^</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="-49"> --</h3>
<p>双横线一般作为命令长选项的前缀。</p>
<p><code>sort --ignore-leading-blanks</code></p>
<p>双横线与Bash内建命令一起使用时，意味着该命令选项的结束。</p>
<p><img src="http://tldp.org/LDP/abs/images/tip.gif" alt="info" /> 下面提供了一种删除文件名以横线开头文件的简单方法。</p>
<div><pre><code>bash$ ls -l
-rw-r--r-- 1 bozo bozo 0 Nov 25 12:29 -badname


bash$ rm -- -badname

bash$ ls -l
total 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>双横线通常也和 <code>set</code> 连用。</p>
<p><code>set -- $variable</code>（查看<em>样例 15-18</em>）。</p>
<h3 id="-50"> -</h3>
<p>重定向输入输出[短横线]。</p>
<div><pre><code>bash$ cat -
abc
abc

...

Ctl-D
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在这个例子中，<code>cat -</code> 输出由键盘读入的标准输入(stdin) 到 标准输出(stdout)。但是在真实应用的 I/O 重定向中是否有使用 '-'？</p>
<div><pre><code><span>(</span>cd /source/directory <span>&amp;&amp;</span> <span>tar</span> cf - <span>.</span> <span>)</span> <span>|</span> <span>(</span>cd /dest/directory <span>&amp;&amp;</span> <span>tar</span> xpvf -<span>)</span>

<span># 将整个文件树从一个目录移动到另一个目录。</span>
<span># 感谢 Alan Cox &lt;a.cox@swansea.ac.uk> 所作出的部分改动</span>

<span># 1) cd /source/directory</span>
<span>#    工作目录定位到文件所属的源目录</span>
<span># 2) &amp;&amp;</span>
<span>#    "与链"：如果 'cd' 命令操作成功，那么执行下一条命令</span>
<span># 3) tar cf - .</span>
<span>#    'tar c' (create 创建) 创建一份新的档案</span>
<span>#    'tar f -' (file 指定文件) 在 '-' 后指定一个目标文件作为输出</span>
<span>#    '.' 代表当前目录</span>
<span># 4) |</span>
<span>#    通过管道进行重定向</span>
<span># 5) ( ... )</span>
<span>#    在建立的子进程中执行命令</span>
<span># 6) cd /dest/directory</span>
<span>#    工作目录定位到目标目录</span>
<span># 7) &amp;&amp;</span>
<span>#    与 2) 相同</span>
<span># 8) tar xpvf -</span>
<span>#    'tar x' 解压档案</span>
<span>#    'tar p' (preserve 保留) 保留档案内文件的所有权及文件权限</span>
<span>#    'tar v' (verbose 冗余) 发送全部信息到标准输出</span>
<span>#    'tar f -' (file 指定文件) 在 '-' 后指定一个目标文件作为输入</span>
<span>#</span>
<span>#    注意 'x' 是一个命令，而 'p', 'v', 'f' 是选项。</span>

<span># 干的漂亮！</span>


<span># 更加优雅的写法是:</span>
<span>#   cd source/directory</span>
<span>#   tar cf - . | (cd ../dest/directory; tar xpvf -)</span>
<span>#</span>
<span># 同样可以写成:</span>
<span>#   cp -a /source/directory/* /dest/directory</span>
<span># 或:</span>
<span>#   cp -a /source/directory/* /source/directory/.[^.]* /dest/directory</span>
<span># 可以在源目录中有隐藏文件时使用</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><div><pre><code>bunzip2 -c linux-2.6.16.tar.bz2 <span>|</span> <span>tar</span> xvf -
<span>#  --未解压的 tar 文件--        | --将解压出的 tar 传递给 "tar"--</span>
<span>#  如果不使用管道让 "tar" 处理 "bunzip2" 得到的文件，</span>
<span>#  那么就需要使用单独的两步来完成。</span>
<span>#  目的是为了解压 "bzipped" 压缩的内核源代码。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面的例子中，&quot;-&quot; 并不是一个Bash的操作符，它仅仅是 <code>tar</code>, <code>cat</code> 等一些特定UNIX命令中将结果输出到标准输出的选项。</p>
<div><pre><code>bash$ echo &quot;whatever&quot; | cat -
whatever 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当需要文件名的时候，- 可以用来代替某个文件而重定向到标准输出（通常出现在 <code>tar cf</code> 中）或从 <em>stdin</em> 中接受数据。这是一种在管道中使用面向文件（file-oriented）工具作为过滤器的方法。</p>
<div><pre><code>bash$ file
Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>单独执行 <code>file</code> 命令，将会得到一条错误信息。</p>
<p>在命令后增加一个 &quot;-&quot; 可以得到一个更加有用的结果。它会使得shell暂停等待用户输入。</p>
<div><pre><code>bash$ file -
abc
standard input:              ASCII text


bash$ file -
#!/bin/bash
standard input:              Bourne-Again shell script text executable
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>现在命令能够接受标准输入并且处理它们了。</p>
<p>&quot;-&quot; 能够通过管道将标准输出重定向到其他命令中。这就可以做到像在某个文件前添加几行这样的事情。</p>
<p>使用 <code>diff</code> 比较两个文件的部分内容：</p>
<div><pre><code><span>grep</span> Linux file1 <span>|</span> <span>diff</span> file2 -
</code></pre>
<div><span>1</span><br></div></div><p>最后介绍一个使用 - 的 <code>tar</code> 命令的实际案例。</p>
<p><strong>样例 3-4. 备份最近一天修改过的所有文件</strong></p>
<div><pre><code><span>#!/bin/bash</span>

<span>#  将当前目录下24小时之内修改过的所有文件备份成一个</span>
<span>#  "tarball" (经 tar 打包`与 gzip 压缩) 文件</span>

<span>BACKUPFILE</span><span>=</span>backup-<span><span>$(</span><span>date</span> +%m-%d-%Y<span>)</span></span>
<span>#                 在备份文件中嵌入时间</span>
<span>#                 感谢 Joshua Tschida 提供的建议</span>

<span>archive</span><span>=</span><span>${1<span>:-</span>$BACKUPFILE}</span>
<span>#  如果没有在命令行中特别制定备份格式，</span>
<span>#  那么将会默认设置为 "backup-MM-DD-YYYY.tar.gz"。</span>

<span>tar</span> cvf - <span><span>`</span><span>find</span> <span>.</span> -mtime -1 -type f -print<span>`</span></span> <span>></span> <span>$archive</span>.tar
<span>gzip</span> <span>$archive</span>.tar
<span>echo</span> <span>"Directory <span>$PWD</span> backed up in archive file <span title="\&quot;">\"</span><span>$archive</span>.tar.gz<span title="\&quot;">\"</span>."</span>

<span>#  Stephane Chazeles 指出如果目录中有非常多的文件，</span>
<span>#  或文件名中包含空白符时，上面的代码会运行失败。</span>

<span># 他建议使用以下的任意一种方法：</span>
<span># -------------------------------------------------------------------</span>
<span>#   find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$archive.tar"</span>
<span>#   使用了 GNU 版本的 "find" 命令。</span>


<span>#   find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;</span>
<span>#   兼容其他的 UNIX 发行版，但是速度会比较慢</span>
<span># -------------------------------------------------------------------</span>


<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="notice" /> 以 &quot;-&quot; 开头的文件在和&quot;-&quot; 重定向操作符一起使用时可能会导致一些问题。因此合格的脚本必须首先检查这种情况。如果遇到，就需要给文件名加一个合适的前缀，比如 <code>./-FILENAME, $PWD/-FILENAME</code> 或者<code>$PATHNAME/-FILENAME</code> 。</p>
<p>如果变量的值以 '-' 开头，也可能会造成类似问题。</p>
<div><pre><code><span>var</span><span>=</span><span>'-n'</span>
<span>echo</span> <span>$var</span>
<span># 等同于 "echo -n"，不会输出任何东西。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="-51"> -</h3>
<p>先前的工作目录。使用 <code>cd -</code> 命令可以返回先前的工作目录。它实际上是使用了 <code>$OLDPWD</code> 环境变量。</p>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="notice" /> 不要将这里的 &quot;-&quot; 与先前的 &quot;-&quot; 重定位操作符混淆。&quot;-&quot; 的具体含义需要根据上下文来解释。</p>
<h3 id="-52"> -</h3>
<p>减号。算术运算符中的减法标志。</p>
<h3 id="-53"> =</h3>
<p>等号。赋值操作符。</p>
<div><pre><code><span>a</span><span>=</span><span>28</span>
<span>echo</span> <span>$a</span>   <span># 28</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在一些情况下，&quot;=&quot; 可以作为字符串比较操作符。</p>
<h3 id="-54"> +</h3>
<p>加号。加法算术运算。</p>
<p>在一些情况下，+ 是作为正则表达式中的一个操作符。</p>
<h3 id="-55"> +</h3>
<p>选项操作符。作为一个命令或过滤器的选项标记。</p>
<p>特定的一些指令和内建命令使用 + 启用特定的选项，使用 - 禁用特定的选项。在参数代换中，+ 是作为变量扩展的备用值（alternate value）的前缀。</p>
<h3 id="-56"> %</h3>
<p>取模。取模操作运算符。</p>
<div><pre><code><span>let</span> <span>"z = 5 % 3"</span>
<span>echo</span> <span>$z</span>  <span># 2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在另外一些情况下，% 是一种模式匹配的操作符。</p>
<h3 id="-57"> ~</h3>
<p>主目录[波浪号]。它相当于内部变量 <code>$HOME</code>。<code>~bozo</code> 是 bozo 的主目录，执行 <code>ls ~bozo</code> 将会列出他的主目录中内容。<code>~/</code> 是当前用户的主目录，执行 <code>ls ~/</code> 将会列出其中所有的内容。</p>
<div><pre><code>bash$ echo ~bozo
/home/bozo

bash$ echo ~
/home/bozo

bash$ echo ~/
/home/bozo/

bash$ echo ~:
/home/bozo:

bash$ echo ~nonexistent-user
~nonexistent-user
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="-58"> ~+</h3>
<p>当前工作目录。它等同于内部变量 <code>$PWD</code>。</p>
<h3 id="-59"> ~-</h3>
<p>先前的工作目录。它等同于内部变量 <code>$OLDPWD</code>。</p>
<h3 id="-60"> =~</h3>
<p><em>正则表达式</em>匹配。将在 *Bash version 3 *章节中介绍。</p>
<h3 id="-61"> ^</h3>
<p>行起始符。在正则表达式中，&quot;^&quot; 代表一行文本的开始。</p>
<h3 id="-62"> ^, ^^</h3>
<p>参数替换中的大写转换符（在Bash第4版新增）。</p>
<h3 id="控制字符"> 控制字符</h3>
<p>改变终端或文件显示的一些行为。一个控制符是由 <em>CONTRL + key</em> 组成的（同时按下）。控制字符同样可以通过转义以八进制或十六进制的方式显示。</p>
<p>控制符不能在脚本中使用。</p>
<h4 id="ctrl-a"> Ctrl-A</h4>
<p>移动光标至行首。</p>
<h4 id="ctrl-b"> Ctrl-B</h4>
<p>非破坏性退格（即不删除字符）。</p>
<h4 id="ctrl-c"> Ctrl-C</h4>
<p>中断指令。终止当前运行的任务。</p>
<h4 id="ctrl-d"> Ctrl-D</h4>
<p>登出shell（类似 <code>exit</code>）</p>
<p>键入 <code>EOF</code>（end-of-file，文件终止标记），中断 <em>stdin</em> 的输入。</p>
<p>当你在终端或 <em>xterm</em> 窗口中输入字符时，<code>Ctl-D</code> 将会删除光标上的字符。当没有字符时，<code>Crl-D</code> 将会登出shell。在 <em>xterm</em> 中，将会关闭整个窗口。</p>
<h4 id="ctrl-e"> Ctrl-E</h4>
<p>移动光标至行末。</p>
<h4 id="ctrl-f"> Ctrl-F</h4>
<p>光标向前移动一个字符。</p>
<h4 id="ctrl-g"> Ctrl-G</h4>
<p>响铃<code>BEL</code>。在一些老式打字机终端上，将会响铃。而在 <em>xterm</em> 中，将会产生“哔”声。</p>
<h4 id="ctrl-h"> Ctrl-H</h4>
<p>抹除（破坏性退格）。退格删除前面的字符。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># 在字符串中嵌入 Ctrl-H</span>

<span>a</span><span>=</span><span>"^H^H"</span>                  <span># 两个退格符 Ctrl-H</span>
                          <span># 在 vi/vim 中使用 Ctrl-V Ctrl-H 来键入</span>
<span>echo</span> <span>"abcdef"</span>             <span># abcdef</span>
<span>echo</span>
<span>echo</span> -n <span>"abcdef<span>$a</span> "</span>       <span># abcd f</span>
<span>#                ^              ^ 末尾有空格退格两次的结果</span>
<span>echo</span>
<span>echo</span> -n <span>"abcdef<span>$a</span>"</span>        <span># abcdef</span>
<span>#                                ^ 末尾没有空格时为什么退格无效了？</span>
                          <span># 并不是我们期望的结果。</span>
<span>echo</span><span>;</span> <span>echo</span>

<span># Constantin Hagemeier 建议尝试一下：</span>
<span># a=$'\010\010'</span>
<span># a=$'\b\b'</span>
<span># a=$'\x08\x08'</span>
<span># 但是这些并不会改变结果。</span>

<span>########################################</span>

<span># 现在来试试这个。</span>

<span>rubout</span><span>=</span><span>"^H^H^H^H^H"</span>       <span># 5个 Ctrl-H</span>

<span>echo</span> -n <span>"12345678"</span>
<span>sleep</span> <span>2</span>
<span>echo</span> -n <span>"<span>$rubout</span>"</span>
<span>sleep</span> <span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h4 id="ctrl-i"> Ctrl-I</h4>
<p>水平制表符。</p>
<h4 id="ctrl-j"> Ctrl-J</h4>
<p>另起一行（换行）。在脚本中，你也可使用八进制 '\012' 或者十六进制 '\x0a' 来表示。</p>
<h4 id="ctrl-k"> Ctrl-K</h4>
<p>垂直制表符。</p>
<p>当你在终端或 <em>xterm</em> 窗口中输入字符时，<code>Ctrl-K</code> 将会删除光标上及其后的所有字符。而在脚本中，<code>Ctrl-K</code> 的作用有些不同。具体查看下方 Lee Lee Maschmeyer 写的样例。</p>
<h4 id="ctrl-l"> Ctrl-L</h4>
<p>清屏、走纸。在终端中等同于 <code>clear</code> 命令。在打印时，<code>Ctrl-L</code> 将会使纸张移动到底部。</p>
<h4 id="ctrl-m"> Ctrl-M</h4>
<p>回车（CR）。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># 感谢 Lee Maschmeyer 提供的样例。</span>

<span>read</span> -n <span>1</span> -s -p <span>\</span>
$<span>'Control-M leaves cursor at beginning of this line. Press Enter. <span title="\x0d">\x0d</span>'</span>
           <span># '0d' 是 Control-M 的十六进制的值</span>
<span>echo</span> <span>></span><span>&amp;2</span>   <span># '-s' 参数禁用了回显，所以需要显式的另起一行。</span>

<span>read</span> -n <span>1</span> -s -p $<span>'Control-J leaves cursor on next line. <span title="\x0a">\x0a</span>'</span>
           <span># '0a' 是 Control-J 换行符的十六进制的值</span>
<span>echo</span> <span>></span><span>&amp;2</span>

<span>###</span>

<span>read</span> -n <span>1</span> -s -p $<span>'And Control-K<span title="\x0b">\x0b</span>goes straight down.'</span>
<span>echo</span> <span>></span><span>&amp;2</span>   <span># Control-K 是垂直制表符。</span>

<span># 一个更好的垂直制表符例子是：</span>

<span>var</span><span>=</span>$<span>'<span title="\x0a">\x0a</span>This is the bottom line<span title="\x0b">\x0b</span>This is the top line<span title="\x0a">\x0a</span>'</span>
<span>echo</span> <span>"<span>$var</span>"</span>
<span>#  这将会产生与上面的例子类似的结果。但是</span>
<span>echo</span> <span>"<span>$var</span>"</span> <span>|</span> col
<span>#  这却会使得右侧行高于左侧行。</span>
<span>#  这也解释了为什么我们需要在行首和行尾加上换行符</span>
<span>#  来避免显示的混乱。</span>

<span># Lee Maschmeyer 的解释：</span>
<span># --------------------------</span>
<span>#  在第一个垂直制表符的例子中，垂直制表符使其</span>
<span>#  在没有回车的情况下向下打印。</span>
<span>#  这在那些不能回退的设备上，例如 Linux 的终端才可以。</span>
<span>#  而垂直制表符的真正目的是向上而非向下。</span>
<span>#  它可以用来在打印机中用来打印上标。</span>
<span>#  col 工具可以用来模拟真实的垂直制表符行为。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h4 id="ctrl-n"> Ctrl-N</h4>
<p>在命令行历史记录中调用下一条历史命令<sup></sup>。</p>
<h4 id="ctrl-o"> Ctrl-O</h4>
<p>在命令行中另起一行。</p>
<h4 id="ctrl-p"> Ctrl-P</h4>
<p>在命令行历史记录中调用上一条历史命令。</p>
<h4 id="ctrl-q"> Ctrl-Q</h4>
<p>恢复（XON）。</p>
<p>终端恢复读入 <em>stdin</em>。</p>
<h4 id="ctrl-r"> Ctrl-R</h4>
<p>在命令行历史记录中进行搜索。</p>
<h4 id="ctrl-s"> Ctrl-S</h4>
<p>挂起（XOFF）。</p>
<p>终端冻结 <em>stdin</em>。（可以使用 <code>Ctrl-Q</code> 恢复）</p>
<h4 id="ctrl-t"> Ctrl-T</h4>
<p>交换光标所在字符与其前一个字符。</p>
<h4 id="ctrl-u"> Ctrl-U</h4>
<p>删除光标所在字符之前的所有字符。
在一些情况下，不管光标在哪个位置，<code>Ctrl-U</code> 都会删除整行文字。</p>
<h4 id="ctrl-v"> Ctrl-V</h4>
<p>输入时，使用 <code>Ctrl-V</code> 允许插入控制字符。例如，下面两条语句是等价的：</p>
<div><pre><code><span>echo</span> -e <span>'<span title="\x0a">\x0a</span>'</span>
<span>echo</span> <span>&lt;</span>Ctl-V<span>></span><span>&lt;</span>Ctl-J<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>Ctrl-V</code> 在文本编辑器中特别有用。</p>
<h4 id="ctrl-w"> Ctrl-W</h4>
<p>当你在终端或 <em>xterm</em> 窗口中输入字符时，<code>Ctrl-W</code> 将会删除光标所在字符之前到其最近的空白符之间的所有字符。
在一些情况下，<code>Ctrl-W</code> 会删除到之前最近的非字母或数字的字符。</p>
<h4 id="ctrl-x"> Ctrl-X</h4>
<p>在一些特定的文本处理程序中，剪切高亮文本并复制到剪贴板（clipboard）。</p>
<h4 id="ctrl-y"> Ctrl-Y</h4>
<p>粘贴之前使用 <code>Ctrl-U</code> 或 <code>Ctrl-W</code> 删除的文字。</p>
<h4 id="ctrl-z"> Ctrl-Z</h4>
<p>暂停当前运行的任务。</p>
<p>在一些特定的文本处理程序中是替代操作。</p>
<p>在 MSDOS 文件系统中作为 <code>EOF</code>（end-of-file，文件终止标记）。</p>
<h3 id="空白符"> 空白符</h3>
<p>作为命令或变量之间的分隔符。空白符包含空格、制表符、换行符或它们的任意组合。<sup></sup>在一些地方，比如变量赋值时，空白符不应该出现，否则会造成语法错误。</p>
<p>空白行在脚本中不会有任何实际作用，但是可以划分代码，使代码更具可读性。</p>
<p>特殊变量 <code>$IFS</code> 是作为一些特定命令的输入域（field）分隔符，默认值为空白符。</p>
<blockquote>
<p>定义：域是字符串中离散的数据块。使用空白符或者指定的字符（通常由 <code>$IFS</code> 决定）来分隔临近域。在一些情况下，域也可以被称作记录（record）。</p>
</blockquote>
<p>如果想在字符串或者变量中保留空白符，请引用。</p>
<p>UNIX 过滤器可以使用 POSIX 字符类 <code>[:space:]</code> 来寻找和操作空白符。</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>操作符（operator）用来执行表达式（operation）。最常见的例子就是算术运算符+ - * /。在Bash中，操作符和关键字的概念有一些重叠。 </p>
</li>
<li id="footnote2"><p>它更被人熟知的名字是三元（ternary）操作符。但是读起来不清晰，而且容易令人混淆。trinary 是一种更加优雅的写法。 </p>
</li>
<li id="footnote3"><p>美国信息交换标准代码（American Standard Code for Information Interchange）。这是一套可以由计算机存储和处理的7位（bit）字符（包含字母、数字和一系列有限的符号）编码系统。 </p>
</li>
<li id="footnote4"><p>进程标识符（PID），是分配给正在运行进程的唯一数字标识。可以使用 <code>ps</code> 命令查看进程的 PID。&lt;br &gt;定义：进程是正在执行的命令或程序，通常也称作任务。 </p>
</li>
<li id="footnote5"><p>由shell来执行大括号扩展操作。命令本身是在扩展的基础上进行操作的。 </p>
</li>
<li id="footnote6"><p>例外：作为管道的一部分的大括号中的代码块可能会运行在子进程中。&lt;br &gt;<pre>ls | { read firstline; read secondline; }<br/>#  错误。大括号中的代码块在子进程中运行，<br />#+ 因此 &quot;ls&quot; 命令输出的结果不能传递到代码块中。<br/>echo &quot;First line is $firstline; second line is $secondline&quot;  # 无效。<br/><br/># 感谢 S.C.</pre> </p>
</li>
<li id="footnote7"><p>正如在古代催情剂（philtre）被认为是一种能引发神奇变化的药剂一样，UNIX 中的过滤器（filter）也是有类似的作用的。<br/>（如果一个程序员做出了一个能够在 Linux 设备上运行的 &quot;love philtre&quot;，那么他将会获得巨大的荣誉。） </p>
</li>
<li id="footnote8"><p>Bash将之前在命令行中执行过的命令存储在缓存（buffer）中，或者一块内存区域里。可以使用内建命令 <code>history</code> 来查看。 </p>
</li>
<li id="footnote9"><p>换行符本身也是一个空白符。因此这就是为什么仅仅包含一个换行符的空行也被认为是空白符。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">4.1 变量替换</title>
    <id>https://clay-wangzhi.com/code/shell/part2/04_1_variable_substitution/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/04_1_variable_substitution/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-1-变量替换"> 4.1 变量替换</h1>
<p>变量名是其所指向值的一个占位符（placeholder）。引用变量值的过程我们称之为变量替换（variable substitution）。</p>
<h3 id=""> $</h3>
<p>接下来我们仔细区分一下<strong>变量名</strong>与<strong>变量值</strong>。如果变量名是 <code>variable1</code>， 那么 <code>$variable1</code> 就是对变量值的引用。<sup></sup></p>
<div><pre><code>bash$ variable1=23


bash$ echo variable1
variable1

bash$ echo $variable1
23
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>变量仅仅在声明时、赋值时、被删除时（<code>unset</code>）、被导出时（<code>export</code>），算术运算中使用双括号结构((...))时或在代表信号时（signal，查看样例 32-5）才不需要有 $ 前缀。赋值可以是使用 =（比如 <code>var1=27</code>），可以是在 <code>read</code> 语句中，也可以是在循环的头部（<code>for var2 in 1 2 3</code>）。</p>
<p>在双引号<code>&quot;&quot;</code>字符串中可以使用变量替换。我们称之为部分引用，有时候也称弱引用。而使用单引号<code>''</code>引用时，变量只会作为字符串显示，变量替换不会发生。我们称之为全引用，有时也称强引用。更多细节将在第五章讲解。</p>
<p>实际上, <code>$variable</code> 这种写法是 <code>${variable}</code> 的简化形式。在某些特殊情况下，使用 <code>$variable</code> 写法会造成语法错误，使用完整形式会更好（查看章节 10.2）。</p>
<p>样例 4-1. 变量赋值与替换</p>
<div><pre><code><span>#!/bin/bash</span>
<span># ex9.sh</span>

<span># 变量赋值与替换</span>

<span>a</span><span>=</span><span>375</span>
<span>hello</span><span>=</span><span>$a</span>
<span>#   ^ ^</span>

<span>#----------------------------------------------------</span>
<span># 初始化变量时，赋值号 = 的两侧绝不允许有空格出现。</span>
<span># 如果有空格会发生什么？</span>

<span>#   "VARIABLE =value"</span>
<span>#            ^</span>
<span>#% 脚本将会尝试运行带参数 "=value" 的 "VARIABLE " 命令。</span>

<span>#   "VARIABLE= value"</span>
<span>#             ^</span>
<span>#% 脚本将会尝试运行 "value" 命令，</span>
<span>#+ 同时设置环境变量 "VARIABLE" 为 ""。</span>
<span>#----------------------------------------------------</span>


<span>echo</span> hello    <span># hello</span>
<span># 没有引用变量，"hello" 只是一个字符串...</span>

<span>echo</span> <span>$hello</span>   <span># 375</span>
<span>#    ^          这是变量引用。</span>

<span>echo</span> <span>${hello}</span> <span># 375</span>
<span>#               与上面的类似，变量引用。</span>

<span># 字符串内引用变量</span>
<span>echo</span> <span>"<span>$hello</span>"</span>    <span># 375</span>
<span>echo</span> <span>"<span>${hello}</span>"</span>  <span># 375</span>

<span>echo</span>

<span>hello</span><span>=</span><span>"A B  C   D"</span>
<span>echo</span> <span>$hello</span>   <span># A B C D</span>
<span>echo</span> <span>"<span>$hello</span>"</span> <span># A B  C   D</span>
<span># 正如我们所见，echo $hello 与 echo "$hello" 的结果不同。</span>
<span># ====================================</span>
<span># 字符串内引用变量将会保留变量的空白符。</span>
<span># ====================================</span>

<span>echo</span>

<span>echo</span> <span>'<span>$hello</span>'</span>  <span># $hello</span>
<span>#    ^      ^</span>
<span>#  单引号会禁用掉（转义）变量引用，这导致 "$" 将以普通字符形式被解析。</span>

<span># 注意单双引号字符串引用效果的不同。</span>

<span>hello</span><span>=</span>    <span># 将其设置为空值</span>
<span>echo</span> <span>"\<span>$hello</span> (null value) = <span>$hello</span>"</span>      <span># $hello (null value) =</span>
<span># 注意 </span>
<span># 将一个变量设置为空与删除(unset)它不同，尽管它们的表现形式相同。</span>

<span># -----------------------------------------------</span>

<span># 使用空白符分隔，可以在一行内对多个变量进行赋值。</span>
<span># 但是这会降低程序的可读性，并且可能会导致部分程序不兼容的问题。</span>

<span>var1</span><span>=</span><span>21</span>  <span>var2</span><span>=</span><span>22</span>  <span>var3</span><span>=</span><span>$V3</span>
<span>echo</span>
<span>echo</span> <span>"var1=<span>$var1</span>   var2=<span>$var2</span>   var3=<span>$var3</span>"</span>

<span># 在一些老版本的 shell 中这样写可能会有问题。</span>

<span># -----------------------------------------------</span>

<span>echo</span><span>;</span> <span>echo</span>

<span>numbers</span><span>=</span><span>"one two three"</span>
<span>#           ^   ^</span>
<span>other_numbers</span><span>=</span><span>"1 2 3"</span>
<span>#               ^ ^</span>
<span># 如果变量中有空白符号，那么必须用引号进行引用。</span>
<span># other_numbers=1 2 3                  # 出错</span>
<span>echo</span> <span>"numbers = <span>$numbers</span>"</span>
<span>echo</span> <span>"other_numbers = <span>$other_numbers</span>"</span>  <span># other_numbers = 1 2 3</span>
<span># 也可以转义空白符。</span>
<span>mixed_bag</span><span>=</span><span>2</span><span>\</span> ---<span>\</span> Whatever
<span>#           ^    ^ 使用 \ 转义空格</span>

<span>echo</span> <span>"<span>$mixed_bag</span>"</span>         <span># 2 --- Whatever</span>

<span>echo</span><span>;</span> <span>echo</span>

<span>echo</span> <span>"uninitialized_variable = <span>$uninitialized_variable</span>"</span>
<span># 未初始化的变量是空值(null表示不含有任何值)。</span>
<span>uninitialized_variable</span><span>=</span>   <span># 只声明而不初始化，等同于设为空值。</span>
<span>echo</span> <span>"uninitialized_variable = <span>$uninitialized_variable</span>"</span> <span># 仍旧为空</span>

<span>uninitialized_variable</span><span>=</span><span>23</span>       <span># 设置变量</span>
<span>unset</span> uninitialized_variable    <span># 删除变量</span>
<span>echo</span> <span>"uninitialized_variable = <span>$uninitialized_variable</span>"</span>
                                <span># uninitialized_variable =</span>
                                <span># 变量值为空</span>
<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="notice" /> 一个未被赋值或未初始化的变量拥有空值（null value）。<em>注意：null值不等同于0</em>。</p>
</blockquote>
<div><pre><code><span>if</span> <span>[</span> -z <span>"<span>$unassigned</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"\<span>$unassigned</span> is NULL."</span>
<span>fi</span>     <span># $unassigned is NULL.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>在赋值前使用变量可能会导致错误。但在算术运算中使用未赋值变量是可行的。</p>
</blockquote>
<div><pre><code><span>echo</span> <span>"<span>$uninitialized</span>"</span>            <span># 空行</span>
<span>let</span> <span>"uninitialized += 5"</span>         <span># 加5</span>
<span>echo</span> <span>"<span>$uninitialized</span>"</span>            <span># 5</span>
<span># 结论：</span>
<span># 一个未初始化的变量不含值(null)，但在算术运算中会被作为0处理。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>也可参考样例 15-23。</p>
</blockquote>
<hr>
<section>
<ol>
<li id="footnote1"><p>实际上，变量名是被称作左值（lvalue），意思是出现在赋值表达式的左侧的值，比如 <code>VARIABLE=23</code>。变量值被称作右值（rvalue），意思是出现在赋值表达式右侧的值，比如 <code>VAR2=$VARIABLE</code>。<br />事实上，变量名只是一个引用，一枚指针，指向实际存储数据内存地址的指针。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">4.2 变量赋值</title>
    <id>https://clay-wangzhi.com/code/shell/part2/04_2_variable_assignment/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/04_2_variable_assignment/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-2-变量赋值"> 4.2 变量赋值</h1>
<h3 id=""> =</h3>
<p>赋值操作符（在其前后没有空白符）。</p>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="noitce" /> 不要混淆 = 与 -eq，后者用来进行比较而非赋值。</p>
<p>同时也要注意 = 根据使用场景既可作赋值操作符，也可作比较操作符。</p>
</blockquote>
<p>样例 4-2. 变量赋值</p>
<div><pre><code><span>#!/bin/bash</span>
<span># 非引用形式变量</span>

<span>echo</span>

<span># 什么时候变量是非引用形式，即变量名前没有 '$' 符号的呢？</span>
<span># 当变量在被赋值而不是被引用时。</span>

<span># 赋值</span>
<span>a</span><span>=</span><span>879</span>
<span>echo</span> <span>"The value of <span title="\&quot;">\"</span>a<span title="\&quot;">\"</span> is <span>$a</span>."</span>

<span># 使用 'let' 进行赋值</span>
<span>let</span> <span>a</span><span>=</span><span>16</span>+5
<span>echo</span> <span>"The value of <span title="\&quot;">\"</span>a<span title="\&quot;">\"</span> is now <span>$a</span>."</span>

<span>echo</span>

<span># 在 'for' 循环中赋值（隐式赋值）</span>
<span>echo</span> -n <span>"Values of <span title="\&quot;">\"</span>a<span title="\&quot;">\"</span> in the loop are: "</span>
<span>for</span> <span>a</span> <span>in</span> <span>7</span> <span>8</span> <span>9</span> <span>11</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$a</span> "</span>
<span>done</span>

<span>echo</span>
<span>echo</span>

<span># 在 'read' 表达式中（另一种赋值形式）</span>
<span>echo</span> -n <span>"Enter <span title="\&quot;">\"</span>a<span title="\&quot;">\"</span> "</span>
<span>read</span> a
<span>echo</span> <span>"The value of <span title="\&quot;">\"</span>a<span title="\&quot;">\"</span> is now <span>$a</span>."</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>样例 4-3. 奇妙的变量赋值</p>
<div><pre><code><span>#!/bin/bash</span>

<span>a</span><span>=</span><span>23</span>              <span># 简单形式</span>
<span>echo</span> <span>$a</span>
<span>b</span><span>=</span><span>$a</span>
<span>echo</span> <span>$b</span>

<span># 来我们玩点炫的（命令替换）。</span>

<span>a</span><span>=</span><span><span>`</span><span>echo</span> Hello<span>!</span><span>`</span></span>   <span># 将 'echo' 命令的结果赋值给 'a'</span>
<span>echo</span> <span>$a</span>
<span>#  注意在命令替换结构中包含感叹号(!)在命令行中使用将会失效，</span>
<span>#+ 因为它将会触发 Bash 的历史(history)机制。</span>
<span>#  在shell脚本内，Bash 的历史机制默认关闭。</span>

<span>a</span><span>=</span><span><span>`</span><span>ls</span> -l<span>`</span></span>         <span># 将 'ls -l' 命令的结果赋值给 'a'</span>
<span>echo</span> <span>$a</span>           <span># 不带引号引用，将会移除所有的制表符与分行符</span>
<span>echo</span>
<span>echo</span> <span>"<span>$a</span>"</span>         <span># 引号引用变量将会保留空白符</span>
                  <span># 查看 "引用" 章节。</span>
                  
<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>使用 <code>$(...)</code> 形式进行赋值（与反引号不同的新形式），与命令替换形式相似。</p>
<div><pre><code><span># 摘自 /etc/rc.d/rc.local</span>
<span>R</span><span>=</span><span><span>$(</span><span>cat</span> /etc/redhat-release<span>)</span></span>
<span>arch</span><span>=</span><span><span>$(</span><span>uname</span> -m<span>)</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">4.3 Bash变量是弱类型的</title>
    <id>https://clay-wangzhi.com/code/shell/part2/04_3_bash_variables_are_untyped/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/04_3_bash_variables_are_untyped/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-3-bash变量是弱类型的"> 4.3 Bash变量是弱类型的</h1>
<p>不同于许多其他编程语言，Bash 并不区分变量的类型。本质上说，<em>Bash 变量是字符串</em>，但在某些情况下，Bash 允许对变量进行算术运算和比较。决定因素则是变量值是否只含有数字。</p>
<p>样例 4-4. 整数还是字符串？</p>
<div><pre><code><span>#!/bin/bash</span>
<span># int-or-string.sh</span>

<span>a</span><span>=</span><span>2334</span>                   <span># 整数。</span>
<span>let</span> <span>"a += 1"</span>
<span>echo</span> <span>"a = <span>$a</span> "</span>           <span># a = 2335</span>
<span>echo</span>                     <span># 依旧是整数。</span>


<span>b</span><span>=</span><span>${a<span>/</span>23<span>/</span>BB}</span>             <span># 将 "23" 替换为 "BB"。</span>
                         <span># $b 变成了字符串。</span>
<span>echo</span> <span>"b = <span>$b</span>"</span>            <span># b = BB35</span>
<span>declare</span> -i b             <span># 将其声明为整数并没有什么卵用。</span>
<span>echo</span> <span>"b = <span>$b</span>"</span>            <span># b = BB35</span>

<span>let</span> <span>"b += 1"</span>             <span># BB35 + 1</span>
<span>echo</span> <span>"b = <span>$b</span>"</span>            <span># b = 1</span>
<span>echo</span>                     <span># Bash 认为字符串的"整数值"为0。</span>

<span>c</span><span>=</span>BB34
<span>echo</span> <span>"c = <span>$c</span>"</span>            <span># c = BB34</span>
<span>d</span><span>=</span><span>${c<span>/</span>BB<span>/</span>23}</span>             <span># 将 "BB" 替换为 "23"。</span>
                         <span># $d 变为了一个整数。</span>
<span>echo</span> <span>"d = <span>$d</span>"</span>            <span># d = 2334</span>
<span>let</span> <span>"d += 1"</span>             <span># 2334 + 1</span>
<span>echo</span> <span>"d = <span>$d</span>"</span>            <span># d = 2335</span>
<span>echo</span>


<span># 如果是空值会怎样呢？</span>
<span>e</span><span>=</span><span>''</span>                     <span># ...也可以是 e="" 或 e=</span>
<span>echo</span> <span>"e = <span>$e</span>"</span>            <span># e =</span>
<span>let</span> <span>"e += 1"</span>             <span># 空值是否允许进行算术运算？</span>
<span>echo</span> <span>"e = <span>$e</span>"</span>            <span># e = 1</span>
<span>echo</span>                     <span># 空值变为了一个整数。</span>

<span># 如果时未声明的变量呢？</span>
<span>echo</span> <span>"f = <span>$f</span>"</span>            <span># f =</span>
<span>let</span> <span>"f += 1"</span>             <span># 是否允许进行算术运算？</span>
<span>echo</span> <span>"f = <span>$f</span>"</span>            <span># f = 1</span>
<span>echo</span>                     <span># 未声明变量变为了一个整数。</span>
<span>#</span>
<span># 然而……</span>
<span>let</span> <span>"f /= <span>$undecl_var</span>"</span>   <span># 可以除以0么？</span>
<span>#   let: f /= : syntax error: operand expected (error token is " ")</span>
<span># 语法错误！在这里 $undecl_var 并没有被设置为0！</span>
<span>#</span>
<span># 但是，仍旧……</span>
<span>let</span> <span>"f /= 0"</span>
<span>#   let: f /= 0: division by 0 (error token is "0")</span>
<span># 预期之中。</span>


<span># 在执行算术运算时，Bash 通常将其空值的整数值设为0。</span>
<span># 但是不要做这种事情！</span>
<span># 因为这可能会导致一些意外的后果。</span>


<span># 结论：上面的结果都表明 Bash 中的变量是弱类型的。</span>

<span>exit</span> <span>$?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><p>弱类型变量有利有弊。它可以使编程更加灵活、更加容易（给与你足够的想象空间）。但它也同样的容易造成一些小错误，容易养成粗心大意的编程习惯。</p>
<p>为了减轻脚本持续跟踪变量类型的负担，Bash <em>不允许</em>变量声明。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">4.4 特殊的变量类型</title>
    <id>https://clay-wangzhi.com/code/shell/part2/04_4_special_variable_types/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/04_4_special_variable_types/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-4-特殊的变量类型"> 4.4 特殊的变量类型</h1>
<h3 id="局部变量"> 局部变量</h3>
<p>仅在代码块或函数中才可见的变量（参考函数章节的局部变量部分）。</p>
<h3 id="环境变量"> 环境变量</h3>
<p>会影响用户及shell行为的变量。</p>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 一般情况下，每一个进程都有自己的“环境”（environment），也就是一组该进程可以访问到的变量。从这个意义上来说，shell表现出与其他进程一样的行为。</p>
<p>每当shell启动时，都会创建出与其环境对应的shell环境变量。改变或增加shell环境变量会使shell更新其自身的环境。<em>子进程</em>（由父进程执行产生）会继承<em>父进程</em>的环境变量。</p>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="notice" /> 分配给环境变量的空间是有限的。创建过多环境变量或占用空间过大的环境变量有可能会造成问题。</p>
</blockquote>
<div><pre><code>bash$ eval &quot;`seq 10000 | sed -e &#39;s/.*/export var&amp;=ZZZZZZZZZZZZZZ/&#39;`&quot;
&gt;
bash$ du
bash: /usr/bin/du: Argument list too long
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>注意，上面的&quot;错误&quot;已经在Linux内核版本号为2.6.23的系统中修复了。</p>
<p>（感谢 Stéphane Chazelas 对此问题的解释并提供了上面的例子。）</p>
</blockquote>
<p>如果在脚本中设置了环境变量，那么这些环境变量需要被“导出”，也就是通知脚本所在的<em>环境</em>做出相应的更新。这个“导出”操作就是 <code>export</code> 命令。</p>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 脚本只能将变量导出到子进程，即在这个脚本中所调用的命令或程序。在命令行中调用的脚本不能够将变量回传给命令行环境，即<em>子进程不能将变量回传给父进程</em>。</p>
<p><strong>定义：</strong> 子进程（child process）是由另一个进程，即其父进程（parent process）所启动的子程序。</p>
</blockquote>
<h3 id="位置参数"> 位置参数</h3>
<p>从命令行中传递给脚本的参数<sup></sup>：<code>$0, $1, $2, $3 ...</code>
即<strong>命令行参数</strong>。</p>
<p><code>$0</code> 代表脚本名称，<code>$1</code> 代表第一个参数，<code>$2</code> 代表第二个，<code>$3</code> 代表第三个，以此类推<sup></sup>。在 <code>$9</code> 之后的参数必须被包含在大括号中，如 <code>${10}, ${11}, ${12}</code>。</p>
<p>特殊变量 <code>$*</code> 与 <code>$@</code> 代表所有位置参数。</p>
<p>样例 4-5. 位置参数</p>
<div><pre><code><span>#!/bin/bash</span>

<span># 调用脚本时使用至少10个参数，例如</span>
<span># ./scriptname 1 2 3 4 5 6 7 8 9 10</span>
<span>MINPARAMS</span><span>=</span><span>10</span>

<span>echo</span>

<span>echo</span> <span>"The name of this script is <span title="\&quot;">\"</span><span>$0</span><span title="\&quot;">\"</span>."</span>
<span># 附带 ./ 代表当前目录</span>
<span>echo</span> <span>"The name of this script is <span title="\&quot;">\"</span><span><span>`</span><span>basename</span> $0<span>`</span></span><span title="\&quot;">\"</span>."</span>
<span># 除去路径信息（查看 'basename'）</span>

<span>echo</span>

<span>if</span> <span>[</span> -n <span>"<span>$1</span>"</span> <span>]</span>              <span># 测试变量是否存在</span>
<span>then</span>
 <span>echo</span> <span>"Parameter #1 is <span>$1</span>"</span>  <span># 使用引号转义#</span>
<span>fi</span>

<span>if</span> <span>[</span> -n <span>"<span>$2</span>"</span> <span>]</span>
<span>then</span>
 <span>echo</span> <span>"Parameter #2 is <span>$2</span>"</span>
<span>fi</span>

<span>if</span> <span>[</span> -n <span>"<span>$3</span>"</span> <span>]</span>
<span>then</span>
 <span>echo</span> <span>"Parameter #3 is <span>$3</span>"</span>
<span>fi</span>

<span># ...</span>

<span>if</span> <span>[</span> -n <span>"<span>${10}</span>"</span> <span>]</span>  <span># 大于 $9 的参数必须被放在大括号中</span>
<span>then</span>
 <span>echo</span> <span>"Parameter #10 is <span>${10}</span>"</span>
<span>fi</span>

<span>echo</span> <span>"-----------------------------------"</span>
<span>echo</span> <span>"All the command-line parameters are: "</span><span>$*</span><span>""</span>

<span>if</span> <span>[</span> <span>$#</span> -lt <span>"<span>$MINPARAMS</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span>
  <span>echo</span> <span>"This script needs at least <span>$MINPARAMS</span> command-line arguments!"</span>
<span>fi</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><p>在位置参数中使用大括号助记符提供了一种非常简单的方式来访问传入脚本的最后一个参数。在其中会使用到间接引用。</p>
<div><pre><code><span>args</span><span>=</span><span>$#</span>           <span># 传入参数的个数</span>
<span>lastarg</span><span>=</span><span>${<span>!</span>args}</span>
<span># 这是 $args 的一种间接引用方式</span>

<span># 也可以使用:       lastarg=${!#}             (感谢 Chris Monson.)</span>
<span># 这是 $# 的一种间接引用方式。</span>
<span># 注意 lastarg=${!$#} 是无效的。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>一些脚本能够根据调用时文件名的不同来执行不同的操作。要达到这样的效果，脚本需要检测 <code>$0</code>，也就是调用时的文件名<sup></sup>。同时，也必须存在指向这个脚本所有别名的符号链接文件（symbolic links）。详情查看样例 16-2。</p>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/tip.gif" alt="info" /> 如果一个脚本需要一个命令行参数但是在调用的时候却没有传入，那么这将会造成一个空变量赋值。这通常不是我们想要的。一种避免的方法是，在使用期望的位置参数时候，在赋值语句两侧添加一个额外的字符。</p>
</blockquote>
<div><pre><code><span>variable1_</span><span>=</span><span>$1_</span>  <span># 而不是 variable1=$1</span>
<span># 使用这种方法可以在没有位置参数的情况下避免产生错误。</span>

<span>critical_argument01</span><span>=</span><span>$variable1_</span>

<span># 多余的字符可以被去掉，就像下面这样：</span>
<span>variable1</span><span>=</span><span>${variable1_<span>/</span>_<span>/</span>}</span>
<span># 仅仅当 $variable1_ 是以下划线开头时候才会有一些副作用。</span>
<span># 这里使用了我们稍后会介绍的参数替换模板中的一种。</span>
<span># （将替换模式设为空等价于删除。）</span>

<span># 更直接的处理方法就是先检测预期的位置参数是否被传入。</span>
<span>if</span> <span>[</span> -z <span>$1</span> <span>]</span>
<span>then</span>
  <span>exit</span> <span>$E_MISSING_POS_PARAM</span>
<span>fi</span>


<span>#  但是，正如 Fabin Kreutz 指出的，</span>
<span>#+ 上面的方法会有一些意想不到的副作用。</span>
<span>#  更好的方法是使用参数替换：</span>
<span>#         ${1:-$DefaultVal}</span>
<span>#  详情查看第十章“操作变量”的第二节“变量替换”。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>样例 4-6. <em>wh</em>, <em>whois</em> 域名查询</p>
<div><pre><code><span>#!/bin/bash</span>
<span># ex18.sh</span>

<span># 在下面三个可选的服务器中进行 whois 域名查询：</span>
<span># ripe.net, cw.net, radb.net</span>

<span># 将这个脚本重命名为 'wh' 后放在 /usr/local/bin 目录下</span>

<span># 这个脚本需要进行符号链接：</span>
<span># ln -s /usr/local/bin/wh /usr/local/bin/wh-ripe</span>
<span># ln -s /usr/local/bin/wh /usr/local/bin/wh-apnic</span>
<span># ln -s /usr/local/bin/wh /usr/local/bin/wh-tucows</span>

<span>E_NOARGS</span><span>=</span><span>75</span>


<span>if</span> <span>[</span> -z <span>"<span>$1</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"Usage: <span><span>`</span><span>basename</span> $0<span>`</span></span> [domain-name]"</span>
  <span>exit</span> <span>$E_NOARGS</span>
<span>fi</span>

<span># 检查脚本名，访问对应服务器进行查询。</span>
<span>case</span> <span><span>`</span><span>basename</span> $0<span>`</span></span> <span>in</span>    <span># 也可以写:    case ${0##*/} in</span>
    <span>"wh"</span>       <span>)</span> whois <span>$1</span>@whois.tucows.com<span>;</span><span>;</span>
    <span>"wh-ripe"</span>  <span>)</span> whois <span>$1</span>@whois.ripe.net<span>;</span><span>;</span>
    <span>"wh-apnic"</span> <span>)</span> whois <span>$1</span>@whois.apnic.net<span>;</span><span>;</span>
    <span>"wh-cw"</span>    <span>)</span> whois <span>$1</span>@whois.cw.net<span>;</span><span>;</span>
    *          <span>)</span> <span>echo</span> <span>"Usage: <span><span>`</span><span>basename</span> $0<span>`</span></span> [domain-name]"</span><span>;</span><span>;</span>
<span>esac</span>

<span>exit</span> <span>$?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>使用 <code>shift</code> 命令可以将全体位置参数向左移一位, 重新赋值。</p>
<p><code>$1 &lt;--- $2</code>, <code>$2 &lt;--- $3</code>, <code>$3 &lt;--- $4</code>，以此类推。</p>
<p>原先的 <code>$1</code> 将会消失，而 <code>$0</code>（脚本名称）不会有任何改变。如果你在脚本中使用了大量的位置参数，<code>shift</code> 可以让你不使用{大括号}助记法也可以访问超过10个的位置参数。</p>
<p>样例 4-7. 使用 <code>shift</code> 命令</p>
<div><pre><code><span>#!/bin/bash</span>
<span># shft.sh: 使用 `shift` 命令步进访问所有的位置参数。</span>

<span># 将这个脚本命名为 shft.sh，然后在调用时跟上一些参数。</span>
<span># 例如：</span>
<span>#    sh shft.sh a b c def 83 barndoor</span>

<span>until</span> <span>[</span> -z <span>"<span>$1</span>"</span> <span>]</span>  <span># 直到访问完所有的参数</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$1</span> "</span>
  <span>shift</span>
<span>done</span>

<span>echo</span>               <span># 换行。</span>

<span># 那些被访问完的参数又会怎样呢？</span>
<span>echo</span> <span>"<span>$2</span>"</span>
<span># 什么都不会被打印出来。</span>
<span># 当 $2 被移动到 $1 且没有 $3 时，$2 将会保持空。</span>
<span># 因此 shift 是移动参数而非复制参数。</span>

<span>exit</span>

<span>#  可以参考 echo-params.sh 脚本，在不使用 shift 命令的情况下，</span>
<span>#+ 步进访问所有位置参数。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p><code>shift</code> 命令也可以带一个参数来指明一次移动多少位。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># shift-past.sh</span>

<span>shift</span> <span>3</span>    <span># 移动3位。</span>
<span># 与 n=3; shift $n 效果相同。</span>

<span>echo</span> <span>"<span>$1</span>"</span>

<span>exit</span> <span>0</span>

<span># ======================== #</span>


$ <span>sh</span> shift-past.sh <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>
<span>4</span>

<span>#  但是就像 Eleni Fragkiadaki 指出的那样，</span>
<span>#  如果尝试将位置参数（$#）传给 'shift'，</span>
<span>#  将会导致脚本错误的结束，同时位置参数也不会发送改变。</span>
<span>#  这也许是因为陷入了一个死循环...</span>
<span>#  比如：</span>
<span>#      until [ -z "$1" ]</span>
<span>#      do</span>
<span>#         echo -n "$1 "</span>
<span>#         shift 20    #  如果少于20个位置参数，</span>
<span>#      done           #+ 那么循环将永远不会结束。</span>
<span>#</span>
<span>#  当你不确定是否有这么多的参数时，你可以加入一个测试：</span>
<span>#      shift 20 || break</span>
<span>#               ^^^^^^^^</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 使用 <code>shift</code> 命令同给函数传参相类似。详情查看样例 36-18。</p>
</blockquote>
<hr>
<section>
<ol>
<li id="footnote1"><p>函数同样也可以接受与使用位置参数。 </p>
</li>
<li id="footnote2"><p>是调用脚本的进程设置了 $0 参数。就是脚本的文件名。详情可以查看 <code>execv</code> 的使用手册。<br>在命令行中，<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.73354em;vertical-align:-0.0391em;"></span><span>0</span><span>是</span><span>s</span><span>h</span><span>e</span><span style="margin-right:0.01968em;">ll</span><span>的名称。</span><span style="margin-right:0.2777777777777778em;"></span><span>&lt;</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span>p</span><span>re</span><span style="margin-right:0.2777777777777778em;"></span><span>&gt;</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.69444em;vertical-align:0em;"></span><span>ba</span><span>s</span><span>h</span></span></span></span> echo $0<br>bash<br><br>tcsh% echo $0<br>tcsh</pre> </p>
</li>
<li id="footnote3"><p>如果脚本被引用（sourced）执行或者被链接（symlinked）执行时会失效。安全的方法是检测变量 <code>$BASH_Source</code>。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第四章 变量与参数</title>
    <id>https://clay-wangzhi.com/code/shell/part2/04_introduction_to_variables_and_parameters/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/04_introduction_to_variables_and_parameters/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第四章-变量与参数"> 第四章 变量与参数</h1>
<h3 id="本章目录"> 本章目录</h3>
<ul>
<li><a href="./04_1_variable_substitution.html">4.1 变量替换</a></li>
<li><a href="./04_2_variable_assignment.html">4.2 变量赋值</a></li>
<li><a href="./04_3_bash_variables_are_untyped.html">4.3 Bash变量弱类型</a></li>
<li><a href="./04_4_special_variable_types.html">4.4 特殊变量类型</a></li>
</ul>
<p>变量（variable）在编程语言中用来表示数据。它本身只是一个标记，指向数据在计算机内存中的一个或一组地址。</p>
<p>变量通常出现在算术运算，数量操作及字符串解析中。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">5.1 引用变量</title>
    <id>https://clay-wangzhi.com/code/shell/part2/05_1_quoting_variables/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/05_1_quoting_variables/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_5-1-引用变量"> 5.1 引用变量</h1>
<p>引用变量时，通常建议将变量包含在双引号中。因为这样可以防止除 <code>$</code>，<code>`</code>（反引号）和<code>\</code>（转义符）之外的其他特殊字符被重新解释。<sup></sup>在双引号中仍然可以使用<code>$</code>引用变量（<code>&quot;$variable&quot;</code>），也就是将变量名替换为变量值（详情查看样例 4-1）。</p>
<p>使用双引号可以防止字符串被分割。<sup></sup>即使参数中拥有很多空白分隔符，被包在双引号中后依旧是算作单一字符。</p>
<div><pre><code><span>List</span><span>=</span><span>"one two three"</span>

<span>for</span> <span>a</span> <span>in</span> <span>$List</span>     <span># 空白符将变量分成几个部分。</span>
<span>do</span>
  <span>echo</span> <span>"<span>$a</span>"</span>
<span>done</span>
<span># one</span>
<span># two</span>
<span># three</span>

<span>echo</span> <span>"---"</span>

<span>for</span> <span>a</span> <span>in</span> <span>"<span>$List</span>"</span>   <span># 在单一变量中保留所有空格。</span>
<span>do</span> <span>#     ^     ^</span>
  <span>echo</span> <span>"<span>$a</span>"</span>
<span>done</span>
<span># one two three</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>下面是一个更加复杂的例子：</p>
<div><pre><code><span>variable1</span><span>=</span><span>"a variable containing five words"</span>
COMMAND This is <span>$variable1</span>    <span># 带上7个参数执行COMMAND命令：</span>
<span># "This" "is" "a" "variable" "containing" "five" "words"</span>

COMMAND <span>"This is <span>$variable1</span>"</span>  <span># 带上1个参数执行COMMAND命令：</span>
<span># "This is a variable containing five words"</span>


<span>variable2</span><span>=</span><span>""</span>    <span># 空值。</span>

COMMAND  <span>$variable2</span> <span>$variable2</span> <span>$variable2</span>
                <span># 不带参数执行COMMAND命令。</span>
COMMAND <span>"<span>$variable2</span>"</span> <span>"<span>$variable2</span>"</span> <span>"<span>$variable2</span>"</span>
                <span># 带上3个参数执行COMMAND命令。</span>
COMMAND <span>"<span>$variable2</span> <span>$variable2</span> <span>$variable2</span>"</span>
                <span># 带上1个参数执行COMMAND命令（2空格）。</span>

<span># 感谢 Stéphane Chazelas。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/tip.gif" alt="info" /> 当字符分割或者保留空白符出现问题时，才需要在<code>echo</code>语句中用双引号包住参数。</p>
</blockquote>
<p>样例 5-1. 输出一些奇怪的变量</p>
<div><pre><code><span>#!/bin/bash</span>
<span># weirdvars.sh: 输出一些奇怪的变量</span>

<span>echo</span>

<span>var</span><span>=</span><span>"'(]<span title="\\">\\</span>{}\$<span title="\&quot;">\"</span>"</span>
<span>echo</span> <span>$var</span>        <span># '(]\{}$"</span>
<span>echo</span> <span>"<span>$var</span>"</span>      <span># '(]\{}$"     没有任何区别。</span>

<span>echo</span>

<span><span>IFS</span></span><span>=</span><span>'\'
echo <span>$var</span>        # '</span><span>(</span><span>]</span> <span>{</span><span>}</span>$<span>"     \ 被转换成了空格，为什么？
echo "</span><span>$var</span><span>"      # '(]\{}$"</span>

<span># 上面的例子由 Stephane Chazelas 提供。</span>

<span>echo</span>

<span>var2</span><span>=</span><span>"<span title="\\">\\</span><span title="\\">\\</span><span title="\&quot;">\"</span>"</span>
<span>echo</span> <span>$var2</span>       <span>#   "</span>
<span>echo</span> <span>"<span>$var2</span>"</span>     <span># \\"</span>
<span>echo</span>
<span># 但是...var2="\\\\"" 不是合法的语句，为什么？</span>
<span>var3</span><span>=</span><span>'<span title="\\">\\</span><span title="\\">\\</span>'</span>
<span>echo</span> <span>"<span>$var3</span>"</span>     <span># \\\\</span>
<span># 强引用是可以的。</span>


<span># ************************************************************ #</span>
<span># 就像第一个例子展示的那样，嵌套引用是允许的。</span>

<span>echo</span> <span>"<span><span>$(</span><span>echo</span> <span>'"'</span><span>)</span></span>"</span>           <span># "</span>
<span>#    ^           ^</span>


<span># 在有些时候这种方法非常有用。</span>

<span>var1</span><span>=</span><span>"Two bits"</span>
<span>echo</span> <span>"\<span>$var1</span> = "</span><span>$var1</span><span>""</span>      <span># $var1 = Two bits</span>
<span>#    ^                ^</span>

<span># 或者，可以像 Chris Hiestand 指出的那样：</span>

<span>if</span> <span>[</span><span>[</span> <span>"<span><span>$(</span><span>du</span> <span>"<span>$My_File1</span>"</span><span>)</span></span>"</span> -gt <span>"<span><span>$(</span><span>du</span> <span>"<span>$My_File2</span>"</span><span>)</span></span>"</span> <span>]</span><span>]</span>
<span>#     ^     ^         ^ ^     ^     ^         ^ ^</span>
<span>then</span>
  <span>..</span>.
<span>fi</span>
<span># ************************************************************ #</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><p>单引号（' '）与双引号类似，但是在单引号中不能引用变量，因为 <code>$</code> 不再具有特殊含义。在单引号中，除<code>'</code>之外的所有特殊字符都将会被直接按照字面意思解释。可以认为单引号（“全引用”）是双引号（“部分引用”）的一种更严格的形式。</p>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 因为在单引号中转义符（\）都已经按照字面意思解释了，因此尝试在单引号中包含单引号将不会产生你所预期的结果。</p>
</blockquote>
<div><pre><code><span>echo</span> <span>"Why can't I write 's between single quotes"</span>
<span>></span>
<span>echo</span>
<span>></span>
<span># 可以采取迂回的方式。</span>
<span>echo</span> <span>'Why can'</span><span>\</span>'<span>'t I write '</span>"<span>'"'</span>s between single quotes'
<span>#    |-------|  |----------|   |-----------------------|</span>
<span># 由三个单引号引用的字符串，再加上转义以及双引号包住的单引号组成。</span>
<span>></span>
<span># 感谢 Stéphane Chazelas 提供的例子。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><hr>
<section>
<ol>
<li id="footnote1"><p>在命令行里，如果双引号包含了 &quot;!&quot; 将会产生错误。这是因为shell将其解释为查看历史命令。而在脚本中，因为历史机制已经被关闭，所以不会产生这个问题。<br>我们更加需要注意的是在双引号中 <code>\</code> 的反常行为，尤其是在使用 <code>echo -e</code> 命令时。<br><pre>bash$ echo hello\!<br>hello!<br>bash$ echo &quot;hello\!&quot;<br>hello\!<br><br><br>bash$ echo \<br>&gt;<br>bash$ echo &quot;\&quot;<br>&gt;<br>bash$ echo \a<br>a<br>bash$ echo &quot;\a&quot;<br>\a<br><br><br>bash$ echo x\ty<br>xty<br>bash$ echo &quot;x\ty&quot;<br>x\ty<br><br>bash$ echo -e x\ty<br>xty<br>bash$ echo -e &quot;x\ty&quot;<br>x       y</pre>在 <code>echo</code> 后的双引号中一般会转义 <code>\</code>。并且 <code>echo -e</code> 会将 <code>&quot;\t&quot;</code> 解释成制表符。<br>（感谢 Wayne Pollock 提出这些；感谢Geoff Lee 与 Daniel Barclay 对此做出的解释。） </p>
</li>
<li id="footnote2"><p>字符分割（word splitting）在本文中的意思是指将一个字符串分割成独立的、离散的变量。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">5.2 转义</title>
    <id>https://clay-wangzhi.com/code/shell/part2/05_2_escaping/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/05_2_escaping/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_5-2-转义"> 5.2 转义</h1>
<p>转义是一种引用单字符的方法。通过在特殊字符前加上转义符 <code>\</code> 来告诉shell按照字面意思去解释这个字符。</p>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="notice" /> 需要注意的是，在一些特定的命令和工具，比如 <code>echo</code> 和 <code>sed</code> 中，转义字符通常会起到相反的效果，即可能会使得那些字符产生特殊含义。</p>
</blockquote>
<p>在 <code>echo</code> 与 <code>sed</code> 命令中，转义字符的特殊含义</p>
<h3 id="n"> \n</h3>
<p>换行（line feed）。</p>
<h3 id="r"> \r</h3>
<p>回车（carriage return）。</p>
<h3 id="t"> \t</h3>
<p>水平制表符。</p>
<h3 id="v"> \v</h3>
<p>垂直制表符。</p>
<h3 id="b"> \b</h3>
<p>退格。</p>
<h3 id="a"> \a</h3>
<p>警报、响铃或闪烁。</p>
<h3 id="_0xx"> \0xx</h3>
<p>ASCII码的八进制形式，等价于 <code>0nn</code>，其中 <code>nn</code> 是数字。</p>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/important.gif" alt="important" /> 在 <code>$' ... '</code> 字符串扩展结构中可以通过转义八进制或十六进制的ASCII码形式给变量赋值，比如 <code>quote=$'\042'</code>。</p>
</blockquote>
<p>样例 5-2. 转义字符</p>
<div><pre><code><span>#!/bin/bash</span>
<span># escaped.sh: 转义字符</span>

<span>##############################################</span>
<span>### 首先让我们先看一下转义字符的基本用法。 ###</span>
<span>##############################################</span>

<span># 转义新的一行。</span>
<span># ------------</span>

<span>echo</span> <span>""</span>

<span>echo</span> <span>"This will print
as two lines."</span>
<span># This will print</span>
<span># as two lines.</span>

<span>echo</span> <span>"This will print \
as one line."</span>
<span># This will print as one line.</span>

<span>echo</span><span>;</span> <span>echo</span>

<span>echo</span> <span>"============="</span>


<span>echo</span> <span>"<span title="\v">\v</span><span title="\v">\v</span><span title="\v">\v</span><span title="\v">\v</span>"</span>      <span># 按字面意思打印 \v\v\v\v</span>
<span># 使用 echo 命令的 -e 选项来打印转义字符。</span>
<span>echo</span> <span>"============="</span>
<span>echo</span> <span>"VERTICAL TABS"</span>
<span>echo</span> -e <span>"<span title="\v">\v</span><span title="\v">\v</span><span title="\v">\v</span><span title="\v">\v</span>"</span>   <span># 打印四个垂直制表符。</span>
<span>echo</span> <span>"=============="</span>

<span>echo</span> <span>"QUOTATION MARK"</span>
<span>echo</span> -e <span>"<span title="\042">\042</span>"</span>       <span># 打印 " （引号，八进制ASCII码为42）。</span>
<span>echo</span> <span>"=============="</span>



<span># 使用 $'\X' 这样的形式后可以不需要加 -e 选项。</span>

<span>echo</span><span>;</span> <span>echo</span> <span>"NEWLINE and (maybe) BEEP"</span>
<span>echo</span> $<span>'<span title="\n">\n</span>'</span>           <span># 新的一行。</span>
<span>echo</span> $<span>'<span title="\a">\a</span>'</span>           <span># 警报（响铃）。</span>
                     <span># 根据不同的终端版本，也可能是闪屏。</span>

<span># 我们之前介绍了 $'\nnn' 字符串扩展，而现在我们要看到的是...</span>

<span># ============================================ #</span>
<span># 自 Bash 第二个版本开始的 $'\nnn' 字符串扩展结构。</span>
<span># ============================================ #</span>

<span>echo</span> <span>"Introducing the \$\' ... \' string-expansion construct . . . "</span>
<span>echo</span> <span>". . . featuring more quotation marks."</span>

<span>echo</span> $<span>'<span title="\t">\t</span> <span title="\042">\042</span> <span title="\t">\t</span>'</span>   <span># 在制表符之间的引号。</span>
<span># 需要注意的是 '\nnn' 是一个八进制的值。</span>

<span># 字符串扩展同样适用于十六进制的值，格式是 $'\xhhh'。</span>
<span>echo</span> $<span>'<span title="\t">\t</span> <span title="\x22">\x22</span> <span title="\t">\t</span>'</span>  <span># 在制表符之间的引号。</span>
<span># 感谢 Greg Keraunen 指出这些。</span>
<span># 在早期的 Bash 版本中允许使用 '\x022' 这样的形式。</span>

<span>echo</span>


<span># 将 ASCII 码字符赋值给变量。</span>
<span># -----------------------</span>
<span>quote</span><span>=</span>$<span>'<span title="\042">\042</span>'</span>        <span># 将 " 赋值给变量。</span>
<span>echo</span> <span>"<span>$quote</span> Quoted string <span>$quote</span> and this lies outside the quotes."</span>

<span>echo</span>

<span># 连接多个 ASCII 码字符给变量。</span>
<span>triple_underline</span><span>=</span>$<span>'<span title="\137">\137</span><span title="\137">\137</span><span title="\137">\137</span>'</span>  <span># 137是 '_' ASCII码的八进制形式</span>
<span>echo</span> <span>"<span>$triple_underline</span> UNDERLINE <span>$triple_underline</span>"</span>

<span>echo</span>

<span>ABC</span><span>=</span>$<span>'<span title="\101">\101</span><span title="\102">\102</span><span title="\103">\103</span><span title="\010">\010</span>'</span>           <span># 101，102，103是 A, B, C </span>
                                  <span># ASCII码的八进制形式。</span>
<span>echo</span> <span>$ABC</span>

<span>echo</span>

<span>escape</span><span>=</span>$<span>'<span title="\033">\033</span>'</span>                    <span># 033 是 ESC 的八进制形式</span>
<span>echo</span> <span>"<span title="\&quot;">\"</span>escape<span title="\&quot;">\"</span> echoes an <span>$escape</span>"</span>
                                  <span># 没有可见输出</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br></div></div><p>下面是一个更加复杂的例子：</p>
<p>样例 5-3. 检测键盘输入</p>
<div><pre><code><span>#!/bin/bash</span>
<span># 作者：Sigurd Solaas，作于2011年4月20日</span>
<span># 授权在《高级Bash脚本编程指南》中使用。</span>
<span># 需要 Bash 版本高于4.2。</span>

<span>key</span><span>=</span><span>"no value yet"</span>
<span>while</span> <span>true</span><span>;</span> <span>do</span>
  <span>clear</span>
  <span>echo</span> <span>"Bash Extra Keys Demo. Keys to try:"</span>
  <span>echo</span>
  <span>echo</span> <span>"* Insert, Delete, Home, End, Page_Up and Page_Down"</span>
  <span>echo</span> <span>"* The four arrow keys"</span>
  <span>echo</span> <span>"* Tab, enter, escape, and space key"</span>
  <span>echo</span> <span>"* The letter and number keys, etc."</span>
  <span>echo</span>
  <span>echo</span> <span>"    d = show date/time"</span>
  <span>echo</span> <span>"    q = quit"</span>
  <span>echo</span> <span>"================================"</span>
  <span>echo</span>
  
  <span># 将独立的Home键值转换为数字7上的Home键值：</span>
  <span>if</span> <span>[</span> <span>"<span>$key</span>"</span> <span>=</span> $<span>'<span title="\x1b">\x1b</span><span title="\x4f">\x4f</span><span title="\x48">\x48</span>'</span> <span>]</span><span>;</span> <span>then</span>
   <span>key</span><span>=</span>$<span>'<span title="\x1b">\x1b</span><span title="\x5b">\x5b</span><span title="\x31">\x31</span><span title="\x7e">\x7e</span>'</span>
   <span>#   引用字符扩展结构。</span>
  <span>fi</span>
  
  <span># 将独立的End键值转换为数字1上的End键值：</span>
  <span>if</span> <span>[</span> <span>"<span>$key</span>"</span> <span>=</span> $<span>'<span title="\x1b">\x1b</span><span title="\x4f">\x4f</span><span title="\x46">\x46</span>'</span> <span>]</span><span>;</span> <span>then</span>
   <span>key</span><span>=</span>$<span>'<span title="\x1b">\x1b</span><span title="\x5b">\x5b</span><span title="\x34">\x34</span><span title="\x7e">\x7e</span>'</span>
  <span>fi</span>
  
  <span>case</span> <span>"<span>$key</span>"</span> <span>in</span>
   $<span>'<span title="\x1b">\x1b</span><span title="\x5b">\x5b</span><span title="\x32">\x32</span><span title="\x7e">\x7e</span>'</span><span>)</span>  <span># 插入</span>
    <span>echo</span> Insert Key
   <span>;</span><span>;</span>
   $<span>'<span title="\x1b">\x1b</span><span title="\x5b">\x5b</span><span title="\x33">\x33</span><span title="\x7e">\x7e</span>'</span><span>)</span>  <span># 删除</span>
    <span>echo</span> Delete Key
   <span>;</span><span>;</span>
   $<span>'<span title="\x1b">\x1b</span><span title="\x5b">\x5b</span><span title="\x31">\x31</span><span title="\x7e">\x7e</span>'</span><span>)</span>  <span># 数字7上的Home键</span>
    <span>echo</span> Home Key
   <span>;</span><span>;</span>
   $<span>'<span title="\x1b">\x1b</span><span title="\x5b">\x5b</span><span title="\x34">\x34</span><span title="\x7e">\x7e</span>'</span><span>)</span>  <span># 数字1上的End键</span>
    <span>echo</span> End Key
   <span>;</span><span>;</span>
   $<span>'<span title="\x1b">\x1b</span><span title="\x5b">\x5b</span><span title="\x35">\x35</span><span title="\x7e">\x7e</span>'</span><span>)</span>  <span># 上翻页</span>
    <span>echo</span> Page_Up
   <span>;</span><span>;</span>
   $<span>'<span title="\x1b">\x1b</span><span title="\x5b">\x5b</span><span title="\x36">\x36</span><span title="\x7e">\x7e</span>'</span><span>)</span>  <span># 下翻页</span>
    <span>echo</span> Page_Down
   <span>;</span><span>;</span>
   $<span>'<span title="\x1b">\x1b</span><span title="\x5b">\x5b</span><span title="\x41">\x41</span>'</span><span>)</span>  <span># 上箭头</span>
    <span>echo</span> Up arrow
   <span>;</span><span>;</span>
   $<span>'<span title="\x1b">\x1b</span><span title="\x5b">\x5b</span><span title="\x42">\x42</span>'</span><span>)</span>  <span># 下箭头</span>
    <span>echo</span> Down arrow
   <span>;</span><span>;</span>
   $<span>'<span title="\x1b">\x1b</span><span title="\x5b">\x5b</span><span title="\x43">\x43</span>'</span><span>)</span>  <span># 右箭头</span>
    <span>echo</span> Right arrow
   <span>;</span><span>;</span>
   $<span>'<span title="\x1b">\x1b</span><span title="\x5b">\x5b</span><span title="\x44">\x44</span>'</span><span>)</span>  <span># 左箭头</span>
    <span>echo</span> Left arrow
   <span>;</span><span>;</span>
   $<span>'<span title="\x09">\x09</span>'</span><span>)</span>  <span># 制表符</span>
    <span>echo</span> Tab Key
   <span>;</span><span>;</span>
   $<span>'<span title="\x0a">\x0a</span>'</span><span>)</span>  <span># 回车</span>
    <span>echo</span> Enter Key
   <span>;</span><span>;</span>
   $<span>'<span title="\x1b">\x1b</span>'</span><span>)</span>  <span># ESC</span>
    <span>echo</span> Escape Key
   <span>;</span><span>;</span>
   $<span>'<span title="\x20">\x20</span>'</span><span>)</span>  <span># 空格</span>
    <span>echo</span> Space Key
   <span>;</span><span>;</span>
   d<span>)</span>
    <span>date</span>
   <span>;</span><span>;</span>
   q<span>)</span>
    <span>echo</span> Time to quit<span>..</span>.
    <span>echo</span>
    <span>exit</span> <span>0</span>
   <span>;</span><span>;</span>
   *<span>)</span>
    <span>echo</span> Your pressed: <span>\</span>'<span>"<span>$key</span>"</span><span>\</span>'
   <span>;</span><span>;</span>
  <span>esac</span>
  
  <span>echo</span>
  <span>echo</span> <span>"================================"</span>
  
  <span>unset</span> K1 K2 K3
  <span>read</span> -s -N1 -p <span>"Press a key: "</span>
  <span>K1</span><span>=</span><span>"<span>$REPLY</span>"</span>
  <span>read</span> -s -N2 -t <span>0.001</span>
  <span>K2</span><span>=</span><span>"<span>$REPLY</span>"</span>
  <span>read</span> -s -N1 -t <span>0.001</span>
  <span>K3</span><span>=</span><span>"<span>$REPLY</span>"</span>
  <span>key</span><span>=</span><span>"<span>$K1</span><span>$K2</span><span>$K3</span>"</span>
  
<span>done</span>

<span>exit</span> <span>$?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br></div></div><p>还可以查看样例 37-1。</p>
<h3 id=""> \&quot;</h3>
<p>转义引号，指代自身。</p>
<div><pre><code><span>echo</span> <span>"Hello"</span>                     <span># Hello</span>
<span>echo</span> <span>"<span title="\&quot;">\"</span>Hello<span title="\&quot;">\"</span> ... he said."</span>    <span># "Hello" ... he said.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="-2"> \$</h3>
<p>转义美元符号（跟在 <code>\\$</code> 后的变量名将不会被引用）。</p>
<div><pre><code><span>echo</span> <span>"\<span>$variable01</span>"</span>           <span># $variable01</span>
<span>echo</span> <span>"The book cost \<span>$7</span>.98."</span>  <span># The book cost $7.98.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="-3"> \\</h3>
<p>转义反斜杠，指代自身。</p>
<div><pre><code><span>echo</span> <span>"<span title="\\">\\</span>"</span>  <span># 结果是 \</span>

<span># 然而...</span>

<span>echo</span> "<span>\</span>"   <span># 在命令行中会出现第二行并提示输入。</span>
           <span># 在脚本中会出错。</span>
           
<span># 但是...</span>

<span>echo</span> '<span>\</span>'   <span># 结果是 \</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 根据转义符所在的上下文（强引用、弱引用，命令替换或者在 here document）的不同，它的行为也会有所不同。</p>
</blockquote>
<div><pre><code>                      <span>#  简单转义与引用</span>
<span>echo</span> <span>\</span>z               <span>#  z</span>
<span>echo</span> <span>\</span><span>\</span>z              <span># \z</span>
<span>echo</span> <span>'\z'</span>             <span># \z</span>
ehco <span>'<span title="\\">\\</span>z'</span>            <span># \\z</span>
<span>echo</span> <span>"\z"</span>             <span># \z</span>
<span>echo</span> <span>"<span title="\\">\\</span>z"</span>            <span># \z</span>
<span>></span>
                      <span>#  命令替换</span>
<span>echo</span> <span><span>`</span><span>echo</span> <span>\</span>z<span>`</span></span>        <span>#  z</span>
<span>echo</span> <span><span>`</span><span>echo</span> <span>\</span><span>\</span>z<span>`</span></span>       <span>#  z</span>
<span>echo</span> <span><span>`</span><span>echo</span> <span>\</span><span>\</span><span>\</span>z<span>`</span></span>      <span># \z</span>
<span>echo</span> <span><span>`</span><span>echo</span> <span>\</span><span>\</span><span>\</span><span>\</span>z<span>`</span></span>     <span># \z</span>
<span>echo</span> <span><span>`</span><span>echo</span> <span>\</span><span>\</span><span>\</span><span>\</span><span>\</span><span>\</span>z<span>`</span></span>   <span># \z</span>
<span>echo</span> <span><span>`</span><span>echo</span> <span>\</span><span>\</span><span>\</span><span>\</span><span>\</span><span>\</span><span>\</span>z<span>`</span></span>  <span># \\z</span>
<span>echo</span> <span><span>`</span><span>echo</span> <span>"\z"</span><span>`</span></span>      <span># \z</span>
<span>echo</span> <span><span>`</span><span>echo</span> <span>"<span title="\\">\\</span>z"</span><span>`</span></span>     <span># \z</span>
<span>></span>
                      <span># Here Document</span>
<span>cat</span> <span>&lt;&lt;</span><span>EOF
\z
EOF</span>                   <span># \z</span>
<span>></span>
<span>cat</span> <span>&lt;&lt;</span><span>EOF
<span title="\\">\\</span>z
EOF</span>                   <span># \z</span>
<span>></span>
<span># 以上例子由 Stéphane Chazelas 提供。 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><blockquote>
<p>含有转义字符的字符串可以赋值给变量，但是仅仅将单一的转义符赋值给变量是不可行的。</p>
</blockquote>
<div><pre><code><span>variable</span><span>=</span><span>\</span>
<span>echo</span> <span>"<span>$variable</span>"</span>
<span># 这样做会报如下错误：</span>
<span># tesh.sh: : command not found</span>
<span># 单独的转义符不能够赋值给变量。</span>
<span># </span>
<span>#  事实上，"\" 转义了换行，实际效果是：</span>
<span>#+ variable=echo "$variable"</span>
<span>#+ 这是一个非法的赋值方式。</span>
<span>></span>
<span>variable</span><span>=</span><span>\</span>
23skidoo
<span>echo</span> <span>"<span>$variable</span>"</span>        <span># 23skidoo</span>
                        <span># 因为第二行是一个合法的赋值，因此不会报错。</span>
<span>></span>
<span>variable</span><span>=</span><span>\</span> 
<span>#        \^    转义符后有一个空格</span>
<span>echo</span> <span>"<span>$variable</span>"</span>        <span># 空格</span>
<span>></span>
<span>variable</span><span>=</span><span>\</span><span>\</span>
<span>echo</span> <span>"<span>$variable</span>"</span>        <span># \</span>
<span>></span>
<span>variable</span><span>=</span><span>\</span><span>\</span><span>\</span>
<span>echo</span> <span>"<span>$variable</span>"</span>
<span># 这样做会报如下错误：</span>
<span># tesh.sh: \: command not found</span>
<span>#</span>
<span>#  第一个转义符转转义了第二个，但是第三个转义符仍旧转义的是换行，</span>
<span>#+ 跟开始的那个例子一样，因此会报错。</span>
<span>></span>
<span>variable</span><span>=</span><span>\</span><span>\</span><span>\</span><span>\</span>
<span>echo</span> <span>"<span>$variable</span>"</span>        <span># \\</span>
                        <span># 第二个和第四个转义符被转义了，因此可行。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>转义空格能够避免在命令参数列表中的字符分割问题。</p>
<div><pre><code><span>file_list</span><span>=</span><span>"/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7"</span>
<span># 将一系列文件作为命令的参数。</span>

<span># 增加两个文件到列表中，并且列出整个表。</span>
<span>ls</span> -l /usr/X11R6/bin/xsetroot /sbin/dump <span>$file_list</span>

<span>echo</span> <span>"-------------------------------------------------------------------------"</span>

<span># 如果我们转义了这些空格会怎样？</span>
<span>ls</span> -l /usr/X11R6/bin/xsetroot<span>\</span> /sbin/dump<span>\</span> <span>$file_list</span>
<span># 错误：因为转义了两个空格，因此前三个文件被连接成了一个参数传递给了 'ls -l'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>转义符也提供一种可以撰写多行命令的方式。通常，每一行是一个命令，但是转义换行后命令就可以在下一行继续撰写。</p>
<div><pre><code><span>(</span>cd /source/directory <span>&amp;&amp;</span> <span>tar</span> cf - <span>.</span> <span>)</span> <span>|</span> <span>\</span>
<span>(</span>cd /dest/directory <span>&amp;&amp;</span> <span>tar</span> xpvf -<span>)</span>
<span># 回顾 Alan Cox 的目录树拷贝命令，但是把它拆成了两行。</span>

<span># 或者你也可以：</span>
<span>tar</span> cf - -C /source/directory <span>.</span> <span>|</span>
<span>tar</span> xpvf - -C /dest/directory
<span># 可以看下方的注释。</span>
<span># （感谢 Stéphane Chazelas。）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 在脚本中，如果以 &quot;|&quot; 管道作为一行的结束字符，那么不需要加转义符 \ 也可以写多行命令。但是一个好的编程习惯就是在写多行命令的事后，无论什么情况都要在行尾加上转义符 \。</p>
</blockquote>
<div><pre><code><span>echo</span> <span>"foo
bar"</span>
<span>#foo</span>
<span>#bar</span>

<span>echo</span>

<span>echo</span> <span>'foo
bar'</span>    <span># 没有区别。</span>
<span>#foo</span>
<span>#bar</span>

<span>echo</span>

<span>echo</span> foo<span>\</span>
bar     <span># 转义换行。</span>
<span>#foobar</span>

<span>echo</span>

<span>echo</span> <span>"foo\
bar"</span>     <span># 没有区别，在弱引用中，\ 转义符仍旧转义了换行。</span>
<span>#foobar</span>

<span>echo</span>

<span>echo</span> <span>'foo\
bar'</span>     <span># 在强引用中，\ 就按照字面意思来解释了。</span>
<span>#foo\</span>
<span>#bar</span>

<span># 由 Stéphane Chazelas 提供的例子。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第五章 引用</title>
    <id>https://clay-wangzhi.com/code/shell/part2/05_quoting/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/05_quoting/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第五章-引用"> 第五章 引用</h1>
<h3 id="本章目录"> 本章目录</h3>
<ul>
<li><a href="./05_1_quoting_variables.html">5.1 引用变量</a></li>
<li><a href="./05_2_escaping.html">5.2 转义</a></li>
</ul>
<hr>
<p>引用就是将一个字符串用引号括起来。这样做是为了保护Shell/Shell脚本中被重新解释过或带扩展功能的<a href="http://tldp.org/LDP/abs/html/special-chars.html" target="_blank" rel="noopener noreferrer">特殊字符</a>（如果一个字符带有其特殊意义而不仅仅是字面量的话，这个字符就能称为“特殊字符”。比如星号“*”就能表示<a href="http://tldp.org/LDP/abs/html/regexp.html#REGEXREF" target="_blank" rel="noopener noreferrer">正则表达式</a>中的一个<a href="http://tldp.org/LDP/abs/html/globbingref.html" target="_blank" rel="noopener noreferrer">通配符</a>）。</p>
<div><pre><code>bash$ ls -l [Vv]*
-rw-rw-r--    1 bozo  bozo       324 Apr  2 15:05 VIEWDATA.BAT
-rw-rw-r--    1 bozo  bozo       507 May  4 14:25 vartrace.sh
-rw-rw-r--    1 bozo  bozo       539 Apr 14 17:11 viewdata.sh

bash$ ls -l &#39;[Vv]*&#39;
ls: [Vv]*: No such file or directory
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>可以看到，提示不存在该文件。这里的<code>'[Vv]*</code>被当成了文件名。
在日常沟通和写作中，当我们引用一个短语的时候，我们会将它单独隔开并赋予它特殊的意义，而在bash脚本中，当我们<em>引用</em>一个字符串，意味着保留它的<em>字面量</em>。</p>
</blockquote>
<p>很多程序和公用代码会展开被引用字符串中的特殊字符。引用的一个重用用途是保护Shell中的命令行参数，但仍然允许调用的程序扩展它。</p>
<div><pre><code>bash$ grep &#39;[Ff]irst&#39; *.txt
file1.txt:This is the first line of file1.txt.
file2.txt:This is the First line of file2.txt.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>在所有.txt文件中找出包含first或者First字符串的行</p>
</blockquote>
<p>注意，不加引号的 <code>grep [Ff]irst *.txt</code> 在Bash下也同样有效。<sup></sup></p>
<p>引用也可以控制<a href="http://tldp.org/LDP/abs/html/internal.html#ECHOREF" target="_blank" rel="noopener noreferrer">echo</a>命令的断行符。</p>
<div><pre><code>bash$ echo $(ls -l)
total 8 -rw-rw-r-- 1 bo bo 13 Aug 21 12:57 t.sh -rw-rw-r-- 1 bo bo 78 Aug 21 12:57 u.sh


bash$ echo &quot;$(ls -l)&quot;
total 8
 -rw-rw-r--  1 bo bo  13 Aug 21 12:57 t.sh
 -rw-rw-r--  1 bo bo  78 Aug 21 12:57 u.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><hr>
<section>
<ol>
<li id="footnote1"><p>前提是当前目录下有文件名为First或first的文件。这也是使用引用的另一个原因。（感谢 Harald Koenig 指出了这一点） </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第六章 退出与退出状态</title>
    <id>https://clay-wangzhi.com/code/shell/part2/06_exit_and_exit_status/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/06_exit_and_exit_status/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第六章-退出与退出状态"> 第六章 退出与退出状态</h1>
<blockquote>
<p>Bourne shell里存在不明确之处，但人们也会使用它们。</p>
<p>—— Chat Ramey</p>
</blockquote>
<p>跟C程序类似，<code>exit</code> 命令被用来结束脚本。同时，它也会返回一个值，返回值可以被交给父进程。</p>
<p>每个命令都会返回一个退出状态（exit status），有时也叫做返回状态（return status）或退出码（exit code）。命令执行成功返回0，如果返回一个非0值，通常情况下会被认为是一个错误代码。一个运行状态良好的UNIX命令、程序和工具在正常执行退出后都会返回一个0的退出码，当然也有例外。</p>
<p>同样地，脚本中的函数和脚本本身也会返回一个退出状态。在脚本或者脚本函数中执行的最后的命令会决定它们的退出状态。在脚本中，<code>exit nnn</code> 命令将会把nnn退出状态码传递给shell（nnn 必须是 0-255 之间的整型数）。</p>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> 当一个脚本以不带参数的 <code>exit</code> 来结束时，脚本的退出状态由脚本最后执行命令决定（<code>exit</code> 命令之前）。</p>
</blockquote>
<div><pre><code><span>#!/bin/bash</span>

COMMAND_1

<span>..</span>.

COMMAND_LAST

<span># 将以最后的命令来决定退出状态</span>

<span>exit</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p><code>exit</code>，<code>exit $?</code> 以及省略 <code>exit</code> 效果等同。</p>
</blockquote>
<div><pre><code><span>#!/bin/bash </span>

COMMAND_1

<span>..</span>.

COMMAND_LAST

<span>#将以最后的命令来决定退出状态</span>

<span>exit</span> <span>$?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>#!/bin/bash</span>

COMMAND_1

<span>..</span>.

COMMAND_LAST

<span>#将以最后的命令来决定退出状态</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>$?</code> 读取上一个执行命令的退出状态。在一个函数返回后，<code>$?</code> 给出函数最后执行的那条命令的退出状态。这就是Bash函数的&quot;返回值&quot;。<sup></sup></p>
<p>在<a href="http://tldp.org/LDP/abs/html/special-chars.html#PIPEREF" target="_blank" rel="noopener noreferrer">管道</a>执行后，<code>$?</code> 给出最后执行的那条命令的退出状态。</p>
<p>在脚本终止后，命令行下键入<code>$?</code>会给出脚本的退出状态，即在脚本中最后一条命令执行后的退出状态。一般情况下，0为成功，1-255为失败。</p>
<p>样例 6-1. 退出与退出状态</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> hello
<span>echo</span> <span>$?</span>    <span># 返回值为0，因为执行成功。</span>

lskdf      <span># 不认识的命令。</span>
<span>echo</span> <span>$?</span>    <span># 返回非0值，因为失败了。</span>

<span>echo</span>

<span>exit</span> <span>113</span>   <span># 将返回113给shell</span>
           <span># 为了验证这些，在脚本结束的地方使用“echo $?”</span>

<span>#  按照惯例，'exit 0' 意味着执行成功，</span>
<span>#+ 非0意味着错误或者异常情况。</span>
<span>#  查看附录章节“退出码的特殊含义”</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><code>$?</code> 对于测试脚本中的命令的执行结果特别有用（查看样例 16-35和样例 16-20）。</p>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> 逻辑非操作符 <a href="http://tldp.org/LDP/abs/html/special-chars.html#NOTREF" target="_blank" rel="noopener noreferrer">!</a> 将会反转测试或命令的结果，并且这将会影响退出状态。</p>
</blockquote>
<p>样例 6-2. 否定一个条件使用!</p>
<div><pre><code><span>true</span>    <span># true 是 shell 内建命令。</span>
<span>echo</span> <span>"exit status of <span title="\&quot;">\"</span>true<span title="\&quot;">\"</span> = <span>$?</span>"</span>     <span># 0</span>

<span>!</span> <span>true</span>
<span>echo</span> <span>"exit status of <span title="\&quot;">\"</span>! true<span title="\&quot;">\"</span> = <span>$?</span>"</span>   <span># 1</span>
<span># 注意在命令之间的 "!" 需要一个空格。</span>
<span># !true 将导致一个"command not found"错误。</span>
<span>#</span>
<span># 如果一个命令以'!'开头，那么将调用 Bash 的历史机制，显示这个命令被使用的历史。</span>

<span>true</span>
<span>!</span>true
<span># 这次就没有错误了，但是同样也没有反转。</span>
<span># 它不过是重复之前的命令（true）。</span>


<span># ============================================================ #</span>
<span># 在 _pipe_ 前使用 ! 将改变返回的退出状态。</span>
<span>ls</span> <span>|</span> bogus_command      <span>#bash: bogus_command: command not found</span>
<span>echo</span> <span>$?</span>                 <span>#127</span>
<span>></span>
<span>!</span> <span>ls</span> <span>|</span> bogus_command    <span>#bash: bogus_command:command not found</span>
<span>echo</span> <span>$?</span>                 <span>#0</span>
<span># 注意 ! 不会改变管道的执行。</span>
<span># 只改变退出状态。</span>
<span>#============================================================  #</span>
<span>></span>
<span># 感谢 Stéphane Chazelas 和 Kristopher Newsome。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="caution" /> 某些特定的退出码具有一些特定的<a href="http://tldp.org/LDP/abs/html/exitcodes.html#EXITCODESREF" target="_blank" rel="noopener noreferrer">保留含义</a>，用户不应该在自己的脚本中重新定义它们。</p>
</blockquote>
<hr>
<section>
<ol>
<li id="footnote1"><p>在函数没有用<a href="http://tldp.org/LDP/abs/html/complexfunct.html#RETURNREF" target="_blank" rel="noopener noreferrer">return</a>来结束这个函数的情况下。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">7.1 测试结构</title>
    <id>https://clay-wangzhi.com/code/shell/part2/07_1_test_constructs/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/07_1_test_constructs/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_7-1-测试结构"> 7.1 测试结构</h1>
<ul>
<li>
<p><code>if/then</code> 结构是用来检测一系列命令的 <a href="http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF" target="_blank" rel="noopener noreferrer">退出状态</a> 是否为0（按 UNIX 惯例,退出码 0 表示命令执行成功），如果为0，则执行接下来的一个或多个命令。</p>
</li>
<li>
<p>测试结构会使用一个特殊的命令 <code>[</code>（参看特殊字符章节 <a href="http://tldp.org/LDP/abs/html/special-chars.html#LEFTBRACKET" target="_blank" rel="noopener noreferrer">左方括号</a>）。等同于 <code>test</code> 命令，它是一个<a href="http://tldp.org/LDP/abs/html/internal.html#BUILTINREF" target="_blank" rel="noopener noreferrer">内建命令</a>，写法更加简洁高效。该命令将其参数视为比较表达式或文件测试，以比较结果作为其退出状态码返回（0 为真，1 为假）。</p>
</li>
<li>
<p>Bash 在 2.02 版本中引入了扩展测试命令 <a href="http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS" target="_blank" rel="noopener noreferrer"><code>[[...]]</code></a>，它提供了一种与其他语言语法更为相似的方式进行比较操作。注意， <code>[[</code> 是一个 <a href="http://tldp.org/LDP/abs/html/internal.html#KEYWORDREF" target="_blank" rel="noopener noreferrer">关键字</a> 而非一个命令。</p>
<p>Bash 将 <code>[[ $a -lt $b ]]</code> 视为一整条语句，执行并返回退出状态。</p>
</li>
<li>
<p>结构 <a href="http://tldp.org/LDP/abs/html/dblparens.html" target="_blank" rel="noopener noreferrer"><code>(( ... ))</code></a> 和 <a href="http://tldp.org/LDP/abs/html/internal.html#LETREF" target="_blank" rel="noopener noreferrer"><code>let ...</code></a> 根据其执行的算术表达式的结果决定退出状态码。这样的 <a href="http://tldp.org/LDP/abs/html/arithexp.html#ARITHEXPREF" target="_blank" rel="noopener noreferrer">算术扩展</a> 结构可以用来进行 <a href="http://tldp.org/LDP/abs/html/comparison-ops.html#ICOMPARISON1" target="_blank" rel="noopener noreferrer">数值比较</a>。</p>
</li>
</ul>
<div><pre><code><span><span>((</span> <span>0</span> <span>&amp;&amp;</span> <span>1</span> <span>))</span></span>                 <span># 逻辑与</span>
<span>echo</span> <span>$?</span>     <span># 1     ***</span>
<span># 然后 ...</span>
<span>let</span> <span>"num = <span><span>((</span> <span>0</span> <span>&amp;&amp;</span> <span>1</span> <span>))</span></span>"</span>
<span>echo</span> <span>$num</span>   <span># 0</span>
<span># 然而 ...</span>
<span>let</span> <span>"num = <span><span>((</span> <span>0</span> <span>&amp;&amp;</span> <span>1</span> <span>))</span></span>"</span>
<span>echo</span> <span>$?</span>     <span># 1     ***</span>


<span><span>((</span> <span>200</span> <span>||</span> <span>11</span> <span>))</span></span>              <span># 逻辑或</span>
<span>echo</span> <span>$?</span>     <span># 0     ***</span>
<span># ...</span>
<span>let</span> <span>"num = <span><span>((</span> <span>200</span> <span>||</span> <span>11</span> <span>))</span></span>"</span>
<span>echo</span> <span>$num</span>   <span># 1</span>
<span>let</span> <span>"num = <span><span>((</span> <span>200</span> <span>||</span> <span>11</span> <span>))</span></span>"</span>
<span>echo</span> <span>$?</span>     <span># 0     ***</span>


<span><span>((</span> <span>200</span> <span>|</span> <span>11</span> <span>))</span></span>               <span># 按位或</span>
<span>echo</span> <span>$?</span>                      <span># 0     ***</span>
<span># ...</span>
<span>let</span> <span>"num = <span><span>((</span> <span>200</span> <span>|</span> <span>11</span> <span>))</span></span>"</span>
<span>echo</span> <span>$num</span>                    <span># 203</span>
<span>let</span> <span>"num = <span><span>((</span> <span>200</span> <span>|</span> <span>11</span> <span>))</span></span>"</span>
<span>echo</span> <span>$?</span>                      <span># 0     ***</span>

<span># "let" 结构的退出状态与双括号算术扩展的退出状态是相同的。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="caution" /> 注意，双括号算术扩展表达式的退出状态码不是一个错误的值。算术表达式为0，返回1；算术表达式不为0，返回0。</p>
<div><pre><code><span>var</span><span>=</span>-2 <span>&amp;&amp;</span> <span><span>((</span> var<span>+</span><span>=</span><span>2</span> <span>))</span></span>
<span>echo</span> <span>$?</span>                   <span># 1</span>

<span>var</span><span>=</span>-2 <span>&amp;&amp;</span> <span><span>((</span> var<span>+</span><span>=</span><span>2</span> <span>))</span></span> <span>&amp;&amp;</span> <span>echo</span> <span>$var</span>
                          <span># 并不会输出 $var, 因为((var+=2))的状态码为1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li><code>if</code> 不仅可以用来测试括号内的条件表达式，还可以用来测试其他任何命令。</li>
</ul>
<div><pre><code><span>if</span> <span>cmp</span> a b <span>&amp;></span> /dev/null  <span># 消去输出结果</span>
<span>then</span> <span>echo</span> <span>"Files a and b are identical."</span>
<span>else</span> <span>echo</span> <span>"Files a and b differ."</span>
<span>fi</span>

<span># 下面介绍一个非常实用的 “if-grep" 结构：</span>
<span># -----------------------------------</span>
<span>if</span> <span>grep</span> -q Bash <span>file</span>
  <span>then</span> <span>echo</span> <span>"File contains at least one occurrence of Bash."</span>
<span>fi</span>
    
<span>word</span><span>=</span>Linux
<span>letter_sequence</span><span>=</span>inu
<span>if</span> <span>echo</span> <span>"<span>$word</span>"</span> <span>|</span> <span>grep</span> -q <span>"<span>$letter_sequence</span>"</span>
<span># 使用 -q 选项消去 grep 的输出结果</span>
<span>then</span>
  <span>echo</span> <span>"<span>$letter_sequence</span> found in "</span><span>$word</span><span>"
else
  echo "</span><span>$letter_sequence</span> not found <span>in</span> <span>$word</span><span>"
fi


if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED
  then echo "</span>Command succeed.<span>"
  else echo "</span>Command failed."
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><ul>
<li>感谢 Stéphane Chazelas 提供了后两个例子。</li>
</ul>
<p>样例 7-1. 什么才是真？</p>
<div><pre><code><span>#!/bin/bash</span>

<span># 提示：</span>
<span># 如果你不确定某个表达式的布尔值，可以用 if 结构进行测试。</span>

<span>echo</span>

<span>echo</span> <span>"Testing <span title="\&quot;">\"</span>0<span title="\&quot;">\"</span>"</span>
<span>if</span> <span>[</span> <span>0</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"0 is true."</span>
<span>else</span>
  <span>echo</span> <span>"0 is false."</span>
<span>fi</span>            <span># 0 为真。</span>

<span>echo</span>

<span>echo</span> <span>"Testing <span title="\&quot;">\"</span>1<span title="\&quot;">\"</span>"</span>
<span>if</span> <span>[</span> <span>1</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"1 is true."</span>
<span>else</span>
  <span>echo</span> <span>"1 is false."</span>
<span>fi</span>            <span># 1 为真。</span>

<span>echo</span>

<span>echo</span> <span>"Testing <span title="\&quot;">\"</span>-1<span title="\&quot;">\"</span>"</span>
<span>if</span> <span>[</span> -1 <span>]</span>
<span>then</span>
  <span>echo</span> <span>"-1 is true."</span>
<span>else</span>
  <span>echo</span> <span>"-1 is false."</span>
<span>fi</span>            <span># -1 为真。</span>

<span>echo</span>

<span>echo</span> <span>"Testing <span title="\&quot;">\"</span>NULL<span title="\&quot;">\"</span>"</span>
<span>if</span> <span>[</span> <span>]</span>        <span># NULL, 空</span>
<span>then</span>
  <span>echo</span> <span>"NULL is true."</span>
<span>else</span>
  <span>echo</span> <span>"NULL is false."</span>
<span>fi</span>            <span># NULL 为假。</span>

<span>echo</span>

<span>echo</span> <span>"Testing <span title="\&quot;">\"</span>xyz<span title="\&quot;">\"</span>"</span>
<span>if</span> <span>[</span> xyz <span>]</span>    <span># 字符串</span>
<span>then</span>
  <span>echo</span> <span>"Random string is true."</span>
<span>else</span>
  <span>echo</span> <span>"Random string is false."</span>
<span>fi</span>            <span># 随机字符串为真。</span>

<span>echo</span>

<span>echo</span> <span>"Testing <span title="\&quot;">\"</span><span>$xyz</span><span title="\&quot;">\"</span>"</span>
<span>if</span> <span>[</span> <span>$xyz</span> <span>]</span>   <span># 原意是测试 $xyz 是否为空，但是</span>
              <span># 现在 $xyz 只是一个没有初始化的变量。</span>
<span>then</span>
  <span>echo</span> <span>"Uninitialized variable is true."</span>
<span>else</span>
  <span>echo</span> <span>"Uninitialized variable is flase."</span>
<span>fi</span>            <span># 未初始化变量含有null空值，为假。</span>

<span>echo</span>

<span>echo</span> <span>"Testing <span title="\&quot;">\"</span>-n \<span>$xyz</span><span title="\&quot;">\"</span>"</span>
<span>if</span> <span>[</span> -n <span>"<span>$xyz</span>"</span> <span>]</span>            <span># 更加准确的写法。</span>
<span>then</span>
  <span>echo</span> <span>"Uninitialized variable is true."</span>
<span>else</span>
  <span>echo</span> <span>"Uninitialized variable is false."</span>
<span>fi</span>            <span># 未初始化变量为假。</span>

<span>echo</span>


<span>xyz</span><span>=</span>          <span># 初始化为空。</span>

<span>echo</span> <span>"Testing <span title="\&quot;">\"</span>-n \<span>$xyz</span><span title="\&quot;">\"</span>"</span>
<span>if</span> <span>[</span> -n <span>"<span>$xyz</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"Null variable is true."</span>
<span>else</span>
  <span>echo</span> <span>"Null variable is false."</span>
<span>fi</span>            <span># 空变量为假。</span>

<span>echo</span>

<span># 什么时候 "false" 为真？</span>

<span>echo</span> <span>"Testing <span title="\&quot;">\"</span>false<span title="\&quot;">\"</span>"</span>
<span>if</span> <span>[</span> <span>"false"</span> <span>]</span>              <span>#  看起来 "false" 只是一个字符串</span>
<span>then</span>
  <span>echo</span> <span>"<span title="\&quot;">\"</span>false<span title="\&quot;">\"</span> is true."</span> <span>#+ 测试结果为真。</span>
<span>else</span>
  <span>echo</span> <span>"<span title="\&quot;">\"</span>false<span title="\&quot;">\"</span> is false."</span>
<span>fi</span>            <span># "false" 为真。</span>

<span>echo</span>

<span>echo</span> <span>"Testing <span title="\&quot;">\"</span>\<span>$false</span><span title="\&quot;">\"</span>"</span>  <span># 未初始化的变量。</span>
<span>if</span> <span>[</span> <span>"<span>$false</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"<span title="\&quot;">\"</span>\<span>$false</span><span title="\&quot;">\"</span> is true."</span>
<span>else</span>
  <span>echo</span> <span>"<span title="\&quot;">\"</span>\<span>$false</span><span title="\&quot;">\"</span> is false."</span>
<span>fi</span>            <span># "$false" 为假。</span>
              <span># 得到了我们想要的结果。</span>

<span># 如果测试空变量 "$true" 会有什么样的结果？</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br></div></div><p>练习：理解 <a href="http://tldp.org/LDP/abs/html/testconstructs.html#EX10" target="_blank" rel="noopener noreferrer">样例 7-1</a></p>
<div><pre><code><span>if</span> <span>[</span> condition-true <span>]</span>
<span>then</span>
   <span>command</span> <span>1</span>
   <span>command</span> <span>2</span>
   <span>..</span>.
<span>else</span>  <span># 如果测试条件为假，则执行 else 后面的代码段</span>
   <span>command</span> <span>3</span>
   <span>command</span> <span>4</span>
   <span>..</span>.
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> 如果把 <code>if</code> 和 <code>then</code> 写在同一行时，则必须在 <code>if</code> 语句后加上一个分号来结束语句。因为 <code>if</code> 和 <code>then</code> 都是 <a href="http://tldp.org/LDP/abs/html/internal.html#KEYWORDREF" target="_blank" rel="noopener noreferrer">关键字</a>。以关键字（或者命令）开头的语句，必须先结束该语句(分号;)，才能执行下一条语句。</p>
<div><pre><code><span>if</span> <span>[</span> -x <span>"<span>$filename</span>"</span> <span>]</span><span>;</span> <span>then</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="else-if-与-elif"> Else if 与 elif</h3>
<p>elif</p>
<p><code>elif</code> 是 <code>else if</code> 的缩写。可以把多个 <code>if/then</code> 语句连到外边去，更加简洁明了。</p>
<div><pre><code><span>if</span> <span>[</span> condition1 <span>]</span>
<span>then</span>
   command1
   command2
   command3
<span>elif</span> <span>[</span>condition2 <span>]</span>
<span># 等价于 else if</span>
<span>then</span>
   command4
   command5
<span>else</span>
   default-command
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><code>if test condition-true</code> 完全等价于 <code>if [ condition-true ]</code>。当语句开始执行时，左括号 <code>[</code> 是作为调用 <code>test</code> 命令的标记<sup></sup>，而右括号则不严格要求，但在新版本的 Bash 里，右括号必须补上。</p>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> <code>test</code> 命令是 Bash 的 <a href="http://tldp.org/LDP/abs/html/internal.html#BUILTINREF" target="_blank" rel="noopener noreferrer">内建命令</a>，可以用来检测文件类型和比较字符串。在 Bash 脚本中，<code>test</code> 不调用 <code>sh-utils</code> 包下的文件 <code>/usr/bin/test</code>。同样，<code>[</code> 也不会调用链接到 <code>/usr/bin/test</code> 的 <code>/usr/bin/[</code> 文件。</p>
<div><pre><code>bash$ type test
test is a shell builtin
bash$ type &#39;[&#39;
[ is a shell builtin
bash$ type &#39;[[&#39;
[[ is a shell keyword
bash$ type &#39;]]&#39;
]] is a shell keyword
bash$ type &#39;]&#39;
bash: type: ]: not found
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>如果你想在 Bash 脚本中使用 <code>/usr/bin/test</code>，那你必须把路径写全。</p>
<p>样例 7-2. <code>test</code>，<code>/usr/bin/test</code>，<code>[]</code> 和 <code>/usr/bin/[</code> 的等价性</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span>

<span>if</span> <span>test</span> -z <span>"<span>$1</span>"</span>
<span>then</span>
  <span>echo</span> <span>"No command-line arguments."</span>
<span>else</span>
  <span>echo</span> <span>"First command-line argument is <span>$1</span>."</span>
<span>fi</span>

<span>echo</span>

<span>if</span> /usr/bin/test -z <span>"<span>$1</span>"</span>      <span># 等价于内建命令 "test"</span>
<span>#  ^^^^^^^^^^^^^              # 指定全路径</span>
<span>then</span>
  <span>echo</span> <span>"No command-line arguments."</span>
<span>else</span>
  <span>echo</span> <span>"First command-line argument is <span>$1</span>."</span>
<span>fi</span>

<span>echo</span>

<span>if</span> <span>[</span> -z <span>"<span>$1</span>"</span> <span>]</span>                <span># 功能和上面的代码相同。</span>
<span>#   if [ -z "$1"                理论上可行，但是 Bash 会提示缺失右括号</span>
<span>then</span>
  <span>echo</span> <span>"No command-line arguments."</span>
<span>else</span>
  <span>echo</span> <span>"First command-line argument is <span>$1</span>."</span>
<span>fi</span>

<span>echo</span>


<span>if</span> /usr/bin/<span>[</span> -z <span>"<span>$1</span>"</span> <span>]</span>       <span># 功能和上面的代码相同。</span>
<span># if /usr/bin/[ -z "$1"       # 理论上可行，但是会报错</span>
<span>#                             # 已经在 Bash 3.x 版本被修复了</span>
<span>then</span>
  <span>echo</span> <span>"No command-line arguments."</span>
<span>else</span>
  <span>echo</span> <span>"First command-line argument is <span>$1</span>."</span>
<span>fi</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>在 Bash 里，<code>[[ ]]</code> 是比 <code>[ ]</code> 更加通用的写法。其作为扩展<code>test</code> 命令从 ksh88 中被继承了过来。</p>
<p>在 <code>[[</code> 和 <code>]]</code> 中不会进行文件名扩展或字符串分割，但是可以进行参数扩展和命令替换。</p>
<div><pre><code><span>file</span><span>=</span>/etc/passwd

<span>if</span> <span>[</span><span>[</span> -e <span>$file</span> <span>]</span><span>]</span>
<span>then</span>
  <span>echo</span> <span>"Password file exists."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>使用 <code>[[...]]</code> 代替 <code>[...]</code>可以避免很多逻辑错误。比如可以在 <code>[[]]</code> 中使用 <code>&amp;&amp;</code>，<code>||</code>，<code>&lt;</code> 和 <code>&gt;</code> 运算符，而在 <code>[]</code> 中使用会报错。</p>
<p>在 <code>[[]]</code> 中会自动执行八进制和十六进制的进制转换操作。</p>
<div><pre><code><span># [[ 八进制和十六进制进制转换 ]]</span>
<span># 感谢 Moritz Gronbach 提出。</span>


<span>decimal</span><span>=</span><span>15</span>
<span>octal</span><span>=</span>017   <span># = 15 (十进制)</span>
<span>hex</span><span>=</span>0x0f    <span># = 15 (十进制)</span>

<span>if</span> <span>[</span> <span>"<span>$decimal</span>"</span> -eq <span>"<span>$octal</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"<span>$decimal</span> equals <span>$octal</span>"</span>
<span>else</span>
  <span>echo</span> <span>"<span>$decimal</span> is not equal to <span>$octal</span>"</span>       <span># 15 不等于 017</span>
<span>fi</span>      <span># 在单括号 [ ] 之间不会进行进制转换。</span>


<span>if</span> <span>[</span><span>[</span> <span>"<span>$decimal</span>"</span> -eq <span>"<span>$octal</span>"</span> <span>]</span><span>]</span>
<span>then</span>
  <span>echo</span> <span>"<span>$decimal</span> equals <span>$octal</span>"</span>                <span># 15 等于 017</span>
<span>else</span>
  <span>echo</span> <span>"<span>$decimal</span> is not equal to <span>$octal</span>"</span>
<span>fi</span>      <span># 在双括号 [[ ]] 之间会进行进制转换。</span>

<span>if</span> <span>[</span><span>[</span> <span>"<span>$decimal</span>"</span> -eq <span>"<span>$hex</span>"</span> <span>]</span><span>]</span>
<span>then</span>
  <span>echo</span> <span>"<span>$decimal</span> equals <span>$hex</span>"</span>                  <span># 15 等于 0x0f</span>
<span>else</span>
  <span>echo</span> <span>"<span>$decimal</span> is not equal to <span>$hex</span>"</span>
<span>fi</span>      <span># 十六进制也可以进行转换。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> 语法上并不严格要求在 <code>if</code> 之后一定要写 <code>test</code> 命令或者测试结构（<code>[]</code> 或 <code>[[]]</code>）。</p>
<div><pre><code><span>dir</span><span>=</span>/home/bozo

<span>if</span> <span>cd</span> <span>"<span>$dir</span>"</span> <span><span>2</span>></span>/dev/null<span>;</span> <span>then</span>   <span># "2>/dev/null" 重定向消去错误输出。</span>
  <span>echo</span> <span>"Now in <span>$dir</span>."</span>
<span>else</span>
  <span>echo</span> <span>"Can't change to <span>$dir</span>."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>if COMMAND</code> 的退出状态就是<code>COMMAND</code> 的退出状态。</p>
<p>同样的，测试括号也不一定需要与 <code>if</code> 一起使用。其可以同 <a href="http://tldp.org/LDP/abs/html/list-cons.html#LISTCONSREF" target="_blank" rel="noopener noreferrer">列表结构</a> 结合而不需要 <code>if</code>。</p>
<div><pre><code><span>var1</span><span>=</span><span>20</span>
<span>var2</span><span>=</span><span>22</span>
<span>[</span> <span>"<span>$var1</span>"</span> -ne <span>"<span>$var2</span>"</span> <span>]</span> <span>&amp;&amp;</span> <span>echo</span> <span>"<span>$var1</span> is not equal to <span>$var2</span>"</span>

<span>home</span><span>=</span>/home/bozo
<span>[</span> -d <span>"<span>$home</span>"</span> <span>]</span> <span>||</span> <span>echo</span> <span>"<span>$home</span> directory does not exist."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><a href="http://tldp.org/LDP/abs/html/dblparens.html" target="_blank" rel="noopener noreferrer"><code>(( ))</code> 结构</a> 扩展和执行算术表达式。如果执行结果为0，其返回的 <a href="http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF" target="_blank" rel="noopener noreferrer">退出状态码</a> 为1（假）。非0表达式返回的退出状态为0（真）。这与上述所使用的 <code>test</code> 和 <code>[ ]</code> 结构形成鲜明的对比。</p>
<p>样例 7-3. 使用 <code>(( ))</code> 进行算术测试</p>
<div><pre><code><span>#!/bin/bash</span>
<span># arith-tests.sh</span>
<span># 算术测试。</span>

<span># (( ... )) 结构执行并测试算术表达式。</span>
<span># 与 [ ... ] 结构的退出状态正好相反。</span>

<span><span>((</span> <span>0</span> <span>))</span></span>
<span>echo</span> <span>"Exit status of <span title="\&quot;">\"</span><span><span>((</span> <span>0</span> <span>))</span></span><span title="\&quot;">\"</span> is <span>$?</span>."</span>         <span># 1</span>

<span><span>((</span> <span>1</span> <span>))</span></span>
<span>echo</span> <span>"Exit status of <span title="\&quot;">\"</span><span><span>((</span> <span>1</span> <span>))</span></span><span title="\&quot;">\"</span> is <span>$?</span>."</span>         <span># 0</span>

<span><span>((</span> <span>5</span> <span>></span> <span>4</span> <span>))</span></span>                                      <span># 真</span>
<span>echo</span> <span>"Exit status of <span title="\&quot;">\"</span><span><span>((</span> <span>5</span> <span>></span> <span>4</span> <span>))</span></span><span title="\&quot;">\"</span> is <span>$?</span>."</span>     <span># 0</span>

<span><span>((</span> <span>5</span> <span>></span> <span>9</span> <span>))</span></span>                                      <span># 假</span>
<span>echo</span> <span>"Exit status of <span title="\&quot;">\"</span><span><span>((</span> <span>5</span> <span>></span> <span>9</span> <span>))</span></span><span title="\&quot;">\"</span> is <span>$?</span>."</span>     <span># 1</span>

<span><span>((</span> <span>5</span> <span>==</span> <span>5</span> <span>))</span></span>                                     <span># 真</span>
<span>echo</span> <span>"Exit status of <span title="\&quot;">\"</span><span><span>((</span> <span>5</span> <span>==</span> <span>5</span> <span>))</span></span><span title="\&quot;">\"</span> is <span>$?</span>."</span>    <span># 0</span>
<span># (( 5 = 5 )) 会报错。</span>

<span><span>((</span> <span>5</span> <span>-</span> <span>5</span> <span>))</span></span>                                      <span># 0</span>
<span>echo</span> <span>"Exit status of <span title="\&quot;">\"</span><span><span>((</span> <span>5</span> <span>-</span> <span>5</span> <span>))</span></span><span title="\&quot;">\"</span> is <span>$?</span>."</span>     <span># 1</span>

<span><span>((</span> <span>5</span> <span>/</span> <span>4</span> <span>))</span></span>                                      <span># 合法</span>
<span>echo</span> <span>"Exit status of <span title="\&quot;">\"</span><span><span>((</span> <span>5</span> <span>/</span> <span>4</span> <span>))</span></span><span title="\&quot;">\"</span> is <span>$?</span>."</span>     <span># 0 </span>

<span><span>((</span> <span>1</span> <span>/</span> <span>2</span> <span>))</span></span>                                      <span># 结果小于1</span>
<span>echo</span> <span>"Exit status of <span title="\&quot;">\"</span><span><span>((</span> <span>1</span> <span>/</span> <span>2</span> <span>))</span></span><span title="\&quot;">\"</span> is <span>$?</span>."</span>     <span># 舍入至0。</span>
                                                 <span># 1</span>

<span><span>((</span> <span>1</span> <span>/</span> <span>0</span> <span>))</span></span> <span><span>2</span>></span>/dev/null                          <span># 除0，非法</span>
<span>#           ^^^^^^^^^^^</span>
<span>echo</span> <span>"Exit status of <span title="\&quot;">\"</span><span><span>((</span> <span>1</span> <span>/</span> <span>0</span> <span>))</span></span><span title="\&quot;">\"</span> is <span>$?</span>."</span>     <span># 1</span>

<span># "2>/dev/null" 的作用是什么？</span>
<span># 如果将其移除会发生什么？</span>
<span># 尝试移除这条语句并重新执行脚本。</span>

<span># ======================================= #</span>

<span># (( ... )) 在 if-then 中也非常有用</span>

<span>var1</span><span>=</span><span>5</span>
<span>var2</span><span>=</span><span>4</span>

<span>if</span> <span><span>((</span> var1 <span>></span> var2 <span>))</span></span>
<span>then</span> <span>#^      ^      注意不是 $var1 和 $var2，为什么？</span>
  <span>echo</span> <span>"<span>$var1</span> is greater then <span>$var2</span>"</span>
<span>fi</span>     <span># 5 大于 4</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><hr>
<section>
<ol>
<li id="footnote1"><p>标记是一个具有特殊意义（<a href="http://tldp.org/LDP/abs/html/x17129.html#METAMEANINGREF" target="_blank" rel="noopener noreferrer">元语义</a>）的符号或者短字符串。在 Bash 里像 <code>[</code> 和 <a href="http://tldp.org/LDP/abs/html/special-chars.html#DOTREF" target="_blank" rel="noopener noreferrer"><code>.（点命令）</code></a> 这样的标记可以扩展成关键字和命令。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">7.2 文件测试操作</title>
    <id>https://clay-wangzhi.com/code/shell/part2/07_2_file_test_operators/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/07_2_file_test_operators/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_7-2-文件测试操作"> 7.2 文件测试操作</h1>
<p>下列每一个运算符在满足其下条件时，返回的结果为真。</p>
<h3 id="e"> -e</h3>
<p>检测文件是否存在</p>
<h3 id="a"> -a</h3>
<p>检测文件是否存在</p>
<p>等价于 <code>-e</code>。不推荐使用，已被弃用<sup></sup>。</p>
<h3 id="f"> -f</h3>
<p>文件是常规文件(regular file)，而非目录或 <a href="http://tldp.org/LDP/abs/html/devref1.html#DEVFILEREF" target="_blank" rel="noopener noreferrer">设备文件</a></p>
<h3 id="s"> -s</h3>
<p>文件大小不为0</p>
<h3 id="d"> -d</h3>
<p>文件是一个目录</p>
<h3 id="b"> -b</h3>
<p>文件是一个 <a href="http://tldp.org/LDP/abs/html/devref1.html#BLOCKDEVREF" target="_blank" rel="noopener noreferrer">块设备</a></p>
<h3 id="c"> -c</h3>
<p>文件是一个 <a href="http://tldp.org/LDP/abs/html/devref1.html#CHARDEVREF" target="_blank" rel="noopener noreferrer">字符设备</a></p>
<div><pre><code><span>device0</span><span>=</span><span>"/dev/sda2"</span>    <span># /   (根目录)</span>
<span>if</span> <span>[</span> -b <span>"<span>$device0</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"<span>$device0</span> is a block device."</span>
<span>fi</span>

<span># /dev/sda2 是一个块设备。</span>



<span>device1</span><span>=</span><span>"/dev/ttyS1"</span>   <span># PCMCIA 调制解调卡</span>
<span>if</span> <span>[</span> -c <span>"<span>$device1</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"<span>$device1</span> is a character device."</span>
<span>fi</span>

<span># /dev/ttyS1 是一个字符设备。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="p"> -p</h3>
<p>文件是一个 <a href="http://tldp.org/LDP/abs/html/special-chars.html#PIPEREF" target="_blank" rel="noopener noreferrer">管道设备</a></p>
<div><pre><code><span>function</span> <span>show_input_type</span><span>(</span><span>)</span>
<span>{</span>
   <span>[</span> -p /dev/fd/0 <span>]</span> <span>&amp;&amp;</span> <span>echo</span> PIPE <span>||</span> <span>echo</span> STDIN
<span>}</span>

show_input_type <span>"Input"</span>                           <span># STDIN</span>
<span>echo</span> <span>"Input"</span> <span>|</span> show_input_type                    <span># PIPE</span>

<span># 这个例子由 Carl Anderson 提供。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="h"> -h</h3>
<p>文件是一个 <a href="http://tldp.org/LDP/abs/html/basic.html#SYMLINKREF" target="_blank" rel="noopener noreferrer">符号链接</a></p>
<h3 id="l"> -L</h3>
<p>文件是一个符号链接</p>
<h3 id="s-2"> -S</h3>
<p>文件是一个 <a href="http://tldp.org/LDP/abs/html/devref1.html#SOCKETREF" target="_blank" rel="noopener noreferrer">套接字</a></p>
<h3 id="t"> -t</h3>
<p>文件（<a href="http://tldp.org/LDP/abs/html/io-redirection.html#FDREF" target="_blank" rel="noopener noreferrer">文件描述符</a>）与终端设备关联</p>
<p>该选项通常被用于 <a href="http://tldp.org/LDP/abs/html/intandnonint.html#II2TEST" target="_blank" rel="noopener noreferrer">测试</a> 脚本中的 <code>stdin [ -t 0 ]</code> 或 <code>stdout [ -t 1 ]</code> 是否为终端设备。</p>
<h3 id="r"> -r</h3>
<p>该文件对执行测试的用户可读</p>
<h3 id="w"> -w</h3>
<p>该文件对执行测试的用户可写</p>
<h3 id="x"> -x</h3>
<p>该文件可被执行测试的用户所执行</p>
<h3 id="g"> -g</h3>
<p>文件或目录设置了 set-group-id <code>sgid</code> 标志</p>
<p>如果一个目录设置了 <code>sgid</code> 标志，那么在该目录中所有的新建文件的权限组都归属于该目录的权限组，而非文件创建者的权限组。该标志对共享文件夹很有用。</p>
<h3 id="u"> -u</h3>
<p>文件设置了 set-user-id <code>suid</code> 标志。</p>
<p>一个属于 root 的可执行文件设置了 <code>suid</code> 标志后，即使是一个普通用户执行也拥有 root 权限<sup></sup>。对需要访问硬件设备的可执行文件（例如 <code>pppd</code> 和 <code>cdrecord</code>）很有用。如果没有 <code>suid</code> 标志，这些可执行文件就不能被非 root 用户所调用了。</p>
<div><pre><code>-rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd
</code></pre>
<div><span>1</span><br></div></div><p>设置了 <code>suid</code> 标志后，在权限中会显示 <code>s</code>。</p>
<h3 id="k"> -k</h3>
<p>设置了粘滞位(sticky bit)。</p>
<p>标志粘滞位是一种特殊的文件权限。如果文件设置了粘滞位，那么该文件将会被存储在高速缓存中以便快速访问<sup></sup>。如果目录设置了该标记，那么它将会对目录的写权限进行限制，目录中只有文件的拥有者可以修改或删除文件。设置标记后你可以在权限中看到 <code>t</code>。</p>
<div><pre><code>drwxrwxrwt    7 root         1024 May 19 21:26 tmp/
</code></pre>
<div><span>1</span><br></div></div><p>如果一个用户不是设置了粘滞位目录的拥有者，但对该目录有写权限，那么他仅仅可以删除目录中他所拥有的文件。这可以防止用户不经意间删除或修改其他人的文件，例如 <code>/tmp</code> 文件夹。（当然目录的所有者可以删除或修改该目录下的所有文件）</p>
<h3 id="o"> -O</h3>
<p>执行用户是文件的拥有者</p>
<h3 id="g-2"> -G</h3>
<p>文件的组与执行用户的组相同</p>
<h3 id="n"> -N</h3>
<p>文件在在上次访问后被修改过了</p>
<h3 id="f1-nt-f2"> f1 -nt f2</h3>
<p>文件 f1 比文件 f2 新</p>
<h3 id="f1-ot-f2"> f1 -ot f2</h3>
<p>文件 f1 比文件 f2 旧</p>
<h3 id="f1-ef-f2"> f1 -ef f2</h3>
<p>文件 f1 和文件 f2 硬链接到同一个文件</p>
<h3 id=""> !</h3>
<p>取反——对测试结果取反(如果条件缺失则返回真)。</p>
<p>样例 7-4. 检测链接是否损坏</p>
<div><pre><code><span>#!/bin/bash</span>
<span># broken-link.sh</span>
<span># Lee bigelow &lt;ligelowbee@yahoo.com> 编写。</span>
<span># ABS Guide 经许可可以使用。</span>

<span>#  该脚本用来发现输出损坏的链接。输出的结果是被引用的，</span>
<span>#+ 所以可以直接导到 xargs 中进行处理 ：）</span>
<span>#  例如：sh broken-link.sh /somedir /someotherdir|xargs rm</span>
<span>#</span>
<span>#  更加优雅的方式：</span>
<span>#</span>
<span>#  find "somedir" -type 1 -print0|\</span>
<span>#  xargs -r0 file|\</span>
<span>#  grep "broken symbolic"|</span>
<span>#  sed -e 's/^\|: *broken symbolic.*$/"/g'</span>
<span>#</span>
<span>#  但是这种方法不是纯 Bash 写法。</span>
<span>#  警告：小心 /proc 文件下的文件和任意循环链接！</span>
<span>############################################</span>


<span>#  如果不给脚本传任何参数，那么 directories-to-search 设置为当前目录</span>
<span>#+ 否则设置为传进的参数</span>
<span>#####################</span>

<span>[</span> <span>$#</span> -eq <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>directory</span><span>=</span><span><span>`</span><span>pwd</span><span>`</span></span> <span>||</span> <span>directory</span><span>=</span><span>$@</span>


<span>#  函数 linkchk 是用来检测传入的文件夹中是否包含损坏的链接文件，</span>
<span>#+ 并引用输出他们。</span>
<span>#  如果文件夹中包含子文件夹，那么将子文件夹继续传给 linkchk 函数进行检测。</span>
<span>#################</span>

<span>linkchk</span> <span>(</span><span>)</span> <span>{</span>
    <span>for</span> <span>element</span> <span>in</span> <span>$1</span>/*<span>;</span> <span>do</span>
      <span>[</span> -h <span>"<span>$element</span>"</span> -a <span>!</span> -e <span>"<span>$element</span>"</span> <span>]</span> <span>&amp;&amp;</span> <span>echo</span> <span>\</span>"<span>$element</span><span>\</span>"
      <span>[</span> -d <span>"<span>$element</span>"</span> <span>]</span> <span>&amp;&amp;</span> linkchk <span>$element</span>
    <span># -h 用来检测是否是链接，-d 用来检测是否是文件夹。</span>
    <span>done</span>
<span>}</span>

<span>#  检测传递给 linkchk() 函数的参数是否是一个存在的文件夹，</span>
<span>#+ 如果不是则报错。</span>
<span>################</span>
<span>for</span> <span>directory</span> <span>in</span> <span>$direcotrys</span><span>;</span> <span>do</span>
    <span>if</span> <span>[</span> -d <span>$directory</span> <span>]</span>
        <span>then</span> linkchk <span>$directory</span>
        <span>else</span>
            <span>echo</span> <span>"<span>$directory</span> is not a directory"</span>
            <span>echo</span> <span>"Usage <span>$0</span> dir1 dir2 ..."</span>
    <span>fi</span>
<span>done</span>

<span>exit</span> <span>$?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><p><a href="http://tldp.org/LDP/abs/html/zeros.html#COOKIES" target="_blank" rel="noopener noreferrer">样例 31-1</a>，<a href="http://tldp.org/LDP/abs/html/loops1.html#BINGREP" target="_blank" rel="noopener noreferrer">样例 11-8</a>，<a href="http://tldp.org/LDP/abs/html/loops1.html#FILEINFO" target="_blank" rel="noopener noreferrer">样例 11-3</a>，<a href="http://tldp.org/LDP/abs/html/zeros.html#RAMDISK" target="_blank" rel="noopener noreferrer">样例 31-3</a>和<a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#MAILFORMAT" target="_blank" rel="noopener noreferrer">样例 A-1</a> 也包含了测试运算符的使用。</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>摘自1913年版本的韦氏词典<br><pre>Deprecate<br>...<br><br>To pray against, as an evil;<br>to seek to avert by prayer;<br>to desire the removal of;<br>to seek deliverance from;<br>to express deep regret for;<br>to disapprove of strongly.</pre> </p>
</li>
<li id="footnote2"><p>注意使用 suid 的可执行文件可能会带来安全问题。suid 标记对 shell 脚本没有影响。 </p>
</li>
<li id="footnote3"><p>在 Linux 系统中，文件已经不使用粘滞位了, 粘滞位只作用于目录。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">7.3 其他比较操作</title>
    <id>https://clay-wangzhi.com/code/shell/part2/07_3_other_comparison_operators/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/07_3_other_comparison_operators/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_7-3-其他比较操作"> 7.3 其他比较操作</h1>
<p>二元比较操作比较变量或者数量。注意整数和字符串比较使用的是两套运算符。</p>
<h2 id="整数比较"> 整数比较</h2>
<h3 id="eq"> -eq</h3>
<p>等于</p>
<p><code>if [ &quot;$a&quot; -eq &quot;$b&quot; ]</code></p>
<h3 id="ne"> -ne</h3>
<p>不等于</p>
<p><code>if [ &quot;$a&quot; -ne &quot;$b&quot; ]</code></p>
<h3 id="gt"> -gt</h3>
<p>大于</p>
<p><code>if [ &quot;$a&quot; -gt &quot;$b&quot; ]</code></p>
<h3 id="ge"> -ge</h3>
<p>大于等于</p>
<p><code>if [ &quot;$a&quot; -ge &quot;$b&quot; ]</code></p>
<h3 id="lt"> -lt</h3>
<p>小于</p>
<p><code>if [ &quot;$a&quot; -lt &quot;$b&quot; ]</code></p>
<h3 id="le"> -le</h3>
<p>小于等于</p>
<p><code>if [ &quot;$a&quot; -le &quot;$b&quot; ]</code></p>
<h3 id=""> &lt;</h3>
<p>小于（使用 <a href="http://tldp.org/LDP/abs/html/dblparens.html" target="_blank" rel="noopener noreferrer">双圆括号</a>）</p>
<p><code>((&quot;$a&quot; &lt; &quot;$b&quot;))</code></p>
<h3 id="-2"> &lt;=</h3>
<p>小于等于（使用双圆括号）</p>
<p><code>((&quot;$a&quot; &lt;= &quot;$b&quot;))</code></p>
<h3 id="-3"> &gt;</h3>
<p>大于（使用双圆括号）</p>
<p><code>((&quot;$a&quot; &gt; &quot;$b&quot;))</code></p>
<h3 id="-4"> &gt;=</h3>
<p>大于等于（使用双圆括号）</p>
<p><code>((&quot;$a&quot; &gt;= &quot;$b&quot;))</code></p>
<h2 id="字符串比较"> 字符串比较</h2>
<h3 id="-5"> =</h3>
<p>等于</p>
<p><code>if [ &quot;$a&quot; = &quot;$b&quot; ]</code></p>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="caution" /> 注意在<code>=</code>前后要加上<a href="http://tldp.org/LDP/abs/images/caution.gif" target="_blank" rel="noopener noreferrer">空格</a></p>
<p><code>if [ &quot;$a&quot;=&quot;$b&quot; ]</code> 和上面不等价。</p>
<h3 id="-6"> ==</h3>
<p>等于</p>
<p><code>if [ &quot;$a&quot; == &quot;$b&quot; ]</code></p>
<p>和 <code>=</code> 同义</p>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> <code>==</code> 运算符在 <a href="http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS" target="_blank" rel="noopener noreferrer">双方括号</a> 和单方括号里表现不同。</p>
<div><pre><code><span>[</span><span>[</span> <span>$a</span> <span>==</span> z* <span>]</span><span>]</span>   <span># $a 以 "z" 开头时为真（模式匹配）</span>
<span>[</span><span>[</span> <span>$a</span> <span>==</span> <span>"z*"</span> <span>]</span><span>]</span> <span># $a 等于 z* 时为真（字符匹配）</span>

<span>[</span> <span>$a</span> <span>==</span> z* <span>]</span>     <span># 发生文件匹配和字符分割。</span>
<span>[</span> <span>"<span>$a</span>"</span> <span>==</span> <span>"z*"</span> <span>]</span> <span># $a 等于 z* 时为真（字符匹配）</span>

<span># 感谢 Stéphane Chazelas</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="-7"> !=</h3>
<p>不等于</p>
<p><code>if [ &quot;$a&quot; != &quot;$b&quot; ]</code></p>
<p>在 <a href="http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS" target="_blank" rel="noopener noreferrer"><code>[[ ... ]]</code></a> 结构中会进行模式匹配。</p>
<h3 id="-8"> &lt;</h3>
<p>小于，按照 <a href="http://tldp.org/LDP/abs/html/special-chars.html#ASCIIDEF" target="_blank" rel="noopener noreferrer">ASCII码</a> 排序。</p>
<p><code>if [[ &quot;$a&quot; &lt; &quot;$b&quot; ]]</code></p>
<p><code>if [ &quot;$a&quot; \&lt; &quot;$b&quot; ]</code></p>
<p>注意在 <code>[]</code> 结构里 <code>&lt;</code> 需要被 <a href="http://tldp.org/LDP/abs/html/escapingsection.html#ESCP" target="_blank" rel="noopener noreferrer">转义</a>。</p>
<h3 id="-9"> &gt;</h3>
<p>大于，按照 ASCII 码排序。</p>
<p><code>if [[ &quot;$a&quot; &gt; &quot;$b&quot; ]]</code></p>
<p><code>if [ &quot;$a&quot; \&gt; &quot;$b&quot; ]</code></p>
<p>注意在 <code>[]</code> 结构里 <code>&gt;</code> 需要被转义。</p>
<p><a href="http://tldp.org/LDP/abs/html/arrays.html#BUBBLE" target="_blank" rel="noopener noreferrer">样例 27-11</a> 包含了比较运算符。</p>
<h3 id="z"> -z</h3>
<p>字符串为空，即字符串长度为0。</p>
<div><pre><code><span>String</span><span>=</span><span>''</span>   <span># 长度为0的字符串变量。</span>

<span>if</span> <span>[</span> -z <span>"<span>$String</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"\<span>$String</span> is null."</span>
<span>else</span>
  <span>echo</span> <span>"\<span>$String</span> is NOT null."</span>
<span>fi</span>     <span># $String is null.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="n"> -n</h3>
<p>字符串非空（<code>null</code>）。</p>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="caution" /> 使用 <code>-n</code> 时字符串必须是在括号中且被引用的。使用 <code>! -z</code> 判断未引用的字符串或者直接判断（<a href="http://tldp.org/LDP/abs/html/comparison-ops.html#STRTEST" target="_blank" rel="noopener noreferrer">样例 7-6</a>）通常可行，但是非常危险。判断字符串时一定要引用<sup></sup>。</p>
<p>样例 7-5. 算术比较和字符串比较</p>
<div><pre><code><span>#!/bin/bash</span>

<span>a</span><span>=</span><span>4</span>
<span>b</span><span>=</span><span>5</span>

<span># 这里的 "a" 和 "b" 可以是整数也可以是字符串。</span>
<span># 因为 Bash 的变量是弱类型的，因此字符串和整数比较有很多相同之处。</span>

<span># 在 Bash 中可以用处理整数的方式来处理全是数字的字符串。</span>
<span># 但是谨慎使用。</span>

<span>echo</span>

<span>if</span> <span>[</span> <span>"<span>$a</span>"</span> -ne <span>"<span>$b</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"<span>$a</span> is not equal to <span>$b</span>"</span>
  <span>echo</span> <span>"(arithmetic comparison)"</span>
<span>fi</span>

<span>echo</span>

<span>if</span> <span>[</span> <span>"<span>$a</span>"</span> <span>!=</span> <span>"<span>$b</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"<span>$a</span> is not equal to <span>$b</span>."</span>
  <span>echo</span> <span>"(string comparison)"</span>
  <span>#     "4"  != "5"</span>
  <span># ASCII 52 != ASCIII 53</span>
<span>fi</span>

<span># 在这个例子里 "-ne" 和 "!=" 都可以。</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>样例 7-6. 测试字符串是否为空（<code>null</code>）</p>
<div><pre><code><span>#!/bin/bash</span>
<span># str-test.sh: 测试是否为空字符串或是未引用的字符串。</span>

<span># 使用 if [ ... ] 结构</span>

<span># 如果字符串未被初始化，则其值是未定义的。</span>
<span># 这种状态就是空 "null"（并不是 0）。</span>

<span>if</span> <span>[</span> -n <span>$string1</span> <span>]</span>    <span># 并未声明或是初始化 string1。</span>
<span>then</span>
  <span>echo</span> <span>"String <span title="\&quot;">\"</span>string1<span title="\&quot;">\"</span> is not null."</span>
<span>else</span>
  <span>echo</span> <span>"String <span title="\&quot;">\"</span>string1<span title="\&quot;">\"</span> is null."</span>
<span>fi</span>
<span># 尽管没有初始化 string1，但是结果显示其非空。</span>

<span>echo</span>

<span># 再试一次。</span>

<span>if</span> <span>[</span> -n <span>"<span>$string1</span>"</span> <span>]</span>   <span># 这次引用了 $string1。</span>
<span>then</span>
  <span>echo</span> <span>"String <span title="\&quot;">\"</span>string1<span title="\&quot;">\"</span> is not null."</span>
<span>else</span>
  <span>echo</span> <span>"String <span title="\&quot;">\"</span>string1<span title="\&quot;">\"</span> is null."</span>
<span>fi</span>                    <span># 在测试括号内引用字符串得到了正确的结果。</span>

<span>echo</span>

<span>if</span> <span>[</span> <span>$string1</span> <span>]</span>       <span># 这次只有一个 $string1。</span>
<span>then</span>
  <span>echo</span> <span>"String <span title="\&quot;">\"</span>string1<span title="\&quot;">\"</span> is not null."</span>
<span>else</span>
  <span>echo</span> <span>"String <span title="\&quot;">\"</span>string1<span title="\&quot;">\"</span> is null."</span>
<span>fi</span>                    <span># 结果正确。</span>
<span># 独立的 [ ... ] 测试运算符可以用来检测字符串是否为空。</span>
<span># 但是最好将字符串进行引用（if [ "$string1" ]）。</span>
<span>#</span>
<span># Stephane Chazelas 指出：</span>
<span>#    if [ $string1 ]    只有一个参数 "]"</span>
<span>#    if [ "$string1" ]  则有两个参数，空的 "$string1" 和 "]"</span>


<span>echo</span>


<span>string1</span><span>=</span>initialized

<span>if</span> <span>[</span> <span>$string1</span> <span>]</span>       <span># $string1 这次仍然没有被引用。</span>
<span>then</span>
  <span>echo</span> <span>"String <span title="\&quot;">\"</span>string1<span title="\&quot;">\"</span> is not null."</span>
<span>else</span>
  <span>echo</span> <span>"String <span title="\&quot;">\"</span>string1<span title="\&quot;">\"</span> is null."</span>
<span>fi</span>                    <span># 这次的结果仍然是正确的。</span>
<span># 最好将字符串引用（"$string1"）</span>


<span>string1</span><span>=</span><span>"a = b"</span>

<span>if</span> <span>[</span> <span>$string1</span> <span>]</span>       <span># $string1 这次仍然没有被引用。</span>
<span>then</span>
  <span>echo</span> <span>"String <span title="\&quot;">\"</span>string1<span title="\&quot;">\"</span> is not null."</span>
<span>else</span>
  <span>echo</span> <span>"String <span title="\&quot;">\"</span>string1<span title="\&quot;">\"</span> is null."</span>
<span>fi</span>                    <span># 这次没有引用就错了。</span>

<span>exit</span> <span>0</span>   <span># 同时感谢 Florian Wisser 的提示。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><p>样例 7-7. <code>zmore</code></p>
<div><pre><code><span>#!/bin/bash</span>
<span># zmore</span>

<span># 使用筛选器 'more' 查看 gzipped 文件。</span>

<span>E_NOARGS</span><span>=</span><span>85</span>
<span>E_NOTFOUND</span><span>=</span><span>86</span>
<span>E_NOTGZIP</span><span>=</span><span>87</span>

<span>if</span> <span>[</span> <span>$#</span> -eq <span>0</span> <span>]</span> <span># 作用和 if [ -z "$1" ] 相同。</span>
<span># $1 可以为空： zmore "" arg2 arg3</span>
<span>then</span>
  <span>echo</span> <span>"Usage: <span><span>`</span><span>basename</span> $0<span>`</span></span> filename"</span> <span>></span><span>&amp;2</span>
  <span># 将错误信息通过标准错误 stderr 进行输出。</span>
  <span>exit</span> <span>$E_NOARGS</span>
  <span># 脚本的退出状态为 85.</span>
<span>fi</span>

<span>filename</span><span>=</span><span>$1</span>

<span>if</span> <span>[</span> <span>!</span> -f <span>"<span>$filename</span>"</span> <span>]</span>   <span># 引用字符串以防字符串中带有空格。</span>
<span>then</span>
  <span>echo</span> <span>"File <span>$filename</span> not found!"</span> <span>></span><span>&amp;2</span>   <span># 通过标准错误 stderr 进行输出。</span>
  <span>exit</span> <span>$E_NOTFOUND</span>
<span>fi</span>

<span>if</span> <span>[</span> <span>${filename<span>##</span>*.}</span> <span>!=</span> <span>"gz"</span> <span>]</span>
<span># 在括号内使用变量代换。</span>
<span>then</span>
  <span>echo</span> <span>"File <span>$1</span> is not a gzipped file!"</span>
  <span>exit</span> <span>$E_NOTGZIP</span>
<span>fi</span>

zcat <span>$1</span> <span>|</span> <span>more</span>

<span># 使用筛选器 'more'</span>
<span># 也可以用 'less' 替代</span>

<span>exit</span> <span>$?</span>   <span># 脚本的退出状态由管道 pipe 的退出状态决定。</span>
<span>#  实际上 "exit $?" 不一定要写出来，</span>
<span>#+ 因为无论如何脚本都会返回最后执行命令的退出状态。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="复合比较"> 复合比较</h2>
<h3 id="a"> -a</h3>
<p>逻辑与</p>
<p><code>exp1 -a exp2</code> 返回真当且仅当 <code>exp1</code> 和 <code>exp2</code> 均为真。</p>
<h3 id="o"> -o</h3>
<p>逻辑或</p>
<p>如果 <code>exp1</code> 或 <code>exp2</code> 为真，则 <code>exp1 -o exp2</code> 返回真。</p>
<p>以上两个操作和 <a href="http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS" target="_blank" rel="noopener noreferrer">双方括号</a> 结构中的 Bash 比较运算符号 <code>&amp;&amp;</code> 和 <code>||</code> 类似。</p>
<div><pre><code><span>[</span><span>[</span> condition1 <span>&amp;&amp;</span> condition2 <span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>测试操作 <code>-o</code> 和 <code>-a</code> 可以在 <a href="http://tldp.org/LDP/abs/html/testconstructs.html#TTESTREF" target="_blank" rel="noopener noreferrer"><code>test</code></a> 命令或在测试括号中进行。</p>
<div><pre><code><span>if</span> <span>[</span> <span>"<span>$expr1</span>"</span> -a <span>"<span>$expr2</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"Both expr1 and expr2 are true."</span>
<span>else</span>
  <span>echo</span> <span>"Either expr1 or expr2 is false."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="caution" /> rihad 指出：</p>
<div><pre><code><span>[</span> <span>1</span> -eq <span>1</span> <span>]</span> <span>&amp;&amp;</span> <span>[</span> -n <span>"<span><span>`</span><span>echo</span> <span>true</span> <span><span>1</span>></span><span>&amp;2</span><span>`</span></span>"</span> <span>]</span>   <span># 真</span>
<span>[</span> <span>1</span> -eq <span>2</span> <span>]</span> <span>&amp;&amp;</span> <span>[</span> -n <span>"<span><span>`</span><span>echo</span> <span>true</span> <span><span>1</span>></span><span>&amp;2</span><span>`</span></span>"</span> <span>]</span>   <span># 没有输出</span>
<span># ^^^^^^^ 条件为假。到这里为止，一切都按预期执行。</span>

<span># 但是</span>
<span>[</span> <span>1</span> -eq <span>2</span> -a -n <span>"<span><span>`</span><span>echo</span> <span>true</span> <span><span>1</span>></span><span>&amp;2</span><span>`</span></span>"</span> <span>]</span>       <span># 真</span>
<span># ^^^^^^^ 条件为假。但是为什么结果为真？</span>

<span># 是因为括号内的两个条件子句都执行了么？</span>
<span>[</span><span>[</span> <span>1</span> -eq <span>2</span> <span>&amp;&amp;</span> -n <span>"<span><span>`</span><span>echo</span> <span>true</span> <span><span>1</span>></span><span>&amp;2</span><span>`</span></span>"</span> <span>]</span><span>]</span>     <span># 没有输出</span>
<span># 并不是。</span>

<span>#  所以显然 &amp;&amp; 和 || 具备“短路”机制，</span>
<span>#+ 例如对于 &amp;&amp;，若第一个表达式为假，则不执行第二个表达式直接返回假，</span>
<span>#+ 而 -a 和 -o 则不是。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>复合比较操作的例子可以参考 <a href="http://tldp.org/LDP/abs/html/ops.html#ANDOR" target="_blank" rel="noopener noreferrer">样例 8-3</a>，<a href="http://tldp.org/LDP/abs/html/arrays.html#TWODIM" target="_blank" rel="noopener noreferrer">样例 27-17</a> 和 <a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#WHX" target="_blank" rel="noopener noreferrer">样例 A-29</a>。</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>S.C. 指出在复合测试中，仅仅引用字符串可能还不够。比如表达式 <code>[ -n &quot;$string&quot; -o &quot;$a&quot; = &quot;$b&quot; ]</code> 在某些 Bash 版本下，如果 <code>$string</code> 为空可能会出错。更加安全的方式是，对于可能为空的字符串，添加一个额外的字符，例如 <code>[ &quot;x$string&quot; != x -o &quot;x$a&quot; = &quot;x$b&quot; ]</code>（其中的 x 互相抵消）。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">7.4 嵌套 if/then 条件测试</title>
    <id>https://clay-wangzhi.com/code/shell/part2/07_4_nested_if_then_condition_tests/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/07_4_nested_if_then_condition_tests/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_7-4-嵌套-if-then-条件测试"> 7.4 嵌套 if/then 条件测试</h1>
<p>可以嵌套 <code>if/then</code> 条件测试结构。嵌套的结果等价于使用 <a href="http://tldp.org/LDP/abs/html/ops.html#LOGOPS1" target="_blank" rel="noopener noreferrer"><code>&amp;&amp;</code></a> 复合比较运算符。</p>
<div><pre><code><span>a</span><span>=</span><span>3</span>

<span>if</span> <span>[</span> <span>"<span>$a</span>"</span> -gt <span>0</span> <span>]</span>
<span>then</span>
  <span>if</span> <span>[</span> <span>"<span>$a</span>"</span> -lt <span>5</span> <span>]</span>
  <span>then</span>
    <span>echo</span> <span>"The value of <span title="\&quot;">\"</span>a<span title="\&quot;">\"</span> lies somewhere between 0 and 5."</span>
  <span>fi</span>
<span>fi</span>

<span># 和下面的结果相同</span>

<span>if</span> <span>[</span> <span>"<span>$a</span>"</span> -gt <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>[</span> <span>"<span>$a</span>"</span> -lt <span>5</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"The value of <span title="\&quot;">\"</span>a<span title="\&quot;">\"</span> lies somewhere between 0 and 5."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>在 <a href="http://tldp.org/LDP/abs/html/bashver2.html#CARDS" target="_blank" rel="noopener noreferrer">样例 37-4</a> 和 <a href="http://tldp.org/LDP/abs/html/system.html#BACKLIGHT" target="_blank" rel="noopener noreferrer">样例 17-11</a> 中展示了嵌套 <code>if/then</code> 条件测试结构。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">7.5 牛刀小试</title>
    <id>https://clay-wangzhi.com/code/shell/part2/07_5_testing_your_knowledge_of_tests/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/07_5_testing_your_knowledge_of_tests/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_7-5-牛刀小试"> 7.5 牛刀小试</h1>
<p>系统文件 <code>xinitrc</code> 可以用来启动软件 X Server。该文件包含了许多 <code>if/then</code> 测试结构。下面的代码摘录自较早版本的 <code>xinitrc</code>（大约在 Red Hat 7.1 版本）。</p>
<div><pre><code><span>if</span> <span>[</span> -f <span>$HOME</span>/.Xclients <span>]</span><span>;</span> <span>then</span>
  <span>exec</span> <span>$HOME</span>/.Xclients
<span>elif</span> <span>[</span> -f /etc/X11/xinit/Xclients <span>]</span><span>;</span> <span>then</span>
  <span>exec</span> /etc/X11/xinit/Xclients
<span>else</span>
    <span># 安全分支。尽管程序不会执行这个分支。</span>
    <span># （我们在 Xclients 中也提供了相同的机制）增强程序可靠性。</span>
    xclock -geometry 100x100-5+5 <span>&amp;</span>
    xterm -geometry 80x50-50+150 <span>&amp;</span>
    <span>if</span> <span>[</span> -f /usr/bin/netscape -a -f /usr/share/doc/HTML/index.html <span>]</span><span>;</span> <span>then</span>
            netscape /usr/share/doc/HTML/index.html
    <span>fi</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>试着解释代码片段中的条件测试结构, 然后试着在 /etc/X11/xinit/xinitrc 查看最新版本，并且分析其中的 if/then 条件测试结构。为了更好的进行分析，你可能需要继续阅读后面章节中对 <a href="http://tldp.org/LDP/abs/html/textproc.html#GREPREF" target="_blank" rel="noopener noreferrer"><code>grep</code></a>，<a href="http://tldp.org/LDP/abs/html/sedawk.html#SEDREF" target="_blank" rel="noopener noreferrer"><code>sed</code></a> 和 <a href="http://tldp.org/LDP/abs/html/regexp.html#REGEXREF" target="_blank" rel="noopener noreferrer">正则表达式</a> 的讨论。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第七章 测试</title>
    <id>https://clay-wangzhi.com/code/shell/part2/07_tests/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/07_tests/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第七章-测试"> 第七章 测试</h1>
<h3 id="本章目录"> 本章目录</h3>
<ul>
<li><a href="./07_1_test_constructs.html">7.1 测试结构</a></li>
<li><a href="./07_2_file_test_operators.html">7.2 文件测试操作</a></li>
<li><a href="./07_3_other_comparison_operators.html">7.3 其他比较操作</a></li>
<li><a href="./07_4_nested_if_then_condition_tests.html">7.4 嵌套 if/then 条件测试</a></li>
<li><a href="./07_5_testing_your_knowledge_of_tests.html">7.5 牛刀小试</a></li>
</ul>
<p>每一个完备的程序设计语言都可以对一个条件进行判断，然后根据判断结果执行相应的指令。Bash 拥有 <a href="http://tldp.org/LDP/abs/html/testconstructs.html#TTESTREF" target="_blank" rel="noopener noreferrer"><code>test</code></a> 命令，<a href="http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS" target="_blank" rel="noopener noreferrer">双方括号</a>、<a href="http://tldp.org/LDP/abs/html/testconstructs.html#DBLPARENSTST" target="_blank" rel="noopener noreferrer">双圆括号</a> 测试操作符以及 <code>if/then</code> 测试结构。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">8.1. 运算符</title>
    <id>https://clay-wangzhi.com/code/shell/part2/08_1_operators/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/08_1_operators/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_8-1-运算符"> 8.1. 运算符</h1>
<h2 id="赋值运算符"> 赋值运算符</h2>
<p><em>变量赋值</em>，初始化或改变一个变量的值。</p>
<h3 id=""> =</h3>
<p>等号<code>=</code>赋值运算符，既可用于算术赋值，也可用于字符串赋值。</p>
<div><pre><code>var=27
category=minerals  # &quot;=&quot;左右不允许有空格
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="caution" /> 注意，不要混淆<code>=</code>赋值运算符与<code>=</code><a href="http://tldp.org/LDP/abs/html/comparison-ops.html#EQUALSIGNREF" target="_blank" rel="noopener noreferrer">测试操作符</a>。</p>
</blockquote>
<div><pre><code>#   =   作为测试操作符

if [ &quot;$string1&quot; = &quot;$string2&quot; ]
then
   command
fi

#  [ &quot;X$string1&quot; = &quot;X$string2&quot; ] 这样写是安全的,
#  这样写可以避免任意一个变量为空时的报错。
#  (变量前加的&quot;X&quot;字符规避了变量为空的情况)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="算术运算符"> 算术运算符</h2>
<h3 id="-2"> +</h3>
<p>加</p>
<h3 id="-3"> -</h3>
<p>减</p>
<h3 id="-4"> *</h3>
<p>乘</p>
<h3 id="-5"> /</h3>
<p>除</p>
<h3 id="-6"> **</h3>
<p>幂运算</p>
<div><pre><code># Bash, 2.02版本，推出了&quot;**&quot;幂运算操作符。

let &quot;z=5**3&quot;    # 5 * 5 * 5
echo &quot;z = $z&quot;   # z = 125
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="-7"> %</h3>
<p>取余(返回整数除法的余数)</p>
<div><pre><code>bash$ expr 5 % 3
2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>5/3=1，余2
取余运算符经常被用于生成一定范围内的数( 案例9-11, 案例9-15)，以及格式化程序输出(案例 27-16，案例 A-6)。
取余运算符还可以用来产生素数（案例A-15），取余的出现大大扩展了整数的算术运算。</p>
<p><strong>样例 8-1. 最大公约数</strong></p>
<div><pre><code>#!/bin/bash
# gcd.sh: 最大公约数
#         使用欧几里得算法

#  两个整数的最大公约数（gcd）
#  是两数能同时整除的最大数

#  欧几里得算法使用辗转相除法
#    In each pass,
#       dividend &lt;---  divisor
#       divisor  &lt;---  remainder
#    until remainder = 0.
#    The gcd = dividend, on the final pass.
#
#  关于欧几里得算法更详细的讨论，可以查看:
#  Jim Loy&#39;s site, http://www.jimloy.com/number/euclids.htm.


# ------------------------------------------------------
# 参数检查
ARGS=2
E_BADARGS=85

if [ $# -ne &quot;$ARGS&quot; ]
then
  echo &quot;Usage: `basename $0` first-number second-number&quot;
  exit $E_BADARGS
fi
# ------------------------------------------------------


gcd ()
{

  dividend=$1             #  随意赋值，
  divisor=$2              #  两数谁大谁小是无关紧要的，
                          #  为什么?

  remainder=1             #  如果在测试括号里使用了一个未初始化的变量，
                          #  会报错的。

  until [ &quot;$remainder&quot; -eq 0 ]
  do    #  ^^^^^^^^^^  该变量必须在使用前初始化！
    let &quot;remainder = $dividend % $divisor&quot;
    dividend=$divisor     # 对被除数，除数重新赋值
    divisor=$remainder
  done                    # 欧几里得算法

}                         # 最后的 $dividend 就是最大公约数（gcd）


gcd $1 $2

echo; echo &quot;GCD of $1 and $2 = $dividend&quot;; echo


# 练习 :
# ---------
# 1) 检查命令行参数，保证其为整数，
#+   如果有错误，捕捉错误并在脚本退出前打印出适当的错误信息。
# 2) 使用本地变量(local variables)重写gcd()函数。

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><h3 id="-8"> +=</h3>
<p>加等 （加上一个数）<sup></sup>
<code>let &quot;var += 5&quot;</code> 的结果是<code>var</code>变量的值增加了5。</p>
<h3 id="-9"> -=</h3>
<p>减等 （减去一个数）</p>
<h3 id="-10"> *=</h3>
<p>乘等 （乘以一个数）
<code>let &quot;var *= 4&quot;</code> 的结果是<code>var</code>变量的值乘了4。</p>
<h3 id="-11"> /=</h3>
<p>除等 （除以一个数）</p>
<h3 id="-12"> %=</h3>
<p>余等 （取余赋值）</p>
<h3 id="小结"> 小结</h3>
<p>算术运算符常用于<code>expr</code>或<code>let</code>表达式中。</p>
<p><strong>样例 8-2. 使用算术运算符</strong></p>
<div><pre><code>#!/bin/bash
# 使变量自增1，10种不同的方法实现

n=1; echo -n &quot;$n &quot;

let &quot;n = $n + 1&quot;   # 可以使用 let &quot;n = n + 1&quot;
echo -n &quot;$n &quot;


: $((n = $n + 1))
#  &quot;:&quot; 是必要的，不加的话，bash会将
#+ &quot;$((n = $n + 1))&quot;看做一条命令。
echo -n &quot;$n &quot;

(( n = n + 1 ))
#  更简洁的写法。
#  感谢 David Lombard指出。
echo -n &quot;$n &quot;

n=$(($n + 1))
echo -n &quot;$n &quot;

: $[ n = $n + 1 ]
#  &quot;:&quot; 是必要的，不加的话，bash会将
#+ &quot;$[ n = $n + 1 ]&quot;看做一条命令。
#  即使&quot;n&quot;是字符串，也是可行的。
echo -n &quot;$n &quot;

n=$[ $n + 1 ]
#  即使&quot;n&quot;是字符串，也是可行的。
#* 不要用这种写法，它已被废弃且不具有兼容性。
#  感谢 Stephane Chazelas.
echo -n &quot;$n &quot;

# 使用C风格的自增运算符也是可以的
# 感谢 Frank Wang 指出。

let &quot;n++&quot;          # let &quot;++n&quot; 可行
echo -n &quot;$n &quot;

(( n++ ))          # (( ++n ))  可行
echo -n &quot;$n &quot;

: $(( n++ ))       # : $(( ++n )) 可行
echo -n &quot;$n &quot;

: $[ n++ ]         # : $[ ++n ] 可行
echo -n &quot;$n &quot;

echo

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p>在早期的Bash版本中，整型变量是带符号的长整型数（32-bit），取值范围从 -2147483648 到 2147483647。如果算术操作超出了整数的取值范围，结果会不准确。</p>
<div><pre><code>echo $BASH_VERSION   # Bash 1.14版本

a=2147483646
echo &quot;a = $a&quot;        # a = 2147483646
let &quot;a+=1&quot;           # 自增 &quot;a&quot;.
echo &quot;a = $a&quot;        # a = 2147483647
let &quot;a+=1&quot;           # 再次自增&quot;a&quot;，超出取值范围。
echo &quot;a = $a&quot;        # a = -2147483648
                     #      错误：超出范围，
                     #+     最左边的符号位被重置，
                     #+     结果变负
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>Bash版本 &gt;= 2.05b, Bash支持了64-bit整型数。</p>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="caution" /> 注意，Bash并不支持浮点运算，Bash会将带小数点的数看做字符串。</p>
</blockquote>
<div><pre><code>a=1.5

let &quot;b = $a + 1.3&quot;  # 报错
# t2.sh: let: b = 1.5 + 1.3: syntax error in expression
#                            (error token is &quot;.5 + 1.3&quot;)

echo &quot;b = $b&quot;       # b=1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果你想在脚本中使用浮点数运算，借助<a href="http://tldp.org/LDP/abs/html/mathc.html#BCREF" target="_blank" rel="noopener noreferrer">bc</a>或外部数学函数库吧。</p>
<h2 id="位运算"> 位运算</h2>
<p>位运算很少出现在shell脚本中，在bash中加入位运算的初衷似乎是为了操控和检测来自<code>ports</code>或<code>sockets</code>的数据。位运算在编译型语言中能发挥更大的作用，比如C/C++，位运算提供了直接访问系统硬件的能力。然而，聪明的vladz在他的base64.sh(案例 A-54)脚本中也用到了位运算。
下面介绍位运算符。</p>
<h3 id="-13"> &lt;&lt;</h3>
<p>左移运算符(左移1位相当于乘2)</p>
<h3 id="-14"> &lt;&lt;=</h3>
<p>左移赋值</p>
<p><code>let &quot;var &lt;&lt;= 2&quot;</code> 的结果是var变量的值向左移了2位(乘以4)</p>
<h3 id="-15"> &gt;&gt;</h3>
<p>右移运算符(右移1位相当于除2)</p>
<h3 id="-16"> &gt;&gt;=</h3>
<p>右移赋值</p>
<h3 id="-17"> &amp;</h3>
<p>按位与（AND）</p>
<h3 id="-18"> &amp;=</h3>
<p>按位与等（AND-equal）</p>
<h3 id="-19"> |</h3>
<p>按位或（OR）</p>
<h3 id="-20"> |=</h3>
<p>按位或等（OR-equal）</p>
<h3 id="-21"> ~</h3>
<p>按位取反</p>
<h3 id="-22"> ^</h3>
<p>按位异或（XOR）</p>
<h3 id="-23"> ^=</h3>
<p>按位异或等（XOR-equal）</p>
<h2 id="逻辑-布尔-运算符"> 逻辑(布尔)运算符</h2>
<h3 id="-24"> !</h3>
<p>非(NOT)</p>
<div><pre><code>if [ ! -f $FILENAME ]
then
  ...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="-25"> &amp;&amp;</h3>
<p>与(AND)</p>
<div><pre><code>if [ $condition1 ] &amp;&amp; [ $condition2 ]
#  等同于:  if [ $condition1 -a $condition2 ]
#  返回true如果 condition1 和 condition2 同时为真...

if [[ $condition1 &amp;&amp; $condition2 ]]    # 可行
#  注意，&amp;&amp; 运算符不能用在[ ... ]结构里。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> &amp;&amp;也可以被用在<code>list</code>结构中连接命令。</p>
</blockquote>
<h3 id="-26"> ||</h3>
<p>或(OR)</p>
<div><pre><code>if [ $condition1 ] || [ $condition2 ]

#  等同于:  if [ $condition1 -a $condition2 ]
#  返回true如果 condition1 和 condition2 任意一个为真...

if [[ $condition1 || $condition2 ]]    # 可行
#  注意，|| 运算符不能用在[ ... ]结构里。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="小结-2"> 小结</h3>
<p><strong>样例 8-3. 在条件测试中使用 &amp;&amp; 和 ||</strong></p>
<div><pre><code>#!/bin/bash

a=24
b=47

if [ &quot;$a&quot; -eq 24 ] &amp;&amp; [ &quot;$b&quot; -eq 47 ]
then
  echo &quot;Test #1 succeeds.&quot;
else
  echo &quot;Test #1 fails.&quot;
fi

#  错误:   if [ &quot;$a&quot; -eq 24 &amp;&amp; &quot;$b&quot; -eq 47 ]
#          这样写的话，bash会先执行&#39;[ &quot;$a&quot; -eq 24&#39;
#          然后就找不到右括号&#39;]&#39;了...
#
#  注意:  if [[ $a -eq 24 &amp;&amp; $b -eq 24 ]]  这样写是可以的
#  双方括号测试结构比单方括号更加灵活。
#  (双方括号中的&quot;&amp;&amp;&quot;与单方括号中的&quot;&amp;&amp;&quot;意义不同)
#  感谢 Stephane Chazelas 指出。


if [ &quot;$a&quot; -eq 98 ] || [ &quot;$b&quot; -eq 47 ]
then
  echo &quot;Test #2 succeeds.&quot;
else
  echo &quot;Test #2 fails.&quot;
fi


#  使用 -a 和 -o 选项也具有同样的效果。
#  感谢 Patrick Callahan 指出。


if [ &quot;$a&quot; -eq 24 -a &quot;$b&quot; -eq 47 ]
then
  echo &quot;Test #3 succeeds.&quot;
else
  echo &quot;Test #3 fails.&quot;
fi


if [ &quot;$a&quot; -eq 98 -o &quot;$b&quot; -eq 47 ]
then
  echo &quot;Test #4 succeeds.&quot;
else
  echo &quot;Test #4 fails.&quot;
fi


a=rhino
b=crocodile
if [ &quot;$a&quot; = rhino ] &amp;&amp; [ &quot;$b&quot; = crocodile ]
then
  echo &quot;Test #5 succeeds.&quot;
else
  echo &quot;Test #5 fails.&quot;
fi

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><p><code>&amp;&amp;</code>和<code>||</code>运算符也可以用在算术运算中。</p>
<div><pre><code>bash$ echo $(( 1 &amp;&amp; 2 )) $((3 &amp;&amp; 0)) $((4 || 0)) $((0 || 0))
1 0 1 0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="其他运算符"> 其他运算符</h2>
<h3 id="-27"> ,</h3>
<p>逗号运算符
逗号运算符用于连接两个或多个算术操作，所有的操作会被依次求值（可能会有副作用）。<sup></sup></p>
<div><pre><code>let &quot;t1 = ((5 + 3, 7 - 1, 15 - 4))&quot;
echo &quot;t1 = $t1&quot;           ^^^^^^  # t1 = 11
# 这里的t1 被赋值了11，为什么？

let &quot;t2 = ((a = 9, 15 / 3))&quot;      # 对&quot;a&quot;赋值并对&quot;t2&quot;求值。
echo &quot;t2 = $t2    a = $a&quot;         # t2 = 5    a = 9
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>逗号运算符常被用在<code>for</code>循环中。参看案例 11-13。</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>取决与不同的上下文，+= 也可能作为字符串连接符。它可以很方便地修改环境变量。 </p>
</li>
<li id="footnote2"><p>副作用，顾名思义，就是预料之外的结果。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">8.2. 数字常量</title>
    <id>https://clay-wangzhi.com/code/shell/part2/08_2_numerical_constants/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/08_2_numerical_constants/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_8-2-数字常量"> 8.2. 数字常量</h1>
<p>通常情况下，shell脚本会把数字以十进制整数看待(base 10)，除非数字加了特殊的前缀或标记。
带前缀0的数字是八进制数(base 8)；带前缀0x的数字是十六进制数(base 16)。
内嵌 # 的数字会以 BASE#NUMBER 的方式进行求值（不能超出当前shell支持整数的范围）。</p>
<p><strong>样例 8-4. 数字常量的表示</strong></p>
<div><pre><code>#!/bin/bash
# numbers.sh: 不同进制数的表示

# 十进制数: 默认
let &quot;dec = 32&quot;
echo &quot;decimal number = $dec&quot;             # 32
# 一切正常。


# 八进制数: 带前导&#39;0&#39;的数
let &quot;oct = 032&quot;
echo &quot;octal number = $oct&quot;               # 26
# 结果以 十进制 打印输出了。
# ------ ------ -----------


# 十六进制数: 带前导&#39;0x&#39;或&#39;0X&#39;的数
let &quot;hex = 0x32&quot;
echo &quot;hexadecimal number = $hex&quot;         # 50

echo $((0x9abc))                         # 39612
#     ^^      ^^   双圆括号进行表达式求值
# 结果以十进制打印输出。



# 其他进制数: BASE#NUMBER
# BASE 范围:  2 - 64
# NUMBER 必须以 BASE 规定的正确形式书写，如下:

let &quot;bin = 2#111100111001101&quot;
echo &quot;binary number = $bin&quot;              # 31181

let &quot;b32 = 32#77&quot;
echo &quot;base-32 number = $b32&quot;             # 231

let &quot;b64 = 64#@_&quot;
echo &quot;base-64 number = $b64&quot;             # 4031

# 这种表示法只对进制范围(2 - 64)内的 ASCII 字符有效。
# 10 数字 + 26 小写字母 + 26 大写字母 + @ + _


echo

echo $((36#zz)) $((2#10101010)) $((16#AF16)) $((53#1aA))
                                         # 1295 170 44822 3375

#  重要提醒:
#  ---------
#  使用超出进制范围以外的符号会报错。

let &quot;bad_oct = 081&quot;

# (可能的) 报错信息:
#  bad_oct = 081: value too great for base (error token is &quot;081&quot;)
#              Octal numbers use only digits in the range 0 - 7.

exit $?        # 退出码 = 1 (错误)

# 感谢 Rich Bartell 和 Stephane Chazelas 的说明。

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">双圆括号结构</title>
    <id>https://clay-wangzhi.com/code/shell/part2/08_3_the_double_parentheses_construct/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/08_3_the_double_parentheses_construct/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="双圆括号结构"> 双圆括号结构</h1>
<p>与<code>let</code>命令类似，<code>(( ... ))</code> 结构允许对算术表达式的扩展和求值。它是<code>let</code>命令的简化形式。例如，a=$(( 5 + 3 )) 会将变量a赋值成 5 + 3，也就是8。在Bash中，双圆括号结构也允许以C风格的方式操作变量。例如，(( var++ ))。</p>
<p><strong>样例 8-5. 以C风格的方式操作变量</strong></p>
<div><pre><code>#!/bin/bash
# c-vars.sh
# 以C风格的方式操作变量，使用(( ... ))结构


echo

(( a = 23 ))  #  C风格的变量赋值，注意&quot;=&quot;等号前后都有空格

echo &quot;a (initial value) = $a&quot;   # 23

(( a++ ))     #  后缀自增&#39;a&#39;，C-style.
echo &quot;a (after a++) = $a&quot;       # 24

(( a-- ))     #  后缀自减&#39;a&#39;, C-style.
echo &quot;a (after a--) = $a&quot;       # 23


(( ++a ))     #  前缀自增&#39;a&#39;, C-style.
echo &quot;a (after ++a) = $a&quot;       # 24

(( --a ))     #  前缀自减&#39;a&#39;, C-style.
echo &quot;a (after --a) = $a&quot;       # 23

echo

########################################################
#  注意，C风格的++，--运算符，前缀形式与后缀形式有不同的
#+ 副作用。

n=1; let --n &amp;&amp; echo &quot;True&quot; || echo &quot;False&quot;  # False
n=1; let n-- &amp;&amp; echo &quot;True&quot; || echo &quot;False&quot;  # True

#  感谢 Jeroen Domburg。
########################################################

echo

(( t = a&lt;45?7:11 ))   # C风格三目运算符。
#       ^  ^ ^
echo &quot;If a &lt; 45, then t = 7, else t = 11.&quot;  # a = 23
echo &quot;t = $t &quot;                              # t = 7

echo


# -----------
# 复活节彩蛋!
# -----------
#  Chet Ramey 偷偷往Bash里加入了C风格的语句结构，
#  还没写文档说明 (实际上很多是从ksh中继承过来的)。
#  在Bash 文档中，Ramey把 (( ... ))结构称为shell 算术运算，
#  但是这种表述并不准确...
#  抱歉啊，Chet，把你的秘密抖出来了。

#  参看 &quot;for&quot; 和 &quot;while&quot; 循环章节关于 (( ... )) 结构的部分。

#  (( ... )) 结构在Bash 2.04版本之后才能正常工作。

exit

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><p>还可以参看 <strong>样例 11-13</strong> 与 <strong>样例 8-4</strong>。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">运算符优先级</title>
    <id>https://clay-wangzhi.com/code/shell/part2/08_4_operator_precedence/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/08_4_operator_precedence/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="运算符优先级"> 运算符优先级</h1>
<p>在脚本中，运算执行的顺序被称为<em>优先级</em>: 高优先级的操作会比低优先级的操作先执行。<sup></sup></p>
<p><strong>表 8-1. 运算符优先级(从高到低)</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">注解</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">var++ var--</td>
<td style="text-align:left">后缀自增/自减</td>
<td style="text-align:left">C风格运算符</td>
</tr>
<tr>
<td style="text-align:left">++var --var</td>
<td style="text-align:left">前缀自增/自减</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">! ~</td>
<td style="text-align:left">按位取反/逻辑取反</td>
<td style="text-align:left">对每一比特位取反/对逻辑判断的结果取反</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">**</td>
<td style="text-align:left">幂运算</td>
<td style="text-align:left">算数运算符</td>
</tr>
<tr>
<td style="text-align:left">* / %</td>
<td style="text-align:left">乘, 除, 取余</td>
<td style="text-align:left">算数运算符</td>
</tr>
<tr>
<td style="text-align:left">+ -</td>
<td style="text-align:left">加, 减</td>
<td style="text-align:left">算数运算符</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; &gt;&gt;</td>
<td style="text-align:left">左移, 右移</td>
<td style="text-align:left">比特位运算符</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">-z -n</td>
<td style="text-align:left">一元比较</td>
<td style="text-align:left">字符串是/否为空</td>
</tr>
<tr>
<td style="text-align:left">-e -f -t -x, etc</td>
<td style="text-align:left">一元比较</td>
<td style="text-align:left">文件测试</td>
</tr>
<tr>
<td style="text-align:left">-lt -gt -le -ge &lt;=  &gt;=</td>
<td style="text-align:left">复合比较</td>
<td style="text-align:left">字符串/整数比较</td>
</tr>
<tr>
<td style="text-align:left">-nt -ot -ef</td>
<td style="text-align:left">复合比较</td>
<td style="text-align:left">文件测试</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">AND(按位与)</td>
<td style="text-align:left">按位与操作</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">XOR(按位异或)</td>
<td style="text-align:left">按位异或操作</td>
</tr>
<tr>
<td style="text-align:left">|</td>
<td style="text-align:left">OR(按位或)</td>
<td style="text-align:left">按位或操作</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&amp;&amp; -a</td>
<td style="text-align:left">AND(逻辑与)</td>
<td style="text-align:left">逻辑与, 复合比较</td>
</tr>
<tr>
<td style="text-align:left">|| -o</td>
<td style="text-align:left">OR(逻辑或)</td>
<td style="text-align:left">逻辑或, 复合比较</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">? :</td>
<td style="text-align:left">if/else三目运算符</td>
<td style="text-align:left">C风格运算符</td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">赋值</td>
<td style="text-align:left">不要与test中的等号混淆</td>
</tr>
<tr>
<td style="text-align:left">*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;=</td>
<td style="text-align:left">赋值运算</td>
<td style="text-align:left">先运算后赋值</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">,</td>
<td style="text-align:left">逗号运算符</td>
<td style="text-align:left">连接一系列语句</td>
</tr>
</tbody>
</table>
<p>实际上，你只需要记住以下规则就可以了:</p>
<ul>
<li>先乘除取余，后加减，与算数运算相似</li>
<li>复合逻辑运算符，&amp;&amp;, ||, -a, -o 优先级较低</li>
<li>优先级相同的操作按<em>从左至右</em>顺序求值</li>
</ul>
<p>现在，让我们利用运算符优先级的知识来分析一下<em>Fedora Core Linux</em>中的<code>/etc/init.d/functions</code>文件。</p>
<div><pre><code>while [ -n &quot;$remaining&quot; -a &quot;$retry&quot; -gt 0 ]; do

# 初看之下很恐怖...


# 分开来分析
while [ -n &quot;$remaining&quot; -a &quot;$retry&quot; -gt 0 ]; do
#       --condition 1-- ^^ --condition 2-

#  如果变量&quot;$remaining&quot; 长度不为0
#+      并且AND (-a)
#+ 变量 &quot;$retry&quot; 大于0
#+ 那么
#+ [ 方括号表达式 ] 返回成功(0)
#+ while-loop 开始迭代执行语句。
#  ==============================================================
#  &quot;condition 1&quot; 和 &quot;condition 2&quot; 在 AND之前执行，为什么？
#  因为AND(-a)优先级比-n,-gt来得低，逻辑与会在最后求值。
#################################################################

if [ -f /etc/sysconfig/i18n -a -z &quot;${NOLOCALE:-}&quot; ] ; then


# 同样，分开来分析
if [ -f /etc/sysconfig/i18n -a -z &quot;${NOLOCALE:-}&quot; ] ; then
#    --condition 1--------- ^^ --condition 2-----

#  如果文件&quot;/etc/sysconfig/i18n&quot; 存在
#+      并且AND (-a)
#+ 变量 $NOLOCALE 长度不为0
#+ 那么
#+ [ 方括号表达式 ] 返回成功(0)
#+ 执行接下来的语句。
#
#  和之前的情况一样，逻辑与AND(-a)最后求值。
#  因为在方括号测试结构中，逻辑运算的优先级是最低的。
#  ==============================================================
#  注意:
#  ${NOLOCALE:-} 是一个参数扩展式，看起来有点多余。
#  但是, 如果 $NOLOCALE 没有提前声明, 它会被设成null，
#  在某些情况下，这会有点问题。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/tip.gif" alt="tip" />为了避免在复杂比较运算中的错误，可以把运算分散到几个括号结构中。</p>
<div><pre><code>if [ &quot;$v1&quot; -gt &quot;$v2&quot;  -o  &quot;$v1&quot; -lt &quot;$v2&quot;  -a  -e &quot;$filename&quot; ]
# 这样写不清晰...

if [[ &quot;$v1&quot; -gt &quot;$v2&quot; ]] || [[ &quot;$v1&quot; -lt &quot;$v2&quot; ]] &amp;&amp; [[ -e &quot;$filename&quot; ]]
# 好多了 -- 把逻辑判断分散到多个组之中
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></blockquote>
<hr>
<section>
<ol>
<li id="footnote1"><p>Precedence(优先级)，根据上下文，与priority含义相近。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第八章 运算符相关话题</title>
    <id>https://clay-wangzhi.com/code/shell/part2/08_operations_and_related_topics/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/08_operations_and_related_topics/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第八章-运算符相关话题"> 第八章 运算符相关话题</h1>
<h3 id="本章目录"> 本章目录</h3>
<ul>
<li><a href="./08_1_operators.html">8.1 运算符</a></li>
<li><a href="./08_2_numerical_constants.html">8.2 数字常量</a></li>
<li><a href="./08_3_the_double_parentheses_construct.html">8.3 双圆括号结构</a></li>
<li><a href="./08_4_operator_precedence.html">8.4 运算符优先级</a></li>
</ul>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第二部分 shell基础</title>
    <id>https://clay-wangzhi.com/code/shell/part2/</id>
    <link href="https://clay-wangzhi.com/code/shell/part2/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第二部分-shell基础"> 第二部分 shell基础</h1>
<h3 id="目录"> 目录</h3>
<ul>
<li><a href="./03_special_characters.html">3. 特殊字符</a></li>
<li><a href="./04_introduction_to_variables_and_parameters.html">4. 变量与参数</a>
<ul>
<li><a href="./04_1_variable_substitution.html">4.1 变量替换</a></li>
<li><a href="./04_2_variable_assignment.html">4.2 变量赋值</a></li>
<li><a href="./04_3_bash_variables_are_untyped.html">4.3 Bash弱类型变量</a></li>
<li><a href="./04_4_special_variable_types.html">4.4 特殊变量类型</a></li>
</ul>
</li>
<li><a href="./05_quoting.html">5. 引用</a>
<ul>
<li><a href="./05_1_quoting_variables.html">5.1 引用变量</a></li>
<li><a href="./05_2_escaping.html">5.2 转义</a></li>
</ul>
</li>
<li><a href="./06_exit_and_exit_status.html">6. 退出与退出状态</a></li>
<li><a href="./07_tests.html">7. 测试</a>
<ul>
<li><a href="./07_1_test_constructs.html">7.1 测试结构</a></li>
<li><a href="./07_2_file_test_operators.html">7.2 文件测试操作</a></li>
<li><a href="./07_3_other_comparison_operators.html">7.3 其他比较操作</a></li>
<li><a href="./07_4_nested_if_then_condition_tests.html">7.4 嵌套 if/then 条件测试</a></li>
<li><a href="./07_5_testing_your_knowledge_of_tests.html">7.5 牛刀小试</a></li>
</ul>
</li>
<li><a href="./08_operations_and_related_topics.html">8. 运算符和相关话题</a>
<ul>
<li><a href="./08_1_operators.html">8.1 运算符</a></li>
<li>8.2 数字常量</li>
<li>8.3 双圆括号结构</li>
<li>8.4 运算符优先级</li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">9.1 内部变量</title>
    <id>https://clay-wangzhi.com/code/shell/part3/09_1_internal_variables/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/09_1_internal_variables/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_9-1-内部变量"> 9.1 内部变量</h1>
<h2 id="内建变量"> 内建变量</h2>
<p>影响 Bash 脚本行为的变量。</p>
<h3 id="bash"> $BASH</h3>
<p>Bash程序的路径。</p>
<div><pre><code>bash$ <span>echo</span> <span>$BASH</span>
/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="bash-env"> $BASH_ENV</h3>
<p>这个环境变量会指向一个 Bash 启动文件，该文件在脚本被调用时会被读取。</p>
<h3 id="bash-subshell"> $BASH_SUBSHELL</h3>
<p>该变量用于提示所处的 subshell 层级。这是在 Bash version 3 中被引入的新特性。</p>
<p>具体用法可以参考 <a href="http://tldp.org/LDP/abs/html/subshells.html#SUBSHELL" target="_blank" rel="noopener noreferrer">样例21-1</a>。</p>
<h3 id="bashpid"> $BASHPID</h3>
<p>当前 Bash 进程实例的进程ID号。虽然与 <code>$$</code> 变量不一样，但是通常它们会给出相同的结果。</p>
<div><pre><code>bash4$ <span>echo</span> <span>$$</span>
<span>11015</span>


bash4$ <span>echo</span> <span>$BASHPID</span>
<span>11015</span>


bash4$ <span>ps</span> ax <span>|</span> <span>grep</span> bash4
<span>11015</span> pts/2    R      <span>0</span>:00 bash4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>然而...</p>
<div><pre><code><span>#!/bin/bash4</span>

<span>echo</span> <span>"\$\$ outside of subshell = <span>$$</span>"</span>                              <span># 9602</span>
<span>echo</span> <span>"\<span>$BASH_SUBSHELL</span>  outside of subshell = <span>$BASH_SUBSHELL</span>"</span>      <span># 0</span>
<span>echo</span> <span>"\<span>$BASHPID</span> outside of subshell = <span>$BASHPID</span>"</span>                   <span># 9602</span>

<span>echo</span>

<span>(</span> <span>echo</span> <span>"\$\$ inside of subshell = <span>$$</span>"</span>                             <span># 9602</span>
  <span>echo</span> <span>"\<span>$BASH_SUBSHELL</span> inside of subshell = <span>$BASH_SUBSHELL</span>"</span>      <span># 1</span>
  <span>echo</span> <span>"\<span>$BASHPID</span> inside of subshell = <span>$BASHPID</span>"</span> <span>)</span>                <span># 9603</span>
  <span>#  注意 $$ 总是返回父进程的 PID。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="bash-versinfo-n"> $BASH_VERSINFO[n]</h3>
<p>这是一个6个元素的数组，其中包含了已经安装的 Bash 的版本信息。该变量与变量 <code>$BASH_VERSION</code> 类似，但是更加详细。</p>
<div><pre><code><span># Bash 版本信息：</span>

<span>for</span> <span>n</span> <span>in</span> <span>0</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>
<span>do</span>
  <span>echo</span> <span>"BASH_VERSINFO[<span>$n</span>] = <span>${<span>BASH_VERSINFO</span><span>[</span>$n<span>]</span>}</span>"</span>
<span>done</span>

<span># BASH_VERSINFO[0] = 3                      # 主版本号</span>
<span># BASH_VERSINFO[1] = 00                     # 次版本号</span>
<span># BASH_VERSINFO[2] = 14                     # 补丁号</span>
<span># BASH_VERSINFO[3] = 1                      # 构建版本号</span>
<span># BASH_VERSINFO[4] = release                # 发行状态</span>
<span># BASH_VERSINFO[5] = i386-redhat-linux-gnu  # 架构</span>
                                            <span># (与 $MACHTYPE 相同)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="bash-version"> $BASH_VERSION</h3>
<p>已经安装的 Bash 的版本信息。</p>
<div><pre><code>bash$ <span>echo</span> <span>$BASH_VERSION</span>
<span>3.2</span>.25<span>(</span><span>1</span><span>)</span>-release
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>tcsh% <span>echo</span> <span>$BASH_VERSION</span>
<span>BASH_VERSION</span><span>:</span> Undefined variable.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>利用 <code>$BASH_VERSION</code> 来判断运行的是哪个 shell 是一个不错的方法，因为变量 <code>$SHELL</code> 并不总是能够给出正确的答案。</p>
<h3 id="cdpath"> $CDPATH</h3>
<p>变量指定 <code>cd</code> 命令可以搜索的路径，路径之间用冒号进行分隔。该变量的功能类似于指定可执行文件搜索路径的变量 <code>$PATH</code>。可以在本地文件 <code>~/.bashrc</code> 中设置该变量。</p>
<div><pre><code>bash$ <span>cd</span> bash-doc
bash: <span>cd</span> <span>:</span> bash-doc: No such <span>file</span> or directory


bash$ <span>CDPATH</span><span>=</span>/usr/share/doc
bash$ <span>cd</span> bash-doc
/usr/share/doc/bash-doc


bash$ <span>echo</span> <span>$PWD</span>
/usr/share/doc/bash-doc
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="dirstack"> $DIRSTACK</h3>
<p>指代目录栈中顶部的值<sup></sup>，目录栈由命令 <code>pushd</code> 和 <code>popd</code> 控制。</p>
<p>该变量相当于命令 <code>dirs</code>，但是 <code>dirs</code> 命令会显示整个目录栈。</p>
<h3 id="editor"> $EDITOR</h3>
<p>脚本所调用的默认编辑器，通常是 <code>vi</code> 或是 <code>emcas</code>。</p>
<h3 id="euid"> $EUID</h3>
<p>有效用户ID。</p>
<p>有效用户ID（EUID）是指当前用户正在使用的用户ID，可以通过 <code>su</code> 命令修改。</p>
<p>{% hint style=&quot;warning&quot; %}</p>
<p><code>$EUID</code> 与 <code>$UID</code> 并不总是相同的。</p>
<p>{% endhint %}</p>
<h3 id="funcname"> $FUNCNAME</h3>
<p>当前运行函数的函数名。</p>
<div><pre><code><span>xyz23</span> <span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"<span>$FUNCNAME</span> now executing."</span>  <span># xyz2 now executing.</span>
<span>}</span>

xyz23

<span>echo</span> <span>"FUNCNAME = <span>$FUNCNAME</span>"</span>        <span># FUNCNAME =</span>
                                   <span># 如果在函数外则为空值。 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以参考 <a href="">样例 A-50</a>。</p>
<h3 id="globignore"> $GLOBIGNORE</h3>
<p>在<a href="./../part5/18_2_globbing.html">文件匹配</a>时所忽略的文件名模式列表。</p>
<h3 id="groups"> $GROUPS</h3>
<p>当前用户所属的用户组。</p>
<p>该变量存储了当前用户所归属的用户组ID列表，是一个数组。内容与记录在文件 <code>/etc/passwd</code> 和文件 <code>/etc/group</code> 中的一致。</p>
<div><pre><code>root<span># echo $GROUPS</span>
<span>0</span>


root<span># echo ${GROUPS[1]}</span>
<span>1</span>


root<span># echo ${GROUPS[5]}</span>
<span>6</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="home"> $HOME</h3>
<p>当前用户的主目录，其值通常为 <code>/home/username</code> （参考 <a href="">样例 10-7</a>）。</p>
<h3 id="homename"> $HOMENAME</h3>
<p>系统启动的初始化脚本通过命令 <code>hostname</code> 给系统分配主机名。而函数 <code>gethostname()</code> 则是给 Bash 的内部变量 <code>$HOSTNAME</code> 赋值。可以参考 <a href="">样例 10-7</a>。</p>
<h3 id="hosttype"> $HOSTTYPE</h3>
<p>主机类型。</p>
<p>类似变量 <a href=""><code>$MACHTYPE</code></a>，用于识别系统硬件信息。</p>
<div><pre><code>bash$ <span>echo</span> <span>$HOSTTYPE</span>
i686
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="ifs"> $IFS</h3>
<p>内部字段分隔符。</p>
<p>该变量决定了 Bash 在解析字符串时如何去识别 <a href="">字段</a> 或单词边界。</p>
<p><code>$IFS</code> 的缺省值是空白符（空格，制表符以及换行符），但其可以被修改。例如你在处理逗号分隔的文件时可以将其设置为逗号。需要注意 <a href=""><code>$*</code></a> 使用保存在 <code>$IFS</code> 中的第一个字符。可以参考 <a href="">样例 5-1</a>。</p>
<div><pre><code>bash$ <span>echo</span> <span>"<span>$IFS</span>"</span>

<span>(</span>当 <span>$IFS</span> 设置为缺省值时，显示空行。<span>)</span>


bash$ <span>echo</span> <span>"<span>$IFS</span>"</span> <span>|</span> <span>cat</span> -vte
 ^I$
 $
<span>(</span>显示空白符：首先是一个空格，然后是 ^I <span>[</span>水平制表符<span>]</span>，
 然后是换行符，最后在末尾显示 <span>"$"</span>。<span>)</span>


bash$ <span>bash</span> -c <span>'set w x y z; IFS=":-;"; echo "<span>$*</span>"'</span>
w:x:y:z
<span>(</span>从字符串中解析命令，然后将命令参数分配给位置参数。<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>通过设置 <code>$IFS</code> 来忽略文件路径名中空格带来的影响。</p>
<div><pre><code><span><span>IFS</span></span><span>=</span><span>"<span><span>$(</span><span>printf</span> <span>'<span title="\n">\n</span><span title="\t">\t</span>'</span><span>)</span></span>"</span>   <span># 按 David Wheeler 所述。</span>
</code></pre>
<div><span>1</span><br></div></div><p>{% hint style=&quot;warning&quot; %}</p>
<p>相比于其他字符，变量 <code>$IFS</code> 在处理空白符时有所不同。</p>
<h4 id="样例-9-1-ifs-与空白符"> 样例 9-1. $IFS 与空白符</h4>
<div><pre><code><span>#!/bin/bash</span>
<span># ifs.sh</span>


<span>var1</span><span>=</span><span>"a+b+c"</span>
<span>var2</span><span>=</span><span>"d-e-f"</span>
<span>var3</span><span>=</span><span>"g,h,i"</span>

<span><span>IFS</span></span><span>=</span>+
<span># 加号会被解析成分隔符。</span>
<span>echo</span> <span>$var1</span>     <span># a b c</span>
<span>echo</span> <span>$var2</span>     <span># d-e-f</span>
<span>echo</span> <span>$var3</span>     <span># g,h,i</span>

<span>echo</span>

<span><span>IFS</span></span><span>=</span><span>"-"</span>
<span># 恢复对加号的默认解析。</span>
<span># 现在减号会被解析成分隔符。</span>
<span>echo</span> <span>$var1</span>     <span># a+b+c</span>
<span>echo</span> <span>$var2</span>     <span># d e f</span>
<span>echo</span> <span>$var3</span>     <span># g,h,i</span>

<span>echo</span>

<span><span>IFS</span></span><span>=</span><span>","</span>
<span># 现在逗号会被解析成分隔符。</span>
<span># 恢复对减号的默认解析。</span>
<span>echo</span> <span>$var1</span>     <span># a+b+c</span>
<span>echo</span> <span>$var2</span>     <span># d-e-f</span>
<span>echo</span> <span>$var3</span>     <span># g h i</span>

<span>echo</span>

<span><span>IFS</span></span><span>=</span><span>" "</span>
<span># 现在空格会被解析成分隔符。</span>
<span># 逗号恢复成默认解析。</span>
<span>echo</span> <span>$var1</span>     <span># a+b+c</span>
<span>echo</span> <span>$var2</span>     <span># d-e-f</span>
<span>echo</span> <span>$var3</span>     <span># g,h,i</span>

<span># ======================================================== #</span>

<span># 然而...</span>
<span># $IFS 处理空白符的方式不同其他字符。</span>

<span>output_args_one_per_line</span><span>(</span><span>)</span>
<span>{</span>
  <span>for</span> arg
  <span>do</span>
    <span>echo</span> <span>"[<span>$arg</span>]"</span>
  <span>done</span> <span>#  ^    ^   为了获得更好的视觉体验，把参数放到了括号里。</span>
<span>}</span>

<span>echo</span><span>;</span> <span>echo</span> <span>"IFS=<span title="\&quot;">\"</span>  <span title="\&quot;">\"</span>"</span>
<span>echo</span> <span>"-------"</span>

<span><span>IFS</span></span><span>=</span><span>" "</span>
<span>var</span><span>=</span><span>" a  b c   "</span>
<span>#    ^ ^^   ^^^</span>
output_args_one_per_line <span>$var</span>  <span># output_args_one_per_line `echo " a  b c   "`</span>
<span># [a]</span>
<span># [b]</span>
<span># [c]</span>


<span>echo</span><span>;</span> <span>echo</span> <span>"IFS=:"</span>
<span>echo</span> <span>"-----"</span>

<span><span>IFS</span></span><span>=</span>:
<span>var</span><span>=</span><span>":a::b:c:::"</span>               <span># 与上面一样的模式，</span>
<span>#    ^ ^^   ^^^                #+ 仅仅是将 " " 替换成了 ":" ...</span>
output_args_one_per_line <span>$var</span>
<span># []</span>
<span># [a]</span>
<span># []</span>
<span># [b]</span>
<span># [c]</span>
<span># []</span>
<span># []</span>

<span># 注意那些“空的”括号。</span>
<span># 同样的情况也会出现在 awk 命令所使用的 "FS" 字段分隔符中。</span>


<span>echo</span>

<span>exit</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br></div></div><p>{% endhint %}</p>
<p>（非常感谢 Stéphane Chazelas 提供了上面的样例并做出的详细说明。）</p>
<p>也可以参考 <a href="">样例 16-41</a>，<a href="">样例 11-8</a> 和 <a href="">样例19-14</a>，获取更多使用 <code>$IFS</code> 的技巧。</p>
<h3 id="ignoreeof"> $IGNOREEOF</h3>
<p>忽略 EOF：用于指示 Shell 在注销前需要忽略多少个文件结束符(EOF，contrl-D)。</p>
<h3 id="lc-collate"> $LC_COLLATE</h3>
<p>经常会在文件 <a href=""><code>.bashrc</code></a> 或是文件 <code>/etc/profile</code> 中被设置。该变量控制文件名扩展和模式匹配中的排序顺序。如果设置不得当，<code>LC_COLLATE</code> 将会导致 <a href="">文件名匹配</a> 中出现非预期结果。</p>
<p>{% hint style=&quot;info&quot; %}</p>
<p>在 Bash 2.05 版本之后，文件名匹配在不再区分中括号中字母的大小写。例如 <code>ls [A-M]*</code> 将会同时匹配 <code>File1.txt</code> 和 <code>file1.txt</code> 两个文件。如果想要恢复成之前的模式，则需要在文件 <code>/etc/profile</code> 或文件 <code>~/.bashrc</code> 中通过语句 <code>export LC_COLLATE=C</code> 设置 <code>LC_COLLATE</code> 的值为 <code>C</code>。</p>
<p>{% endhint %}</p>
<h3 id="lc-ctype"> $LC_CTYPE</h3>
<p>这个内部变量控制在 <a href="">文件匹配</a> 和模式匹配中的字符解析行为。</p>
<h3 id="lineno"> $LINENO</h3>
<p>该变量记录了其在脚本中被使用时所处行的行号。该变量只有在被使用时才有意义，在调试过程中非常有用。</p>
<div><pre><code><span># *** 调试部分起始 ***</span>
<span>last_cmd_arg</span><span>=</span><span>$_</span>  <span># 保存最后的命令。</span>

<span>echo</span> <span>"At line number <span>$LINENO</span>, variable <span title="\&quot;">\"</span>v1<span title="\&quot;">\"</span> = <span>$v1</span>"</span>
<span>echo</span> <span>"Last command argument processed = <span>$last_cmd_arg</span>"</span>
<span># *** 调试部分终止 ***</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="machtype"> $MACHTYPE</h3>
<p>设备类型。</p>
<p>识别系统硬件。</p>
<div><pre><code>bash$ <span>echo</span> <span>$MACHTYPE</span>
i686
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="oldpwd"> $OLDPWD</h3>
<p>上一个工作目录(OLD-Print-Working-Directory)，也就是之前所在的目录。</p>
<h3 id="ostype"> $OSTYPE</h3>
<p>操作系统类型。</p>
<div><pre><code>bash$ <span>echo</span> <span>$OSTYPE</span>
linux
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="path"> $PATH</h3>
<p>可执行文件搜索路径，其值通常包含 <code>/usr/bin</code>，<code>/usr/X11R6/bin/</code>，<code>/usr/local/bin</code> 等路径。</p>
<p>给定一个命令，shell就会自动从搜索路径包含的目录中利用哈希表搜索该可执行命令。而搜索路径就保存在 <a href="">环境变量</a> <code>$PATH</code> 中，其中包含的一系列目录则通过冒号进行分隔。通常情况下，<code>$PATH</code> 会定义在文件 <code>/etc/profile</code> 或文件 <a href=""><code>~/.bashrc</code></a> 中（参考 <a href="">附录 H</a>）。</p>
<div><pre><code>bash$ <span>echo</span> <span>$PATH</span>
/bin:/usr/bin:/usr/local/bin/:/usr/X11R6/bin:/sbin:/usr/sbin
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>PATH=${PATH}:/opt/bin</code> 表示添加目录 <code>/opt/bin</code> 到当前的搜索路径中。在脚本中可以通过这种方式临时添加目录到搜索路径。而当脚本结束时，<code>$PATH</code> 就会恢复到原始值（类似于脚本这样的子进程所作出的修改，不会影响到例如 shell 这样的父进程的环境）。</p>
<p>{% hint style=&quot;info&quot; %}</p>
<p>基于安全考虑，通常在 <code>$PATH</code> 中会省略当前工作目录 <code>./</code>。</p>
<p>{% endhint %}</p>
<h3 id="pipestatus"> $PIPESTATUS</h3>
<p>该 <a href="">数组</a> 变量保存了最后运行的前台 <a href="">管道</a> 的 <a href="">退出状态(es)</a>。</p>
<div><pre><code>bash$ <span>echo</span> <span>$PIPESTATUS</span>
<span>0</span>

bash$ <span>ls</span> -al <span>|</span> bogus_command
bash: bogus_command: <span>command</span> not found
bash$ <span>echo</span> <span>${<span>PIPESTATUS</span><span>[</span>1<span>]</span>}</span>
<span>127</span>

bash$ <span>ls</span> -al <span>|</span> bogus_command
bash: bogus_command: <span>command</span> not found
bash$ <span>echo</span> <span>$?</span>
<span>127</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><code>$PIPESTATUS</code> 数组中的每一个元素都代表了该管道中相对应命令的退出状态。<code>$PIPESTATUS[0]</code> 表示管道中第一个命令的退出状态，<code>$PIPESTATUS[1]</code> 表示第二个命令的退出状态，以此类推。</p>
<p>{% hint style=&quot;warning&quot; %}</p>
<p>在Bash 3.0 以下版本的登录shell中，变量 <code>$PIPESTATUS</code> 可能会包含一个不正确的 0 值。</p>
<div><pre><code>tcsh% <span>bash</span>

bash$ <span>who</span> <span>|</span> <span>grep</span> nobody <span>|</span> <span>sort</span>
bash$ <span>echo</span> <span>${<span>PIPESTATUS</span><span>[</span>*<span>]</span>}</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果脚本包含了上述代码，应该得到期望的输出是 0 1 0。</p>
<p>感谢 Wayne Pollock 指出了这个问题并提供了上述的样例。</p>
<p>{% endhint %}</p>
<p>{% hint style=&quot;info&quot; %}</p>
<p>在某些场景下，<code>$PIPESTATUS</code> 变量将会产生非预期结果。</p>
<div><pre><code>bash$ <span>echo</span> <span>$BASH_VERSION</span>
<span>3.00</span>.14<span>(</span><span>1</span><span>)</span>-release

bash$ <span>ls</span> <span>|</span> bogus_command <span>|</span> <span>wc</span>
bash: bogus_command: <span>command</span> not found
 <span>0</span>       <span>0</span>       <span>0</span>

bash$ <span>echo</span> <span>${<span>PIPESTATUS</span><span>[</span>@<span>]</span>}</span>
<span>141</span> <span>127</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Chet Ramey 把上述非预期结果的原因归咎于 <a href=""><code>ls</code></a> 命令的行为。如果 <code>ls</code> 将结果输出到没有被读取的管道上，产生的 SIGPIPE 信号将会终止 <code>ls</code> 命令，同时其 <a href="">退出状态</a> 从期望的 0 变为 141。而同样的情况也会发生在命令 <code>tr</code> 中。</p>
<p>{% endhint %}</p>
<p>{% hint style=&quot;info&quot; %}</p>
<p><code>$PIPESTATUS</code> 是一个易失的变量。该变量需要在目标管道执行完成后，且其他任何命令执行之前去捕获。</p>
<div><pre><code>bash$ <span>ls</span> <span>|</span> bogus_command <span>|</span> <span>wc</span>
bash: bogus_command: <span>command</span> not found
 <span>0</span>       <span>0</span>                <span>0</span>

bash$ <span>echo</span> <span>${<span>PIPESTATUS</span><span>[</span>@<span>]</span>}</span>
<span>0</span> <span>127</span> <span>0</span>

bash$ <span>echo</span> <span>${<span>PIPESTATUS</span><span>[</span>@<span>]</span>}</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>{% endhint %}</p>
<p>{% hint style=&quot;info&quot; %}</p>
<p>在 <code>$PIPESTATUS</code> 不能给出所期望的信息的情况下，使用 <a href="">pipeline 选项</a> 可能会有帮助。</p>
<p>{% endhint %}</p>
<h3 id="ppid"> $PPID</h3>
<p>一个进程的 <code>$PPID</code> 即该进程的父进程的进程ID(pid)。<sup></sup></p>
<p>可以与命令 <a href=""><code>pidof</code></a> 进行比较。</p>
<h3 id="prompt-command"> $PROMPT_COMMAND</h3>
<p>该变量存储在主提示符 <code>$PS1</code> 显示之前所需要执行的命令。</p>
<h3 id="ps1"> $PS1</h3>
<p>主提示符，即在命令行中显示的提示符。</p>
<h3 id="ps2"> $PS2</h3>
<p>次要提示符，当需要额外输入时出现的提示符。默认显示为 <code>&gt;</code>。</p>
<h3 id="ps3"> $PS3</h3>
<p>三级提示符，显示在 <code>select</code> 循环中（参考 <a href="">样例 11-30</a>）。</p>
<h3 id="ps4"> $PS4</h3>
<p>四级提示符，当使用 <code>-x [verbose trace]</code> <a href="">选项</a> 调用脚本时显示的提示符。默认显示为 <code>+</code>。</p>
<p>其可以作为调试的辅助手段，把一些诊断信息显示在 <code>$PS4</code> 中可能会有帮助。</p>
<div><pre><code><span>P4</span><span>=</span><span>'<span><span>$(</span><span>read</span> <span>time</span> junk <span>&lt;</span> /proc/$$/schedstat<span>;</span> <span>echo</span> <span>"@@@ <span>$time</span> @@@ "</span> <span>)</span></span>'</span>
<span># 根据 Erik Brandsberg 提供的建议。</span>
<span>set</span> -x
<span># 可以在后面写各种命令...</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="pwd"> $PWD</h3>
<p>工作目录（你当前所在的目录）。</p>
<p>该变量是内建命令 <a href=""><code>pwd</code></a> 的翻版。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>E_WRONG_DIRECTORY</span><span>=</span><span>85</span>

<span>clear</span> <span># 清空屏幕。</span>

<span>TargetDirectory</span><span>=</span>/home/bozo/projects/GreatAmericanNovel

<span>cd</span> <span>$TargetDirectory</span>
<span>echo</span> <span>"Deleting stale files in <span>$TargetDirectory</span>."</span>

<span>if</span> <span>[</span> <span>"<span>$PWD</span>"</span> <span>!=</span> <span>"<span>$TargetDirectory</span>"</span> <span>]</span>
<span>then</span>    <span># 小心不要偶然清空了错误的目录。</span>
  <span>echo</span> <span>"Wrong directory!"</span>
  <span>echo</span> <span>"In <span>$PWD</span>, rather than <span>$TargetDirectory</span>!"</span>
  <span>echo</span> <span>"Bailing out!"</span>
  <span>exit</span> <span>$E_WRONG_DIRECTORY</span>
<span>fi</span>

<span>rm</span> -rf *
<span>rm</span> .<span>[</span>A-Za-z0-9<span>]</span>*    <span># 删除隐藏文件。</span>
<span># rm -f .[^.]* ..?*   删除那些以多个点开头的文件。</span>
<span># (shopt -s dotglob; rm -f *)   这样写也可以。</span>
<span># 感谢 S.C. 提出这点。</span>

<span>#  文件名可以包含ASCII码中范围为 0-255 的所有字符，</span>
<span>#+ 除了字符 "/"。</span>
<span>#  删除以一些特殊字符开头的文件，例如 -</span>
<span>#+ 留作练习。（提示： rm ./-weirdname 或者 rm -- -weirdname）</span>
<span>result</span><span>=</span><span>$?</span>   <span># 删除操作的结果。如果删除成功，值为0。</span>

<span>echo</span>
<span>ls</span> -al              <span># 是不是还有剩余没有删除的文件？</span>
<span>echo</span> <span>"Done."</span>
<span>echo</span> <span>"Old files deleted in <span>$TargetDirectory</span>."</span>
<span>echo</span>

<span># 如果有其他需要，在这里完成。</span>

<span>exit</span> <span>$result</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h3 id="reply"> $REPLY</h3>
<p>当没有给 <a href=""><code>read</code></a> 命令提供接收参数时的默认接收参数。该变量同样适用于 <a href=""><code>select</code></a> 菜单接收用户输入值的场景，需要注意的是，用户只需要输入菜单项的编号，而不需要输入完整的菜单项内容。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># reply.sh</span>

<span># REPLY 是 'read' 命令的默认接收参数。</span>

<span>echo</span>
<span>echo</span> -n <span>"What is your favorite vegetable? "</span>
<span>read</span>

<span>echo</span> <span>"Your favorite vegetable is <span>$REPLY</span>."</span>
<span>#  当且仅当 'read' 命令没有接收参数的时候，</span>
<span>#+ REPLY 才能保存最近一次 'read' 命令接收的值。</span>

<span>echo</span>
<span>echo</span> -n <span>"What is your favorite fruit? "</span>
<span>read</span> fruit
<span>echo</span> <span>"Your favorite fruit is <span>$fruit</span>."</span>
<span>echo</span> <span>"but..."</span>
<span>echo</span> <span>"Value of \<span>$REPLY</span> is still <span>$REPLY</span>."</span>
<span>#  因为变量 $fruit 接收了新一次 "read" 命令所读入的值，</span>
<span>#+ 所以 $REPLY 仍旧存储的是上一次接收的值。</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="seconds"> $SECONDS</h3>
<p>该变量记录到目前为止脚本执行的时间，单位为秒。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>TIME_LIMIT</span><span>=</span><span>10</span>
<span>INTERVAL</span><span>=</span><span>1</span>

<span>echo</span>
<span>echo</span> <span>"Hit Control-C to exit before <span>$TIME_LIMIT</span> seconds."</span>
<span>echo</span>

<span>while</span> <span>[</span> <span>"<span>$SECONDS</span>"</span> -le <span>"<span>$TIME_LIMIT</span>"</span> <span>]</span>
<span>do</span>   <span>#   $SECONDS 是一个 shell 的内部变量。</span>
  <span>if</span> <span>[</span> <span>"<span>$SECONDS</span>"</span> -eq <span>1</span> <span>]</span>
  <span>then</span>
    <span>units</span><span>=</span>second
  <span>else</span>
    <span>units</span><span>=</span>seconds
  <span>fi</span>
  
  <span>echo</span> <span>"This script has been running <span>$SECONDS</span> <span>$units</span>."</span>
  <span>#  在一台性能较差或负载过重的设备上，</span>
  <span>#+ 这个脚本可能会偶尔跳过几个计数。</span>
  <span>sleep</span> <span>$INTERVAL</span>
<span>done</span>

<span>echo</span> -e <span>"<span title="\a">\a</span>"</span>  <span># 发出蜂鸣声！</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="shellopts"> $SHELLOPTS</h3>
<p>该只读变量记录了 shell 中已启用的 <a href="">选项</a> 列表。</p>
<div><pre><code>bash$ <span>echo</span> <span>$SHELLOPTS</span>
braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="shlvl"> $SHLVL</h3>
<p>当前 shell 的层级，即嵌套了多少层 Bash <sup></sup>。如果命令行的层级 <code>$SHLVL</code> 为 1，那么在其中执行的脚本层级则增加到 2。</p>
<p>{% hint style=&quot;info&quot; %}</p>
<p>该变量 <a href="">不受 subshell 影响</a>。当你需要指出嵌套了多少层 subshell 时，需要使用变量 。</p>
<p>{% endhint %}</p>
<h3 id="tmout"> $TMOUT</h3>
<p>如果 <code>$TMOUT</code> 被设为非 0 值 <code>time</code>，那么 shell 会在 <code>$time</code> 秒后超时，然后导致 shell 登出。</p>
<p>在 Bash 2.05b 版本之后，可以在脚本中将 <code>read</code> 命令与 <code>$TMOUT</code> 变量进行结合。</p>
<div><pre><code><span># 只能在 Bash 2.05b 及之后的版本中成功执行。</span>

<span>TMOUT</span><span>=</span><span>3</span>    <span># 提示会在 3 秒后超时。</span>

<span>echo</span> <span>"What is your favorite song?"</span>
<span>echo</span> <span>"Quickly now, you only have <span>$TMOUT</span> seconds to answer!"</span>
<span>read</span> song

<span>if</span> <span>[</span> -z <span>"<span>$song</span>"</span> <span>]</span>
<span>then</span>
  <span>song</span><span>=</span><span>"(no answer)"</span>
  <span># 默认值。</span>
<span>fi</span>

<span>echo</span> <span>"Your favorite song is <span>$song</span>."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>在脚本中，同样也存在其他一些实现超时功能的更复杂的方法。其中一个方法是设置一个循环的计时器，当脚本超时的时候，计时器会给脚本发送一个信号。同时，也需要一个处理信号的程序来 <a href="">捕获</a>（参考 <a href="">样例 32-5</a>）由循环计时器产生的中断。</p>
<h4 id="样例-9-2-限时输入"> 样例 9-2. 限时输入</h4>
<div><pre><code><span>#!/bin/bash</span>
<span># timed-input.sh</span>

<span># TMOUT=3    在新版本的 Bash 中起效。</span>

<span>TIMER_INTERRUPT</span><span>=</span><span>14</span>
<span>TIMELIMIT</span><span>=</span><span>3</span>  <span># 在该实例中设置为 3 秒。</span>
             <span># 同样可以设置成其他值。</span>
             
<span>PrintAnswer</span><span>(</span><span>)</span>
<span>{</span>
  <span>if</span> <span>[</span> <span>"<span>$answer</span>"</span> <span>=</span> TIMEOUT <span>]</span>
  <span>then</span>
    <span>echo</span> <span>$answer</span>
  <span>else</span>       <span># 不要混淆了这两个实例。</span>
    <span>echo</span> <span>"Your favorite veggie is <span>$answer</span>"</span>
    <span>kill</span> <span>$!</span>  <span>#  终止在后台运行的</span>
             <span>#+ 不再被需要的 TimerOn 函数。</span>
             <span>#  $! 代表最后一个在后台运行的作业的进程ID。</span>
  <span>fi</span>

<span>}</span>
                
                
<span>TimerOn</span><span>(</span><span>)</span>
<span>{</span>
  <span>sleep</span> <span>$TIMELIMIT</span> <span>&amp;&amp;</span> <span>kill</span> -s <span>14</span> <span>$$</span> <span>&amp;</span>
  <span># 等待 3 秒，然后给脚本发送一个信号。</span>
<span>}</span>


<span>Int14Vector</span><span>(</span><span>)</span>
<span>{</span>
  <span>answer</span><span>=</span><span>"TIMEOUT"</span>
  PrintAnswer
  <span>exit</span> <span>$TIMER_INTERRUPT</span>
<span>}</span>

<span>trap</span> Int14Vector <span>$TIMER_INTERRUPT</span>
<span># 我们的目的就是通过时间中断 (14) 终止程序。</span>

<span>echo</span> <span>"What is your favorite vegetable "</span>
TimerOn
<span>read</span> answer
PrintAnswer


<span>#  必须承认，这个实现限时输入的方法并不优雅。</span>
<span>#  但利用 "read" 命令的 "-t" 选项可以简化这个操作。</span>
<span>#  参考脚本 "t-out.sh"。</span>
<span>#  思考一下，如果不是对用户的单次输入时间进行限制，</span>
<span>#+ 而是对整个脚本的运行时间进行限制，应该怎么做？</span>

<span>#  如果你需要更优雅的写法 ...</span>
<span>#+ 可以考虑用 C 或者 C++ 来编写应用，</span>
<span>#+ 并使用其中包含的类似 'alarm' 或是 ‘setitimer' 等合适的库函数来实现计时。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><p>还有一种方法是使用 <a href=""><code>stty</code></a>。</p>
<h4 id="样例-9-3-再来一次-限时输入"> 样例 9-3. 再来一次，限时输入</h4>
<div><pre><code><span>#!/bin/bash</span>
<span># timeout.sh</span>

<span>#  该脚本由 Stephane Chazelas 编写，</span>
<span>#+ 并由本书作者修改。</span>

<span>INTERVAL</span><span>=</span><span>5</span>                <span># 超时所需的时间间隔</span>

<span>timedout_read</span><span>(</span><span>)</span> <span>{</span>
  <span>timeout</span><span>=</span><span>$1</span>
  <span>varname</span><span>=</span><span>$2</span>
  <span>old_tty_settings</span><span>=</span><span><span>`</span>stty -g<span>`</span></span>
  stty -icanon min <span>0</span> <span>time</span> <span>${timeout}</span><span>0</span>
  <span>eval</span> <span>read</span> <span>$varname</span>      <span># 或者直接写成 read $varname</span>
  stty <span>"<span>$old_tty_settings</span>"</span>
  <span># 参考 "stty" 的帮助页面 (man)。</span>
<span>}</span>

<span>echo</span><span>;</span> <span>echo</span> -n <span>"What's your name? Quick! "</span>
timedout_read <span>$INTERVAL</span> your_name

<span>#  该脚本也许并不能在所有类型的终端上正常运行。</span>
<span>#  最大的超时时间间隔依赖于终端。</span>
<span>#+ （通常是 25.5 秒）。</span>

<span>echo</span>

<span>if</span> <span>[</span> <span>!</span> -z <span>"<span>$your_name</span>"</span> <span>]</span>  <span># 如果在超时前输入了姓名 ...</span>
<span>then</span>
  <span>echo</span> <span>"Your name is <span>$your_name</span>."</span>
<span>else</span>
  <span>echo</span> <span>"Timed out."</span>
<span>fi</span>

<span>echo</span>

<span># 该脚本的计时行为与 "timed-input.sh" 中的计时行为有所不同，</span>
<span># 该脚本的计时器会在每次按键后被重置。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>可能最简单的方法就是利用 <a href=""><code>read</code></a> 命令的 <code>-t</code> 选项。</p>
<h4 id="样例-9-4-限时-read"> 样例 9-4. 限时 read</h4>
<div><pre><code><span>#!/bin/bash</span>
<span># t-out.sh [time-out]</span>
<span># 从 "syngin seven" 的建议中所汲取的灵感，谢谢你们。</span>


<span>TIMELIMIT</span><span>=</span><span>4</span>         <span># 4 秒</span>

<span>read</span> -t <span>$TIMELIMIT</span> variable <span>&lt;</span><span>&amp;1</span>
<span>#                           ^^^</span>
<span>#  在这个实例中，只有 Bash 1.x 或 Bash 2.x 版本需要 "&lt;&amp;1"，</span>
<span>#  而在 Bash 3 及更高版本则不需要。</span>

<span>echo</span>

<span>if</span> <span>[</span> -z <span>"<span>$variable</span>"</span> <span>]</span>  <span># 判断是否为空。</span>
<span>then</span>
  <span>echo</span> <span>"Timed out, variable still unset."</span>
<span>else</span>
  <span>echo</span> <span>"variable = <span>$variable</span>"</span>
<span>fi</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="uid"> $UID</h3>
<p>用户 ID。</p>
<p>记录在文件 <a href=""><code>/etc/passwd</code></a> 中当前用户的用户标识号。</p>
<p>该 ID 表示的是当前用户的真实 ID，即使用户通过 <code>su</code> 命令临时切换至另一个用户，这个 ID 也不会改变。<code>$UID</code> 是一个只读变量，不能够被命令行或是脚本中的命令所修改，并与内建命令 <a href=""><code>id</code></a> 相对应。</p>
<h4 id="样例-9-5-我是-root-用户吗"> 样例 9-5. 我是 root 用户吗？</h4>
<div><pre><code><span>#!/bin/bash</span>
<span># am-i-root.sh:   我是否是 root 用户？</span>

<span>ROOT_UID</span><span>=</span><span>0</span>   <span># Root 用户的 $UID 为 0。</span>

<span>if</span> <span>[</span> <span>"<span>$UID</span>"</span> -eq <span>"<span>$ROOT_UID</span>"</span> <span>]</span>  <span># 只有真正的 "root" 用户才能经受得住考研。</span>
<span>then</span>
  <span>echo</span> <span>"You are root."</span>
<span>else</span>
  <span>echo</span> <span>"You are just an ordinary user (but mom loves you just the same)."</span>
<span>fi</span>

<span>exit</span> <span>0</span>


<span># ============================================================= #</span>
<span># 下面的代码将不会被执行，因为脚本已经退出了。</span>

<span># 另外一种判断是否是 root 用户的方法：</span>

<span>ROOTUSER_NAME</span><span>=</span>root

<span>username</span><span>=</span><span><span>`</span><span>id</span> -nu<span>`</span></span>              <span># 或是...  username=`whoami`</span>
<span>if</span> <span>[</span> <span>"<span>$username</span>"</span> <span>=</span> <span>"<span>$ROOTUSER_NAME</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"Rooty, toot, toot. You are root."</span>
<span>else</span>
  <span>echo</span> <span>"You are just a regular fella."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>还可以参考 <a href="">样例2-3</a>。</p>
<p>{% hint style=&quot;info&quot; %}</p>
<p>变量 <code>$ENV</code>，<code>$LOGNAME</code>，<code>$MAIL</code>，<code>$TERM</code>，<code>$USER</code> 以及 <code>$USERNAME</code> 并不是 Bash 的 <a href="">内建变量</a>，而是在 <a href=""><code>Bash</code></a> 或系统的某个启动文件中，被设置而成的 <a href="">环境变量</a>。代表当前用户登录 shell 名称的变量 <code>$SHELL</code> 是在文件 <code>/etc/password</code> 或是某个初始化脚本中被设定的，它也不是一个 Bash 的内建变量。</p>
<div><pre><code>tcsh% <span>echo</span> <span>$LOGNAME</span>
bozo
tcsh% <span>echo</span> <span>$SHELL</span>
/bin/tcsh
tcsh% <span>echo</span> <span>$TERM</span>
rxvt

bash$ <span>echo</span> <span>$LOGNAME</span>
bozo
bash$ <span>echo</span> <span>$SHELL</span>
/bin/tcsh
bash$ <span>echo</span> <span>$TERM</span>
rxvt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>{% endhint %}</p>
<h2 id="位置参数"> 位置参数</h2>
<h3 id="_0-1-2-等"> $0, $1, $2 等</h3>
<p>位置参数。出现在从命令行传递给脚本、函数或是通过内建命令 <a href=""><code>set</code></a> 设置变量时（参考 <a href="">样例 4-5</a> 或是 <a href="">样例 15-16</a>）。</p>
<h3 id=""> $#</h3>
<p>命令行参数<sup></sup>或是位置参数的个数（参考 <a href="">样例 36-2</a>）。</p>
<h3 id="-2"> $*</h3>
<p>将所有的位置参数整合，视作一个单词。</p>
<p>{% hint style=&quot;info&quot; %}</p>
<p>该参数必须是被引用的状态，<code>&quot;$*&quot;</code>。</p>
<p>{% endhint %}</p>
<h3 id="-3"> $@</h3>
<p>该参数等同于 <code>$*</code>，但其中每个参数都是独立的被引用的字符串。也就是说，所有的参数都是被原封不动的进行传递，并没有被解析或是扩展。这意味着，参数列表中的每一个参数都被独立视为一个单词。</p>
<p>{% hint style=&quot;info&quot; %}</p>
<p>同样，该参数必须是被引用的状态，<code>&quot;$@&quot;</code>。</p>
<p>{% endhint %}</p>
<h4 id="样例-9-6-参数列表-利用-和-列出参数"> 样例 9-6. 参数列表：利用 $* 和 $@ 列出参数</h4>
<div><pre><code><span>#!/bin/bash</span>
<span># arglist.sh</span>
<span># 在调用该脚本时需要跟上一些参数，例如 "one two three" ...</span>

<span>E_BADARGS</span><span>=</span><span>85</span>

<span>if</span> <span>[</span> <span>!</span> -n <span>"<span>$1</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"Usage: <span><span>`</span><span>basename</span> $0<span>`</span></span> argument1 argument2 etc."</span>
  <span>exit</span> <span>$E_BADARGS</span>
<span>fi</span>

<span>echo</span>

<span>index</span><span>=</span><span>1</span>          <span># 初始化计数器。</span>

<span>echo</span> <span>"Listing args with <span title="\&quot;">\"</span>\<span>$*</span><span title="\&quot;">\"</span>:"</span>
<span>for</span> <span>arg</span> <span>in</span> <span>"<span>$*</span>"</span>  <span># 如果这里没有引用 "$*"，脚本将不会正常运行。</span>
<span>do</span>
  <span>echo</span> <span>"Arg #<span>$index</span> = <span>$arg</span>"</span>
  <span>let</span> <span>"index+=1"</span>
<span>done</span>             <span># $* 将所有参数视作一个单词。</span>
<span>echo</span> <span>"Entire arg list seen as single word."</span>

<span>echo</span>

<span>index</span><span>=</span><span>1</span>          <span># 重置计数器。</span>
                 <span># 如果忘了这一步将会发生什么？</span>
                 
<span>echo</span> <span>"Listing args with <span title="\&quot;">\"</span>\<span>$@</span><span title="\&quot;">\"</span>:"</span>
<span>for</span> <span>arg</span> <span>in</span> <span>"<span>$@</span>"</span>
<span>do</span>
  <span>echo</span> <span>"Arg #<span>$index</span> = <span>$arg</span>"</span>
  <span>let</span> <span>"index+=1"</span>
<span>done</span>             <span># $@ 将所有参数视作独立的单词。</span>
<span>echo</span> <span>"Arg list seen as separate words."</span>

<span>echo</span>

<span>index</span><span>=</span><span>1</span>          <span># 重置计数器。</span>

<span>echo</span> <span>"Listing args with \<span>$*</span> (unquoted):"</span>
<span>for</span> <span>arg</span> <span>in</span> <span>$*</span>
<span>do</span>
  <span>echo</span> <span>"Arg #<span>$index</span> = <span>$arg</span>"</span>
  <span>let</span> <span>"index+=1"</span>
<span>done</span>             <span># 未被引用的 $* 将所有参数视作独立的单词。</span>
<span>echo</span> <span>"Arg list seen as separate words."</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><p>在 <code>shift</code> 命令执行后，<code>$@</code> 将会保留除了 <code>$1</code> 之外的剩余的命令行参数，而 <code>$1</code> 则会被丢弃。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># 使用 ./scriptname 1 2 3 4 5 调用脚本</span>

<span>echo</span> <span>"<span>$@</span>"</span>    <span># 1 2 3 4 5</span>
<span>shift</span>
<span>echo</span> <span>"<span>$@</span>"</span>    <span># 2 3 4 5</span>
<span>shift</span>
<span>echo</span> <span>"<span>$@</span>"</span>    <span># 3 4 5</span>

<span># 每一次 "shift" 都会丢弃参数 $1。</span>
<span># "$@" 则包含了剩余的所有参数。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>参数 <code>$@</code> 也可被用作过滤 shell 脚本输入的工具。结构 <code>cat &quot;$@&quot;</code> 可以接受来自标准输入 <code>stdin</code> 的输入，也可以接受传递给脚本的参数中的文件中的输入。参考 <a href="">样例 16-24</a> 和 <a href="">样例 16-25</a>。</p>
<p>{% hint style=&quot;warning&quot; %}</p>
<p>根据分隔符 <a href=""><code>$IFS</code></a> 设置的不同，<code>$*</code> 和 <code>$@</code> 有时会出现不一致或非预期行为。</p>
<p>{% endhint %}</p>
<h4 id="样例-9-7-和-的不一致行为"> 样例 9-7. $* 和 $@ 的不一致行为</h4>
<div><pre><code><span>#!/bin/bash</span>

<span>#  Bash 的内部变量 "$*" 和 "$@" 拥有不稳定的行为，</span>
<span>#+ 这些行为是否出现通常依赖于它们是否是被引用的状态。</span>
<span>#  下面的代码会演示在分词和换行时，这些变量所会出现的一些不一致的处理方式。</span>


<span>set</span> -- <span>"First one"</span> <span>"second"</span> <span>"third:one"</span> <span>""</span> <span>"Fifth: :one"</span>
<span># 设置脚本参数，$1, $2, $3 等等。</span>

<span>echo</span> 

<span>echo</span> <span>'IFS unchanged, using "<span>$*</span>"'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>"<span>$*</span>"</span>               <span># 被引用状态。</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>   <span># 这一行在下面所有的例子中都保持不变。</span>
                            <span># 输出参数。</span>
<span>done</span>
<span>echo</span> ---

<span>echo</span> <span>'IFS unchanged, using <span>$*</span>'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>$*</span>                 <span># 未被引用状态。</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>echo</span> <span>'IFS unchanged, using "<span>$@</span>"'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>"<span>$@</span>"</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>echo</span> <span>'IFS unchanged, using <span>$@</span>'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>$@</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span><span>IFS</span></span><span>=</span>:
<span>echo</span> <span>'IFS=":", using "<span>$*</span>"'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>"<span>$*</span>"</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>echo</span> <span>'IFS=":", using <span>$*</span>'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>$*</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>var</span><span>=</span><span>$*</span>
<span>echo</span> <span>'IFS=":", using "<span>$var</span>" (var=<span>$*</span>)'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>"<span>$var</span>"</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>echo</span> <span>'IFS=":", using <span>$var</span> (var=<span>$*</span>)'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>$var</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>var</span><span>=</span><span>"<span>$*</span>"</span>
<span>echo</span> <span>'IFS=":", using <span>$var</span> (var="<span>$*</span>")'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>$var</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>echo</span> <span>'IFS=":", using "<span>$var</span>" (var="<span>$*</span>")'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>"<span>$var</span>"</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>echo</span> <span>'IFS=":", using "<span>$@</span>"'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>"<span>$@</span>"</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>echo</span> <span>'IFS=":", using <span>$@</span>'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>$@</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>var</span><span>=</span><span>$@</span>
<span>echo</span> <span>'IFS=":", using <span>$var</span> (var=<span>$@</span>)'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>$var</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>echo</span> <span>'IFS=":", using "<span>$var</span>" (var=<span>$@</span>)'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>"<span>$var</span>"</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>var</span><span>=</span><span>"<span>$@</span>"</span>
<span>echo</span> <span>'IFS=":", using "<span>$var</span>" (var="<span>$@</span>")'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>"<span>$var</span>"</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>
<span>echo</span> ---

<span>echo</span> <span>'IFS=":", using <span>$var</span> (var="<span>$@</span>")'</span>
<span>c</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>$var</span>
<span>do</span> <span>echo</span> <span>"<span><span>$((</span>c<span>+</span><span>=</span><span>1</span><span>))</span></span>: [<span>$i</span>]"</span>
<span>done</span>

<span>echo</span>

<span># 尝试在 ksh 或是 zsh -y 下执行这个脚本。</span>

<span>exit</span> <span>0</span>

<span>#  这个样例是由 Stephane Chazelas 所编写，</span>
<span>#+ 由本书作者轻微改动。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br></div></div><p>{% hint style=&quot;info&quot; %}</p>
<p><code>$@</code> 和 <code>$*</code> 仅在被双引号引用时才会表现出不同。</p>
<p>{% endhint %}</p>
<h4 id="样例-9-8-当-ifs-为空时-和-的表现"> 样例 9-8. 当 $IFS 为空时 $* 和 $@ 的表现</h4>
<div><pre><code><span>#!/bin/bash</span>

<span>#  如果 $IFS 被设置为空，</span>
<span>#+ 那么 "$*" 和 "$@" 将不会像期望的那样输出位置参数。</span>

mecho <span>(</span><span>)</span>       <span># 输出位置参数。</span>
<span>{</span>
<span>echo</span> <span>"<span>$1</span>,<span>$2</span>,<span>$3</span>"</span><span>;</span>
<span>}</span>


<span><span>IFS</span></span><span>=</span><span>""</span>         <span># 设置为空。</span>
<span>set</span> a b c      <span># 位置参数。</span>

mecho <span>"<span>$*</span>"</span>     <span># abc,,</span>
<span>#                   ^^</span>
mecho <span>$*</span>       <span># a,b,c</span>

mecho <span>$@</span>       <span># a,b,c</span>
mecho <span>"<span>$@</span>"</span>     <span># a,b,c</span>

<span>#  当 $IFS 为空时 $* 和 $@ 的行为</span>
<span>#+ 依赖于 Bash 或是 sh 所运行的版本。</span>
<span>#  因此不宜在脚本中使用这个“特性”。</span>


<span># 感谢 Stephane Chazelas。</span>

<span>exit</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="其他特殊参数"> 其他特殊参数</h2>
<h3 id="-4"> $-</h3>
<p>使用 <a href=""><code>set</code></a> 命令设置的脚本标记。参考 <a href="">样例 15-16</a>。</p>
<p>{% hint style=&quot;warning&quot; %}</p>
<p>这个参数最开始是从 ksh 引入到 Bash中的。但很遗憾的是，该参数在 Bash 脚本中并不能可靠地运行。该参数可能的一个用法是用于 <a href="">自检脚本是否可交互</a>。</p>
<p>{% endhint %}</p>
<h3 id="-5"> $!</h3>
<p>运行在后台的最后一个任务的 <a href="">进程ID</a>。</p>
<div><pre><code><span>LOG</span><span>=</span><span>$0</span>.log

<span>COMMAND1</span><span>=</span><span>"sleep 100"</span>

<span>echo</span> <span>"Logging PIDs background commands for script: <span>$0</span>"</span> <span>>></span> <span>"<span>$LOG</span>"</span>
<span># 这样就可以监控命令，并在必要的时候终止它们。</span>
<span>echo</span> <span>>></span> <span>"<span>$LOG</span>"</span>

<span># 记录命令。</span>

<span>echo</span> -n <span>"PID of <span title="\&quot;">\"</span><span>$COMMAND1</span><span title="\&quot;">\"</span>:  "</span> <span>>></span> <span>"<span>$LOG</span>"</span>
<span>${COMMAND1}</span> <span>&amp;</span>
<span>echo</span> <span>$!</span> <span>>></span> <span>"<span>$LOG</span>"</span>
<span># "sleep 100" 的 PID 是 1506</span>

<span># 感谢 Jacques Lederer 提出的该建议。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>将 <code>$!</code> 用于控制任务：</p>
<div><pre><code>possibly_hanging_job <span>&amp;</span> <span>{</span> <span>sleep</span> <span>${TIMEOUT}</span><span>;</span> <span>eval</span> <span>'kill -9 <span>$!</span>'</span> <span>&amp;></span> /dev/null<span>;</span> <span>}</span>
<span># 强制终止一个出错的程序。</span>
<span># 非常有用，例如可以用在启动脚本中。</span>

<span># 感谢 Sylvain Fourmanoit 提出的这个利用变量 "$!" 的创造性用法。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>也可以这么使用：</p>
<div><pre><code><span># 该样例由 Matthew Sage 编写。</span>
<span># 本书经授权后使用。</span>

<span>TIMEOUT</span><span>=</span><span>30</span>   <span># 以秒为单位的超时时间值。</span>
<span>count</span><span>=</span><span>0</span>

possibly_hanging_job <span>&amp;</span> <span>{</span>
        <span>while</span> <span><span>((</span>count <span>&lt;</span> TIMEOUT <span>))</span></span><span>;</span> <span>do</span>
                <span>eval</span> <span>'[ ! -d "/proc/<span>$!</span>" ] &amp;&amp; <span><span>((</span>count <span>=</span> TIMEOUT<span>))</span></span>'</span>
                <span># 当前运行进程的详细信息都可以在 /proc 中找到。</span>
                <span># "-d" 用于测试进程是否存在（即在 /proc 文件夹下该进程的文件夹是否存在）。</span>
                <span># 我们在等待出问题的任务出现。</span>
                <span><span>((</span>count<span>++</span><span>))</span></span>
                <span>sleep</span> <span>1</span>
        <span>done</span>
        <span>eval</span> <span>'[ -d "/proc/<span>$!</span>" ] &amp;&amp; kill -15 <span>$!</span>'</span>
        <span># 如果被挂起的任务正在运行就终止它。</span>
<span>}</span>

<span>#  -------------------------------------------------------------- #</span>

<span>#  然而，如果另外一个进程在 "hanging_job" 之后开始运行</span>
<span>#+ 该函数可能不能正常运行 ...</span>
<span>#  在那种情况下，一个非我们预期的任务会被终止。</span>
<span>#  Ariel Meragelman 提出了如下的解决方案。</span>

<span>TIMEOUT</span><span>=</span><span>30</span>
<span>count</span><span>=</span><span>0</span>

possibly_hanging_job <span>&amp;</span> <span>{</span>
    <span>while</span> <span><span>((</span>count <span>&lt;</span> TIMEOUT <span>))</span></span><span>;</span> <span>do</span>
            <span>eval</span> <span>'[ !-d "/proc/<span>$lastjob</span>" ] &amp;&amp; <span><span>((</span>count <span>=</span> TIMEOUT<span>))</span></span>'</span>
            <span>lastjob</span><span>=</span><span>$!</span>
            <span><span>((</span>count<span>++</span><span>))</span></span>
            <span>sleep</span> <span>1</span>
    <span>done</span>
    <span>eval</span> <span>'[ -d "/proc/<span>$lastjob</span>" ] &amp;&amp; kill -15 <span>$lastjob</span>'</span>
<span>}</span>

<span>exit</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h3 id="-6"> $_</h3>
<p>该变量被设置为上一个执行的命令的最后一个参数。</p>
<h4 id="样例-9-9-下划线变量"> 样例 9-9. 下划线变量</h4>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>$_</span>              <span>#  /bin/bash</span>
                     <span>#  仅通过调用 /bin/bash 执行该脚本。</span>
                     <span>#  注意这个结果会根据脚本如何被调用</span>
                     <span>#+ 而有所不同。</span>

<span>du</span> <span>></span>/dev/null        <span>#  这样命令就不会在命令行上有任何输出。</span>
<span>echo</span> <span>$_</span>              <span>#  du</span>

<span>ls</span> -al <span>></span>/dev/null    <span>#  这样命令就不会在命令行上有任何输出。</span>
<span>echo</span> <span>$_</span>              <span>#  -al (最后一个参数)</span>

<span>:</span>
<span>echo</span> <span>$_</span>              <span>#  :</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="-7"> $?</h3>
<p>命令、<a href="">函数</a> 或是脚本自身的 <a href="">退出状态</a>。参考 <a href="">样例 24-7</a>。</p>
<h3 id="-8"> $$</h3>
<p>脚本自身的进程 ID<sup></sup>。该变量 <code>$$</code> 通常在脚本构建独有的临时文件时被使用（参考 <a href="">样例 32-6</a>，<a href="">样例 16-31</a>，以及 <a href="">样例 15-27</a>）。该方法通常比调用 <a href=""><code>mktemp</code></a> 命令更简单。</p>
<h2 id="注记"> 注记</h2>
<p>{% hint style=&quot;info&quot; %}
栈寄存器是一段连续的内存空间，在该空间中，存入（压栈）的值是以倒序的方式取出（出栈）的。最后一个存入的值被最先取出。其通常又被称为后进先出(LIFO)或是下堆栈。
{% endhint %}</p>
<p>{% hint style=&quot;info&quot; %}
当前运行脚本的进程 ID 就是 <code>$$</code>。
{% endhint %}</p>
<p>{% hint style=&quot;info&quot; %}
类似于 <a href="">递归</a>。在本文中，嵌套是指代一种模式被嵌入在一种更大的模式中。在 1913 年出版的韦伯斯特大辞典中用一种更加优雅的方式解释了什么是嵌套：“一组按体积大小排列的盒子、箱子或是类似的东西，它们中的每一个都被放入到另一个更大的箱子中。(A collection of boxes, cases, or the like, of graduated size, each put within the one next larger.)”。
{% endhint %}</p>
<p>{% hint style=&quot;info&quot; %}
术语“变量(argument)”和“参数(parameter)”通常情况下是可以互相交换使用的。在本书中，它们具有相同的含义：传入脚本或函数的变量。
{% endhint %}</p>
<p>{% hint style=&quot;info&quot; %}
在 subshell 中运行的脚本，<code>$$</code> <a href="">返回脚本的进程 ID</a> 而非 subshell 的。
{% endhint %}</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>Footnotes placeholder </p>
</li>
<li id="footnote2"><p>Footnotes placeholder </p>
</li>
<li id="footnote3"><p>Footnotes placeholder </p>
</li>
<li id="footnote4"><p>Footnotes placeholder </p>
</li>
<li id="footnote5"><p>Footnotes placeholder </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">9.2.1 declare 的另类用法</title>
    <id>https://clay-wangzhi.com/code/shell/part3/09_2_1_another_use_for_declare/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/09_2_1_another_use_for_declare/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_9-2-1-declare-的另类用法"> 9.2.1 <code>declare</code> 的另类用法</h1>
<p><code>declare</code> 命令可以帮助用户识别变量、<a href="">环境变量</a> 或是其他信息，与 <a href="">数组</a> 搭配效果更佳。</p>
<div><pre><code>bash$ <span>declare</span> <span>|</span> <span>grep</span> <span>HOME</span>
<span><span>HOME</span></span><span>=</span>/home/bozo


bash$ <span>zzy</span><span>=</span><span>68</span>
bash$ <span>declare</span> <span>|</span> <span>grep</span> zzy
<span>zzy</span><span>=</span><span>68</span>


bash$ <span>Colors</span><span>=</span><span>(</span><span>[</span><span>0</span><span>]</span><span>=</span><span>"purple"</span> <span>[</span><span>1</span><span>]</span><span>=</span><span>"reddish-orange"</span> <span>[</span><span>2</span><span>]</span><span>=</span><span>"light green"</span><span>)</span>
bash$ <span>echo</span> <span>${Colors<span>[</span>@<span>]</span>}</span>
purple reddish-orange light green
bash$ <span>declare</span> <span>|</span> <span>grep</span> Colors
<span>Colors</span><span>=</span><span>(</span><span>[</span><span>0</span><span>]</span><span>=</span><span>"purple"</span> <span>[</span><span>1</span><span>]</span><span>=</span><span>"reddish-orange"</span> <span>[</span><span>2</span><span>]</span><span>=</span><span>"light green"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">9.2 变量类型标注：declare 与 typeset</title>
    <id>https://clay-wangzhi.com/code/shell/part3/09_2_typing_variables_declare_or_typeset/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/09_2_typing_variables_declare_or_typeset/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_9-2-变量类型标注-declare-与-typeset"> 9.2 变量类型标注：<code>declare</code> 与 <code>typeset</code></h1>
<p><a href="">内建命令</a> <code>declare</code> 和 <code>typeset</code> 是完全相同的命令，其被用于修改变量的属性。相比起一部分编程语言来说，这种修改属于非常弱的类型标注方式<sup></sup>。<code>declare</code> 命令只有在 Bash version 2 及更高版本才能使用，而 <code>typeset</code> 命令可以在 ksh 脚本中运行。</p>
<h2 id="declare-typeset-命令选项"> <code>declare</code>/<code>typeset</code> 命令选项</h2>
<h3 id="r-只读-readonly"> -r 只读（readonly）</h3>
<p>（<code>declare -r var1</code> 与 <code>readonly var1</code> 的作用相同）</p>
<p>该选项约等于 C 语言中的类型限定符 <code>const</code>。任何尝试修改只读变量的行为都会导致脚本出错。</p>
<div><pre><code><span>declare</span> -r <span>var1</span><span>=</span><span>1</span>
<span>echo</span> <span>"var1 = <span>$var1</span>"</span>   <span># var1 = 1</span>

<span><span>((</span> var1<span>++</span> <span>))</span></span>          <span># x.sh: line 4: var1: readonly variable</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="i-整型-integer"> -i 整型（integer）</h3>
<div><pre><code><span>declare</span> -i number
<span># 脚本会将之后所有出现的 "number" 变量的类型都视作整型。</span>

<span>number</span><span>=</span><span>3</span>
<span>echo</span> <span>"Number = <span>$number</span>"</span>     <span># Number = 3</span>

<span>number</span><span>=</span>three
<span>echo</span> <span>"Number = <span>$number</span>"</span>     <span># Number = 0</span>
<span># 脚本试图将字符串 "three" 视为整型。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>被视为整型的变量无需命令 <a href=""><code>expr</code></a> 或是 <a href=""><code>let</code></a> 即可进行数学运算。</p>
<div><pre><code><span>n</span><span>=</span><span>6</span>/3
<span>echo</span> <span>"n = <span>$n</span>"</span>       <span># n = 6/3</span>

<span>declare</span> -i n
<span>n</span><span>=</span><span>6</span>/3
<span>echo</span> <span>"n = <span>$n</span>"</span>       <span># n = 2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="a-数组-array"> -a 数组（array）</h3>
<div><pre><code><span>declare</span> -a indices
</code></pre>
<div><span>1</span><br></div></div><p>变量 <code>indices</code> 会被视作 <a href="">数组</a>。</p>
<h3 id="f-函数-function"> -f 函数（function）</h3>
<div><pre><code><span>declare</span> -f
</code></pre>
<div><span>1</span><br></div></div><p>如果没有在 <code>declare -f</code> 后带上任何参数，该语句将会列出在脚本中已经定义的所有函数。</p>
<div><pre><code><span>declare</span> -f function_name
</code></pre>
<div><span>1</span><br></div></div><p>而 <code>declare -f function_name</code> 则仅仅列出名为 <code>function_name</code> 的函数。</p>
<h3 id="x-导出-export"> -x 导出（export）</h3>
<div><pre><code><span>declare</span> -x var3
</code></pre>
<div><span>1</span><br></div></div><p>该语句声明了变量 <code>var3</code> 可以导出到该变量所属脚本之外的 shell 环境中。</p>
<h3 id="x-var-value"> -x var=$value</h3>
<div><pre><code><span>declare</span> -x <span>var3</span><span>=</span><span>373</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>declare</code> 命令允许在设置变量属性的同时给变量赋值。</p>
<h4 id="样例9-10-使用-declare-命令标注变量类型"> 样例9-10. 使用 <code>declare</code> 命令标注变量类型</h4>
<div><pre><code><span>#!/bin/bash</span>

<span>func1</span> <span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> This is a function.
<span>}</span>

<span>declare</span> -f        <span># 显示上面的所有函数。</span>

<span>echo</span>

<span>declare</span> -i var1   <span># var1 是一个整型变量。</span>
<span>var1</span><span>=</span><span>2367</span>
<span>echo</span> <span>"var1 declared as <span>$var1</span>"</span>
<span>var1</span><span>=</span>var1+1       <span># 整型变量的运算可以省略 let 命令。</span>
<span>echo</span> <span>"var1 incremented by 1 is <span>$var1</span>."</span>
<span># 尝试修改整型变量。</span>
<span>echo</span> <span>"Attempting to change var1 to floating point value, 2367.1."</span>
<span>var1</span><span>=</span><span>2367.1</span>       <span># 报错，并且 var1 的值并没有被修改。</span>
<span>echo</span> <span>"var1 is still <span>$var1</span>"</span>

<span>echo</span>

<span>declare</span> -r <span>var2</span><span>=</span><span>13.36</span>         <span># 'declare' 允许在设置变量属性时，</span>
                              <span>#+ 同时给变量赋值。</span>
<span>echo</span> <span>"var2 declared as <span>$var2</span>"</span> <span># 尝试修改只读变量。</span>
<span>var2</span><span>=</span><span>13.37</span>                    <span># 报错，然后脚本异常结束。</span>

<span>echo</span> <span>"var2 is still <span>$var2</span>"</span>    <span># 这行语句将不会被执行。</span>

<span>exit</span> <span>0</span>                        <span># 脚本也不会从这里结束。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>{% hint style=&quot;warning&quot; %}</p>
<p>使用内建命令 <code>declare</code> 还可以限制变量的 <a href="">作用域</a>。</p>
<div><pre><code><span>foo</span> <span>(</span><span>)</span>
<span>{</span>
<span>FOO</span><span>=</span><span>"bar"</span>
<span>}</span>

<span>bar</span> <span>(</span><span>)</span>
<span>{</span>
foo
<span>echo</span> <span>$FOO</span>
<span>}</span>

bar   <span># 输出 bar。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>但是...</p>
<div><pre><code><span>foo</span><span>(</span><span>)</span><span>{</span>
<span>declare</span> <span>FOO</span><span>=</span><span>"bar"</span>
<span>}</span>

<span>bar</span> <span>(</span><span>)</span>
<span>{</span>
foo
<span>echo</span> <span>$FOO</span>
<span>}</span>

bar  <span># 什么都不会输出。</span>


<span># 感谢 Michael Iatrou 指出这点。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>{% endhint %}</p>
<h2 id="注记"> 注记</h2>
<p>{% hint style=&quot;info&quot; %}
在本书中，变量类型标注（typing）是指指定变量类型并限制其属性。例如一个变量被 <code>declared</code> 或是 <code>typed</code> 命令声明为整型，则该变量不再适用于各种 <a href="">字符串操作</a>。</p>
<div><pre><code><span>declare</span> -i intvar

<span>intvar</span><span>=</span><span>23</span>
<span>echo</span> <span>"<span>$intvar</span>"</span>   <span># 23</span>
<span>intvar</span><span>=</span>stringval
<span>echo</span> <span>"<span>$intvar</span>"</span>   <span># 0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>{% endhint %}</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>Footnotes placeholder </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">9.3 $RANDOM：生成随机数</title>
    <id>https://clay-wangzhi.com/code/shell/part3/09_3_random_generate_random_integer/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/09_3_random_generate_random_integer/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_9-3-random-生成随机数"> 9.3 <code>$RANDOM</code>：生成随机数</h1>
<blockquote>
<p>任何试图通过确定性方法生成随机数的行为都是在犯罪。</p>
<p>—— 约翰·冯·诺伊曼</p>
</blockquote>
<p><code>$RANDOM</code> 是 Bash 中用来生成 0 至 32767 之间随机整数<sup></sup>的一个内置 <a href="">函数</a>（而非常量）。其<strong>不应</strong>被用于生成密钥。</p>
<h4 id="样例-9-11-生成随机数"> 样例 9-11. 生成随机数</h4>
<div><pre><code><span>#!/bin/bash</span>

<span># $RANDOM 每一次调用都会返回一个随机的不同的整数。</span>
<span># 随机数的标称范围为 0 - 32767（16位有符号整型）。</span>

<span>MAXCOUNT</span><span>=</span><span>10</span>
<span>count</span><span>=</span><span>1</span>

<span>echo</span>
<span>echo</span> <span>"<span>$MAXCOUNT</span> random numbers:"</span>
<span>echo</span> <span>"-----------------"</span>
<span>while</span> <span>[</span> <span>"<span>$count</span>"</span> -le <span>$MAXCOUNT</span> <span>]</span>      <span># 生成 10 ($MAXCOUNT) 个随机整数。</span>
<span>do</span>
  <span>number</span><span>=</span><span>$RANDOM</span>
  <span>echo</span> <span>$number</span>
  <span>let</span> <span>"count += 1"</span>  <span># 增加计数。</span>
<span>done</span>
<span>echo</span> <span>"-----------------"</span>

<span># 如果你需要一个小于指定上界的随机数，可以使用 'modulo' 操作符。</span>
<span># 该操作符可以返回除法后的余数。</span>

<span>RANGE</span><span>=</span><span>500</span>

<span>echo</span>

<span>number</span><span>=</span><span>$RANDOM</span>
<span>let</span> <span>"number %= <span>$RANGE</span>"</span>
<span>#           ^^</span>
<span>echo</span> <span>"Random number less than <span>$RANGE</span> --- <span>$number</span>"</span>

<span>echo</span>



<span>#  如果你需要生成的随机数大于一个指定的下界，</span>
<span>#+ 可以增加一步判断，判别并丢弃所有小于下界的数。</span>

<span>FLOOR</span><span>=</span><span>200</span>

<span>number</span><span>=</span><span>0</span>   <span># 初始化</span>
<span>while</span> <span>[</span> <span>"<span>$number</span>"</span> -le <span>$FLOOR</span> <span>]</span>
<span>do</span>
  <span>number</span><span>=</span><span>$RANDOM</span>
<span>done</span>
<span>echo</span> <span>"Random number greater than <span>$FLOOR</span> --- <span>$number</span>"</span>
<span>echo</span>

   <span># 现在来看一种可以代替上面循环的更简单的方式，也就是</span>
   <span>#       let "number = $RANDOM + $FLOOR"</span>
   <span># 该方式可以不使用 while 循环，效率更高。</span>
   <span># 但是，该方法可能会产生一些问题，是什么呢？</span>



<span># 通过结合上面的两种方法，可以获得一个特定范围内的随机数。</span>
<span>number</span><span>=</span><span>0</span>   <span># 初始化</span>
<span>while</span> <span>[</span> <span>"<span>$number</span>"</span> -le <span>$FLOOR</span> <span>]</span>
<span>do</span>
  <span>number</span><span>=</span><span>$RANDOM</span>
  <span>let</span> <span>"number %= <span>$RANGE</span>"</span>  <span># 将 $number 缩小至 $RANGE 的范围内。</span>
<span>done</span>
<span>echo</span> <span>"Random number between <span>$FLOOR</span> and <span>$RANGE</span> --- <span>$number</span>"</span>
<span>echo</span>



<span># 生成二元选择值，即真(true)或假(false)。</span>
<span>BINARY</span><span>=</span><span>2</span>
<span>T</span><span>=</span><span>1</span>
<span>number</span><span>=</span><span>$RANDOM</span>

<span>let</span> <span>"number %= <span>$BINARY</span>"</span>
<span>#  如果使用    let "number >>= 14"    可以获得更优的随机分布</span>
<span>#+ （除了最低位，其余二进制位都右移）。</span>
<span>if</span> <span>[</span> <span>"<span>$number</span>"</span> -eq <span>$T</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"TRUE"</span>
<span>else</span>
  <span>echo</span> <span>"FALSE"</span>
<span>fi</span>

<span>echo</span>


<span># 扔一个骰子。</span>
<span>SPOTS</span><span>=</span><span>6</span>   <span># 模 6 的余数范围为 0 - 5。</span>
          <span># 然后加 1 就可以得到期望的范围 1 - 6。</span>
          <span># 感谢 Paulo Marcel Coelho Aragao 简化了代码。</span>
<span>die1</span><span>=</span><span>0</span>
<span>die2</span><span>=</span><span>0</span>
<span># 如果设置 SPOTS=7 就可以不用加 1 得到值。这是不是一种更好的方法，为什么？</span>

<span># 为了保证公平，独立的投每一个骰子。</span>

    <span>let</span> <span>"die1 = <span>$RANDOM</span> % <span>$SPOTS</span> + 1"</span> <span># 投第一个骰子。</span>
    <span>let</span> <span>"die2 = <span>$RANDOM</span> % <span>$SPOTS</span> + 1"</span> <span># 投第二个骰子。</span>
    <span>#  哪一种运算符有更高的优先级，</span>
    <span>#+ 取余(%)还是加法(+)？</span>


<span>let</span> <span>"throw = <span>$die1</span> + <span>$die2</span>"</span>
<span>echo</span> <span>"Throw of the dice = <span>$throw</span>"</span>
<span>echo</span>


<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br></div></div><h4 id="样例-9-12-从牌组中随机选牌"> 样例 9-12. 从牌组中随机选牌</h4>
<div><pre><code><span>#!/bin/bash</span>
<span># pick-card.sh</span>

<span># 该样例演示了如何从数组中随机选择元素。</span>


<span># 随机选择任意一张牌。</span>

<span>Suites</span><span>=</span><span>"Clubs
Diamonds
Hearts
Spades"</span>

<span>Denominations</span><span>=</span><span>"2
3
4
5
6
7
8
9
10
Jack
Queen
King
Ace"</span>

<span># 注意一个变量占了多行。</span>


<span>suite</span><span>=</span><span>(</span><span>$Suites</span><span>)</span>                <span># 读入数组变量。</span>
<span>denomination</span><span>=</span><span>(</span><span>$Denominations</span><span>)</span>

<span>num_suites</span><span>=</span><span>${<span>#</span>suite<span>[</span>*<span>]</span>}</span>        <span># 数组中的元素数量。</span>
<span>num_denominations</span><span>=</span><span>${<span>#</span>denomination<span>[</span>*<span>]</span>}</span>

<span>echo</span> -n <span>"<span>${denomination<span>[</span>$((RANDOM<span>%</span>num_denominations))<span>]</span>}</span> of "</span>
<span>echo</span> <span>${suite<span>[</span>$((RANDOM<span>%</span>num_suites))<span>]</span>}</span>


<span># $bozo sh pick-cards.sh</span>
<span># Jack of Clubs</span>


<span># 感谢 jipe 指出可以用 $RANDOM 随机选牌。</span>
<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h4 id="example-9-13-模拟布朗运动"> Example 9-13. 模拟布朗运动</h4>
<div><pre><code><span>#!/bin/bash</span>
<span># brownian.sh</span>
<span># 作者：Mendel Cooper</span>
<span># 发布日期：10/26/07</span>
<span># 开源协议：GPL3</span>

<span>#  ----------------------------------------------------------------</span>
<span>#  该脚本模拟了布朗运动。</span>
<span>#+ 布朗运动是指微小粒子受到流体粒子随机碰撞，</span>
<span>#+ 而在流体中做的无规则随机运动。</span>
<span>#+ 也就是俗称的“醉汉走路”。</span>

<span>#  布朗运动也可以被视作是一个简化的高尔顿板。</span>
<span>#+ 高尔顿板是一个有着交错排列的钉子的倾斜板子，</span>
<span>#+ 每次可以从中向下滚动一堆石子。</span>
<span>#+ 在板子底端是一排槽位，</span>
<span>#+ 石子最后会落在槽位中。</span>
<span>#  把它想象成一个简单的弹珠游戏就可以了。</span>
<span>#  当运行这个脚本之后，</span>
<span>#+ 你就会发现大部分的石子都聚集在中间的槽位里。</span>
<span>#+ 这与预期的二项分布相符。</span>
<span>#  作为模拟高尔顿板的程序，</span>
<span>#+ 脚本忽略了许多参数，</span>
<span>#+ 例如板子的倾斜角度、石子滚动的摩擦系数、</span>
<span>#+ 冲击角度以及钉子的弹性系数等等。</span>
<span>#  忽略的这些参数能够在多大程度上影响模拟的精度？</span>
<span>#  -------------------------------------------------------------</span>

<span>PASSES</span><span>=</span><span>500</span>            <span>#  粒子作用数 / 石子数。</span>
<span>ROWS</span><span>=</span><span>10</span>               <span>#  碰撞数 / 每一排钉子的数量。</span>
<span>RANGE</span><span>=</span><span>3</span>               <span>#  $RANDOM 的输出范围为 0 - 2。</span>
<span>POS</span><span>=</span><span>0</span>                 <span>#  滚落左侧或是右侧。</span>
<span><span>RANDOM</span></span><span>=</span><span>$$</span>             <span>#  将脚本的进程 ID 作为</span>
                      <span>#+ 生成随机数的种子。</span>

<span>declare</span> -a Slots      <span># 用于储存落入每一个槽位的石子数量。</span>
<span>NUMSLOTS</span><span>=</span><span>21</span>           <span># 底部槽位的数量。</span>


<span>Initialize_Slots</span> <span>(</span><span>)</span> <span>{</span> <span># 初始化数组。</span>
<span>for</span> <span>i</span> <span>in</span> <span><span>$(</span> <span>seq</span> $NUMSLOTS <span>)</span></span>
<span>do</span>
  Slots<span>[</span><span>$i</span><span>]</span><span>=</span><span>0</span>
<span>done</span>

<span>echo</span>                  <span># 在正式模拟开始之前先输出空行。</span>
  <span>}</span>


<span>Show_Slots</span> <span>(</span><span>)</span> <span>{</span>
<span>echo</span><span>;</span> <span>echo</span>
<span>echo</span> -n <span>" "</span>
<span>for</span> <span>i</span> <span>in</span> <span><span>$(</span> <span>seq</span> $NUMSLOTS <span>)</span></span>   <span># 更精致地输出数组中的所有元素。</span>
<span>do</span>
  <span>printf</span> <span>"%3d"</span> <span>${Slots<span>[</span>$i<span>]</span>}</span>   <span># 每个结果都占三个字符的宽度。</span>
<span>done</span>

<span>echo</span> <span># 槽位：</span>
<span>echo</span> <span>" |__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|"</span>
<span>echo</span> <span>"                                ||"</span>
<span>echo</span> <span>#  需要注意的是，如果任意一个槽位中石子的数量超过 99，</span>
     <span>#+ 将会打乱整个程序的显示效果。</span>
     <span>#  如果只运行 500 次通常可以避免这个问题。</span>
  <span>}</span>


<span>Move</span> <span>(</span><span>)</span> <span>{</span>              <span># 将一个单位左移、右移或保持原地不动。</span>
  <span>Move</span><span>=</span><span>$RANDOM</span>         <span># $RANDOM 到底有多随机？让我们看看...</span>
  <span>let</span> <span>"Move %= RANGE"</span>  <span># 标准化至范围 0 - 2。</span>
  <span>case</span> <span>"<span>$Move</span>"</span> <span>in</span>
    <span>0</span> <span>)</span> <span>;</span><span>;</span>                   <span># 什么也不做，也就是原地不动。</span>
    <span>1</span> <span>)</span> <span><span>((</span>POS<span>--</span><span>))</span></span><span>;</span><span>;</span>          <span># 左移。</span>
    <span>2</span> <span>)</span> <span><span>((</span>POS<span>++</span><span>))</span></span><span>;</span><span>;</span>          <span># 右移。</span>
    * <span>)</span> <span>echo</span> -n <span>"Error "</span><span>;</span><span>;</span>   <span># 出现异常！（应该永远不会发生）</span>
  <span>esac</span>
  <span>}</span>


<span>Play</span> <span>(</span><span>)</span> <span>{</span>                    <span># 模拟单次运行（内部循环）。</span>
<span>i</span><span>=</span><span>0</span>
<span>while</span> <span>[</span> <span>"<span>$i</span>"</span> -lt <span>"<span>$ROWS</span>"</span> <span>]</span>   <span># 每一排钉子经过且仅经过一次石子。</span>
<span>do</span>
  Move
  <span><span>((</span>i<span>++</span><span>))</span></span><span>;</span>
<span>done</span>

<span>SHIFT</span><span>=</span><span>11</span>                     <span># 为什么是 11 而不是 10？</span>
<span>let</span> <span>"POS += <span>$SHIFT</span>"</span>          <span># 将原点移到中间。</span>
<span><span>((</span> Slots[$POS]<span>++</span> <span>))</span></span>          <span># 调试：echo $POS</span>

<span># echo -n "$POS "</span>

  <span>}</span>


<span>Run</span> <span>(</span><span>)</span> <span>{</span>                     <span># 外部循环。</span>
<span>p</span><span>=</span><span>0</span>
<span>while</span> <span>[</span> <span>"<span>$p</span>"</span> -lt "<span>$PASSES</span> <span>]</span>
<span>do</span>
  Play
  <span><span>((</span> p<span>++</span> <span>))</span></span>
  <span>POS</span><span>=</span><span>0</span>                      <span># 重置为 0。为什么要这么做？</span>
<span>done</span>
  <span>}</span>


<span># --------------</span>
<span># main ()</span>
Initialize_Slots
Run
Show_Slots
<span># --------------</span>

<span>exit</span> <span>$?</span>

<span>#  练习：</span>
<span>#  ---------</span>
<span>#  1) 将结果显示为一张直方图，</span>
<span>#+    或者是一张散点图。</span>
<span>#  2) 修改脚本，使用 /dev/urandom 提到 $RANDOM。</span>
<span>#     这会使脚本更加的随机化么？</span>
<span>#  3) 当每一个石子落下的时候，</span>
<span>#+    尝试添加一些动画效果。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br></div></div><p>Jipe 提供了一些生成指定范围内随机数的方法。</p>
<div><pre><code><span>#  生成范围为 6 到 30 的随机数。</span>
   <span>rnumber</span><span>=</span><span><span>$((</span>RANDOM<span>%</span><span>25</span><span>+</span><span>6</span><span>))</span></span>

<span>#  生成范围为 6 到 30 的随机数，</span>
<span>#+ 并且该随机数能被 3 整除。</span>
   <span>rnumber</span><span>=</span><span><span>$((</span><span>(</span>RANDOM<span>%</span><span>30</span><span>/</span><span>3</span><span>+</span><span>1</span><span>)</span><span>*</span><span>3</span><span>))</span></span>

<span>#  需要注意这种方法并不是在所有情况下都能起效。</span>
<span>#  会在 $RANDOM%30 为 0 时失效。</span>

<span>#  Frank Wang 建议可以换用下面的方法：</span>
   <span>rnumber</span><span>=</span><span><span>$((</span> RANDOM<span>%</span><span>27</span><span>/</span><span>3</span><span>*</span><span>3</span><span>+</span><span>6</span> <span>))</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>Bill Gradwohl 提出了一种改良后的仅适用于正数的公式。</p>
<div><pre><code><span>rnumber</span><span>=</span><span><span>$((</span><span>(</span>RANDOM<span>%</span><span>(</span>max<span>-</span>min<span>+</span>divisibleBy<span>))</span></span>/divisibleBy*divisibleBy+min<span>))</span>
</code></pre>
<div><span>1</span><br></div></div><p>Bill 在这还给出了一个生成指定范围内随机数的通用函数。</p>
<h4 id="样例-9-14-指定范围随机数"> 样例 9-14. 指定范围随机数</h4>
<div><pre><code><span>#!/bin/bash</span>
<span># random-between.sh</span>
<span># 生成指定范围内的随机数。</span>
<span># 本书作者在 Bill Gradwhol 所提供的脚本的基础上作了些细微修改。</span>
<span># Anthony Le Clezio 修正了 187 行和 189 行。</span>
<span># 本书被授权使用该脚本。</span>


<span>randomBetween</span><span>(</span><span>)</span> <span>{</span>
   <span>#  生成一个范围在 $min 和 $max 之间，</span>
   <span>#+ 并且能被 $divisibleBy 整除的</span>
   <span>#+ 随机正数或负数。</span>
   <span>#  返回的随机数遵循合理的随机分布。</span>
   
   <span>#  Bill Gradwohl - Oct 1, 2003</span>
   
   <span>syntax</span><span>(</span><span>)</span> <span>{</span>
   <span># 嵌套函数。</span>
      <span>echo</span>
      <span>echo</span>    <span>"Syntax: randomBetween [min] [max] [multiple]"</span>
      <span>echo</span>
      <span>echo</span> -n <span>"Expects up to 3 passed parameters, "</span>
      <span>echo</span>    <span>"but all are completely optional."</span>
      <span>echo</span>    <span>"min is the minimum value"</span>
      <span>echo</span>    <span>"max is the maximum value"</span>
      <span>echo</span> -n <span>"multiple specifies that the answer must be "</span>
      <span>echo</span>     <span>"a multiple of this value."</span>
      <span>echo</span>    <span>"    i.e. answer must be evenly divisible by this number."</span>
      <span>echo</span>
      <span>echo</span>    <span>"If any value is missing, defaults area supplied as: 0 32767 1"</span>
      <span>echo</span> -n <span>"Successful completion returns 0, "</span>
      <span>echo</span>      <span>"unsuccessful completion returns"</span>
      <span>echo</span>    <span>"function syntax and 1."</span>
      <span>echo</span> -n <span>"The answer is returned in the global variable "</span>
      <span>echo</span>    <span>"randomBetweenAnswer"</span>
      <span>echo</span> -n <span>"Negative values for any passed parameter are "</span>
      <span>echo</span>    <span>"handled correctly."</span>
   <span>}</span>
   
   <span>local</span> <span>min</span><span>=</span><span>${1<span>:-</span>0}</span>
   <span>local</span> <span>max</span><span>=</span><span>${2<span>:-</span>32767}</span>
   <span>local</span> <span>divisibleBy</span><span>=</span><span>${3<span>:-</span>1}</span>
   <span># 考虑到没有给函数传参的情况，给变量设置默认值。</span>
   
   <span>local</span> x
   <span>local</span> spread
   
   <span># 确保 divisibleBy 的值为正数。</span>
   <span>[</span> <span>${divisibleBy}</span> -lt <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>divisibleBy</span><span>=</span><span><span>$((</span><span>0</span><span>-</span>divisibleBy<span>))</span></span>
   
   <span># 合规校验。</span>
   <span>if</span> <span>[</span> <span>$#</span> -gt <span>3</span> -o <span>${divisibleBy}</span> -eq <span>0</span> -o  <span>${min}</span> -eq <span>${max}</span> <span>]</span><span>;</span> <span>then</span>
      syntax
      <span>return</span> <span>1</span>
   <span>fi</span>
   
   <span># 检查 min 和 max 的值是否颠倒。</span>
   <span>if</span> <span>[</span> <span>${min}</span> -gt <span>${max}</span> <span>]</span><span>;</span> <span>then</span>
      <span># 交换它们。</span>
      <span>x</span><span>=</span><span>${min}</span>
      <span>min</span><span>=</span><span>${max}</span>
      <span>max</span><span>=</span><span>${x}</span>
   <span>fi</span>
   
   <span>#  如果 min 值本身不能被 $divisibleBy 整除，</span>
   <span>#+ 则将其修正到范围内。</span>
   <span>if</span> <span>[</span> <span><span>$((</span>min<span>/</span>divisibleBy<span>*</span>divisibleBy<span>))</span></span> -ne <span>${min}</span> <span>]</span><span>;</span> <span>then</span>
      <span>if</span> <span>[</span> <span>${min}</span> -lt <span>0</span> <span>]</span><span>;</span> <span>then</span>
         <span>min</span><span>=</span><span><span>$((</span>min<span>/</span>divisibleBy<span>*</span>divisibleBy<span>))</span></span>
      <span>else</span>
         <span>min</span><span>=</span><span><span>$((</span><span>((</span>min<span>/</span>divisibleBy<span>)</span><span>+</span><span>1</span><span>)</span><span>*</span>divisibleBy<span>))</span></span>
      <span>fi</span>
   <span>fi</span>
   
   <span>#  如果 max 值本身不能被 $divisibleBy 整除，</span>
   <span>#+ 则将其修正到范围内。</span>
   <span>if</span> <span>[</span> <span><span>$((</span>max<span>/</span>divisibleBy<span>*</span>divisibleBy<span>))</span></span> -ne <span>${max}</span> <span>]</span><span>;</span> <span>then</span>
      <span>if</span> <span>[</span> <span>${max}</span> -lt <span>0</span> <span>]</span><span>;</span> <span>then</span>
         <span>max</span><span>=</span><span><span>$((</span><span>((</span>max<span>/</span>divisibleBy<span>)</span><span>-</span><span>1</span><span>)</span><span>*</span>divisibleBy<span>))</span></span>
      <span>else</span>
         <span>max</span><span>=</span><span><span>$((</span>max<span>/</span>divisibleBy<span>*</span>divisibleBy<span>))</span></span>
      <span>fi</span>
   <span>fi</span>

   <span>#  ---------------------------------------------------------------------</span>
   <span>#  接下来开始真正的内容。</span>
   
   <span>#  需要注意的是，为了得到端点间合理的随机分布，</span>
   <span>#+ 随机数的取值范围应是 0 至 abs(max-min)+divisibleBy，</span>
   <span>#+ 而不是简单的 abs(max-min)+1。</span>
   
   <span>#  少量的增长将会带来端点间</span>
   <span>#+ 合理的随机分布。</span>
   
   <span>#  将公式修改为使用 abs(max-min)+1 仍然可以得到正确的答案，</span>
   <span>#+ 但是获得的这些随机数的随机性是有缺陷的，</span>
   <span>#+ 因为这种情况下返回的端点值 ($min 和 $max) 的次数远少于</span>
   <span>#+ 使用正确公式时所返回的次数。</span>
   <span>#  ---------------------------------------------------------------------</span>

   <span>spread</span><span>=</span><span><span>$((</span>max<span>-</span>min<span>))</span></span>
   <span>#  Omair Eshkenazi 指出在这里没有必要进行校验，</span>
   <span>#+ 因为 max 和 min 的值已经被交换了。</span>
   <span>[</span> <span>${spread}</span> -lt <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>spread</span><span>=</span><span><span>$((</span><span>0</span><span>-</span>spread<span>))</span></span>
   <span>let</span> <span>spread</span><span>+=</span>divisibleBy
   <span>randomBetweenAnswer</span><span>=</span><span><span>$((</span><span>(</span>RANDOM<span>%</span>spread<span>)</span><span>/</span>divisibleBy<span>*</span>divisibleBy<span>+</span>min<span>))</span></span>
   
   <span>return</span> <span>0</span>
   
   <span>#  但是 Paulo Marcel Coelho Aragao 指出</span>
   <span>#+ 当 $max 和 $min 不能被 $divisibleBy 整除时，</span>
   <span>#+ 该公式就会失效。</span>
   <span>#</span>
   <span>#  他建议替换为下面的公式：</span>
   <span>#    rnumber = $(((RANDOM%(max-min+1)+min)/divisibleBy*divisibleBy))</span>
   
<span>}</span>

<span># 接下来测试函数。</span>
<span>min</span><span>=</span>-14
<span>max</span><span>=</span><span>20</span>
<span>divisibleBy</span><span>=</span><span>3</span>


<span>#  循环执行足够多次数的函数，生成包含这些随机数的数组，</span>
<span>#+ 然后校验数组中是否包含了端点范围内的每一个数字。</span>

<span>declare</span> -a answer
<span>minimum</span><span>=</span><span>${min}</span>
<span>maximum</span><span>=</span><span>${max}</span>
   <span>if</span> <span>[</span> <span><span>$((</span>minimum<span>/</span>divisibleBy<span>*</span>divisibleBy<span>))</span></span> -ne <span>${minimum}</span> <span>]</span><span>;</span> <span>then</span>
      <span>if</span> <span>[</span> <span>${minimum}</span> -lt <span>0</span> <span>]</span><span>;</span> <span>then</span>
         <span>minimum</span><span>=</span><span><span>$((</span>minimum<span>/</span>divisibleBy<span>*</span>divisibleBy<span>))</span></span>
      <span>else</span>
         <span>minimum</span><span>=</span><span><span>$((</span><span>((</span>minimum<span>/</span>divisibleBy<span>)</span><span>+</span><span>1</span><span>)</span><span>*</span>divisibleBy<span>))</span></span>
      <span>fi</span>
   <span>fi</span>
   
   
   <span>#  如果 max 值本身不能被 $divisibleBy 整除，</span>
   <span>#+ 则将其修正到范围内。</span>
   
   <span>if</span> <span>[</span> <span><span>$((</span>maximum<span>/</span>divisibleBy<span>*</span>divisibleBy<span>))</span></span> -ne <span>${maximum}</span> <span>]</span><span>;</span> <span>then</span>
      <span>if</span> <span>[</span> <span>${maximum}</span> -lt <span>0</span> <span>]</span><span>;</span> <span>then</span>
         <span>maximum</span><span>=</span><span><span>$((</span><span>((</span>maximum<span>/</span>divisibleBy<span>)</span><span>-</span><span>1</span><span>)</span><span>*</span>divisibleBy<span>))</span></span>
      <span>else</span>
         <span>maximum</span><span>=</span><span><span>$((</span>maximum<span>/</span>divisibleBy<span>*</span>divisibleBy<span>))</span></span>
      <span>fi</span>
   <span>fi</span>


<span>#  需要保证数组的下标只能为正数，</span>
<span>#+ 因此这里需要通过位移来保证</span>
<span>#+ 结果为正。</span>

<span>disp</span><span>=</span><span><span>$((</span><span>0</span><span>-</span>minimum<span>))</span></span>
<span>for</span> <span><span>((</span>i<span>=</span>${minimum}<span>;</span> i<span>&lt;=</span>${maximum}<span>;</span> i<span>+</span><span>=</span>divisibleBy<span>))</span></span><span>;</span> <span>do</span>
   answer<span>[</span>i+disp<span>]</span><span>=</span><span>0</span>
<span>done</span>


<span># 现在开始循环执行函数以获得大量的随机数。</span>
<span>loopIt</span><span>=</span><span>1000</span>   <span>#  脚本的作者建议使用 100000，</span>
              <span>#+ 但是这会花费大量的时间。</span>
              
<span>for</span> <span><span>((</span>i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span>${loopIt}<span>;</span> i<span>++</span><span>))</span></span><span>;</span> <span>do</span>

   <span>#  注意，我们在这里颠倒了 min 和 max 的值，</span>
   <span>#+ 为的是校验函数在这种情况下是否能正常执行。</span>
   
   randomBetween <span>${max}</span> <span>${min}</span> <span>${divisibleBy}</span>
   
   <span># 如果获得了非预期的答案，则报错。</span>
   <span>[</span> <span>${randomBetweenAnswer}</span> -lt <span>${min}</span> -o <span>${randomBetweenAnswer}</span> -gt <span>${max}</span> <span>]</span> <span>\</span>
   <span>&amp;&amp;</span> <span>echo</span> MIN or MAX error - <span>${randomBetweenAnswer}</span><span>!</span>
   <span>[</span> <span><span>$((</span>randomBetweenAnswer<span>%</span>${divisibleBy}<span>))</span></span> -ne <span>0</span> <span>]</span> <span>\</span>
   <span>&amp;&amp;</span> <span>echo</span> DIVISIBLE BY error - <span>${randomBetweenAnswer}</span><span>!</span>
   
   <span># 保存统计结果。</span>
   answer<span>[</span>randomBetweenAnswer+disp<span>]</span><span>=</span><span><span>$((</span>answer[randomBetweenAnswer<span>+</span>disp]<span>+</span><span>1</span><span>))</span></span>
<span>done</span>



<span># 校验最终结果。</span>

<span>for</span> <span><span>((</span>i<span>=</span>${minimum}<span>;</span> i<span>&lt;=</span>${maximum}<span>;</span> i<span>+</span><span>=</span>divisibleBy<span>))</span></span><span>;</span> <span>do</span>
   <span>[</span> <span>${answer<span>[</span>i+disp<span>]</span>}</span> -eq <span>0</span> <span>]</span> <span>\</span>
   <span>&amp;&amp;</span> <span>echo</span> <span>"We never got an answer of <span>$i</span>."</span> <span>\</span>
   <span>||</span> <span>echo</span> <span>"<span>${i}</span> occurred <span>${answer<span>[</span>i+disp<span>]</span>}</span> times."</span>
<span>done</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br></div></div><p>那么 <code>$RANDOM</code> 到底有多随机？最好的测试方法就是写一个脚本跟踪由 <code>$RANDOM</code> 生成的随机数的分布。接下来让我们多投几次由 <code>$RANDOM</code> 做的骰子...</p>
<h4 id="样例-9-15-用-random-投骰子"> 样例 9-15. 用 <code>RANDOM</code> 投骰子</h4>
<div><pre><code><span>#!/bin/bash</span>
<span># RANDOM 有多随机？</span>

<span><span>RANDOM</span></span><span>=</span><span>$$</span>       <span># 用脚本的进程 ID 重置随机数生成器种子。</span>

<span>PIPS</span><span>=</span><span>6</span>          <span># 骰子有 6 个点。</span>
<span>MAXTHORWS</span><span>=</span><span>600</span>   <span># 如果你没有更好消磨时间的办法，就增加这个值。</span>
                <span># 投骰子的次数。</span>

<span>ones</span><span>=</span><span>0</span>          <span>#  必须初始化计数器的值为 0，</span>
<span>twos</span><span>=</span><span>0</span>          <span>#+ 因为未初始化的变量的值为 null 而非 0。</span>
<span>threes</span><span>=</span><span>0</span>
<span>fours</span><span>=</span><span>0</span>
<span>fives</span><span>=</span><span>0</span>
<span>sixes</span><span>=</span><span>0</span>

<span>print_result</span> <span>(</span><span>)</span>
<span>{</span>
<span>echo</span>
<span>echo</span> <span>"ones =   <span>$ones</span>"</span>
<span>echo</span> <span>"twos =   <span>$twos</span>"</span>
<span>echo</span> <span>"threes = <span>$threes</span>"</span>
<span>echo</span> <span>"fours =  <span>$fours</span>"</span>
<span>echo</span> <span>"fives =  <span>$fives</span>"</span>
<span>echo</span> <span>"sixes =  <span>$sixes</span>"</span>
<span>echo</span>
<span>}</span>

<span>update_count</span><span>(</span><span>)</span>
<span>{</span>
<span>case</span> <span>"<span>$1</span>"</span> <span>in</span>
  <span>0</span><span>)</span> <span><span>((</span>ones<span>++</span><span>))</span></span><span>;</span><span>;</span>   <span># 因为骰子没有 0 点，所以这个其实对应的是 1 点。</span>
  <span>1</span><span>)</span> <span><span>((</span>twos<span>++</span><span>))</span></span><span>;</span><span>;</span>   <span># 这个对应 2 点。</span>
  <span>2</span><span>)</span> <span><span>((</span>threes<span>++</span><span>))</span></span><span>;</span><span>;</span> <span># 以此类推。</span>
  <span>3</span><span>)</span> <span><span>((</span>fours<span>++</span><span>))</span></span><span>;</span><span>;</span>
  <span>4</span><span>)</span> <span><span>((</span>fives<span>++</span><span>))</span></span><span>;</span><span>;</span>
  <span>5</span><span>)</span> <span><span>((</span>sixes<span>++</span><span>))</span></span><span>;</span><span>;</span>
<span>esac</span>
<span>}</span>

<span>echo</span>


<span>while</span> <span>[</span> <span>"<span>$throw</span>"</span> -lt <span>"<span>$MAXTHROWS</span>"</span> <span>]</span>
<span>do</span>
  <span>let</span> <span>"die1 = RANDOM % <span>$PIPS</span>"</span>
  update_count <span>$die1</span>
  <span>let</span> <span>"throw += 1"</span>
<span>done</span>

print_result

<span>exit</span> <span>$?</span>

<span>#  假设 RANDOM 是真随机，那么计数结果应该均匀分布。</span>
<span>#  当 $MAXTHROWS 的值为 600 时，每一个计数器的值都应该在 100 左右，</span>
<span>#+ 上下浮动大约 20。</span>
<span>#</span>
<span>#  记住 RANDOM 是一个 ***伪随机*** 生成器，</span>
<span>#+ 并且也不是其中最优秀的那一个。</span>

<span>#  随机化是一个很深奥且复杂的话题。</span>
<span>#  足够长的“随机”序列可能会出现一些</span>
<span>#+ 混乱或其他非随机化的表现。</span>

<span># 练习（简单）：</span>
<span># ---------------</span>
<span># 重写脚本，修改为投掷硬币 1000 次。</span>
<span># 显示为正面 "HEADS" 和背面 "TAILS"。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><p>从上一个样例中我们可以发现，在每次调用 <code>RANDOM</code> 生成器时，最好利用重置生成器种子。在 <code>RANDOM</code> 生成器中使用相同的种子会生成相同序列的随机数。<sup></sup>（与 C 语言中的 <code>random()</code> 函数的行为一致）</p>
<h4 id="样例-9-16-重置-random-种子"> 样例 9-16. 重置 <code>RANDOM</code> 种子</h4>
<div><pre><code><span>#!/bin/bash</span>
<span># seeding-random.sh: 设置 RANDOM 变量的种子。</span>
<span># 版本号 1.1, 发布日期 09 Feb 2013</span>

<span>MAXCOUNT</span><span>=</span><span>25</span>       <span># 生成随机数的个数。</span>
<span>SEED</span><span>=</span>

<span>random_numbers</span> <span>(</span><span>)</span>
<span>{</span>
<span>local</span> <span>count</span><span>=</span><span>0</span>
<span>local</span> number

<span>while</span> <span>[</span> <span>"<span>$count</span>"</span> -lt <span>"<span>$MAXCOUNT</span>"</span> <span>]</span>
<span>do</span>
  <span>number</span><span>=</span><span>$RANDOM</span>
  <span>echo</span> -n <span>"<span>$number</span> "</span>
  <span>let</span> <span>"count++"</span>
<span>done</span>
<span>}</span>

<span>echo</span><span>;</span> <span>echo</span>

<span>SEED</span><span>=</span><span>1</span>
<span><span>RANDOM</span></span><span>=</span><span>$SEED</span>      <span># 设置变量 RANDOM 会为随机数生成器设置种子。</span>
<span>echo</span> <span>"Random seed = <span>$SEED</span>"</span>
random_numbers

<span><span>RANDOM</span></span><span>=</span><span>$SEED</span>      <span># 同样的种子 ...</span>
<span>echo</span><span>;</span> <span>echo</span> <span>"Again, with same random seed ..."</span>
<span>echo</span> <span>"Random seed = <span>$SEED</span>"</span>
random_numbers    <span># ... 生成了同样的数字序列。</span>
                  <span>#</span>
                  <span># 在什么情况下重复一个随机化序列会有用？</span>
                  
<span>echo</span><span>;</span> <span>echo</span>

<span>SEED</span><span>=</span><span>2</span>
<span><span>RANDOM</span></span><span>=</span><span>$SEED</span>      <span># 用不同的种子再试一次 ...</span>
<span>echo</span> <span>"Random seed = <span>$SEED</span>"</span>
random_numbers    <span># ... 生成了不同的数字序列。</span>

<span>echo</span><span>;</span> <span>echo</span>

<span># RANDOM=$$  利用脚本的进程 ID 设置 RANDOM 的种子。</span>
<span># 同样也可以利用 'time' 或是 'date' 命令设置 RANDOM 的种子。</span>

<span># 更花哨一点的 ...</span>
<span>SEED</span><span>=</span><span><span>$(</span><span>head</span> -1 /dev/urandom <span>|</span> od -N <span>1</span> <span>|</span> <span>awk</span> <span>'{ print <span>$2</span> }'</span><span>|</span> <span>sed</span> s/^0*//<span>)</span></span>
<span>#  从 /dev/urandom （系统的伪随机设备文件）中</span>
<span>#+ 获取伪随机输出，</span>
<span>#+ 然后通过 "od" 转换为可打印八进制字符行，</span>
<span>#+ 然后 "awk" 命令会检索出一个数字作为种子，</span>
<span>#+ 最后用 "sed" 命令删除数字前面所有的前置 0。</span>
<span><span>RANDOM</span></span><span>=</span><span>$SEED</span>
<span>echo</span> <span>"Random seed = <span>$SEED</span>"</span>
random_numbers

<span>echo</span><span>;</span> <span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><p>{% hint style=&quot;info&quot; %}</p>
<p>伪设备文件 <code>/dev/urandom</code> 提供了比 <code>$RANDOM</code> 变量更随机化的伪随机数。命令 <code>dd if=/dev/urandom of=targetfile bs=1 count=XXX</code> 将会创建一个包含均匀分布的伪随机数的文件。但是想要在脚本中将这些随机数赋值给变量需要做一些变通，比如使用命令 <a href=""><code>od</code></a> 进行过滤（参照上面的样例以及 <a href="">样例 16-14</a> 和 <a href="">样例 A-36</a>）或者使用管道导入命令 <a href="">md5sum</a> 中（参照 <a href="">样例 36-16</a>）。</p>
<p>当然也有其他在脚本中生成伪随机数的方法。比如 <code>Awk</code> 命令就提供了这样一种非常简易的方法。</p>
<h4 id="样例-9-17-使用-awk-命令生成伪随机数"> 样例 9-17. 使用 <a href=""><code>awk</code></a> 命令生成伪随机数</h4>
<div><pre><code><span>#!/bin/bash</span>
<span>#  random2.sh: 返回大小在 0 - 1 内，</span>
<span>#+ 精度为小数点后 6 位的伪随机数。例如：0.822725</span>
<span>#  使用 awk rand() 函数。</span>

<span>AWKSCRIPT</span><span>=</span><span>' { srand(); print rand() } '</span>
<span>#           传递给 awk 的命令或参数</span>
<span># 注意 srand() 重置了 awk 的随机数生成种子。</span>


<span>echo</span> -n <span>"Random number between 0 and 1 = "</span>

<span>echo</span> <span>|</span> <span>awk</span> <span>"<span>$AWKSCRIPT</span>"</span>
<span># 如果省略 'echo' 将会发生什么？</span>

<span>exit</span> <span>0</span>


<span># 练习：</span>
<span># ---------</span>

<span># 1) 使用循环结构，输出 10 个不同的随机数。</span>
<span>#      （提示：你必须在每次循环中使用 srand() 函数重置种子以获得不同的随机数种子。</span>
<span>#+       如果你省略了这一步会发生什么？）</span>

<span># 2) 利用整型乘数作为随机数的缩放因子，</span>
<span>#+   生成大小在 10 到 100 之间的随机数。</span>

<span># 3) 内容与练习 #2 相同，只是这次生成随机整数。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>同样，命令 <a href=""><code>date</code></a> 可以用于 <a href="">生成整型随机数序列</a>。</p>
<p>{% endhint %}</p>
<h2 id="注记"> 注记</h2>
<p>{% hint style=&quot;info&quot; %}
真正的“随机性”，就其存在而言，只存在于一些类似放射性衰变这样还未被完全理解的自然现象中。计算机只能模拟这样的随机性，因此计算机生成的“随机数”序列被称作伪随机数。
{% endhint %}</p>
<p>{% hint style=&quot;info&quot; %}
计算机用于生成伪随机数的种子可以被视作一个标识标签。例如，你可以将用种子 23 生成的随机数序列视作第23号序列。</p>
<p>伪随机数序列的一个属性是该序列在开始重复之前的周期长度。一个好的伪随机数生成器能够生成周期非常长的序列。
{% endhint %}</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>Footnote Placeholder </p>
</li>
<li id="footnote2"><p>Footnote Placeholder </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第九章 换个角度看变量</title>
    <id>https://clay-wangzhi.com/code/shell/part3/09_another_look_at_variables/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/09_another_look_at_variables/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第九章-换个角度看变量"> 第九章 换个角度看变量</h1>
<h3 id="本章目录"> 本章目录</h3>
<ul>
<li><a href="./09_1_internal_variables.html">9.1 内部变量</a></li>
<li><a href="./09_2_typing_variables_declare_or_typeset.html">9.2 变量类型标注：<code>declare</code> 与 <code>typeset</code></a>
<ul>
<li><a href="./09_2_1_another_use_for_declare.html">9.2.1 <code>declare</code> 的另类用法</a></li>
</ul>
</li>
<li><a href="./09_3_random_generate_random_integer.html">9.3 <code>$RANDOM</code>：生成随机数</a></li>
</ul>
<p>在脚本中恰当的使用变量可以增强脚本并提高适应性。因此就需要了解变量的微妙之处和细微差异。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">10.1.1 使用 awk 处理字符串</title>
    <id>https://clay-wangzhi.com/code/shell/part3/10_1_1_manipulating_strings_using_awk/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/10_1_1_manipulating_strings_using_awk/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_10-1-1-使用-awk-处理字符串"> 10.1.1 使用 <code>awk</code> 处理字符串</h1>
<p>在 Bash 脚本中可以调用字符串处理工具 <code>awk</code> 来替换内置的字符串处理操作。</p>
<p>样例 10-6. 使用另一种方式来截取和定位子字符串</p>
<div><pre><code><span>#!/bin/bash</span>
<span># substring-extraction.sh</span>

<span>String</span><span>=</span>23skidoo1
<span>#      012345678    Bash</span>
<span>#      123456789    awk</span>
<span># 注意不同字符串索引系统：</span>
<span># Bash 中第一个字符的位置为0。</span>
<span># Awk 中第一个字符的位置为1。</span>

<span>echo</span> <span>${String<span>:</span>2<span>:</span>4}</span> <span># 从第3位开始（0-1-2），4个字符的长度</span>
                                         <span># skid</span>

<span># Awk 中与 ${string:pos:length} 等价的是 substr(string,pos,length)。</span>
<span>echo</span> <span>|</span> <span>awk</span> <span>'
{ print substr("'</span>"<span>${String}</span><span>"'"</span>,3,4<span>)</span>      <span># skid</span>
<span>}</span>
<span>'
#  将空的 "echo" 通过管道传递给 awk 作为一个模拟输入，
#+ 这样就不需要提供一个文件名来操作 awk 了。

echo "----"

# 同样的：

echo | awk '</span>
<span>{</span> print index<span>(</span><span>"'"</span><span>${String}</span><span>"'"</span>, <span>"skid"</span><span>)</span>      <span># 3</span>
<span>}</span>                                           <span># （skid 从第3位开始）</span>
'   <span># 这里使用 awk 等价于 "expr index"。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">10.1.2 参考资料</title>
    <id>https://clay-wangzhi.com/code/shell/part3/10_1_2_further_reference/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/10_1_2_further_reference/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_10-1-2-参考资料"> 10.1.2 参考资料</h1>
<p>更多关于脚本中处理字符串的资料，可以查看 <a href="http://tldp.org/LDP/abs/html/parameter-substitution.html" target="_blank" rel="noopener noreferrer">章节 10.2</a> 以及 <a href="http://tldp.org/LDP/abs/html/moreadv.html#EXPRREF" target="_blank" rel="noopener noreferrer"><code>expr</code></a> 命令的<a href="http://tldp.org/LDP/abs/html/moreadv.html#EXPEXTRSUB" target="_blank" rel="noopener noreferrer">相关章节</a>。</p>
<p>脚本样例：</p>
<ol>
<li><a href="http://tldp.org/LDP/abs/html/moreadv.html#EX45" target="_blank" rel="noopener noreferrer">样例 16-9</a></li>
<li><a href="http://tldp.org/LDP/abs/html/parameter-substitution.html#LENGTH" target="_blank" rel="noopener noreferrer">样例 10-9</a></li>
<li><a href="http://tldp.org/LDP/abs/html/parameter-substitution.html#PATTMATCHING" target="_blank" rel="noopener noreferrer">样例 10-10</a></li>
<li><a href="http://tldp.org/LDP/abs/html/parameter-substitution.html#RFE" target="_blank" rel="noopener noreferrer">样例 10-11</a></li>
<li><a href="http://tldp.org/LDP/abs/html/parameter-substitution.html#VARMATCH" target="_blank" rel="noopener noreferrer">样例 10-13</a></li>
<li><a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#INSERTIONSORT" target="_blank" rel="noopener noreferrer">样例 A-36</a></li>
<li><a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#QKY" target="_blank" rel="noopener noreferrer">样例 A-41</a></li>
</ol>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">10.1 字符串处理</title>
    <id>https://clay-wangzhi.com/code/shell/part3/10_1_manipulating_strings/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/10_1_manipulating_strings/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_10-1-字符串处理"> 10.1 字符串处理</h1>
<p>Bash 支持的字符串操作数量达到了一个惊人的数目。但可惜的是，这些操作工具缺乏一个统一的核心。他们中的一些是<a href="http://tldp.org/LDP/abs/html/parameter-substitution.html#PARAMSUBREF" target="_blank" rel="noopener noreferrer">参数代换</a>的子集，另外一些则是 UNIX 下 <a href="http://tldp.org/LDP/abs/html/moreadv.html#EXPRREF" target="_blank" rel="noopener noreferrer"><code>expr</code></a> 函数的子集。这将会导致语法前后不一致或者功能上出现重叠，更不用说那些可能导致的混乱了。</p>
<h3 id="字符串长度"> 字符串长度</h3>
<h4 id="string"> <code>${#string}</code></h4>
<h4 id="expr-length-string"> <code>expr length $string</code></h4>
<p>上面两个表达式等价于C语言中的 <code>strlen()</code> 函数。</p>
<h4 id="expr-string"> <code>expr &quot;$string&quot; : '.*'</code></h4>
<div><pre><code><span>stringZ</span><span>=</span>abcABC123ABCabc

<span>echo</span> <span>${<span>#</span>stringZ}</span>                 <span># 15</span>
<span>echo</span> <span><span>`</span><span>expr</span> length $stringz<span>`</span></span>      <span># 15</span>
<span>echo</span> <span><span>`</span><span>expr</span> <span>"<span>$stringZ</span>"</span> <span>:</span> <span>'.*'</span><span>`</span></span>    <span># 15</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>样例 10-1. 在文本的段落之间插入空行</p>
<div><pre><code><span>#!/bin/bash</span>
<span># paragraph-space.sh</span>
<span># 版本 2.1，发布日期 2012年7月29日</span>

<span># 在无空行的文本文件的段落之间插入空行。</span>
<span># 像这样使用: $0 &lt;FILENAME</span>

<span>MINLEN</span><span>=</span><span>60</span>        <span># 可以试试修改这个值。它用来做判断。</span>
<span>#  假设一行的字符数小于 $MINLEN，并且以句点结束段落。</span>
<span>#+ 结尾部分有练习！</span>

<span>while</span> <span>read</span> line  <span># 当文件有许多行的时候</span>
<span>do</span>
  <span>echo</span> <span>"<span>$line</span>"</span>   <span># 输出行本身。</span>
  
  <span>len</span><span>=</span><span>${<span>#</span>line}</span>
  <span>if</span> <span>[</span><span>[</span> <span>"<span>$len</span>"</span> -lt <span>"<span>$MINLEN</span>"</span> <span>&amp;&amp;</span> <span>"<span>$line</span>"</span> <span>=</span>~ <span>[</span>*<span>{</span><span>\</span>.<span>}</span><span>]</span>$ <span>]</span><span>]</span>
<span># if [[ "$len" -lt "$MINLEN" &amp;&amp; "$line" =~ \[*\.\] ]]</span>
<span># 新版Bash将不能正常运行前一个版本的脚本。Ouch！</span>
<span># 感谢 Halim Srama 指出这点，并且给出了修正版本。</span>
    <span>then</span> <span>echo</span>    <span>#  在该行以句点结束时，</span>
  <span>fi</span>             <span>#+ 增加一行空行。</span>
<span>done</span>

<span>exit</span>

<span># 练习：</span>
<span># -----</span>
<span>#  1) 该脚本通常会在文件的最后插入一个空行。</span>
<span>#+    尝试解决这个问题。</span>
<span>#  2) 在第17行仅仅考虑到了以句点作为句子终止的情况。</span>
<span>#+    修改以满足其他的终止符，例如 ?, ! 和 "。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h3 id="起始部分字符串匹配长度"> 起始部分字符串匹配长度</h3>
<h4 id="expr-match-string-substring"> <code>expr match &quot;$string&quot; '$substring'</code></h4>
<p>其中，<code>$substring</code> 是一个<a href="http://tldp.org/LDP/abs/html/regexp.html#REGEXREF" target="_blank" rel="noopener noreferrer">正则表达式</a>。</p>
<h4 id="expr-string-substring"> <code>expr &quot;$string&quot; : '$substring'</code></h4>
<p>其中，<code>$substring</code> 是一个正则表达式。</p>
<div><pre><code>
<span>stringZ</span><span>=</span>abcABC123ABCabc
<span>#       |------|</span>
<span>#       12345678</span>

<span>echo</span> <span><span>`</span><span>expr</span> match <span>"<span>$stringZ</span>"</span> <span>'abc[A-Z]*.2'</span><span>`</span></span>   <span># 8</span>
<span>echo</span> <span><span>`</span><span>expr</span> <span>"<span>$stringZ</span>"</span> <span>:</span> <span>'abc[A-Z]*.2'</span><span>`</span></span>       <span># 8</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="索引"> 索引</h3>
<h4 id="expr-index-string-substring"> <code>expr index $string $substring</code></h4>
<p>返回在 <code>$string</code> 中第一个出现的 <code>$substring</code> 字符所在的位置。</p>
<div><pre><code><span>stringZ</span><span>=</span>abcABC123ABCabc
<span>#       123456 ...</span>
<span>echo</span> <span><span>`</span><span>expr</span> index <span>"<span>$stringZ</span>"</span> C12<span>`</span></span>             <span># 6</span>
                                             <span># C 的位置。</span>
<span>echo</span> <span><span>`</span><span>expr</span> index <span>"<span>$stringZ</span>"</span> 1c<span>`</span></span>              <span># 3</span>
<span># 'c' (第三号位) 较 '1' 出现的更早。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>几乎等价于C语言中的 <code>strchr()</code>。</p>
<h3 id="截取字符串-字符串分片"> 截取字符串（字符串分片）</h3>
<h4 id="string-position"> <code>${string:position}</code></h4>
<p>在 <code>$string</code> 中截取自 <code>$position</code> 起的字符串。</p>
<p>如果参数 <code>$string</code> 是 &quot;*&quot; 或者 &quot;@&quot;，那么将会截取自 <code>$position</code> 起的<a href="http://tldp.org/LDP/abs/html/internalvariables.html#POSPARAMREF" target="_blank" rel="noopener noreferrer">位置参数</a>。<sup></sup></p>
<h4 id="string-position-length"> <code>${string:position:length}</code></h4>
<p>在 <code>$string</code> 中截取自 <code>$position</code> 起，长度为 <code>$length</code> 的字符串。</p>
<div><pre><code>
<span>stringZ</span><span>=</span>abcABC123ABCabc
<span>#       0123456789.....</span>
<span>#       索引位置从0开始。</span>

<span>echo</span> <span>${stringZ<span>:</span>0}</span>                            <span># abcABC123ABCabc</span>
<span>echo</span> <span>${stringZ<span>:</span>1}</span>                            <span># bcABC123ABCabc</span>
<span>echo</span> <span>${stringZ<span>:</span>7}</span>                            <span># 23ABCabc</span>

<span>echo</span> <span>${stringz<span>:</span>7<span>:</span>3}</span>                          <span># 23A</span>
                                             <span># 三个字符的子字符串。</span>
                                             
                                             

<span># 从右至左进行截取可行么？</span>

<span>echo</span> <span>${stringZ<span>:-</span>4}</span>                           <span># abcABC123ABCabc</span>
<span># ${parameter:-default} 将会得到整个字符串。</span>
<span># 但是……</span>

<span>echo</span> <span>${stringZ<span>:</span>(-4)}</span>                         <span># Cabc</span>
<span>echo</span> <span>${stringZ<span>:</span> -4}</span>                          <span># Cabc</span>
<span># 现在可以了。</span>
<span># 括号或者增加空格都可以"转义"位置参数。</span>

<span># 感谢 Dan Jacobson 指出这些。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>其中，参数 <code>position</code> 与 <code>length</code> 可以传入一个变量而不一定需要传入常量。</p>
<p>样例 10-2. 产生一个8个字符的随机字符串</p>
<div><pre><code><span>#!/bin/bash</span>
<span># rand-string.sh</span>
<span># 产生一个8个字符的随机字符串。</span>

<span>if</span> <span>[</span> -n <span>"<span>$1</span>"</span> <span>]</span>  <span>#  如果在命令行中已经传入了参数，</span>
<span>then</span>            <span>#+ 那么就以它作为起始字符串。</span>
  <span>str0</span><span>=</span><span>"<span>$1</span>"</span>
<span>else</span>            <span>#  否则，就将脚本的进程标识符PID作为起始字符串。</span>
  <span>str0</span><span>=</span><span>"<span>$$</span>"</span>
<span>fi</span>

<span>POS</span><span>=</span><span>2</span>  <span># 从字符串的第二位开始。</span>
<span>LEN</span><span>=</span><span>8</span>  <span># 截取八个字符。</span>

<span>str1</span><span>=</span><span><span>$(</span> <span>echo</span> <span>"<span>$str0</span>"</span> <span>|</span> md5sum <span>|</span> md5sum <span>)</span></span>
<span>#                      ^^^^^^   ^^^^^^</span>
<span># 将字符串通过管道计算两次 md5 来进行两次混淆。</span>

<span>randstring</span><span>=</span><span>"<span>${str1<span>:</span>$POS<span>:</span>$LEN}</span>"</span>
<span>#                  ^^^^ ^^^^</span>
<span># 允许传入参数</span>

<span>echo</span> <span>"<span>$randstring</span>"</span>

<span>exit</span> <span>$?</span>

<span># bozo$ ./rand-string.sh my-password</span>
<span># 1bdd88c4</span>

<span># 不过不建议将其作为一种能够抵抗黑客的生成密码的方法。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>如果参数 <code>$string</code> 是 &quot;*&quot; 或者 &quot;@&quot;，那么将会截取自 <code>$position</code> 起，最大个数为 <code>$length</code> 的位置参数。</p>
<div><pre><code><span>echo</span> <span>${*<span>:</span>2}</span>          <span># 输出第二个及之后的所有位置参数。</span>
<span>echo</span> <span>${@<span>:</span>2}</span>          <span># 同上。</span>

<span>echo</span> <span>${*<span>:</span>2<span>:</span>3}</span>        <span># 从第二个位置参数起，输出三个位置参数。 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="expr-substr-string-position-length"> <code>expr substr $string $position $length</code></h4>
<p>在 <code>$string</code> 中截取自 <code>$position</code> 起，长度为 <code>$length</code> 的字符串。</p>
<div><pre><code><span>stringZ</span><span>=</span>abcABC123ABCabc
<span>#       123456789......</span>
<span>#       索引位置从1开始。</span>

<span>echo</span> <span><span>`</span><span>expr</span> substr $stringZ <span>1</span> <span>2</span><span>`</span></span>              <span># ab</span>
<span>echo</span> <span><span>`</span><span>expr</span> substr $stringZ <span>4</span> <span>3</span><span>`</span></span>              <span># ABC</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="expr-match-string-substring-2"> <code>expr match &quot;$string&quot; '\($substring\)'</code></h4>
<p>在 <code>$string</code> 中截取自 <code>$position</code> 起的字符串，其中 <code>$substring</code> 是<a href="http://tldp.org/LDP/abs/html/regexp.html#REGEXREF" target="_blank" rel="noopener noreferrer">正则表达式</a>。</p>
<h4 id="expr-string-substring-2"> <code>expr &quot;$string&quot; : '\($substring\)'</code></h4>
<p>在 <code>$string</code> 中截取自 <code>$position</code> 起的字符串，其中 <code>$substring</code> 是正则表达式。</p>
<div><pre><code><span>stringZ</span><span>=</span>abcABC123ABCabc
<span>#       =======</span>

<span>echo</span> <span><span>`</span><span>expr</span> match <span>"<span>$stringZ</span>"</span> <span>'\(.[b-c]*[A-Z]..[0-9]\)'</span><span>`</span></span>   <span># abcABC1</span>
<span>echo</span> <span><span>`</span><span>expr</span> <span>"<span>$stringZ</span>"</span> <span>:</span> <span>'\(.[b-c]*[A-Z]..[0-9]\)'</span><span>`</span></span>       <span># abcABC1</span>
<span>echo</span> <span><span>`</span><span>expr</span> <span>"<span>$stringZ</span>"</span> <span>:</span> <span>'\(.......\)'</span><span>`</span></span>                   <span># abcABC1</span>
<span># 上面所有的形式都给出了相同的结果。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="expr-match-string-substring-3"> <code>expr match &quot;$string&quot; '.*\($substring\)'</code></h4>
<p>从 <code>$string</code> 结尾部分截取 <code>$substring</code> 字符串，其中 <code>$substring</code> 是正则表达式。</p>
<h4 id="expr-string-substring-3"> <code>expr &quot;$string&quot; : '.*\($substring\)'</code></h4>
<p>从 <code>$string</code> 结尾部分截取 <code>$substring</code> 字符串，其中 <code>$substring</code> 是正则表达式。</p>
<div><pre><code><span>stringZ</span><span>=</span>abcABC123ABCabc
<span>#                ======</span>

<span>echo</span> <span><span>`</span><span>expr</span> match <span>"<span>$stringZ</span>"</span> <span>'.*\([A-C][A-C][A-C][a-c]*\)'</span><span>`</span></span>    <span># ABCabc</span>
<span>echo</span> <span><span>`</span><span>expr</span> <span>"<span>$stringZ</span>"</span> <span>:</span> <span>'.*\(......\)'</span><span>`</span></span>                       <span># ABCabc</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="删除子串"> 删除子串</h3>
<h4 id="string-substring"> <code>${string#substring}</code></h4>
<p>删除从 <code>$string</code> 起始部分起，匹配到的最短的 <code>$substring</code>。</p>
<h4 id="string-substring-2"> <code>${string##substring}</code></h4>
<p>删除从 <code>$string</code> 起始部分起，匹配到的最长的 <code>$substring</code>。</p>
<div><pre><code><span>stringZ</span><span>=</span>abcABC123ABCabc
<span>#       |----|          最长</span>
<span>#       |----------|    最短</span>

<span>echo</span> <span>${stringZ<span>#</span>a*C}</span>      <span># 123ABCabc</span>
<span># 删除 'a' 与 'c' 之间最短的匹配。</span>

<span>echo</span> <span>${stringZ<span>##</span>a*C}</span>     <span># abc</span>
<span># 删除 'a' 与 'c' 之间最长的匹配。</span>



<span># 你可以使用变量代替 substring。</span>

<span>X</span><span>=</span><span>'a*C'</span>

<span>echo</span> <span>${stringZ<span>#</span>$X}</span>      <span># 123ABCabc</span>
<span>echo</span> <span>${stringZ<span>##</span>$X}</span>     <span># abc</span>
                        <span># 同上。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h4 id="string-substring-3"> <code>${string%substring}</code></h4>
<p>删除从 <code>$string</code> 结尾部分起，匹配到的最短的 <code>$substring</code>。</p>
<p>例如：</p>
<div><pre><code><span># 将当前目录下所有后缀名为 "TXT" 的文件改为 "txt" 后缀。</span>
<span># 例如 "file1.TXT" 改为 "file1.txt"。</span>

<span>SUFF</span><span>=</span>TXT
<span>suff</span><span>=</span>txt

<span>for</span> <span>i</span> <span>in</span> <span><span>$(</span><span>ls</span> *.$SUFF<span>)</span></span>
<span>do</span>
  <span>mv</span> -f <span>$i</span> <span><span>$(</span>i%.$SUFF<span>)</span></span><span>.</span><span>$suff</span>
  <span>#  除了从变量 $i 右侧匹配到的最短的字符串之外，</span>
  <span>#+ 其他一切都保持不变。</span>
<span>done</span> <span>### 如果需要，循环可以压缩成一行的形式。</span>

<span># 感谢 Rory Winston。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="string-substring-4"> <code>${string%%substring}</code></h4>
<p>删除从 <code>$string</code> 结尾部分起，匹配到的最长的 <code>$substring</code>。</p>
<div><pre><code>
<span>stringZ</span><span>=</span>abcABC123ABCabc
<span>#                    ||     最短</span>
<span>#        |------------|     最长</span>

<span>echo</span> <span>${stringZ<span>%</span>b*c}</span>      <span># abcABC123ABCa</span>
<span># 从结尾处删除 'b' 与 'c' 之间最短的匹配。</span>

<span>echo</span> <span>${stringZ<span>%%</span>b*c}</span>     <span># a</span>
<span># 从结尾处删除 'b' 与 'c' 之间最长的匹配。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这个操作对生成文件名非常有帮助。</p>
<p>样例 10-3. 改变图像文件的格式及文件名</p>
<div><pre><code><span>#!/bin/bash</span>
<span>#  cvt.sh:</span>
<span>#  将目录下所有的 MacPaint 文件转换为 "pbm" 格式。</span>

<span>#  使用由 Brian Henderson (bryanh@giraffe-data.com) 维护的</span>
<span>#+ "netpbm" 包下的 "macptobpm" 二进制工具。</span>
<span>#  Netpbm 是大多数 Linux 发行版的标准组成部分。</span>

<span>OPERATION</span><span>=</span>macptopbm
<span>SUFFIX</span><span>=</span>pbm          <span># 新的文件名后缀。</span>

<span>if</span> <span>[</span> -n <span>"<span>$1</span>"</span> <span>]</span>
<span>then</span>
  <span>directory</span><span>=</span><span>$1</span>      <span># 如果已经通过脚本参数传入了目录名的情况……</span>
<span>else</span>
  <span>directory</span><span>=</span><span>$PWD</span>    <span># 否则就使用当前工作目录。</span>
<span>fi</span>

<span>#  假设目标目录下的所有 MacPaint 图像文件都拥有</span>
<span>#+ ".mac" 的文件后缀名。</span>

<span>for</span> <span>file</span> <span>in</span> <span>$directory</span>/*    <span># 文件名匹配。</span>
<span>do</span>
  <span>filename</span><span>=</span><span>${file<span>%</span>.*c}</span>      <span>#  从文件名中删除 ".mac" 后缀</span>
                            <span>#+ ('.*c' 匹配 '.' 与 'c' 之间的</span>
                            <span>#  所有字符，包括其本身)。</span>
  <span>$OPERATION</span> <span>$file</span> <span>></span> <span>"<span>$filename</span>.<span>$SUFFIX</span>"</span>
                            <span># 将转换结果重定向到新的文件。</span>
  <span>rm</span> -f <span>$file</span>               <span># 在转换后删除原文件。</span>
  <span>echo</span> <span>"<span>$filename</span>.<span>$SUFFIX</span>"</span>  <span># 将记录输出到 stdout 中。</span>
<span>done</span>

<span>exit</span> <span>0</span>

<span># 练习：</span>
<span># -----</span>
<span># 这个脚本会将当前工作目录下的所有文件进行转换。</span>
<span># 修改脚本，使得它仅转换 ".mac" 后缀的文件。</span>



<span># *** 还可以使用另外一种方法。 *** #</span>

<span>#!/bin/bash</span>
<span># 将图像批处理转换成不同的格式。</span>
<span># 假设已经安装了 imagemagick。（在大部分 Linux 发行版中都有）</span>

<span>INFMT</span><span>=</span>png   <span># 可以是 tif, jpg, gif 等等。</span>
<span>OUTFMT</span><span>=</span>pdf  <span># 可以是 tif, jpg, gif, pdf 等等。</span>

<span>for</span> <span>pic</span> <span>in</span> *<span>"<span>$INFMT</span>"</span>
<span>do</span>
  <span>p2</span><span>=</span><span><span>$(</span><span>ls</span> <span>"<span>$pic</span>"</span> <span>|</span> <span>sed</span> -e s/<span>\</span>.$INFMT//<span>)</span></span>
  <span># echo $p2</span>
  convert <span>"<span>$pic</span>"</span> <span>$p2</span><span>.</span><span>$OUTFMT</span>
<span>done</span>

<span>exit</span> <span>$?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><p>样例 10-4. 将流音频格式转换成 ogg 格式</p>
<div><pre><code><span>#!/bin/bash</span>
<span># ra2ogg.sh: 将流音频文件 (*.ra) 转换成 ogg 格式。</span>

<span># 使用 "mplayer" 媒体播放器程序：</span>
<span>#      http://www.mplayerhq.hu/homepage</span>
<span># 使用 "ogg" 库与 "oggenc"：</span>
<span>#      http://www.xiph.org/</span>
<span>#</span>
<span># 脚本同时需要安装一些解码器，例如 sipr.so 等等一些。</span>
<span># 这些解码器可以在 compat-libstdc++ 包中找到。</span>


<span>OFILEPREF</span><span>=</span><span>${1<span>%%</span>ra}</span>      <span># 删除 "ra" 后缀。</span>
<span>OFILESUFF</span><span>=</span>wav           <span># wav 文件后缀。</span>
<span>OUTFILE</span><span>=</span><span>"<span>$OFILEPREF</span>"</span>"<span>$OFILESUFF</span><span>"
E_NOARGS=85

if [ -z "</span><span>$1</span><span>" ]          # 必须指定一个文件进行转换。
then
  echo "</span>Usage: <span><span>`</span><span>basename</span> $0<span>`</span></span> <span>[</span>filename<span>]</span><span>"
  exit <span>$E_NOAGRS</span>
fi


######################################################
mplayer "</span><span>$1</span><span>" -ao pcm:file=<span>$OUTFILE</span>
oggenc "</span><span>$OUTFILE</span><span>"  # 由 oggenc 自动加上正确的文件后缀名。
######################################################

rm "</span><span>$OUTFILE</span><span>"      # 立即删除 *.wav 文件。
                   # 如果你仍需保留原文件，注释掉上面这一行即可。
                   
exit <span>$?</span>

#  注意：
#  -----
#  在网站上，点击一个 *.ram 的流媒体音频文件
#+ 通常只会下载到 *.ra 音频文件的 URL。
#  你可以使用 "</span><span>wget</span><span>" 或者类似的工具下载 *.ra 文件本身。


#  练习：
#  -----
#  这个脚本仅仅转换 *.ra 文件。
#  修改脚本增加适应性，使其可以转换 *.ram 或其他文件格式。
#
#  如果你非常有热情，你可以扩展这个脚本使其
#+ 可以自动下载并且转换流媒体音频文件。
#  给定一个 URL，自动下载流媒体音频文件 (使用 "</span>wget"<span>)</span>，
<span>#+ 然后转换它。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><p>下面是使用字符串截取结构对 <a href="http://tldp.org/LDP/abs/html/extmisc.html#GETOPTY" target="_blank" rel="noopener noreferrer"><code>getopt</code></a> 的一个简单模拟。</p>
<p>样例 10-5. 模拟 <code>getopt</code></p>
<div><pre><code><span>#!/bin/bash</span>
<span># getopt-simple.sh</span>
<span># 作者: Chris Morgan</span>
<span># 允许在高级脚本编程指南中使用。</span>


<span>getopt_simple</span><span>(</span><span>)</span>
<span>{</span>
    <span>echo</span> <span>"getopt_simple()"</span>
    <span>echo</span> <span>"Parameters are '<span>$*</span>'"</span>
    <span>until</span> <span>[</span> -z <span>"<span>$1</span>"</span> <span>]</span>
    <span>do</span>
      <span>echo</span> <span>"Processing parameter of: '<span>$1</span>'"</span>
      <span>if</span> <span>[</span> <span>${1<span>:</span>0<span>:</span>1}</span> <span>=</span> <span>'/'</span> <span>]</span>
      <span>then</span>
          <span>tmp</span><span>=</span><span>${1<span>:</span>1}</span>               <span># 删除开头的 '/'</span>
          <span>parameter</span><span>=</span><span>${tmp<span>%%</span>=*}</span>     <span># 取出名称。</span>
          <span>value</span><span>=</span><span>${tmp<span>##</span>*=}</span>         <span># 取出值。</span>
          <span>echo</span> <span>"Parameter: '<span>$parameter</span>', value: '<span>$value</span>'"</span>
          <span>eval</span> <span>$parameter</span><span>=</span><span>$value</span>
      <span>fi</span>
      <span>shift</span>
    <span>done</span>
<span>}</span>

<span># 将所有参数传递给 getopt_simple()。</span>
getopt_simple <span>$*</span>

<span>echo</span> <span>"test is '<span>$test</span>'"</span>
<span>echo</span> <span>"test2 is '<span>$test2</span>'"</span>

<span>exit</span> <span>0</span>  <span># 可以查看该脚本的修改版 UseGetOpt.sh。</span>

---

<span>sh</span> getopt_example.sh /test<span>=</span>value1 /test2<span>=</span>value2

Parameters are <span>'/test=value1 /test2=value2'</span>
Processing parameter of: <span>'/test=value1'</span>
Parameter: <span>'test'</span>, value: <span>'value1'</span>
Processing parameter of: <span>'/test2=value2'</span>
Parameter: <span>'test2'</span>, value: <span>'value2'</span>
<span>test</span> is <span>'value1'</span>
test2 is <span>'value2'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h3 id="子串替换"> 子串替换</h3>
<h4 id="string-substring-replacement"> <code>${string/substring/replacement}</code></h4>
<p>替换匹配到的第一个 <code>$substring</code> 为 <code>$replacement</code>。<sup></sup></p>
<h4 id="string-substring-replacement-2"> <code>${string//substring/replacement}</code></h4>
<p>替换匹配到的所有 <code>$substring</code> 为 <code>$replacement</code>。</p>
<div><pre><code><span>stringZ</span><span>=</span>abcABC123ABCabc

<span>echo</span> <span>${stringZ<span>/</span>abc<span>/</span>xyz}</span>       <span># xyzABC123ABCabc</span>
                              <span># 将匹配到的第一个 'abc' 替换为 'xyz'。</span>
                              
<span>echo</span> <span>${stringZ<span>/</span><span>/</span>abc<span>/</span>xyz}</span>      <span># xyzABC123ABCxyz</span>
                              <span># 将匹配到的所有 'abc' 替换为 'xyz'。</span>
                              
<span>echo</span>  ---------------
<span>echo</span> <span>"<span>$stringZ</span>"</span>               <span># abcABC123ABCabc</span>
<span>echo</span>  ---------------
                              <span># 字符串本身并不会被修改！</span>
                              
<span># 匹配以及替换的字符串可以是参数么？</span>
<span>match</span><span>=</span>abc
<span>repl</span><span>=</span>000
<span>echo</span> <span>${stringZ<span>/</span>$match<span>/</span>$repl}</span>  <span># 000ABC123ABCabc</span>
<span>#              ^      ^         ^^^</span>
<span>echo</span> <span>${stringZ<span>/</span><span>/</span>$match<span>/</span>$repl}</span> <span># 000ABC123ABC000</span>
<span># Yes!          ^      ^        ^^^         ^^^</span>

<span>echo</span>

<span># 如果没有给定 $replacement 字符串会怎样？</span>
<span>echo</span> <span>${stringZ<span>/</span>abc}</span>           <span># ABC123ABCabc</span>
<span>echo</span> <span>${stringZ<span>/</span><span>/</span>abc}</span>          <span># ABC123ABC</span>
<span># 仅仅是将其删除而已。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h4 id="string-substring-replacement-3"> <code>${string/#substring/replacement}</code></h4>
<p>替换 <code>$string</code> 中最前端匹配到的 <code>$substring</code> 为 <code>$replacement</code>。</p>
<h4 id="string-substring-replacement-4"> <code>${string/%substring/replacement}</code></h4>
<p>替换 <code>$string</code> 中最末端匹配到的 <code>$substring</code> 为 <code>$replacement</code>。</p>
<div><pre><code><span>stringZ</span><span>=</span>abcABC123ABCabc

<span>echo</span> <span>${stringZ<span>/</span><span>#</span>abc<span>/</span>XYZ}</span>          <span># XYZABC123ABCabc</span>
                                  <span># 将前端的 'abc' 替换为 'XYZ'</span>
                                  
<span>echo</span> <span>${stringZ<span>/</span><span>%</span>abc<span>/</span>XYZ}</span>          <span># abcABC123ABCXYZ</span>
                                  <span># 将末端的 'abc' 替换为 'XYZ'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><hr>
<section>
<ol>
<li id="footnote1"><p>这种情况同时适用于命令行参数和传入函数的参数。 </p>
</li>
<li id="footnote2"><p>注意根据使用时上下文的不同，<code>$substring</code> 和 <code>$replacement</code> 可以是文本字符串也可以是变量。可以参考第一个样例。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">10.2 参数替换</title>
    <id>https://clay-wangzhi.com/code/shell/part3/10_2_parameter_substitution/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/10_2_parameter_substitution/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_10-2-参数替换"> 10.2 参数替换</h1>
<p>参数替换用来处理或扩展变量。</p>
<h3 id="parameter"> <code>${parameter}</code></h3>
<p>等同于 <code>$parameter</code>，是变量 parameter 的值。在一些特定的环境下，只允许使用不易混淆的 <code>${parameter}</code> 形式。</p>
<p>可以用于连接变量与字符串。</p>
<div><pre><code><span>your_id</span><span>=</span><span>${<span>USER</span>}</span>-on-<span>${<span>HOSTNAME</span>}</span>
<span>echo</span> <span>"<span>$your_id</span>"</span>
<span># </span>
<span>echo</span> <span>"Old \<span>$PATH</span> = <span>$PATH</span>"</span>
<span><span>PATH</span></span><span>=</span><span>${<span>PATH</span>}</span>:/opt/bin  <span># 在脚本执行过程中临时在 $PATH 中加入 /opt/bin。</span>
<span>echo</span> <span>"New \<span>$PATH</span> = <span>$PATH</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="parameter-default-parameter-default"> <code>${parameter-default}, ${parameter:-default}</code></h3>
<p>在没有设置变量的情况下使用缺省值。</p>
<div><pre><code><span>var1</span><span>=</span><span>1</span>
<span>var2</span><span>=</span><span>2</span>
<span># 没有设置 var3。</span>

<span>echo</span> <span>${var1-$var2}</span>   <span># 1</span>
<span>echo</span> <span>${var3-$var2}</span>   <span># 2</span>
<span>#           ^          注意前面的 $ 前缀。</span>



<span>echo</span> <span>${username-`whoami`}</span>
<span># 如果变量 $username 没有被设置，输出 `whoami` 的结果。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> <code>${parameter-default}</code> 与 <code>${parameter:-default}</code> 的作用几乎相同，唯一不同的情况就是当变量 parameter 已经被声明但值为空时。</p>
</blockquote>
<div><pre><code><span>#!/bin/bash</span>
<span># param-sub.sh</span>

<span># 无论变量的值是否为空，其是否已被声明决定了缺省设置的触发。</span>

<span>username0</span><span>=</span>
<span>echo</span> <span>"username0 has been declared, but is set to null."</span>
<span>echo</span> <span>"username0 = <span>${username0-`whoami`}</span>"</span>
<span># 将不会输出 `whoami` 的结果。</span>

<span>echo</span>

<span>echo</span> username1 has not been declared.
<span>echo</span> <span>"username1 = <span>${username1-`whoami`}</span>"</span>
<span># 将会输出 `whoami` 的结果。</span>

<span>username2</span><span>=</span>
<span>echo</span> <span>"username2 has been declared, but is set to null."</span>
<span>echo</span> <span>"username2 = <span>${username2<span>:-</span>`whoami`}</span>"</span>
<span>#                            ^</span>
<span># 因为这里是 :- 而不是 -，所以将会输出 `whoami` 的结果。</span>
<span># 与上面的 username0 比较。</span>


<span># </span>

<span># 再来一次：</span>

<span>variable</span><span>=</span>
<span># 变量已被声明，但其值为空。</span>

<span>echo</span> <span>"<span>${varibale-0}</span>"</span>    <span># 没有输出。</span>
<span>echo</span> <span>"<span>${variable<span>:-</span>1}</span>"</span>   <span># 1</span>
<span>#               ^</span>

unser variable

<span>echo</span> <span>"<span>${variable-2}</span>"</span>    <span># 2</span>
<span>echo</span> <span>"<span>${variable<span>:-</span>3}</span>"</span>   <span># 3</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>当传入的命令行参数的数量不足时，可以使用这种缺省参数结构。</p>
<div><pre><code><span>DEFAULT_FILENAME</span><span>=</span>generic.data
<span>filename</span><span>=</span><span>${1<span>:-</span>$DEFAULT_FILENAME}</span>
<span># 如果没有其他特殊情况，下面的代码块将会操作文件 "generic.data"。</span>
<span># 代码块开始</span>
<span># ...</span>
<span># ...</span>
<span># ...</span>
<span># 代码块结束</span>



<span># 摘自样例 "hanoi2.bash"：</span>
<span>DISKS</span><span>=</span><span>${1<span>:-</span>E_NOPARAM}</span>   <span># 必须指定碟子的个数。</span>
<span>#  将 $DISKS 设置为传入的第一个命令行参数，</span>
<span>#+ 如果没有传入第一个参数，则设置为 $E_NOPARAM。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>可以查看 <a href="http://tldp.org/LDP/abs/html/special-chars.html#EX58" target="_blank" rel="noopener noreferrer">样例 3-4</a>，<a href="http://tldp.org/LDP/abs/html/zeros.html#EX73" target="_blank" rel="noopener noreferrer">样例 31-2</a> 和 <a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#COLLATZ" target="_blank" rel="noopener noreferrer">样例 A-6</a>。</p>
<p>可以同 <a href="http://tldp.org/LDP/abs/html/list-cons.html#ANDDEFAULT" target="_blank" rel="noopener noreferrer">使用与链设置缺省命令行参数</a> 做比较。</p>
<h3 id="parameter-default-parameter-default-2"> <code>${parameter=default}, ${parameter:=default}</code></h3>
<p>在没有设置变量的情况下，将其设置为缺省值。</p>
<p>两种形式的作用几乎相同，唯一不同的情况与上面类似，就是当变量 parameter 已经被声明但值为空时。<sup></sup></p>
<div><pre><code><span>echo</span> <span>${var=abc}</span>   <span># abc</span>
<span>echo</span> <span>${vat=xyz}</span>   <span># abc</span>
<span># $var 已经在第一条语句中被赋值为 abc，因此第二条语句将不会改变它的值。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="parameter-alt-value-parameter-alt-value"> <code>${parameter+alt_value}, ${parameter:+alt_value}</code></h3>
<p>如果变量已被设置，使用 alt_value，否则使用空值。</p>
<p>两种形式的作用几乎相同，唯一不同的情况就是当变量 parameter 已经被声明但值为空时，看下面的例子。</p>
<div><pre><code><span>echo</span> <span>"###### \<span>${parameter+alt_value}</span> ########"</span>
<span>echo</span>

<span>a</span><span>=</span><span>${param1+xyz}</span>
<span>echo</span> <span>"a = <span>$a</span>"</span>      <span># a =</span>

<span>param2</span><span>=</span>
<span>a</span><span>=</span><span>${param2+xyz}</span>
<span>echo</span> <span>"a = <span>$a</span>"</span>      <span># a = xyz</span>

<span>param3</span><span>=</span><span>123</span>
<span>a</span><span>=</span><span>${param3+xyz}</span>
<span>echo</span> <span>"a = <span>$a</span>"</span>      <span># a = xyz</span>

<span>echo</span>
<span>echo</span> <span>"###### \<span>${parameter<span>:+</span>alt_value}</span> ########"</span>
<span>echo</span>

<span>a</span><span>=</span><span>${param4<span>:+</span>xyz}</span>
<span>echo</span> <span>"a = <span>$a</span>"</span>      <span># a =</span>

<span>param5</span><span>=</span>
<span>a</span><span>=</span><span>${param5<span>:+</span>xyz}</span>
<span>echo</span> <span>"a = <span>$a</span>"</span>      <span># a =</span>
<span># 不同于 a=${param5+xyz}</span>

<span>param6</span><span>=</span><span>123</span>
<span>a</span><span>=</span><span>${param6<span>:+</span>xyz}</span>
<span>echo</span> <span>"a = <span>$a</span>"</span>      <span># a = xyz</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id="parameter-err-msg-parameter-err-msg"> <code>${parameter?err_msg}, ${parameter:?err_msg}</code></h3>
<p>如果变量已被设置，那么使用原值，否则输出 err_msg 并且终止脚本，返回 <a href="http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF" target="_blank" rel="noopener noreferrer">错误码</a> 1。</p>
<p>两种形式的作用几乎相同，唯一不同的情况与上面类似，就是当变量 parameter 已经被声明但值为空时。</p>
<p>样例 10-7. 如何使用变量替换和错误信息</p>
<div><pre><code><span>#!/bin/bash</span>

<span># 检查系统环境变量。</span>
<span># 这是一种良好的预防性维护措施。</span>
<span># 如果控制台用户的名称 $USER 没有被设置，那么主机将不能够识别用户。</span>

<span>:</span> <span>${<span>HOSTNAME</span>?}</span> <span>${<span>USER</span>?}</span> <span>${<span>HOME</span>?}</span> <span>${MAIL?}</span>
  <span>echo</span>
  <span>echo</span> <span>"Name of the machine is <span>$HOSTNAME</span>."</span>
  <span>echo</span> <span>"You are <span>$USER</span>."</span>
  <span>echo</span> <span>"Your home directory is <span>$HOME</span>."</span>
  <span>echo</span> <span>"Your mail INBOX is located in <span>$MAIL</span>."</span>
  <span>echo</span>
  <span>echo</span> <span>"If you are reading this message,"</span>
  <span>echo</span> <span>"critcial environmental variables have been set."</span>
  <span>echo</span>
  <span>echo</span>
  
<span># ------------------------------------------------------</span>

<span># ${variablename?} 结构统一可以检查脚本中的变量是否被设置。</span>

<span>ThisVariable</span><span>=</span>Value-of-ThisVariable
<span># 顺带一提，这个字符串的值可以被设置成名称中不可以使用的禁用字符。</span>
<span>:</span> <span>${ThisVariable?}</span>
<span>echo</span> <span>"Value of ThisVariable is <span>$ThisVariable</span>."</span>

<span>echo</span><span>;</span> <span>echo</span>


<span>:</span> <span>${ZZXy23AB?"ZZXy23AB has not been set."}</span>
<span># 因为 ZZXy23AB 没有被设置，所以脚本会终止同时显示错误消息。</span>

<span># 你可以指定错误消息。</span>
<span># : ${variablename?"ERROR MESSAGE"}</span>


<span># 与这些结果相同:  dummy_variable=${ZZXy23AB?}</span>
<span>#                 dummy_variable=${ZZXy23AB?"ZZXy23AB has not been set."}</span>
<span>#</span>
<span>#                 echo ${ZZXy23AB?} >/dev/null</span>

<span># 将上面这些检查变量是否被设置的方法同 "set -u" 作比较。</span>



<span>echo</span> <span>"You will not see this message, because script already terminated."</span>

<span>HERE</span><span>=</span><span>0</span>
<span>exit</span> <span>$HERE</span>   <span># 将不会从这里退出。</span>

<span>#  事实上，这个脚本将会返回退出码（echo $?）1。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p>样例 10-8. 参数替换与 &quot;usage&quot; 消息</p>
<div><pre><code><span>#!/bin/bash</span>
<span># usage-message.sh</span>

<span>:</span> <span>${1?"Usage<span>:</span> $0 ARGUMENT"}</span>
<span># 如果命令行参数缺失，脚本将会在这里结束，并且返回下面的错误信息。</span>
<span>#    usage-message.sh: 1: Usage: usage-message.sh ARGUMENT</span>

<span>echo</span> <span>"These two lines echo only if command-line parameter given."</span>
<span>echo</span> <span>"command-line parameter = <span title="\&quot;">\"</span><span>$1</span><span title="\&quot;">\"</span>"</span>

<span>exit</span> <span>0</span>  <span># 仅当命令行参数存在是才会从这里退出。</span>

<span># 在传入和未传入命令行参数的情况下查看退出状态。</span>
<span># 如果传入了命令行参数，那么 "$?" 的结果是0。</span>
<span># 如果没有，那么 "$?" 的结果是1。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>参数替换用来处理或扩展变量。下面的表达式是对 <code>expr</code> 处理字符串的操作的补足（查看样例 16-9）。这些特殊的表达式通常养来解析文件的路径名。</p>
<h3 id="变量长度-删除子串"> 变量长度 / 删除子串</h3>
<h4 id="var"> <code>${#var}</code></h4>
<p>字符串的长度（<code>$var</code> 中字符的个数）。对任意 <a href="http://tldp.org/LDP/abs/html/arrays.html#ARRAYREF" target="_blank" rel="noopener noreferrer">数组</a> array，<code>${#array}</code> 返回数组中第一个元素的长度。</p>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> 以下情况例外：</p>
<ul>
<li><code>${#*}</code> 和 <code>${#@}</code> 返回位置参数的个数。</li>
<li>任意数组 array，<code>${#array[*]}</code> 和 <code>${#array[@]}</code> 返回数组中元素的个数。</li>
</ul>
</blockquote>
<p>样例 10-9. 变量长度</p>
<div><pre><code><span>#!/bin/bash</span>
<span># length.sh</span>

<span>E_NO_ARGS</span><span>=</span><span>65</span>

<span>if</span> <span>[</span> <span>$#</span> -eq <span>0</span> <span>]</span>  <span># 脚本必须传入参数。</span>
<span>then</span>
  <span>echo</span> <span>"Please invoke this script with one or more command-line arguments."</span>
  <span>exit</span> <span>$E_NO_ARGS</span>
<span>fi</span>

<span>var01</span><span>=</span>abcdEFGH28ij
<span>echo</span> <span>"var01 = <span>${var01}</span>"</span>
<span>echo</span> <span>"Length of var01 = <span>${<span>#</span>var01}</span>"</span>
<span># 现在我们尝试加入空格。</span>
<span>var02</span><span>=</span><span>"abcd EFGH28ij"</span>
<span>echo</span> <span>"var02 = <span>${var02}</span>"</span>
<span>echo</span> <span>"Length of var02 = <span>${<span>#</span>var02}</span>"</span>

<span>echo</span> <span>"Number of command-line arguments passed to script = <span>${<span>#</span>@}</span>"</span>
<span>echo</span> <span>"Number of command-line arguments passed to script = <span>${<span>#</span>*}</span>"</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h4 id="var-pattern-var-pattern"> <code>${var#Pattern}, ${var##Pattern}</code></h4>
<p><code>${var#Pattern}</code> 删除 <code>$var</code> 前缀部分匹配到的最短长度的 <code>$Pattern</code>。</p>
<p><code>${var##Pattern}</code> 删除 <code>$var</code> 前缀部分匹配到的最长长度的 <code>$Pattern</code>。</p>
<p>摘自 <a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#DAYSBETWEEN" target="_blank" rel="noopener noreferrer">样例 A-7</a> 的例子：</p>
<div><pre><code><span># 函数摘自样例 "day-between.sh"。</span>
<span># 删除传入的参数中的前缀0。</span>

strip_leading_zero <span>(</span><span>)</span> <span>#  删除传入参数中可能存在的</span>
<span>{</span>                     <span>#+ 前缀0。</span>
  <span>return</span><span>=</span><span>${1<span>#</span>0}</span>       <span>#  "1" 代表 "$1"，即传入的参数。</span>
<span>}</span>                     <span>#  从 "$1" 中删除 "0"。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>下面是由 Manfred Schwarb 提供的上述函数的改进版本：</p>
<div><pre><code>strip_leading_zero2 <span>(</span><span>)</span> <span># 删除前缀0，</span>
<span>{</span>                      <span># 否则 Bash 会将其解释为8进制数。</span>
  <span>shopt</span> -s extglob     <span># 启用扩展通配特性。</span>
  <span>local</span> <span>val</span><span>=</span><span>${1<span>##</span>+(0)}</span> <span># 使用本地变量，匹配前缀中所有的0。</span>
  <span>shopt</span> -u extglob     <span># 禁用扩展通配特性。</span>
  <span>_strip_leading_zero2</span><span>=</span><span>${var<span>:-</span>0}</span>
                       <span># 如果输入的为0，那么返回 0 而不是 ""。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>另外一个样例：</p>
<div><pre><code><span>echo</span> <span><span>`</span><span>basename</span> <span>$PWD</span><span>`</span></span>        <span># 当前工作目录的目录名。</span>
<span>echo</span> <span>"<span>${<span>PWD</span><span>##</span>*<span>/</span>}</span>"</span>           <span># 当前工作目录的目录名。</span>
<span>echo</span>
<span>echo</span> <span><span>`</span><span>basename</span> $0<span>`</span></span>          <span># 脚本名。</span>
<span>echo</span> <span>$0</span>                     <span># 脚本名。</span>
<span>echo</span> <span>"<span>${0<span>##</span>*<span>/</span>}</span>"</span>             <span># 脚本名。</span>
<span>echo</span>
<span>filename</span><span>=</span>test.data
<span>echo</span> <span>"<span>${filename<span>##</span>*.}</span>"</span>      <span># data</span>
                            <span># 文件扩展名。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="var-pattern-var-pattern-2"> <code>${var%Pattern}, ${var%%Pattern}</code></h4>
<p><code>${var%Pattern}</code> 删除 <code>$var</code> 后缀部分匹配到的最短长度的 <code>$Pattern</code>。</p>
<p><code>${var%%Pattern}</code> 删除 <code>$var</code> 后缀部分匹配到的最长长度的 <code>$Pattern</code>。</p>
<p>在 Bash 的 <a href="http://tldp.org/LDP/abs/html/bashver2.html#BASH2REF" target="_blank" rel="noopener noreferrer">第二个版本</a> 中增加了一些额外的选择。</p>
<p>样例 10-10. 参数替换中的模式匹配</p>
<div><pre><code><span>#!/bin/bash</span>
<span># patt-matching.sh</span>

<span># 使用 # ## % %% 参数替换操作符进行模式匹配</span>

<span>var1</span><span>=</span>abcd12345abc6789
<span>pattern1</span><span>=</span>a*c  <span># 通配符 * 可以匹配 a 与 c 之间的任意字符</span>

<span>echo</span>
<span>echo</span> <span>"var1 = <span>$var1</span>"</span>           <span># abcd12345abc6789</span>
<span>echo</span> <span>"var1 = <span>${var1}</span>"</span>         <span># abcd12345abc6789</span>
                              <span># （另一种形式）</span>
<span>echo</span> <span>"Number of characters in <span>${var1}</span> = <span>${<span>#</span>var1}</span>"</span>
<span>echo</span>

<span>echo</span> <span>"pattern1 = <span>$pattern1</span>"</span>   <span># a*c  (匹配 'a' 与 'c' 之间的一切)</span>
<span>echo</span> <span>"--------------"</span>
<span>echo</span> <span>'<span>${var1<span>#</span>$pattern1}</span>  ='</span> <span>"<span>${var1<span>#</span>$pattern1}</span>"</span>    <span>#         d12345abc6789</span>
<span># 匹配到首部最短的3个字符                                   abcd12345abc6789</span>
<span>#             ^                                           |-|</span>
<span>echo</span> <span>'<span>${var1<span>##</span>$pattern1}</span> ='</span> <span>"<span>${var1<span>##</span>$pattern1}</span>"</span>   <span>#                  6789</span>
<span># 匹配到首部最长的12个字符                                  abcd12345abc6789</span>
<span>#             ^                                           |----------|</span>

<span>echo</span><span>;</span> <span>echo</span><span>;</span> <span>echo</span>

<span>pattern2</span><span>=</span>b*9            <span># 匹配 'b' 与 '9' 之间的任意字符</span>
<span>echo</span> <span>"var1 = <span>$var1</span>"</span>     <span># 仍旧是 abcd12345abc6789</span>
<span>echo</span>
<span>echo</span> <span>"pattern2 = <span>$pattern2</span>"</span>
<span>echo</span> <span>"--------------"</span>
<span>echo</span> <span>'<span>${var1<span>%</span>pattern2}</span>  ='</span> <span>"<span>${var1<span>%</span>$pattern2}</span>"</span>     <span>#     abcd12345a</span>
<span># 匹配到尾部最短的6个字符                                  abcd12345abc6789</span>
<span>#             ^                                                    |----|</span>
<span>echo</span> <span>'<span>${var1<span>%%</span>pattern2}</span> ='</span> <span>"<span>${var1<span>%%</span>$pattern2}</span>"</span>    <span>#     a</span>
<span># 匹配到尾部最长的12个字符                                 abcd12345abc6789</span>
<span>#             ^                                           |-------------|</span>

<span># 牢记 # 与 ## 是从字符串左侧开始，</span>
<span>#      % 与 %% 是从右侧开始。</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>样例 10-11. 更改文件扩展名：</p>
<div><pre><code><span>#!/bin/bash</span>
<span># rfe.sh: 更改文件扩展名。</span>
<span>#</span>
<span>#         rfe old_extension new_extension</span>
<span>#</span>
<span># 如：</span>
<span># 将当前目录下所有 *.gif 文件重命名为 *.jpg，</span>
<span>#         rfe gif jpg</span>


<span>E_BADARGS</span><span>=</span><span>65</span>

<span>case</span> <span>$#</span> <span>in</span>
  <span>0</span><span>|</span><span>1</span><span>)</span>             <span># 竖线 | 在这里表示逻辑或关系。</span>
  <span>echo</span> <span>"Usage: <span><span>`</span><span>basename</span> $0<span>`</span></span> old_file_suffix new_file_suffix"</span>
  <span>exit</span> <span>$E_BADARGS</span>  <span># 如果只有0个或1个参数，那么退出脚本。</span>
  <span>;</span><span>;</span>
<span>esac</span>


<span>for</span> <span>filename</span> <span>in</span> *.<span>$1</span>
<span># 遍历以第一个参数作为后缀名的文件列表。</span>
<span>do</span>
  <span>mv</span> <span>$filename</span> <span>${filename<span>%</span>$1}</span><span>$2</span>
  <span># 删除文件后缀名，增加第二个参数作为后缀名。</span>
<span>done</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id="变量扩展-替换子串"> 变量扩展 / 替换子串</h3>
<p>下面这些结构采用自 ksh。</p>
<h4 id="var-pos"> <code>${var:pos}</code></h4>
<p>扩展为从偏移量 pos 处截取的变量 var。</p>
<h4 id="var-pos-len"> <code>${var:pos:len}</code></h4>
<p>扩展为从偏移量 pos 处截取变量 var 最大长度为 len 的字符串。</p>
<h4 id="var-pattern-replacement"> <code>${var/Pattern/Replacement}</code></h4>
<p>替换 var 中第一个匹配到的 Pattern 为 Replacement。</p>
<p>如果 Replacement 被省略，那么匹配到的第一个 Pattern 将被替换为空，即删除。</p>
<h4 id="var-pattern-replacement-2"> <code>${var//Pattern/Replacement}</code></h4>
<p>全局替换。替换 var 中所有匹配到的 Pattern 为 Replacement。</p>
<p>跟上面一样，如果 Replacement 被省略，那么匹配到的所有 Pattern 将被替换为空，即删除。</p>
<p>样例 10-12. 使用模式匹配解析任意字符串</p>
<div><pre><code><span>#!/bin/bash</span>

<span>var1</span><span>=</span>abcd-1234-defg
<span>echo</span> <span>"var1 = <span>$var1</span>"</span>

<span>t</span><span>=</span><span>${var1<span>#</span>*-*}</span>
<span>echo</span> <span>"var1 (with everything, up to and including first - stripped out) = <span>$t</span>"</span>
<span>#  t=${var1#*-} 效果相同，</span>
<span>#+ 因为 # 只匹配最短的字符串，</span>
<span>#+ 并且 * 可以任意匹配，其中也包括空字符串。</span>
<span># （感谢 Stephane Chazelas 指出这一点。）</span>

<span>t</span><span>=</span><span>${var<span>##</span>*-*}</span>
<span>echo</span> <span>"If var1 contains a <span title="\&quot;">\"</span>-<span title="\&quot;">\"</span>, returns empty string...   var1 = <span>$t</span>"</span>


<span>t</span><span>=</span><span>${var1<span>%</span>*-*}</span>
<span>echo</span> <span>"var1 (with everything from the last - on stripped out) = <span>$t</span>"</span>

<span>echo</span>

<span># -------------------------------------------</span>
<span>path_name</span><span>=</span>/home/bozo/ideas/thoughts/for.today
<span># -------------------------------------------</span>
<span>echo</span> <span>"path_name = <span>$path_name</span>"</span>
<span>t</span><span>=</span><span>${path_name<span>##</span><span>/</span>*<span>/</span>}</span>
<span>echo</span> <span>"path_name, stripped of prefixes = <span>$t</span>"</span>
<span># 在这里与 t=`basename $path_name` 效果相同。</span>
<span>#  t=${path_name%/}; t=${t##*/}  是更加通用的方法，</span>
<span>#+ 但有时仍旧也会出现问题。</span>
<span>#  如果 $path_name 以换行结束，那么 `basename $path_name` 将会失效，</span>
<span>#+ 但是上面这种表达式却可以。</span>
<span># （感谢 S.C.）</span>

<span>t</span><span>=</span><span>${path_name<span>%</span><span>/</span>*.*}</span>
<span># 同 t=`dirname $path_name` 效果相同。</span>
<span>echo</span> <span>"path_name, stripped of suffixes = <span>$t</span>"</span>
<span># 在一些情况下会失效，比如 "../", "/foo////", # "foo/", "/"。</span>
<span>#  在删除后缀时，尤其是当文件名没有后缀，目录名却有后缀时，</span>
<span>#+ 事情会变的非常复杂。</span>
<span># （感谢 S.C.）</span>

<span>echo</span>

<span>t</span><span>=</span><span>${path_name<span>:</span>11}</span>
<span>echo</span> <span>"<span>$path_name</span>, with first 11 chars stripped off = <span>$t</span>"</span>
<span>t</span><span>=</span><span>${path_name<span>:</span>11<span>:</span>5}</span>
<span>echo</span> <span>"<span>$path_name</span>, with first 11 chars stripped off, length 5 = <span>$t</span>"</span>

<span>echo</span>

<span>t</span><span>=</span><span>${path_name<span>/</span>bozo<span>/</span>clown}</span>
<span>echo</span> <span>"<span>$path_name</span> with <span title="\&quot;">\"</span>bozo<span title="\&quot;">\"</span> replaced by <span title="\&quot;">\"</span>clown<span title="\&quot;">\"</span> = <span>$t</span>"</span>
<span>t</span><span>=</span><span>${path_name<span>/</span>today<span>/</span>}</span>
<span>echo</span> <span>"<span>$path_name</span> with <span title="\&quot;">\"</span>today<span title="\&quot;">\"</span> deleted = <span>$t</span>"</span>
<span>t</span><span>=</span><span>${path_name<span>/</span><span>/</span>o<span>/</span>O}</span>
<span>echo</span> <span>"<span>$path_name</span> with all o's capitalized = <span>$t</span>"</span>
<span>t</span><span>=</span><span>${path_name<span>/</span><span>/</span>o<span>/</span>}</span>
<span>echo</span> <span>"<span>$path_name</span> with all o's deleted = <span>$t</span>"</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><h4 id="var-pattern-replacement-3"> <code>${var/#Pattern/Replacement}</code></h4>
<p>替换 var 前缀部分匹配到的 Pattern 为 Replacement。</p>
<h4 id="var-pattern-replacement-4"> <code>${var/%Pattern/Replacement}</code></h4>
<p>替换 var 后缀部分匹配到的 Pattern 为 Replacement。</p>
<p>样例 10-13. 在字符串首部或尾部进行模式匹配</p>
<div><pre><code><span>#!/bin/bash</span>
<span># var-match.sh:</span>
<span># 演示在字符串首部或尾部进行模式替换。</span>

<span>v0</span><span>=</span>abc1234zip1234abc    <span># 初始值。</span>
<span>echo</span> <span>"v0 = <span>$v0</span>"</span>         <span># abc1234zip1234abc</span>
<span>echo</span>

<span># 在字符串首部进行匹配</span>
<span>v1</span><span>=</span><span>${v0<span>/</span><span>#</span>abc<span>/</span>ABCDEF}</span>    <span># abc1234zip123abc</span>
                        <span># |-|</span>
<span>echo</span> <span>"v1 = <span>$v1</span>"</span>         <span># ABCDEF1234zip1234abc</span>
                        <span># |----|</span>
                        
<span># 在字符串尾部进行匹配</span>
<span>v2</span><span>=</span><span>${v0<span>/</span><span>%</span>abc<span>/</span>ABCDEF}</span>    <span># abc1234zip123abc</span>
                        <span>#              |-|</span>
<span>echo</span> <span>"v2 = <span>$v2</span>"</span>         <span># abc1234zip1234ABCDEF</span>
                        <span>#               |----|</span>
                        
<span>echo</span>

<span>#  --------------------------------------------</span>
<span>#  必须在字符串的最开始或者最末尾的地方进行匹配，</span>
<span>#+ 否则将不会发生替换。</span>
<span>#  --------------------------------------------</span>
<span>v3</span><span>=</span><span>${v0<span>/</span><span>#</span>123<span>/</span>000}</span>       <span># 虽然匹配到了，但是不在最开始的地方。</span>
<span>echo</span> <span>"v3 = <span>$v3</span>"</span>         <span># abc1234zip1234abc</span>
                        <span># 没有替换。</span>
<span>v4</span><span>=</span><span>${v0<span>/</span><span>%</span>123<span>/</span>000}</span>       <span># 虽然匹配到了，但是不在最末尾的地方。</span>
<span>echo</span> <span>"v4 = <span>$v4</span>"</span>         <span># abc1234zip1234abc</span>
                        <span># 没有替换。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h4 id="varprefix-varprefix"> <code>${!varprefix*}, ${!varprefix@}</code></h4>
<p>匹配先前声明过所有以 varprefix 作为变量名前缀的变量。</p>
<div><pre><code><span># 这是带 * 或 @ 的间接引用的一种变换形式。</span>
<span># 在 Bash 2.04 版本中加入了这个特性。</span>

<span>xyz23</span><span>=</span>whatever
<span>xyz23</span><span>=</span>

<span>a</span><span>=</span><span>${<span>!</span>xyz*}</span>         <span>#  扩展为声明变量中以 "xyz"</span>
<span># ^ ^   ^           + 开头变量名。</span>
<span>echo</span> <span>"a = <span>$a</span>"</span>      <span>#  a = xyz23 xyz24</span>
<span>a</span><span>=</span><span>${<span>!</span>xyz@}</span>         <span>#  同上。</span>
<span>echo</span> <span>"a = <span>$a</span>"</span>      <span>#  a = xyz23 xyz24</span>

<span>echo</span> <span>"---"</span>

<span>abc23</span><span>=</span>something_else
<span>b</span><span>=</span><span>${<span>!</span>abc*}</span>
<span>echo</span> <span>"b = <span>$b</span>"</span>      <span>#  b = abc23</span>
<span>c</span><span>=</span><span>${<span>!</span>b}</span>            <span>#  这是我们熟悉的间接引用的形式。</span>
<span>echo</span> <span>$c</span>            <span>#  something_else</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><hr>
<section>
<ol>
<li id="footnote1"><p>如果在非交互的脚本中，<code>$parameter</code> 为空，那么程序将会终止，并且返回 <a href="http://tldp.org/LDP/abs/html/exitcodes.html#EXITCODESREF" target="_blank" rel="noopener noreferrer">错误码 127</a>（意为“找不到命令”）。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第十章 变量处理</title>
    <id>https://clay-wangzhi.com/code/shell/part3/10_manipulating_variables/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/10_manipulating_variables/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第十章-变量处理"> 第十章 变量处理</h1>
<h3 id="本章目录"> 本章目录</h3>
<ul>
<li><a href="./10_1_manipulating_strings.html">10.1 字符串处理</a>
<ul>
<li><a href="./10_1_1_manipulating_strings_using_awk.html">10.1.1 使用 <code>awk</code> 处理字符串</a></li>
<li><a href="./10_1_2_further_reference.html">10.1.2 参考资料</a></li>
</ul>
</li>
<li><a href="./10_2_parameter_substitution.html">10.2 参数替换</a></li>
</ul>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">11.1 循环</title>
    <id>https://clay-wangzhi.com/code/shell/part3/11_1_loops/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/11_1_loops/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_11-1-循环"> 11.1 循环</h1>
<p>循环是当循环控制条件为真时，一系列命令迭代<sup></sup>执行的代码块。</p>
<h3 id="for-循环"> for 循环</h3>
<h3 id="for-arg-in-list"> <code>for arg in [list]</code></h3>
<p>这是 shell 中最基本的循环结构，它与C语言形式的循环有着明显的不同。</p>
<div><pre><code><span>for</span> <span>arg</span> <span>in</span> <span>[</span>list<span>]</span>
<span>do</span>
  command<span>(</span>s<span>)</span><span>..</span>.
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> 在循环的过程中，<code>arg</code> 会从 <code>list</code> 中连续获得每一个变量的值。</p>
</blockquote>
<div><pre><code><span>for</span> <span>arg</span> <span>in</span> <span>"<span>$var1</span>"</span> <span>"<span>$var2</span>"</span> <span>"<span>$var3</span>"</span> <span>..</span>. <span>"<span>$varN</span>"</span>
<span># 第一次循环中，arg = $var1</span>
<span># 第二次循环中，arg = $var2</span>
<span># 第三次循环中，arg = $var3</span>
<span># ...</span>
<span># 第 N 次循环中，arg = $varN</span>
<span>></span>
<span># 为了防止可能的字符分割问题，[list] 中的参数都需要被引用。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>参数 list 中允许含有 <a href="http://tldp.org/LDP/abs/html/special-chars.html#ASTERISKREF" target="_blank" rel="noopener noreferrer">通配符</a>。</p>
<p>如果 <code>do</code> 和 <code>for</code> 写在同一行时，需要在 list 之后加上一个分号。</p>
<p><code>for arg in [list] ; do</code></p>
<p>样例 11-1. 简单的 for 循环</p>
<div><pre><code><span>#!/bin/bash</span>
<span># 列出太阳系的所有行星。</span>

<span>for</span> <span>planet</span> <span>in</span> Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto
<span>do</span>
  <span>echo</span> <span>$planet</span>  <span># 每一行输出一个行星。</span>
<span>done</span>

<span>echo</span><span>;</span> <span>echo</span>

<span>for</span> <span>planet</span> <span>in</span> <span>"Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"</span>
    <span># 所有的行星都输出在一行上。</span>
    <span># 整个 'list' 被包裹在引号中时是作为一个单一的变量。</span>
    <span># 为什么？因为空格也是变量的一部分。</span>
<span>do</span>
  <span>echo</span> <span>$planet</span>
<span>done</span>

<span>echo</span><span>;</span> <span>echo</span> <span>"Whoops! Pluto is no longer a planet!"</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>[list] 中的每一个元素中都可能含有多个参数。这在处理参数组中非常有用。在这种情况下，使用 <a href="http://tldp.org/LDP/abs/html/internal.html#SETREF" target="_blank" rel="noopener noreferrer"><code>set</code></a> 命令（查看 <a href="http://tldp.org/LDP/abs/html/internal.html#EX34" target="_blank" rel="noopener noreferrer">样例 15-16</a>）强制解析 [list] 中的每一个元素，并将元素的每一个部分分配给位置参数。</p>
<p>样例 11-2. <code>for</code> 循环 [list] 中的每一个变量有两个参数的情况</p>
<div><pre><code><span>#!/bin/bash</span>
<span># 让行星再躺次枪。</span>

<span># 将每个行星与其到太阳的距离放在一起。</span>

<span>for</span> <span>planet</span> <span>in</span> <span>"Mercury 36"</span> <span>"Venus 67"</span> <span>"Earth 93"</span> <span>"Mars 142"</span> <span>"Jupiter 483"</span>
<span>do</span>
  <span>set</span> -- <span>$planet</span>  <span>#  解析变量 "planet"</span>
                  <span>#+ 并将其每个部分赋值给位置参数。</span>
  <span># "--" 防止一些极端情况，比如 $planet 为空或者以破折号开头。</span>
  
  <span># 因为位置参数会被覆盖掉，因此需要先保存原先的位置参数。</span>
  <span># 你可以使用数组来保存</span>
  <span>#         original_params=("$@")</span>
  
  <span>echo</span> <span>"<span>$1</span>		<span>$2</span>,000,000 miles from the sum"</span>
  <span>#-------两个制表符---将后面的一系列 0 连到参数 $2 上。</span>
<span>done</span>

<span># （感谢 S.C. 做出的额外注释。）</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>一个单一变量也可以成为 <code>for</code> 循环中的 [list]。</p>
<p>样例 11-3. 文件信息：查看一个单一变量中含有的文件列表的文件信息</p>
<div><pre><code><span>#!/bin/bash</span>
<span># fileinfo.sh</span>

<span>FILES</span><span>=</span><span>"/usr/sbin/accept
/usr/sbin/pwck
/usr/sbin/chroot
/usr/bin/fakefile
/sbin/badblocks
/sbin/ypbind"</span>     <span># 你可能会感兴趣的一系列文件。</span>
                  <span># 包含一个不存在的文件，/usr/bin/fakefile。</span>
                  
<span>echo</span>

<span>for</span> <span>file</span> <span>in</span> <span>$FILES</span>
<span>do</span>

  <span>if</span> <span>[</span> <span>!</span> -e <span>"<span>$file</span>"</span> <span>]</span>       <span># 检查文件是否存在。</span>
  <span>then</span>
    <span>echo</span> <span>"<span>$file</span> does not exist."</span><span>;</span> <span>echo</span>
    <span>continue</span>                <span># 继续判断下一个文件。</span>
  <span>fi</span>
  
  <span>ls</span> -l <span>$file</span> <span>|</span> <span>awk</span> <span>'{ print <span>$8</span> "         file size: " <span>$5</span> }'</span>  <span># 输出其中的两个域。</span>
  whatis <span><span>`</span><span>basename</span> $file<span>`</span></span>   <span># 文件信息。</span>
  <span># 脚本正常运行需要注意提前设置好 whatis 的数据。</span>
  <span># 使用 root 权限运行 /usr/bin/makewhatis 可以完成。</span>
  <span>echo</span>
<span>done</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p><code>for</code> 循环中的 [list] 可以是一个参数。</p>
<p>样例 11-4. 操作含有一系列文件的参数</p>
<div><pre><code><span>#!/bin/bash</span>

<span>filename</span><span>=</span><span>"*txt"</span>

<span>for</span> <span>file</span> <span>in</span> <span>$filename</span>
<span>do</span>
 <span>echo</span> <span>"Contents of <span>$file</span>"</span>
 <span>echo</span> <span>"---"</span>
 <span>cat</span> <span>"<span>$file</span>"</span>
 <span>echo</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果在匹配文件扩展名的 <code>for</code> 循环中的 [list] 含有通配符（* 和 ?），那么将会进行文件名扩展。</p>
<p>样例 11-5. 在 <code>for</code> 循环中操作文件</p>
<div><pre><code><span>#!/bin/bash</span>
<span># list-glob.sh: 通过文件名扩展在 for 循环中产生 [list]。</span>
<span># 通配 = 文件名扩展。</span>

<span>echo</span>

<span>for</span> <span>file</span> <span>in</span> *
<span>#           ^  Bash 在检测到通配表达式时，</span>
<span>#+             会进行文件名扩展。</span>
<span>do</span>
  <span>ls</span> -l <span>"<span>$file</span>"</span>  <span># 列出 $PWD（当前工作目录）下的所有文件。</span>
  <span>#  回忆一下，通配符 "*" 会匹配所有的文件名，</span>
  <span>#+ 但是，在文件名扩展中，他将不会匹配以点开头的文件。</span>
  
  <span>#  如果没有匹配到文件，那么它将会扩展为它自身。</span>
  <span>#  为了防止出现这种情况，需要设置 nullglob 选项。</span>
  <span>#+    (shopt -s nullglob)。</span>
  <span>#  感谢 S.C.</span>
<span>done</span>

<span>echo</span><span>;</span> <span>echo</span>

<span>for</span> <span>file</span> <span>in</span> <span>[</span>jx<span>]</span>*
<span>do</span>
  <span>rm</span> -f <span>$file</span>    <span># 删除当前目录下所有以 "j" 或 "x" 开头的文件。</span>
  <span>echo</span> <span>"Removed file <span title="\&quot;">\"</span><span>$file</span><span title="\&quot;">\"</span>"</span><span>.</span>
<span>done</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>如果在 <code>for</code> 循环中省略 <code>in [list]</code> 部分，那么循环将会遍历位置参数（<code>$@</code>）。<a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#PRIMES" target="_blank" rel="noopener noreferrer">样例 A-15</a> 中使用到了这一点。也可以查看 <a href="http://tldp.org/LDP/abs/html/internal.html#REVPOSPARAMS" target="_blank" rel="noopener noreferrer">样例 15-17</a>。</p>
<p>样例 11-6. 缺少 <code>in [list]</code> 的 <code>for</code> 循环</p>
<div><pre><code><span>#!/bin/bash</span>

<span># 尝试在带参数和不带参数两种情况下调用这个脚本，观察发生了什么。</span>

<span>for</span> a
<span>do</span>
 <span>echo</span> -n <span>"<span>$a</span> "</span>
<span>done</span>

<span>#  缺失 'in list' 的情况下，循环会遍历 '$@'</span>
<span>#+（命令行参数列表，包括空格）。</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>可以在 <code>for</code> 循环中使用 <a href="http://tldp.org/LDP/abs/html/commandsub.html#COMMANDSUBREF" target="_blank" rel="noopener noreferrer">命令代换</a> 生成 [list]。查看 <a href="http://tldp.org/LDP/abs/html/extmisc.html#EX53" target="_blank" rel="noopener noreferrer">样例 16-54</a>，<a href="http://tldp.org/LDP/abs/html/loops1.html#SYMLINKS" target="_blank" rel="noopener noreferrer">样例 11-11</a> 和 <a href="http://tldp.org/LDP/abs/html/mathc.html#BASE" target="_blank" rel="noopener noreferrer">样例 16-48</a>。</p>
<p>样例 11-7. 在 <code>for</code> 循环中使用命令代换生成 [list]</p>
<div><pre><code><span>#!/bin/bash</span>
<span># for-loopcmd.sh: 带命令代换所生成 [list] 的 for 循环</span>

<span>NUMBERS</span><span>=</span><span>"9 7 3 8 37.53"</span>

<span>for</span> <span>number</span> <span>in</span> <span><span>`</span><span>echo</span> $NUMBERS<span>`</span></span>  <span># for number in 9 7 3 8 37.53</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$number</span> "</span>
<span>done</span>

<span>echo</span>
<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>下面是使用命令代换生成 [list] 的更加复杂的例子。</p>
<p>样例 11-8. 一种替代 <code>grep</code> 搜索二进制文件的方法</p>
<div><pre><code><span>#!/bin/bash</span>
<span># bin-grep.sh: 在二进制文件中定位匹配的字符串。</span>

<span># 一种替代 `grep` 搜索二进制文件的方法</span>
<span># 与 "grep -a" 的效果类似</span>

<span>E_BADARGS</span><span>=</span><span>65</span>
<span>E_NOFILE</span><span>=</span><span>66</span>

<span>if</span> <span>[</span> <span>$#</span> -ne <span>2</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"Usage: <span><span>`</span><span>basename</span> $0<span>`</span></span> search_string filename"</span>
  <span>exit</span> <span>$E_BADARGS</span>
<span>fi</span>

<span>if</span> <span>[</span> <span>!</span> -f <span>"<span>$2</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"File <span title="\&quot;">\"</span><span>$2</span><span title="\&quot;">\"</span> does not exist."</span>
  <span>exit</span> <span>$E_NOFILE</span>
<span>fi</span>


<span><span>IFS</span></span><span>=</span>$<span>'<span title="\012">\012</span>'</span>       <span># 按照 Anton Filippov 的意见应该是</span>
                  <span># IFS="\n"</span>
<span>for</span> <span>word</span> <span>in</span> <span><span>$(</span> strings <span>"<span>$2</span>"</span> <span>|</span> <span>grep</span> <span>"<span>$1</span>"</span> <span>)</span></span>
<span># "strings" 命令列出二进制文件中的所有字符串。</span>
<span># 将结果通过管道输出到 "grep" 中，检查是不是匹配的字符串。</span>
<span>do</span>
  <span>echo</span> <span>$word</span>
<span>done</span>

<span># 就像 S.C. 指出的那样，第 23-30 行可以换成下面的形式：</span>
<span>#    strings "$2" | grep "$1" | tr -s "$IFS" '[\n*]'</span>


<span># 尝试运行脚本 "./bin-grep.sh mem /bin/ls"</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>下面的例子同样展示了如何使用命令代换生成 [list]。</p>
<p>样例 11-9. 列出系统中的所有用户</p>
<div><pre><code><span>#!/bin/bash</span>
<span># userlist.sh</span>

<span>PASSWORD_FILE</span><span>=</span>/etc/passwd
<span>n</span><span>=</span><span>1</span>           <span># 用户数量</span>

<span>for</span> <span>name</span> <span>in</span> <span><span>$(</span><span>awk</span> <span>'BEGIN{fs=":"}{print <span>$1</span>}'</span> <span>&lt;</span> <span>"<span>$PASSWORD_FILE</span>"</span> <span>)</span></span>
<span># 分隔符 = :              ^^^^^^</span>
<span># 输出第一个域                    ^^^^^^^^</span>
<span># 读取密码文件 /etc/passwd                    ^^^^^^^^^^^^^^^^^</span>
<span>do</span>
  <span>echo</span> <span>"USER #<span>$n</span> = <span>$name</span>"</span>
  <span>let</span> <span>"n += 1"</span>
<span>done</span>


<span># USER #1 = root</span>
<span># USER #2 = bin</span>
<span># USER #3 = daemon</span>
<span># ...</span>
<span># USER #33 = bozo</span>

<span>exit</span> <span>$?</span>

<span># 讨论：</span>
<span># -----</span>
<span># 一个普通用户是如何读取 /etc/passwd 文件的？</span>
<span># 提示：检查 /etc/passwd 的文件权限。</span>
<span># 这算不算是一个安全漏洞？为什么？</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>另外一个关于 [list] 的例子也来自于命令代换。</p>
<p>样例 11-10. 检查目录中所有二进制文件的原作者</p>
<div><pre><code><span>#!/bin/bash</span>
<span># findstring.sh</span>
<span># 在指定目录的二进制文件中寻找指定的字符串。</span>

<span>directory</span><span>=</span>/usr/bin
<span>fstring</span><span>=</span><span>"Free Software Foundation"</span>  <span># 查看哪些文件来自于 FSF。</span>

<span>for</span> <span>file</span> <span>in</span> <span><span>$(</span> <span>find</span> $directory -type f -name <span>'*'</span> <span>|</span> <span>sort</span> <span>)</span></span>
<span>do</span>
  strings -f <span>$file</span> <span>|</span> <span>grep</span> <span>"<span>$fstring</span>"</span> <span>|</span> <span>sed</span> -e <span>"s%<span>$driectory</span>%%"</span>
  <span>#  在 "sed" 表达式中，你需要替换掉 "/" 分隔符，</span>
  <span>#+ 因为 "/" 是一个会被过滤的字符。</span>
  <span>#  如果不做替换，将会产生一个错误。（你可以尝试一下。）</span>
<span>done</span>

<span>exit</span> <span>$?</span>

<span># 简单的练习：</span>
<span># ----------</span>
<span># 修改脚本，使其可以从命令行参数中获取 $directory 和 $fstring。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>最后一个关于 [list] 和命令代换的例子，但这个例子中的命令是一个<a href="http://tldp.org/LDP/abs/html/functions.html#FUNCTIONREF" target="_blank" rel="noopener noreferrer">函数</a>。</p>
<div><pre><code><span>generate_list</span> <span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"one two three"</span>
<span>}</span>

<span>for</span> <span>word</span> <span>in</span> <span><span>$(</span>generate_list<span>)</span></span>  <span># "word" 获得函数执行的结果。</span>
<span>do</span>
  <span>echo</span> <span>"<span>$word</span>"</span>
<span>done</span>

<span># one</span>
<span># two</span>
<span># three</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><code>for</code> 循环的结果可以通过管道导向至一个或多个命令中。</p>
<p>样例 11-11. 列出目录中的所有符号链接。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># symlinks.sh: 列出目录中的所有符号链接。</span>

<span>directory</span><span>=</span><span>${1-`pwd`}</span>
<span># 如果没有特别指定，缺省目录为当前工作目录。</span>
<span># 等价于下面的代码块。</span>
<span># ---------------------------------------------------</span>
<span># ARGS=1                 # 只有一个命令行参数。</span>
<span>#</span>
<span># if [ $# -ne "$ARGS" ]  # 如果不是只有一个参数的情况下</span>
<span># then</span>
<span>#   directory=`pwd`      # 设为当前工作目录。</span>
<span># else</span>
<span>#   directory=$1</span>
<span># fi</span>
<span># ---------------------------------------------------</span>

<span>echo</span> <span>"symbolic links in directory <span title="\&quot;">\"</span><span>$directory</span><span title="\&quot;">\"</span>"</span>

<span>for</span> <span>file</span> <span>in</span> <span>"<span><span>$(</span> <span>find</span> $directory -type <span>1</span> <span>)</span></span>"</span>   <span># -type 1 = 符号链接</span>
<span>do</span>
  <span>echo</span> <span>"<span>$file</span>"</span>
<span>done</span> <span>|</span> <span>sort</span>                                  <span># 否则文件顺序会是乱序。</span>
<span>#  严格的来说这里并不需要使用循环，</span>
<span>#+ 因为 "find" 命令的输出结果已经被扩展成一个单一字符串了。</span>
<span>#  然而，为了方便大家理解，我们使用了循环的方式。</span>

<span>#  Dominik 'Aeneas' Schnitzer 指出，</span>
<span>#+ 不引用 $( find $directory -type 1 ) 的话，</span>
<span>#  脚本将在文件名包含空格时阻塞。</span>

<span>exit</span> <span>0</span>


<span># --------------------------------------------------------</span>
<span># Jean Helou 提供了另外一种方法：</span>

<span>echo</span> <span>"symbolic links in directory <span title="\&quot;">\"</span><span>$directory</span><span title="\&quot;">\"</span>"</span>
<span># 备份当前的内部字段分隔符。谨慎永远没有坏处。</span>
<span>OLDIFS</span><span>=</span><span>$IFS</span>
<span><span>IFS</span></span><span>=</span>:

<span>for</span> <span>file</span> <span>in</span> <span><span>$(</span><span>find</span> $directory -type <span>1</span> -printf <span>"%p<span>$IFS</span>"</span><span>)</span></span>
<span>do</span>     <span>#                              ^^^^^^^^^^^^^^^^</span>
       <span>echo</span> <span>"<span>$file</span>"</span>
       <span>done</span><span>|</span><span>sort</span>

<span># James "Mike" Conley 建议将 Helou 的代码修改为：</span>

<span>OLDIFS</span><span>=</span><span>$IFS</span>
<span><span>IFS</span></span><span>=</span><span>''</span> <span># 空的内部字段分隔符意味着将不会分隔任何字符串</span>
<span>for</span> <span>file</span> <span>in</span> <span><span>$(</span> <span>find</span> $directory -type <span>1</span> <span>)</span></span>
<span>do</span>
  <span>echo</span> <span>$file</span>
  <span>done</span> <span>|</span> <span>sort</span>
  
<span>#  上面的代码可以在目录名包含冒号（前一个允许包含空格）</span>
<span>#+ 的情况下仍旧正常工作。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><p>只需要对上一个样例做一些小小的改动，就可以把在标准输出 <code>stdout</code> 中的循环 <a href="http://tldp.org/LDP/abs/html/io-redirection.html#IOREDIRREF" target="_blank" rel="noopener noreferrer">重定向</a> 到文件中。</p>
<p>样例 11-12. 将目录中的所有符号链接保存到文件中。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># symlinks.sh: 列出目录中的所有符号链接。</span>

<span>OUTFILE</span><span>=</span>symlinks.list

<span>directory</span><span>=</span><span>${1-`pwd`}</span>
<span># 如果没有特别指定，缺省目录为当前工作目录。</span>


<span>echo</span> <span>"symbolic links in directory <span title="\&quot;">\"</span><span>$directory</span><span title="\&quot;">\"</span>"</span> <span>></span> <span>"<span>$OUTFILE</span>"</span>
<span>echo</span> <span>"---------------------------"</span> <span>>></span> <span>"<span>$OUTFILE</span>"</span>

<span>for</span> <span>file</span> <span>in</span> <span>"<span><span>$(</span> <span>find</span> $directory -type <span>1</span> <span>)</span></span>"</span>    <span># -type 1 = 符号链接</span>
<span>do</span>
  <span>echo</span> <span>"<span>$file</span>"</span>
<span>done</span> <span>|</span> <span>sort</span> <span>>></span> <span>"<span>$OUTFILE</span>"</span>                     <span># 将 stdout 的循环结果</span>
<span>#           ^^^^^^^^^^^^^                       重定向到文件。</span>

<span># echo "Output file = $OUTFILE"</span>

<span>exit</span> <span>$?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>还有另外一种看起来非常像C语言中循环那样的语法。你需要使用到 <a href="http://tldp.org/LDP/abs/html/dblparens.html#DBLPARENSREF" target="_blank" rel="noopener noreferrer">双圆括号</a> 语法。</p>
<p>样例 11-13. C语言风格的循环</p>
<div><pre><code><span>#!/bin/bash</span>
<span># 用多种方式数到10。</span>

<span>echo</span>

<span># 基础版</span>
<span>for</span> <span>a</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span> <span>8</span> <span>9</span> <span>10</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$a</span> "</span>
<span>done</span>

<span>echo</span><span>;</span> <span>echo</span>

<span># +==========================================+</span>

<span># 使用 "seq"</span>
<span>for</span> <span>a</span> <span>in</span> <span><span>`</span><span>seq</span> <span>10</span><span>`</span></span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$a</span> "</span>
<span>done</span>

<span>echo</span><span>;</span> <span>echo</span>

<span># +==========================================+</span>

<span># 使用大括号扩展语法</span>
<span># Bash 3+ 版本有效。</span>
<span>for</span> <span>a</span> <span>in</span> <span>{</span><span>1</span><span>..</span><span>10</span><span>}</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$a</span> "</span>
<span>done</span>

<span>echo</span><span>;</span> <span>echo</span>

<span># +==========================================+</span>

<span># 现在用类似C语言的语法再实现一次。</span>

<span>LIMIT</span><span>=</span><span>10</span>

<span>for</span> <span><span>((</span>a<span>=</span><span>1</span><span>;</span> a <span>&lt;=</span> LIMIT <span>;</span> a<span>++</span><span>))</span></span>  <span># 双圆括号语法，不带 $ 的 LIMIT</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$a</span> "</span>
<span>done</span>                           <span># 从 ksh93 中学习到的特性。</span>

<span>echo</span><span>;</span> <span>echo</span>

<span># +==========================================+</span>

<span># 我们现在使用C语言中的逗号运算符来使得两个变量同时增加。</span>

<span>for</span> <span><span>((</span>a<span>=</span><span>1</span><span>,</span> b<span>=</span><span>1</span><span>;</span> a <span>&lt;=</span> LIMIT <span>;</span> a<span>++</span><span>,</span> b<span>++</span><span>))</span></span>
<span>do</span>  <span># 逗号连接操作。</span>
  <span>echo</span> -n <span>"<span>$a</span>-<span>$b</span> "</span>
<span>done</span>

<span>echo</span><span>;</span> <span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div><p>还可以查看 <a href="http://tldp.org/LDP/abs/html/arrays.html#QFUNCTION" target="_blank" rel="noopener noreferrer">样例 27-16</a>，<a href="http://tldp.org/LDP/abs/html/arrays.html#TWODIM" target="_blank" rel="noopener noreferrer">样例 27-17</a> 和 <a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#COLLATZ" target="_blank" rel="noopener noreferrer">样例 A-6</a>。</p>
<p>---</p>
<p>接下来，我们将展示在真实环境中应用的循环。</p>
<p>样例 11-14. 在批处理模式下使用 <code>efax</code></p>
<div><pre><code><span>#!/bin/bash</span>
<span># 传真（必须提前安装了 'efax' 模块）。</span>

<span>EXPECTED_ARGS</span><span>=</span><span>2</span>
<span>E_BADARGS</span><span>=</span><span>85</span>
<span>MODEM_PORT</span><span>=</span><span>"/dev/ttyS2"</span>   <span># 你的电脑可能会不一样。</span>
<span>#                ^^^^^       PCMCIA 调制解调卡缺省端口。</span>

<span>if</span> <span>[</span> <span>$#</span> -ne <span>$EXPECTED_ARGS</span> <span>]</span>
<span># 检查是不是传入了适当数量的命令行参数。</span>
<span>then</span>
   <span>echo</span> <span>"Usage: <span><span>`</span><span>basename</span> $0<span>`</span></span> phone# text-file"</span>
   <span>exit</span> <span>$E_BADARGS</span>
<span>fi</span>


<span>if</span> <span>[</span> <span>!</span> -f <span>"<span>$2</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"File <span>$2</span> is not a text file."</span>
  <span>#     File 不是一个正常文件或者文件不存在。</span>
  <span>exit</span> <span>$E_BADARGS</span>
<span>fi</span>


fax <span>make</span> <span>$2</span>              <span># 根据文本文件创建传真格式文件。</span>

<span>for</span> <span>file</span> <span>in</span> <span><span>$(</span><span>ls</span> $2.0*<span>)</span></span>  <span># 连接转换后的文件。</span>
                         <span># 在参数列表中使用通配符（文件名通配）。</span>
<span>do</span>
  <span>fil</span><span>=</span><span>"<span>$fil</span> <span>$file</span>"</span>
<span>done</span>

efax -d <span>"<span>$MODEM_PORT</span>"</span>  -t <span>"T<span>$1</span>"</span> <span>$fil</span>   <span># 最后使用 efax。</span>
<span># 如果上面一行执行失败，尝试添加 -o1。</span>


<span>#  S.C. 指出，上面的 for 循环可以被压缩为</span>
<span>#     efax -d /dev/ttyS2 -o1 -t "T$1" $2.0*</span>
<span>#+ 但是这并不是一个好主意。</span>

<span>exit</span> <span>$?</span>   <span># efax 同时也会将诊断信息传递给标准输出。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> <a href="http://tldp.org/LDP/abs/html/internal.html#KEYWORDREF" target="_blank" rel="noopener noreferrer">关键字</a> <code>do</code> 和 <code>done</code> 圈定了 for 循环代码块的范围。但是在一些特殊的情况下，也可以被 <a href="http://tldp.org/LDP/abs/html/special-chars.html#CODEBLOCKREF" target="_blank" rel="noopener noreferrer">大括号</a> 取代。</p>
</blockquote>
<div><pre><code><span>for</span><span><span>((</span>n<span>=</span><span>1</span><span>;</span> n<span>&lt;=</span><span>10</span><span>;</span> n<span>++</span><span>))</span></span>
<span># 没有 do！</span>
<span>{</span>
  <span>echo</span> -n <span>"* <span>$n</span> *"</span>
<span>}</span>
<span># 没有 done！</span>
<span>></span>
<span>></span>
<span># 输出：</span>
<span># * 1 ** 2 ** 3 ** 4 ** 5 ** 6 ** 7 ** 8 ** 9 ** 10 *</span>
<span># 并且 echo $? 返回 0，因此 Bash 并不认为这是一个错误。</span>
<span>></span>
<span>></span>
<span>echo</span>
<span>></span>
<span>></span>
<span>#  但是注意在典型的 for 循环 for n in [list] ... 中，</span>
<span>#+ 需要在结尾加一个分号。</span>
<span>></span>
<span>for</span> <span>n</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span>
<span>{</span>  <span>echo</span> -n <span>"<span>$n</span> "</span><span>;</span> <span>}</span>
<span>#               ^</span>
<span>></span>
<span>></span>
<span># 感谢 Yongye 指出这一点。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="while-循环"> while 循环</h3>
<p><code>while</code> 循环结构会在循环顶部检测循环条件，若循环条件为真（ <a href="http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF" target="_blank" rel="noopener noreferrer">退出状态</a> 为0）则循环持续进行。与 <a href="http://tldp.org/LDP/abs/html/loops1.html#FORLOOPREF1" target="_blank" rel="noopener noreferrer"><code>for</code> 循环</a> 不同的是，<code>while</code> 循环是在不知道循环次数的情况下使用的。</p>
<div><pre><code><span>while</span> <span>[</span> condition <span>]</span>
<span>do</span>
  command<span>(</span>s<span>)</span><span>..</span>.
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在 <code>while</code> 循环结构中，你不仅可以使用像 <code>if/test</code> 中那样的 <a href="http://tldp.org/LDP/abs/html/testconstructs.html#TESTCONSTRUCTS1" target="_blank" rel="noopener noreferrer">括号结构</a>，也可以使用用途更广泛的 <a href="http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS" target="_blank" rel="noopener noreferrer">双括号结构</a>（<code>while [[ condition ]]</code>）。</p>
<p>就像在 <code>for</code> 循环中那样，将 <code>do</code> 和循环条件放在同一行时需要加一个分号。</p>
<p><code>while [ condition ] ; do</code></p>
<p>在 <code>while</code> 循环中，括号结构 <a href="http://tldp.org/LDP/abs/html/loops1.html#WHILENOBRACKETS" target="_blank" rel="noopener noreferrer">并不是必须存在的</a>。比如说 <a href="http://tldp.org/LDP/abs/html/internal.html#GETOPTSX" target="_blank" rel="noopener noreferrer"><code>getopts</code> 结构</a>。</p>
<p>样例 11-15. 简单的 <code>while</code> 循环</p>
<div><pre><code><span>#!/bin/bash</span>

<span>var0</span><span>=</span><span>0</span>
<span>LIMIT</span><span>=</span><span>10</span>

<span>while</span> <span>[</span> <span>"<span>$var0</span>"</span> -lt <span>"<span>$LIMIT</span>"</span> <span>]</span>
<span>#      ^                    ^</span>
<span># 必须有空格，因为这是测试结构</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$var0</span> "</span>        <span># -n 不会另起一行</span>
  <span>#             ^           空格用来分开输出的数字。</span>
  
  <span>var0</span><span>=</span><span><span>`</span><span>expr</span> $var0 + <span>1</span><span>`</span></span>   <span># var0=$(($var0+1))  效果相同。</span>
                          <span># var0=$((var0 + 1)) 效果相同。</span>
                          <span># let "var0 += 1"    效果相同。</span>
<span>done</span>                      <span># 还有许多其他的方法也可以达到相同的效果。</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>样例 11-16. 另一个例子</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span>
                               <span># 等价于：</span>
<span>while</span> <span>[</span> <span>"<span>$var1</span>"</span> <span>!=</span> <span>"end"</span> <span>]</span>     <span># while test "$var1" != "end"</span>
<span>do</span>
  <span>echo</span> <span>"Input variable #1 (end to exit) "</span>
  <span>read</span> var1                    <span># 不是 'read $var1' （为什么？）。</span>
  <span>echo</span> <span>"variable #1 = <span>$var1</span>"</span>   <span># 因为存在 "#"，所以需要使用引号。</span>
  <span># 如果输入的是 "end"，也将会在这里输出。</span>
  <span># 在结束本轮循环之前都不会再测试循环条件了。</span>
  <span>echo</span>
<span>done</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>一个 <code>while</code> 循环可以有多个测试条件，但只有最后的那一个条件决定了循环是否终止。这是一种你需要注意到的不同于其他循环的语法。</p>
<p>样例 11-17. 多条件 <code>while</code> 循环</p>
<div><pre><code><span>#!/bin/bash</span>

<span>var1</span><span>=</span>unset
<span>previous</span><span>=</span><span>$var1</span>

<span>while</span> <span>echo</span> <span>"previous-variable = <span>$previous</span>"</span>
      <span>echo</span>
      <span>previous</span><span>=</span><span>$var1</span>
      <span>[</span> <span>"<span>$var1</span>"</span> <span>!=</span> end <span>]</span> <span># 记录下 $var1 之前的值。</span>
      <span># 在 while 循环中有4个条件，但只有最后的那个控制循环。</span>
      <span># 最后一个条件的退出状态才会被记录。</span>
<span>do</span>
<span>echo</span> <span>"Input variable #1 (end to exit) "</span>
  <span>read</span> var1
  <span>echo</span> <span>"variable #1 = <span>$var1</span>"</span>
<span>done</span>

<span># 猜猜这是怎样实现的。</span>
<span># 这是一个很小的技巧。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>就像 <code>for</code> 循环一样， <code>while</code> 循环也可以使用双圆括号结构写得像C语言那样（也可以查看<a href="http://tldp.org/LDP/abs/html/dblparens.html#CVARS" target="_blank" rel="noopener noreferrer">样例 8-5</a>）。</p>
<p>样例 11-18. C语言风格的 <code>while</code> 循环</p>
<div><pre><code><span>#!/bin/bash</span>
<span># wh-loopc.sh: 在 "while" 循环中计数到10。</span>

<span>LIMIT</span><span>=</span><span>10</span>                 <span># 循环10次。</span>
<span>a</span><span>=</span><span>1</span>

<span>while</span> <span>[</span> <span>"<span>$a</span>"</span> -le <span>$LIMIT</span> <span>]</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$a</span> "</span>
  <span>let</span> <span>"a+=1"</span>
<span>done</span>                     <span># 没什么好奇怪的吧。</span>

<span>echo</span><span>;</span> <span>echo</span>

<span># +==============================================+</span>

<span># 现在我们用C语言风格再写一次。</span>

<span><span>((</span>a <span>=</span> <span>1</span><span>))</span></span>      <span># a=1</span>
<span># 双圆括号结构允许像C语言一样在赋值语句中使用空格。</span>

<span>while</span> <span><span>((</span> a <span>&lt;=</span> LIMIT <span>))</span></span>   <span>#  双圆括号结构，</span>
<span>do</span>                       <span>#+ 并且没有使用 "$"。</span>
  <span>echo</span> -n <span>"<span>$a</span> "</span>
  <span><span>((</span>a <span>+</span><span>=</span> <span>1</span><span>))</span></span>             <span># let "a+=1"</span>
  <span># 是的，就是这样。</span>
  <span># 双圆括号结构允许像C语言一样自增一个变量。</span>
<span>done</span>

<span>echo</span>

<span># 这可以让C和Java程序猿感觉更加舒服。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>在测试部分，<code>while</code> 循环可以调用 <a href="http://tldp.org/LDP/abs/html/functions.html#FUNCTIONREF" target="_blank" rel="noopener noreferrer">函数</a>。</p>
<div><pre><code><span>t</span><span>=</span><span>0</span>

<span>condition</span> <span>(</span><span>)</span>
<span>{</span>
  <span><span>((</span>t<span>++</span><span>))</span></span>
  
  <span>if</span> <span>[</span> <span>$t</span> -lt <span>5</span> <span>]</span>
  <span>then</span>
    <span>return</span> <span>0</span>  <span># true 真</span>
  <span>else</span>
    <span>return</span> <span>1</span>  <span># false 假</span>
  <span>fi</span>
<span>}</span>

<span>while</span> condition
<span>#     ^^^^^^^^^</span>
<span>#     调用函数循环四次。</span>
<span>do</span>
  <span>echo</span> <span>"Still going: t = <span>$t</span>"</span>
<span>done</span>

<span># Still going: t = 1</span>
<span># Still going: t = 2</span>
<span># Still going: t = 3</span>
<span># Still going: t = 4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><blockquote>
<p>和 <a href="http://tldp.org/LDP/abs/html/testconstructs.html#IFGREPREF" target="_blank" rel="noopener noreferrer">if 测试</a> 结构一样，<code>while</code> 循环也可以省略括号。</p>
</blockquote>
<div><pre><code><span>while</span> condition
<span>do</span>
  command<span>(</span>s<span>)</span> <span>..</span>.
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在 <code>while</code> 循环中结合 <a href="http://tldp.org/LDP/abs/html/internal.html#READREF" target="_blank" rel="noopener noreferrer"><code>read</code></a> 命令，我们就得到了一个非常易于使用的 <a href="http://tldp.org/LDP/abs/html/internal.html#WHILEREADREF" target="_blank" rel="noopener noreferrer"><code>while read</code></a> 结构。它可以用来读取和解析文件。</p>
<div><pre><code><span>cat</span> <span>$filename</span> <span>|</span>    <span># 从文件获得输入。</span>
<span>while</span> <span>read</span> line    <span># 只要还有可以读入的行，循环就继续。</span>
<span>do</span>
  <span>..</span>.
<span>done</span>

<span># ==================== 摘自样例脚本 "sd.sh" =================== #</span>

  <span>while</span> <span>read</span> value   <span># 一次读入一个数据。</span>
  <span>do</span>
    <span>rt</span><span>=</span><span><span>$(</span><span>echo</span> <span>"scale=<span>$SC</span>; <span>$rt</span> + <span>$value</span>"</span> <span>|</span> <span>bc</span><span>)</span></span>
    <span><span>((</span> ct<span>++</span> <span>))</span></span>
  <span>done</span>
  
  <span>am</span><span>=</span><span><span>$(</span><span>echo</span> <span>"scale=<span>$SC</span>; <span>$rt</span> / <span>$ct</span>"</span> <span>|</span> <span>bc</span><span>)</span></span>
  
  <span>echo</span> <span>$am</span><span>;</span> <span>return</span> <span>$ct</span>   <span># 这个功能“返回”了2个值。</span>
  <span># 注意：这个技巧在 $ct > 255 的情况下会失效。</span>
  <span># 如果要操作更大的数字，注释掉上面的 "return $ct" 就可以了。</span>
<span>}</span> <span>&lt;</span><span>"<span>$datafile</span>"</span>   <span># 传入数据文件。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> 在 <code>while</code> 循环后面可以通过 &lt; 将标准输入 <a href="http://tldp.org/LDP/abs/html/redircb.html#REDIRREF" target="_blank" rel="noopener noreferrer">重定位到文件</a> 中。
<code>while</code> 循环同样可以 <a href="http://tldp.org/LDP/abs/html/internal.html#READPIPEREF" target="_blank" rel="noopener noreferrer">通过管道</a> 传入标准输入中。</p>
</blockquote>
<h3 id="until"> until</h3>
<p>与 <code>while</code> 循环相反，<code>until</code> 循环测试其顶部的循环条件，直到其中的条件为真时停止。</p>
<div><pre><code><span>until</span> <span>[</span> condition-is-true <span>]</span>
<span>do</span>
  commands<span>(</span>s<span>)</span><span>..</span>.
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意到，跟其他的一些编程语言不同，<code>until</code> 循环的测试条件在循环顶部。</p>
<p>就像在 <code>for</code> 循环中那样，将 <code>do</code> 和循环条件放在同一行时需要加一个分号。</p>
<p><code>until[ condition-is-true ] ; do</code></p>
<p>样例 11-19. <code>until</code> 循环</p>
<div><pre><code><span>#!/bin/bash</span>

<span>END_CONDITION</span><span>=</span>end

<span>until</span> <span>[</span> <span>"<span>$var1</span>"</span> <span>=</span> <span>"<span>$END_CONDITION</span>"</span> <span>]</span>
<span># 在循环顶部测试条件。</span>
<span>do</span>
  <span>echo</span> <span>"Input variable #1 "</span>
  <span>echo</span> <span>"(<span>$END_CONDITION</span> to exit)"</span>
  <span>read</span> var1
  <span>echo</span> <span>"variable #1 = <span>$var1</span>"</span>
  <span>echo</span>
<span>done</span>

<span>#                ---                   #</span>

<span>#  就像 "for" 和 "while" 循环一样，</span>
<span>#+ "until" 循环也可以写的像C语言一样。</span>

<span>LIMIT</span><span>=</span><span>10</span>
<span>var</span><span>=</span><span>0</span>

<span>until</span> <span><span>((</span> var <span>></span> LIMIT <span>))</span></span>
<span>do</span>  <span># ^^ ^     ^     ^^   没有方括号，没有 $ 前缀。</span>
  <span>echo</span> -n <span>"<span>$var</span> "</span>
  <span><span>((</span> var<span>++</span> <span>))</span></span>
<span>done</span>    <span># 0 1 2 3 4 5 6 7 8 9 10</span>


<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>如何在 <code>for</code>，<code>while</code> 和 <code>until</code> 之间做出选择？我们知道在C语言中，在已知循环次数的情况下更加倾向于使用 <code>for</code> 循环。但是在Bash中情况可能更加复杂一些。Bash中的 <code>for</code> 循环相比起其他语言来说，结构更加松散，使用更加灵活。因此使用你认为最简单的就好。</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>迭代：重复执行一个或一组命令。通常情况下，会使用<code>while</code>或者<code>until</code>进行控制。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">11.2 嵌套循环</title>
    <id>https://clay-wangzhi.com/code/shell/part3/11_2_nested_loops/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/11_2_nested_loops/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_11-2-嵌套循环"> 11.2 嵌套循环</h1>
<p>嵌套循环，顾名思义就是在循环里面还有循环。外层循环会不断的触发内层循环直到外层循环结束。当然，你仍然可以使用 <code>break</code> 可以终止外层或内层的循环。</p>
<p>样例 11-20. 嵌套循环</p>
<div><pre><code><span>#!/bin/bash</span>
<span># nested-loop.sh: 嵌套 "for" 循环。</span>

<span>outer</span><span>=</span><span>1</span>             <span># 设置外层循环计数器。</span>

<span># 外层循环。</span>
<span>for</span> <span>a</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> 
<span>do</span>
  <span>echo</span> <span>"Pass <span>$outer</span> in outer loop."</span>
  <span>echo</span> <span>"---------------------"</span>
  <span>inner</span><span>=</span><span>1</span>           <span># 重设内层循环计数器。</span>
  
  <span># =====================================</span>
  <span># 内层循环。</span>
  <span>for</span> <span>b</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>
  <span>do</span>
    <span>echo</span> <span>"Pass <span>$inner</span> in inner loop."</span>
    <span>let</span> <span>"inner+=1"</span>  <span># 增加内层循环计数器。</span>
  <span>done</span>
  <span># 内层循环结束。</span>
  <span># =====================================</span>
  
  <span>let</span> <span>"outer+=1"</span>    <span># 增加外层循环计数器。</span>
  <span>echo</span>              <span># 在每次外层循环输出中加入空行。</span>
<span>done</span>
<span># 外层循环结束。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>查看 <a href="http://tldp.org/LDP/abs/html/arrays.html#BUBBLE" target="_blank" rel="noopener noreferrer">样例 27-11</a> 详细了解嵌套 <a href="http://tldp.org/LDP/abs/html/loops1.html#WHILELOOPREF" target="_blank" rel="noopener noreferrer">while 循环</a>。查看 <a href="http://tldp.org/LDP/abs/html/arrays.html#EX68" target="_blank" rel="noopener noreferrer">样例 27-13</a> 详细了解嵌套 <a href="http://tldp.org/LDP/abs/html/loops1.html#UNTILLOOPREF" target="_blank" rel="noopener noreferrer">until 循环</a>。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第十二章 命令替换</title>
    <id>https://clay-wangzhi.com/code/shell/part3/12_command_substitution/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/12_command_substitution/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第十二章-命令替换"> 第十二章 命令替换</h1>
<p>命令替换重新指定一个<sup></sup>或多个命令的输出。其实就是将命令的输出导到另外一个地方<sup></sup>。</p>
<p>命令替换的通常形式是（<code>`...`</code>），即用反引号引用命令。</p>
<div><pre><code><span>script_name</span><span>=</span><span><span>`</span><span>basename</span> $0<span>`</span></span>
<span>echo</span> <span>"The name of this script is <span>$scirpt_name</span>."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>命令的输出可以作为另一个命令的参数，也可以赋值给一个变量。甚至在 <a href="http://tldp.org/LDP/abs/html/loops1.html#FORLOOPREF1" target="_blank" rel="noopener noreferrer"><code>for</code></a> 循环中可以用输出产生参数表。</p>
<div><pre><code><span>rm</span> <span><span>`</span><span>cat</span> filename<span>`</span></span>   <span># "filename" 中包含了一系列需要被删除的文件名。</span>
<span>#</span>
<span># S.C. 指出这样写可能会导致出现 "arg list too long" 的错误。</span>
<span># 更好的写法应该是 xargs rm -- &lt; filename</span>
<span># （ -- 可以在 "filename" 文件名以 "-" 为开头时仍旧正常执行 ）</span>

<span>textfile_listing</span><span>=</span><span><span>`</span><span>ls</span> *.txt<span>`</span></span>
<span># 变量中包含了当前工作目录下所有的名为 *.txt 的文件。</span>
<span>echo</span> <span>$textfile_listing</span>

<span>textfile_listing2</span><span>=</span><span><span>$(</span><span>ls</span> *.txt<span>)</span></span>   <span># 命令替换的另一种形式。</span>
<span>echo</span> <span>$textfile_listing2</span>
<span># 结果相同。</span>

<span># 这样将一系列文件名赋值给一个单一字符串可能会出现换行。</span>
<span>#</span>
<span># 而更加安全的方式是将这一系列文件存入数组。</span>
<span>#      shopt -s nullglob    # 设置后，如果没有匹配到文件，那么变量会被赋值为空。</span>
<span>#      textfile_listing=( *.txt )</span>
<span>#</span>
<span># 感谢 S.C.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> 命令替换本质上是调用了一个 <a href="http://tldp.org/LDP/abs/html/subshells.html#SUBSHELLSREF" target="_blank" rel="noopener noreferrer">子进程</a> 来执行。</p>
</blockquote>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="caution" /> 命令替换有可能会出现 <a href="http://tldp.org/LDP/abs/html/quotingvar.html#WSPLITREF" target="_blank" rel="noopener noreferrer">字符分割</a> 的情况。</p>
</blockquote>
<blockquote>
<div><pre><code>COMMAND <span><span>`</span><span>echo</span> a b<span>`</span></span>     <span># 2个参数：a和b</span>

COMMAND <span>"<span><span>`</span><span>echo</span> a b<span>`</span></span>"</span>   <span># 1个参数："a b"</span>

COMMAND <span><span>`</span><span>echo</span><span>`</span></span>         <span># 没有参数</span>

COMMAND <span>"<span><span>`</span><span>echo</span><span>`</span></span>"</span>       <span># 一个空参数</span>


<span># 感谢 S.C.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></blockquote>
<blockquote>
<p>但即使不存在字符分割的情况，使用命令替换也会出现丢失尾部换行符的情况。</p>
</blockquote>
<blockquote>
<div><pre><code><span># cd "`pwd`"  # 你是不是认为这条语句在任何情况下都不会出现错误？</span>
<span># 但事实却不是这样的。</span>

<span>mkdir</span> <span>'dir with trailing newline
'</span>

<span>cd</span> <span>'dir with trailing newline
'</span>

<span>cd</span> <span>"<span><span>`</span><span>pwd</span><span>`</span></span>"</span>  <span># Bash 会出现如下错误提示：</span>
<span># bash: cd: /tmp/file with trailing newline: No such file or directory</span>

<span>cd</span> <span>"<span>$PWD</span>"</span>   <span># 这样写是对的。</span>





<span>old_tty_setting</span><span>=</span><span><span>$(</span>stty -g<span>)</span></span>   <span># 保存旧的设置。</span>
<span>echo</span> <span>"Hit a key "</span>
stty -icanon -echo           <span># 禁用终端的 canonical 模式。</span>
                             <span># 同时禁用 echo。</span>
<span>key</span><span>=</span><span><span>$(</span><span>dd</span> <span>bs</span><span>=</span><span>1</span> <span>count</span><span>=</span><span>1</span> <span><span>2</span>></span> /dev/null<span>)</span></span>   <span># 使用 'dd' 获得键值。</span>
stty <span>"<span>$old_tty_setting</span>"</span>      <span># 恢复旧的设置。</span>
<span>echo</span> <span>"You hit <span>${<span>#</span>key}</span> key."</span>  <span># ${#variable} 表示 $variable 中的字符个数。</span>
<span>#</span>
<span># 除了按下回车键外，其余情况都会输出 "You hit 1 key."</span>
<span># 按下回车键会输出 "You hit 0 key."</span>
<span># 因为唯一的换行符在命令替换中被丢失了。</span>

<span># 这段代码摘自 Stéphane Chazelas。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div></blockquote>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="caution" /> 使用 <code>echo</code> 输出未被引用的命令代换的变量时会删掉尾部的换行。这可能会导致非常不好的情况出现。</p>
</blockquote>
<blockquote>
<div><pre><code><span>dir_listing</span><span>=</span><span><span>`</span><span>ls</span> -l<span>`</span></span>
<span>echo</span> <span>$dir_listing</span>     <span># 未被引用</span>

<span># 你希望会出现按行显示出文件列表。</span>

<span># 但是，你却看到了：</span>
<span># total 3 -rw-rw-r-- 1 bozo bozo 30 May 13 17:15 1.txt -rw-rw-r-- 1 bozo</span>
<span># bozo 51 May 15 20:57 t2.sh -rwxr-xr-x 1 bozo bozo 217 Mar 5 21:13 wi.sh</span>

<span># 所有换行都消失了。</span>


<span>echo</span> <span>"<span>$dir_listing</span>"</span>   <span># 被引用</span>
<span># -rw-rw-r--    1 bozo       30 May 13 17:15 1.txt</span>
<span># -rw-rw-r--    1 bozo       51 May 15 20:57 t2.sh</span>
<span># -rwxr-xr-x    1 bozo      217 Mar  5 21:13 wi.sh</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></blockquote>
<p>你甚至可以使用 <a href="http://tldp.org/LDP/abs/html/io-redirection.html#IOREDIRREF" target="_blank" rel="noopener noreferrer">重定向</a> 或者 <a href="http://tldp.org/LDP/abs/html/basic.html#CATREF" target="_blank" rel="noopener noreferrer"><code>cat</code></a> 命令把一个文件的内容通过命令代换赋值给一个变量。</p>
<div><pre><code><span>variable1</span><span>=</span><span><span>`</span><span>&lt;</span>file1<span>`</span></span>      <span># 将 "file1" 的内容赋值给 variable1。</span>
<span>variable2</span><span>=</span><span><span>`</span><span>cat</span> file2<span>`</span></span>   <span># 将 "file2" 的内容赋值给 variable2。</span>
                        <span># 使用 cat 命令会开一个新进程，因此执行速度会比重定向慢。</span>

<span># 需要注意的是，这些变量中可能包含一些空格或者控制字符。</span>

<span># 无需显示的赋值给一个变量。</span>
<span>echo</span> <span>"<span><span>`</span> <span>&lt;</span>$0<span>`</span></span>"</span>           <span># 输出脚本自身。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>#  摘录自系统文件 /etc/rc.d/rc.sysinit</span>
<span>#+ （Red Hat Linux 发行版）</span>


<span>if</span> <span>[</span> -f /fsckoptions <span>]</span><span>;</span> <span>then</span>
        <span>fsckoptions</span><span>=</span><span><span>`</span><span>cat</span> /fsckoptions<span>`</span></span>
<span>..</span>.
<span>fi</span>
<span>#</span>
<span>#</span>
<span>if</span> <span>[</span> -e <span>"/proc/ide/<span>${disk<span>[</span>$device<span>]</span>}</span>/media"</span> <span>]</span> <span>;</span> <span>then</span>
             <span>hdmedia</span><span>=</span><span><span>`</span><span>cat</span> /proc/ide/$<span>{</span>disk<span>[</span>$device<span>]</span><span>}</span>/media<span>`</span></span>
<span>..</span>.
<span>fi</span>
<span>#</span>
<span>#</span>
<span>if</span> <span>[</span> <span>!</span> -n <span>"<span><span>`</span><span>uname</span> -r <span>|</span> <span>grep</span> -- <span>"-"</span><span>`</span></span>"</span> <span>]</span><span>;</span> <span>then</span>
       <span>ktag</span><span>=</span><span>"<span><span>`</span><span>cat</span> /proc/version<span>`</span></span>"</span>
<span>..</span>.
<span>fi</span>
<span>#</span>
<span>#</span>
<span>if</span> <span>[</span> <span>$usb</span> <span>=</span> <span>"1"</span> <span>]</span><span>;</span> <span>then</span>
    <span>sleep</span> <span>5</span>
    <span>mouseoutput</span><span>=</span><span><span>`</span><span>cat</span> /proc/bus/usb/devices <span><span>2</span>></span>/dev/null<span>|</span><span>grep</span> -E <span>"^I.*Cls=03.*Prot=02"</span><span>`</span></span>
    <span>kbdoutput</span><span>=</span><span><span>`</span><span>cat</span> /proc/bus/usb/devices <span><span>2</span>></span>/dev/null<span>|</span><span>grep</span> -E <span>"^I.*Cls=03.*Prot=01"</span><span>`</span></span>
<span>..</span>.
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="caution" /> 尽量不要将一大段文字赋值给一个变量，除非你有足够的理由。也绝不要将一个二进制文件的内容赋值给一个变量。</p>
</blockquote>
<blockquote>
<p>样例 12-1. 蠢蠢的脚本</p>
<div><pre><code><span>#!/bin/bash</span>
<span># stupid-script-tricks.sh: 不要在自己的电脑上尝试。</span>
<span># 摘自 "Stupid Script Tricks" 卷一。</span>

<span>exit</span> <span>99</span>  <span>### 如果你有胆，就注释掉这行。:)</span>

<span>dangerous_variable</span><span>=</span><span><span>`</span><span>cat</span> /boot/vmlinuz<span>`</span></span>   <span># 压缩的 Linux 内核。</span>

<span>echo</span> <span>"string-length of \<span>$dangerous_variable</span> = <span>${<span>#</span>dangerous_variable}</span>"</span>
<span># $dangerous_variable 的长度为 794151</span>
<span># （更新版本的内核可能更大。）</span>
<span># 与 'wc -c /boot/vmlinuz' 的结果不同。</span>

<span># echo "$dangerous_variable"</span>
<span># 不要作死。否则脚本会挂起。</span>



<span># 将二进制文件的内容赋值给一个变量没有任何意义。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></blockquote>
<blockquote>
<p>尽管脚本会挂起，但并不会出现缓存溢出的情况。而这正是像 Bash 这样的解释型语言相比起编译型语言能够提供更多保护的一个例子。</p>
</blockquote>
<p>命令替换允许将 <a href="http://tldp.org/LDP/abs/html/loops1.html#FORLOOPREF1" target="_blank" rel="noopener noreferrer">循环</a> 的输出结果赋值给一个变量。这其中的关键在于循环内部的 <a href="http://tldp.org/LDP/abs/html/internal.html#ECHOREF" target="_blank" rel="noopener noreferrer"><code>echo</code></a> 命令。</p>
<p>样例 12-2. 将循环的输出结果赋值给变量</p>
<div><pre><code><span>#!/bin/bash</span>
<span># csubloop.sh: 将循环的输出结果赋值给变量。</span>

<span>variable1</span><span>=</span><span><span>`</span><span>for</span> <span>i</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$i</span>"</span>                 <span>#  在这里，'echo' 命令非常关键。</span>
<span>done</span><span>`</span></span>

<span>echo</span> <span>"variable1 = <span>$variable1</span>"</span>  <span># variable1 = 12345</span>


<span>i</span><span>=</span><span>0</span>
<span>variable2</span><span>=</span><span><span>`</span><span>while</span> <span>[</span> <span>"<span>$i</span>"</span> -lt <span>10</span> <span>]</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$i</span>"</span>                 <span># 很关键的 'echo'。</span>
  <span>let</span> <span>"i += 1"</span>                 <span># i 自增。</span>
<span>done</span><span>`</span></span>

<span>echo</span> <span>"variable2 = <span>$variable2</span>"</span>  <span># variable2 = 0123456789</span>

<span># 这个例子表明可以在变量声明时嵌入循环。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><blockquote>
<p>命令替换能够让 Bash 做更多的事情。而这仅仅需要在书写程序或者脚本时将结果输出到标准输出 <code>stdout</code> 中，然后将这些输出结果赋值给变量即可。</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>

<span>/*  "Hello, world." C program  */</span>

<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
  <span>printf</span><span>(</span> <span>"Hello, world.\n"</span> <span>)</span><span>;</span>
  <span>return</span> <span>(</span><span>0</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code>bash$ gcc -0 hello hello.c
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>#!/bin/bash</span>
<span># hello.sh</span>

<span>greeting</span><span>=</span><span><span>`</span>./hello<span>`</span></span>
<span>echo</span> <span>$greeting</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>bash$ sh hello.sh
Hello, world.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></blockquote>
<blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /> 在命令替换中，你可以使用 <code>$(...)</code> 来替代反引号。</p>
<div><pre><code><span>output</span><span>=</span><span><span>$(</span><span>sed</span> -n /<span>"<span>$1</span>"</span>/p $file<span>)</span></span>   <span># 摘自 "grp.sh"。</span>

<span># 将文本文件的内容赋值给一个变量。</span>
<span>File_contents1</span><span>=</span><span><span>$(</span><span>cat</span> $file1<span>)</span></span>
<span>File_contents2</span><span>=</span><span><span>$(</span><span>&lt;</span>$file2<span>)</span></span>        <span># 这么做也是可以的。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>$(...)</code> 和反引号在处理双反斜杠上有所不同。</p>
<div><pre><code>bash$ echo `echo \\`


bash$ echo $(echo \\)
\
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>$(...)</code> 允许嵌套。<sup></sup></p>
<div><pre><code><span>word_count</span><span>=</span><span><span>$(</span> <span>wc</span> -w <span>$(</span>echo * <span>|</span> <span>awk</span> <span>'{print <span>$8</span>}'</span><span>)</span> <span>)</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>样例 12-3. 寻找变位词（anagram）</p>
<div><pre><code><span>#!/bin/bash</span>
<span># agram2.sh</span>
<span># 嵌套命令替换的例子。</span>

<span># 其中使用了作者写的工具包 "yawl" 中的 "anagram" 工具。</span>
<span># http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz</span>
<span># http://bash.deta.in/yawl-0.3.2.tar.gz</span>

<span>E_NOARGS</span><span>=</span><span>86</span>
<span>E_BADARG</span><span>=</span><span>87</span>
<span>MINLEN</span><span>=</span><span>7</span>

<span>if</span> <span>[</span> -z <span>"<span>$1</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"Usage <span>$0</span> LETTERSET"</span>
  <span>exit</span> <span>$E_NOARGS</span>         <span># 脚本需要命令行参数。</span>
<span>elif</span> <span>[</span> <span>${<span>#</span>1}</span> -lt <span>$MINLEN</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"Argument must have at least <span>$MINLEN</span> letters."</span>
  <span>exit</span> <span>$E_BADARG</span>
<span>fi</span>



<span>FILTER</span><span>=</span><span>'.......'</span>         <span># 至少需要7个字符。</span>
<span>#       1234567</span>
<span>Anagrams</span><span>=</span><span>(</span> <span><span>$(</span><span>echo</span> <span>$(</span>anagram $1 <span>|</span> <span>grep</span> $FILTER<span>)</span> <span>)</span></span> <span>)</span>
<span>#          $(     $(        嵌套命令集        ) )</span>
<span>#        (              赋值给数组                )</span>

<span>echo</span>
<span>echo</span> <span>"<span>${<span>#</span>Anagrams<span>[</span>*<span>]</span>}</span>  7+ letter anagrams found"</span>
<span>echo</span>
<span>echo</span> <span>${Anagrams<span>[</span>0<span>]</span>}</span>      <span># 第一个变位词。</span>
<span>echo</span> <span>${Anagrams<span>[</span>1<span>]</span>}</span>      <span># 第二个变位词。</span>
                         <span># 以此类推。</span>

<span># echo "${Anagrams[*]}"  # 将所有变位词在一行里面输出。</span>

<span># 可以配合后面的数组章节来理解上面的代码。</span>

<span># 建议同时查看另一个寻找变位词的脚本 agram.sh。</span>

<span>exit</span> <span>$?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div></blockquote>
<p>以下是包含命令替换的样例：</p>
<ol>
<li><a href="http://tldp.org/LDP/abs/html/loops1.html#BINGREP" target="_blank" rel="noopener noreferrer">样例 11-8</a></li>
<li><a href="http://tldp.org/LDP/abs/html/testbranch.html#CASECMD" target="_blank" rel="noopener noreferrer">样例 11-27</a></li>
<li><a href="http://tldp.org/LDP/abs/html/randomvar.html#SEEDINGRANDOM" target="_blank" rel="noopener noreferrer">样例 9-16</a></li>
<li><a href="http://tldp.org/LDP/abs/html/moreadv.html#EX57" target="_blank" rel="noopener noreferrer">样例 16-3</a></li>
<li><a href="http://tldp.org/LDP/abs/html/textproc.html#LOWERCASE" target="_blank" rel="noopener noreferrer">样例 16-22</a></li>
<li><a href="http://tldp.org/LDP/abs/html/textproc.html#GRP" target="_blank" rel="noopener noreferrer">样例 16-17</a></li>
<li><a href="http://tldp.org/LDP/abs/html/extmisc.html#EX53" target="_blank" rel="noopener noreferrer">样例 16-54</a></li>
<li><a href="http://tldp.org/LDP/abs/html/loops1.html#EX24" target="_blank" rel="noopener noreferrer">样例 11-14</a></li>
<li><a href="http://tldp.org/LDP/abs/html/loops1.html#SYMLINKS" target="_blank" rel="noopener noreferrer">样例 11-11</a></li>
<li><a href="http://tldp.org/LDP/abs/html/filearchiv.html#STRIPC" target="_blank" rel="noopener noreferrer">样例 16-32</a></li>
<li><a href="http://tldp.org/LDP/abs/html/redircb.html#REDIR4" target="_blank" rel="noopener noreferrer">样例 20-8</a></li>
<li><a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#TREE" target="_blank" rel="noopener noreferrer">样例 A-16</a></li>
<li><a href="http://tldp.org/LDP/abs/html/procref1.html#PIDID" target="_blank" rel="noopener noreferrer">样例 29-3</a></li>
<li><a href="http://tldp.org/LDP/abs/html/mathc.html#MONTHLYPMT" target="_blank" rel="noopener noreferrer">样例 16-47</a></li>
<li><a href="http://tldp.org/LDP/abs/html/mathc.html#BASE" target="_blank" rel="noopener noreferrer">样例 16-48</a></li>
<li><a href="http://tldp.org/LDP/abs/html/mathc.html#ALTBC" target="_blank" rel="noopener noreferrer">样例 16-49</a></li>
</ol>
<hr>
<section>
<ol>
<li id="footnote1"><p>在命令替换中可以使用外部系统命令，<a href="http://tldp.org/LDP/abs/html/internal.html#BUILTINREF" target="_blank" rel="noopener noreferrer">内建命令</a> 甚至是 <a href="http://tldp.org/LDP/abs/html/assortedtips.html#RVT" target="_blank" rel="noopener noreferrer">脚本函数</a>。 </p>
</li>
<li id="footnote2"><p>从技术的角度来讲，命令替换实际上是获得了命令输出到标准输出的结果，然后通过赋值号将结果赋值给一个变量。 </p>
</li>
<li id="footnote3"><p>事实上，使用反引号进行嵌套也是可行的。但是 John Default 提醒到需要将内部的反引号进行转义。<pre>word_count=` wc -w \`echo * | awk '{print $8}'\` `</pre> </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第十三章 算术扩展</title>
    <id>https://clay-wangzhi.com/code/shell/part3/13_arithmetic_expansion/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/13_arithmetic_expansion/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第十三章-算术扩展"> 第十三章 算术扩展</h1>
<p>算术扩展为脚本中的（整数）算术操作提供了强有力的工具。你可以使用反引号、双圆括号或者 <code>let</code> 将字符串转换为数学表达式。</p>
<h3 id="差异比较"> 差异比较</h3>
<h4 id="使用-反引号-的算术扩展-通常与-expr-一起使用"> 使用 <a href="http://tldp.org/LDP/abs/html/commandsub.html#BACKQUOTESREF" target="_blank" rel="noopener noreferrer">反引号</a> 的算术扩展（通常与 <a href="http://tldp.org/LDP/abs/html/moreadv.html#EXPRREF" target="_blank" rel="noopener noreferrer"><code>expr</code></a> 一起使用）</h4>
<div><pre><code><span>z</span><span>=</span><span><span>`</span><span>expr</span> $z + <span>3</span><span>`</span></span>         <span># 'expr' 命令执行了算术扩展。</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="使用-双圆括号-或-let-的算术扩展。"> 使用 <a href="http://tldp.org/LDP/abs/html/dblparens.html" target="_blank" rel="noopener noreferrer">双圆括号</a> 或 <a href="http://tldp.org/LDP/abs/html/internal.html#LETREF" target="_blank" rel="noopener noreferrer"><code>let</code></a> 的算术扩展。</h4>
<p>事实上，在算术扩展中，反引号已经被双圆括号 <code>((...))</code> 和 <code>$((...))</code> 以及 <a href="http://tldp.org/LDP/abs/html/internal.html#LETREF" target="_blank" rel="noopener noreferrer"><code>let</code></a> 所取代。</p>
<div><pre><code><span>z</span><span>=</span><span><span>$((</span>$z<span>+</span><span>3</span><span>))</span></span>
<span>z</span><span>=</span><span><span>$((</span>z<span>+</span><span>3</span><span>))</span></span>                     <span># 同样正确。</span>
                               <span># 在双圆括号内，参数引用形式可用可不用。</span>
                                            
<span># $((EXPRESSION)) 是算术扩展。  # 不要与命令替换混淆。</span>



<span># 双圆括号不是只能用作赋值算术结果。</span>

  <span>n</span><span>=</span><span>0</span>
  <span>echo</span> <span>"n = <span>$n</span>"</span>                <span># n = 0</span>

  <span><span>((</span> n <span>+</span><span>=</span> <span>1</span> <span>))</span></span>                 <span># 自增。</span>
<span># (( $n += 1 )) 是错误用法！</span>
  <span>echo</span> <span>"n = <span>$n</span>"</span>                <span># n = 1</span>


<span>let</span> <span>z</span><span>=</span>z+3
<span>let</span> <span>"z += 3"</span>  <span># 引号允许在赋值表达式中使用空格。</span>
              <span># 'let' 事实上执行的算术运算而非算术扩展。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>以下是包含算术扩展的样例：</p>
<ol>
<li><a href="http://tldp.org/LDP/abs/html/moreadv.html#EX45" target="_blank" rel="noopener noreferrer">样例 16-9</a></li>
<li><a href="http://tldp.org/LDP/abs/html/loops1.html#EX25" target="_blank" rel="noopener noreferrer">样例 11-15</a></li>
<li><a href="http://tldp.org/LDP/abs/html/arrays.html#EX66" target="_blank" rel="noopener noreferrer">样例 27-1</a></li>
<li><a href="http://tldp.org/LDP/abs/html/arrays.html#BUBBLE" target="_blank" rel="noopener noreferrer">样例 27-11</a></li>
<li><a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#TREE" target="_blank" rel="noopener noreferrer">样例 A-16</a></li>
</ol>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第三部分 shell进阶</title>
    <id>https://clay-wangzhi.com/code/shell/part3/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第三部分-shell进阶"> 第三部分 shell进阶</h1>
<h3 id="目录"> 目录</h3>
<ul>
<li><a href="./09_another_look_at_variables.html">9. 换个角度看变量</a>
<ul>
<li><a href="./09_1_internal_variables.html">9.1 内部变量</a></li>
<li><a href="./09_2_typing_variables_declare_or_typeset.html">9.2 变量类型标注：<code>declare</code> 与 <code>typeset</code></a>
<ul>
<li><a href="./09_2_1_another_use_for_declare.html">9.2.1 <code>declare</code> 的另类用法</a></li>
</ul>
</li>
<li><a href="./09_3_random_generate_random_integer.html">9.3 <code>$RANDOM</code>：生成随机数</a></li>
</ul>
</li>
<li><a href="./10_manipulating_variables.html">10. 变量处理</a>
<ul>
<li><a href="./10_1_manipulating_strings.html">10.1 字符串处理</a>
<ul>
<li><a href="./10_1_1_manipulating_strings_using_awk.html">10.1.1 使用 <code>awk</code> 处理字符串</a></li>
<li><a href="./10_1_2_further_reference.html">10.1.2 参考资料</a></li>
</ul>
</li>
<li><a href="./10_2_parameter_substitution.html">10.2 参数替换</a></li>
</ul>
</li>
<li><a href="./11_loops_and_branches.html">11. 循环与分支</a>
<ul>
<li><a href="./11_1_loops.html">11.1 循环</a></li>
<li><a href="./11_2_nested_loops.html">11.2 嵌套循环</a></li>
<li><a href="./11_3_loop_control.html">11.3 循环控制</a></li>
<li><a href="./11_4_testing_and_branching.html">11.4 测试与分支</a></li>
</ul>
</li>
<li><a href="./12_command_substitution.html">12. 命令替换</a></li>
<li><a href="./13_arithmetic_expansion.html">13. 算术扩展</a></li>
<li><a href="./14_recess_time.html">14. 休息时间</a></li>
</ul>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第四部分 命令</title>
    <id>https://clay-wangzhi.com/code/shell/part4-command/</id>
    <link href="https://clay-wangzhi.com/code/shell/part4-command/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第四部分-命令"> 第四部分 命令</h1>
<p>掌握 Linux 命令是编写有效的 shell 脚本必不可少的序曲。</p>
<p>本章节涉及了下列的命令：</p>
<ul>
<li><a href=""><code>.</code></a>（参照 <a href=""><code>source</code></a>）</li>
<li><a href=""><code>ac</code></a></li>
<li><a href=""><code>adduser</code></a></li>
<li><a href=""><code>agetty</code></a></li>
<li><a href=""><code>agrep</code></a></li>
<li><a href=""><code>ar</code></a></li>
<li><a href=""><code>arch</code></a></li>
<li><a href=""><code>at</code></a></li>
<li><a href=""><code>autoload</code></a></li>
<li><a href=""><code>awk</code></a>（参考 <a href="">使用 <code>awk</code> 进行数学运算</a>）</li>
<li><a href=""><code>badblocks</code></a></li>
<li><a href=""><code>banner</code></a></li>
<li><a href=""><code>basename</code></a></li>
<li><a href=""><code>batch</code></a></li>
<li><a href=""><code>bc</code></a></li>
<li><a href=""><code>bg</code></a></li>
<li><a href=""><code>bind</code></a></li>
<li><a href=""><code>bison</code></a></li>
<li><a href=""><code>builtin</code></a></li>
<li><a href=""><code>bzgrep</code></a></li>
<li><a href=""><code>bzip2</code></a></li>
<li><a href=""><code>cal</code></a></li>
<li><a href=""><code>caller</code></a></li>
<li><a href=""><code>cat</code></a></li>
<li><a href=""><code>cd</code></a></li>
<li><a href=""><code>chattr</code></a></li>
<li><a href=""><code>chfn</code></a></li>
<li><a href=""><code>chgrp</code></a></li>
<li><a href=""><code>chkconfig</code></a></li>
<li><a href=""><code>chmod</code></a></li>
<li><a href=""><code>chown</code></a></li>
<li><a href=""><code>chroot</code></a></li>
<li><a href=""><code>cksum</code></a></li>
<li><a href=""><code>clear</code></a></li>
<li><a href=""><code>clock</code></a></li>
<li><a href=""><code>cmp</code></a></li>
<li><a href=""><code>col</code></a></li>
<li><a href=""><code>colrm</code></a></li>
<li><a href=""><code>column</code></a></li>
<li><a href=""><code>comm</code></a></li>
<li><a href=""><code>command</code></a></li>
<li><a href=""><code>compgen</code></a></li>
<li><a href=""><code>complete</code></a></li>
<li><a href=""><code>compress</code></a></li>
<li><a href=""><code>coproc</code></a></li>
<li><a href=""><code>cp</code></a></li>
<li><a href=""><code>cpio</code></a></li>
<li><a href=""><code>cron</code></a></li>
<li><a href=""><code>crypt</code></a></li>
<li><a href=""><code>csplit</code></a></li>
<li><a href=""><code>cu</code></a></li>
<li><a href=""><code>cut</code></a></li>
<li><a href=""><code>date</code></a></li>
<li><a href=""><code>dc</code></a></li>
<li><a href=""><code>dd</code></a></li>
<li><a href=""><code>debugfs</code></a></li>
<li><a href=""><code>declare</code></a></li>
<li><a href=""><code>depmod</code></a></li>
<li><a href=""><code>df</code></a></li>
<li><a href=""><code>dialog</code></a></li>
<li><a href=""><code>diff</code></a></li>
<li><a href=""><code>diff3</code></a></li>
<li><a href=""><code>diffstat</code></a></li>
<li><a href=""><code>dig</code></a></li>
<li><a href=""><code>dirname</code></a></li>
<li><a href=""><code>dirs</code></a></li>
<li><a href=""><code>disown</code></a></li>
<li><a href=""><code>dmesg</code></a></li>
<li><a href=""><code>doexec</code></a></li>
<li><a href=""><code>dos2unix</code></a></li>
<li><a href=""><code>du</code></a></li>
<li><a href=""><code>dump</code></a></li>
<li><a href=""><code>dumpe2fs</code></a></li>
<li><a href=""><code>e2fsck</code></a></li>
<li><a href=""><code>echo</code></a></li>
<li><a href=""><code>egrep</code></a></li>
<li><a href=""><code>enable</code></a></li>
<li><a href=""><code>enscript</code></a></li>
<li><a href=""><code>env</code></a></li>
<li><a href=""><code>eqn</code></a></li>
<li><a href=""><code>eval</code></a></li>
<li><a href=""><code>exec</code></a></li>
<li><a href=""><code>exit</code></a>（相关话题：<a href="">退出状态</a>）</li>
<li><a href=""><code>expand</code></a></li>
<li><a href=""><code>export</code></a></li>
<li><a href=""><code>expr</code></a></li>
<li><a href=""><code>factor</code></a></li>
<li><a href=""><code>false</code></a></li>
<li><a href=""><code>fdformat</code></a></li>
<li><a href=""><code>fdisk</code></a></li>
<li><a href=""><code>fg</code></a></li>
<li><a href=""><code>fgrep</code></a></li>
<li><a href=""><code>file</code></a></li>
<li><a href=""><code>find</code></a></li>
<li><a href=""><code>finger</code></a></li>
<li><a href=""><code>flex</code></a></li>
<li><a href=""><code>flock</code></a></li>
<li><a href=""><code>fmt</code></a></li>
<li><a href=""><code>fold</code></a></li>
<li><a href=""><code>free</code></a></li>
<li><a href=""><code>fsck</code></a></li>
<li><a href=""><code>ftp</code></a></li>
<li><a href=""><code>fuser</code></a></li>
<li><a href=""><code>getfacl</code></a></li>
<li><a href=""><code>getopt</code></a></li>
<li><a href=""><code>getopts</code></a></li>
<li><a href=""><code>gettext</code></a></li>
<li><a href=""><code>getty</code></a></li>
<li><a href=""><code>gnome-mount</code></a></li>
<li><a href=""><code>grep</code></a></li>
<li><a href=""><code>groff</code></a></li>
<li><a href=""><code>groupmod</code></a></li>
<li><a href=""><code>groups</code></a>（相关话题：变量 <a href=""><code>$GROUPS</code></a>）</li>
<li><a href=""><code>gs</code></a></li>
<li><a href=""><code>gzip</code></a></li>
<li><a href=""><code>halt</code></a></li>
<li><a href=""><code>hash</code></a></li>
<li><a href=""><code>hdparm</code></a></li>
<li><a href=""><code>head</code></a></li>
<li><a href=""><code>help</code></a></li>
<li><a href=""><code>hexdump</code></a></li>
<li><a href=""><code>host</code></a></li>
<li><a href=""><code>hostid</code></a></li>
<li><a href=""><code>hostname</code></a>（相关话题：变量 <a href=""><code>$HOSTNAME</code></a>）</li>
<li><a href=""><code>hwclock</code></a></li>
<li><a href=""><code>iconv</code></a></li>
<li><a href=""><code>id</code></a>（相关话题：变量 <a href=""><code>$UID</code></a>）</li>
<li><a href=""><code>ifconfig</code></a></li>
<li><a href=""><code>info</code></a></li>
<li><a href=""><code>infocmp</code></a></li>
<li><a href=""><code>init</code></a></li>
<li><a href=""><code>insmod</code></a></li>
<li><a href=""><code>install</code></a></li>
<li><a href=""><code>ip</code></a></li>
<li><a href=""><code>ipcalc</code></a></li>
<li><a href=""><code>iptables</code></a></li>
<li><a href=""><code>iwconfig</code></a></li>
<li><a href=""><code>jobs</code></a></li>
<li><a href=""><code>join</code></a></li>
<li><a href=""><code>jot</code></a></li>
<li><a href=""><code>kill</code></a></li>
<li><a href=""><code>killall</code></a></li>
<li><a href=""><code>last</code></a></li>
<li><a href=""><code>lastcomm</code></a></li>
<li><a href=""><code>lastlog</code></a></li>
<li><a href=""><code>ldd</code></a></li>
<li><a href=""><code>less</code></a></li>
<li><a href=""><code>let</code></a></li>
<li><a href=""><code>lex</code></a></li>
<li><a href=""><code>lid</code></a></li>
<li><a href=""><code>ln</code></a></li>
<li><a href=""><code>locate</code></a></li>
<li><a href=""><code>lockfile</code></a></li>
<li><a href=""><code>logger</code></a></li>
<li><a href=""><code>logname</code></a></li>
<li><a href=""><code>logout</code></a></li>
<li><a href=""><code>logrotate</code></a></li>
<li><a href=""><code>look</code></a></li>
<li><a href=""><code>losetup</code></a></li>
<li><a href=""><code>lp</code></a></li>
<li><a href=""><code>ls</code></a></li>
<li><a href=""><code>lsdev</code></a></li>
<li><a href=""><code>lsmod</code></a></li>
<li><a href=""><code>lsof</code></a></li>
<li><a href=""><code>lspci</code></a></li>
<li><a href=""><code>lsusb</code></a></li>
<li><a href=""><code>ltrace</code></a></li>
<li><a href=""><code>lynx</code></a></li>
<li><a href=""><code>lzcat</code></a></li>
<li><a href=""><code>lzma</code></a></li>
<li><a href=""><code>m4</code></a></li>
<li><a href=""><code>mail</code></a></li>
<li><a href=""><code>mailstats</code></a></li>
<li><a href=""><code>mailto</code></a></li>
<li><a href=""><code>make</code></a></li>
<li><a href=""><code>MAKEDEV</code></a></li>
<li><a href=""><code>man</code></a></li>
<li><a href=""><code>mapfile</code></a></li>
<li><a href=""><code>mcookie</code></a></li>
<li><a href=""><code>md5sum</code></a></li>
<li><a href=""><code>merge</code></a></li>
<li><a href=""><code>mesg</code></a></li>
<li><a href=""><code>mimencode</code></a></li>
<li><a href=""><code>mkbootdisk</code></a></li>
<li><a href=""><code>mkdir</code></a></li>
<li><a href=""><code>mkdosfs</code></a></li>
<li><a href=""><code>mke2fs</code></a></li>
<li><a href=""><code>mkfifo</code></a></li>
<li><a href=""><code>mkisofs</code></a></li>
<li><a href=""><code>mknod</code></a></li>
<li><a href=""><code>mkswap</code></a></li>
<li><a href=""><code>mktemp</code></a></li>
<li><a href=""><code>mmencode</code></a></li>
<li><a href=""><code>modinfo</code></a></li>
<li><a href=""><code>modprobe</code></a></li>
<li><a href=""><code>more</code></a></li>
<li><a href=""><code>mount</code></a></li>
<li><a href=""><code>msgfmt</code></a></li>
<li><a href=""><code>mv</code></a></li>
<li><a href=""><code>nc</code></a></li>
<li><a href=""><code>netconfig</code></a></li>
<li><a href=""><code>netstat</code></a></li>
<li><a href=""><code>newgrp</code></a></li>
<li><a href=""><code>nice</code></a></li>
<li><a href=""><code>nl</code></a></li>
<li><a href=""><code>nm</code></a></li>
<li><a href=""><code>nmap</code></a></li>
<li><a href=""><code>nohup</code></a></li>
<li><a href=""><code>nslookup</code></a></li>
<li><a href=""><code>objdump</code></a></li>
<li><a href=""><code>od</code></a></li>
<li><a href=""><code>openssl</code></a></li>
<li><a href=""><code>passwd</code></a></li>
<li><a href=""><code>paste</code></a></li>
<li><a href=""><code>patch</code></a>（相关话题：<a href=""><code>diff</code></a>）</li>
<li><a href=""><code>pathchk</code></a></li>
<li><a href=""><code>pax</code></a></li>
<li><a href=""><code>pgrep</code></a></li>
<li><a href=""><code>pidof</code></a></li>
<li><a href=""><code>ping</code></a></li>
<li><a href=""><code>pkill</code></a></li>
<li><a href=""><code>popd</code></a></li>
<li><a href=""><code>pr</code></a></li>
<li><a href=""><code>printenv</code></a></li>
<li><a href=""><code>printf</code></a></li>
<li><a href=""><code>procinfo</code></a></li>
<li><a href=""><code>ps</code></a></li>
<li><a href=""><code>pstree</code></a></li>
<li><a href=""><code>ptx</code></a></li>
<li><a href=""><code>pushd</code></a></li>
<li><a href=""><code>pwd</code></a>（相关话题：变量 <a href=""><code>$PWD</code></a>）</li>
<li><a href=""><code>quota</code></a></li>
<li><a href=""><code>rcp</code></a></li>
<li><a href=""><code>rdev</code></a></li>
<li><a href=""><code>rdist</code></a></li>
<li><a href=""><code>read</code></a></li>
<li><a href=""><code>readelf</code></a></li>
<li><a href=""><code>readlink</code></a></li>
<li><a href=""><code>readonly</code></a></li>
<li><a href=""><code>reboot</code></a></li>
<li><a href=""><code>recode</code></a></li>
<li><a href=""><code>renice</code></a></li>
<li><a href=""><code>reset</code></a></li>
<li><a href=""><code>resize</code></a></li>
<li><a href=""><code>restore</code></a></li>
<li><a href=""><code>rev</code></a></li>
<li><a href=""><code>rlogin</code></a></li>
<li><a href=""><code>rm</code></a></li>
<li><a href=""><code>rmdir</code></a></li>
<li><a href=""><code>rmmod</code></a></li>
<li><a href=""><code>route</code></a></li>
<li><a href=""><code>rpm</code></a></li>
<li><a href=""><code>rpm2cpio</code></a></li>
<li><a href=""><code>rsh</code></a></li>
<li><a href=""><code>rsync</code></a></li>
<li><a href=""><code>runlevel</code></a></li>
<li><a href=""><code>run-parts</code></a></li>
<li><a href=""><code>rx</code></a></li>
<li><a href=""><code>rz</code></a></li>
<li><a href=""><code>sar</code></a></li>
<li><a href=""><code>scp</code></a></li>
<li><a href=""><code>script</code></a></li>
<li><a href=""><code>sdiff</code></a></li>
<li><a href=""><code>sed</code></a></li>
<li><a href=""><code>seq</code></a></li>
<li><a href=""><code>service</code></a></li>
<li><a href=""><code>set</code></a></li>
<li><a href=""><code>setfacl</code></a></li>
<li><a href=""><code>setquota</code></a></li>
<li><a href=""><code>setserial</code></a></li>
<li><a href=""><code>setterm</code></a></li>
<li><a href=""><code>sha1sum</code></a></li>
<li><a href=""><code>shar</code></a></li>
<li><a href=""><code>shopt</code></a></li>
<li><a href=""><code>shred</code></a></li>
<li><a href=""><code>shutdown</code></a></li>
<li><a href=""><code>size</code></a></li>
<li><a href=""><code>skill</code></a></li>
<li><a href=""><code>sleep</code></a></li>
<li><a href=""><code>slocate</code></a></li>
<li><a href=""><code>snice</code></a></li>
<li><a href=""><code>sort</code></a></li>
<li><a href=""><code>source</code></a></li>
<li><a href=""><code>sox</code></a></li>
<li><a href=""><code>split</code></a></li>
<li><a href=""><code>sq</code></a></li>
<li><a href=""><code>ssh</code></a></li>
<li><a href=""><code>stat</code></a></li>
<li><a href=""><code>strace</code></a></li>
<li><a href=""><code>strings</code></a></li>
<li><a href=""><code>strip</code></a></li>
<li><a href=""><code>stty</code></a></li>
<li><a href=""><code>su</code></a></li>
<li><a href=""><code>sudo</code></a></li>
<li><a href=""><code>sum</code></a></li>
<li><a href=""><code>suspend</code></a></li>
<li><a href=""><code>swapoff</code></a></li>
<li><a href=""><code>swapon</code></a></li>
<li><a href=""><code>sx</code></a></li>
<li><a href=""><code>sync</code></a></li>
<li><a href=""><code>sz</code></a></li>
<li><a href=""><code>tac</code></a></li>
<li><a href=""><code>tail</code></a></li>
<li><a href=""><code>tar</code></a></li>
<li><a href=""><code>tbl</code></a></li>
<li><a href=""><code>tcpdump</code></a></li>
<li><a href=""><code>tee</code></a></li>
<li><a href=""><code>telinit</code></a></li>
<li><a href=""><code>telnet</code></a></li>
<li><a href=""><code>Tex</code></a></li>
<li><a href=""><code>texexec</code></a></li>
<li><a href=""><code>time</code></a></li>
<li><a href=""><code>times</code></a></li>
<li><a href=""><code>tmpwatch</code></a></li>
<li><a href=""><code>top</code></a></li>
<li><a href=""><code>touch</code></a></li>
<li><a href=""><code>tput</code></a></li>
<li><a href=""><code>tr</code></a></li>
<li><a href=""><code>traceroute</code></a></li>
<li><a href=""><code>true</code></a></li>
<li><a href=""><code>tset</code></a></li>
<li><a href=""><code>tsort</code></a></li>
<li><a href=""><code>tty</code></a></li>
<li><a href=""><code>tune2fs</code></a></li>
<li><a href=""><code>type</code></a></li>
<li><a href=""><code>typeset</code></a></li>
<li><a href=""><code>ulimit</code></a></li>
<li><a href=""><code>umask</code></a></li>
<li><a href=""><code>umount</code></a></li>
<li><a href=""><code>uname</code></a></li>
<li><a href=""><code>unarc</code></a></li>
<li><a href=""><code>unarj</code></a></li>
<li><a href=""><code>uncompress</code></a></li>
<li><a href=""><code>unexpand</code></a></li>
<li><a href=""><code>uniq</code></a></li>
<li><a href=""><code>units</code></a></li>
<li><a href=""><code>unlzma</code></a></li>
<li><a href=""><code>unrar</code></a></li>
<li><a href=""><code>unset</code></a></li>
<li><a href=""><code>unsq</code></a></li>
<li><a href=""><code>unzip</code></a></li>
<li><a href=""><code>uptime</code></a></li>
<li><a href=""><code>usbmodules</code></a></li>
<li><a href=""><code>useradd</code></a></li>
<li><a href=""><code>userdel</code></a></li>
<li><a href=""><code>usermod</code></a></li>
<li><a href=""><code>users</code></a></li>
<li><a href=""><code>usleep</code></a></li>
<li><a href=""><code>uucp</code></a></li>
<li><a href=""><code>uudecode</code></a></li>
<li><a href=""><code>uuencode</code></a></li>
<li><a href=""><code>uux</code></a></li>
<li><a href=""><code>vacation</code></a></li>
<li><a href=""><code>vdir</code></a></li>
<li><a href=""><code>vmstat</code></a></li>
<li><a href=""><code>vrfy</code></a></li>
<li><a href=""><code>w</code></a></li>
<li><a href=""><code>wait</code></a></li>
<li><a href=""><code>wall</code></a></li>
<li><a href=""><code>watch</code></a></li>
<li><a href=""><code>wc</code></a></li>
<li><a href=""><code>wget</code></a></li>
<li><a href=""><code>whatis</code></a></li>
<li><a href=""><code>whereis</code></a></li>
<li><a href=""><code>which</code></a></li>
<li><a href=""><code>who</code></a></li>
<li><a href=""><code>whoami</code></a></li>
<li><a href=""><code>whois</code></a></li>
<li><a href=""><code>write</code></a></li>
<li><a href=""><code>xargs</code></a></li>
<li><a href=""><code>xrandr</code></a></li>
<li><a href=""><code>xz</code></a></li>
<li><a href=""><code>yacc</code></a></li>
<li><a href=""><code>yes</code></a></li>
<li><a href=""><code>zcat</code></a></li>
<li><a href=""><code>zdiff</code></a></li>
<li><a href=""><code>zdump</code></a></li>
<li><a href=""><code>zegrep</code></a></li>
<li><a href=""><code>zfgrep</code></a></li>
<li><a href=""><code>zgrep</code></a></li>
<li><a href=""><code>zip</code></a></li>
</ul>
<h3 id="目录"> 目录</h3>
<ul>
<li><a href="">15. 内建命令</a>
<ul>
<li><a href="">15.1 任务控制命令</a></li>
</ul>
</li>
<li><a href="">16. 外部筛选器，任务及命令</a>
<ul>
<li><a href="">16.1 基础命令</a></li>
<li><a href="">16.2 复杂命令</a></li>
<li><a href="">16.3 时间/日期命令</a></li>
<li><a href="">16.4 文本处理命令</a></li>
<li><a href="">16.5 文件与归档命令</a></li>
<li><a href="">16.6 通信命令</a></li>
<li><a href="">16.7 终端控制命令</a></li>
<li><a href="">16.8 数学命令</a></li>
<li><a href="">16.9 其他命令</a></li>
</ul>
</li>
<li><a href="">17. 系统与管理命令</a>
<ul>
<li><a href="">17.1 分析一个系统脚本</a></li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">18.1 正则表达式简介</title>
    <id>https://clay-wangzhi.com/code/shell/part5/18_1_a_brief_introduction_to_regular_expressions/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/18_1_a_brief_introduction_to_regular_expressions/"/>
    <updated>2021-05-11T06:41:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_18-1-正则表达式简介"> 18.1 正则表达式简介</h1>
<p>正则表达式是一系列的字符串。这些包含超过其字面含义的字符串被称之为元字符。例如，一个符号前面的引用符代表一个人的言语能力，或者按照上面的说法，代表着meta-meaning<a href="http://tldp.org/LDP/abs/html/x17129.html#FTN.AEN17134" target="_blank" rel="noopener noreferrer">[1]</a>。正则表达式是一组字符串和（或者）一组匹配（特定的）模式的元字符。</p>
<p>一个正则表达式包含下面的一个或多个选项：</p>
<ul>
<li>一组字符串。这是仅仅表示字面意思的字符串。最简单形式的正则表达式仅仅包含一组字符串。</li>
<li>一个锚字符。锚节点指定了正则表达式在一行文本中的匹配位置。例如，^和$就是锚字符。</li>
<li>修饰符。修饰符扩展或者限定（修改）了正则表达式在文本中的匹配范围。修饰符包括星号、方括号和反斜线。</li>
</ul>
<p>正则表达式的主要用在文本搜索和字符串操作。一个正则表达式匹配单个字符或者一组字符 -- 一系列的字符或者字符串的一部分。</p>
<ul>
<li>
<p>星号 * 匹配前面的子表达式任意次，包括0次</p>
<p>&quot;1133*&quot;匹配&quot;11&quot;加一个或多个&quot;3&quot;：113，1133，1133333，及以后</p>
</li>
<li>
<p>点号 . 匹配任意字符，除了新的一行<a href="http://tldp.org/LDP/abs/html/x17129.html#AEN17189" target="_blank" rel="noopener noreferrer">[2]</a></p>
<p>&quot;13.&quot;匹配&quot;13&quot;加至少一个字符（包括空格）：1133，11333，但不是13（缺少额外的字符）<br>
参见例子<a href="http://tldp.org/LDP/abs/html/textproc.html#CWSOLVER" target="_blank" rel="noopener noreferrer">16-18</a>，展示单字符匹配</p>
</li>
<li>
<p>脱字符 ^ 匹配行的起始位置，但有时候会根据上下文环境匹配其相反的意义（译者注：例如[^a]匹配任意一个非a的字符）</p>
</li>
<li>
<p>美元符 $ 匹配行的结束位置</p>
<p>&quot;XXX$&quot;匹配行尾处的&quot;XXX&quot;<br>
&quot;^$&quot;匹配空行</p>
</li>
<li>
<p>方括号 [...] 匹配所包含的任意一个字符</p>
<p>&quot;[xyz]&quot;匹配x、y或z中的任意一个字符<br>
&quot;[c-n]&quot;匹配c到n之间的任意一个字符<br>
&quot;[B-Pk-y]&quot;匹配B到P和k到y之间任意一个字符<br>
&quot;[a-z0-9]&quot;匹配任意一个小写字符和任意一个数字<br>
&quot;[<sup>b-d]&quot;匹配任意一个不在b到d之间的字符。这是一个很好的例子，展示了&quot;</sup>&quot;的匹配了正则表达式的反义（类似在其他环境下的&quot;!&quot;符号所起的作用）<br>
组合一连串的用方括号括起来的字符能匹配非常多的词组模式。&quot;[Yy][Ee][Ss]&quot;匹配yes、Yes、YES、yEs等等。&quot;[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]&quot;匹配任何一个社会保险号</p>
</li>
<li>
<p>反斜线 \ 转义一个特殊字符，意味着这个字符被解释为字面意义（因此不再包含特殊意思）</p>
<p>&quot;$&quot;表示回它的字面意义&quot;$&quot;，而不是它原本在正则表达式中代表行尾的意义。同样，&quot;\&quot;表示字面意义&quot;&quot;</p>
</li>
<li>
<p>转义后的尖括号 &lt;..&gt; 代表词组的边界</p>
<p>尖括号必须进行转义，否则它们就代表其字面意义<br>
&quot;&lt;the&gt;&quot;匹配词组&quot;the&quot;，而不是词组&quot;them,&quot; &quot;there,&quot; &quot;other,&quot;等等</p>
</li>
</ul>
<div><pre><code>bash$ <span>cat</span> textfile
This is line <span>1</span>, of <span>which</span> there is only one instance.
 This is the only instance of line <span>2</span>.
 This is line <span>3</span>, another line.
 This is line <span>4</span>.


bash$ <span>grep</span> <span>'the'</span> textfile
This is line <span>1</span>, of <span>which</span> there is only one instance.
 This is the only instance of line <span>2</span>.
 This is line <span>3</span>, another line.


bash$ <span>grep</span> <span>'\&lt;the\>'</span> textfile
This is the only instance of line <span>2</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>唯一判断一个特定的正则表达式是否有效的方法就是测试它。</p>
<div><pre><code>测试文件: tstfile                          <span># No match.</span>
                                            <span># No match.</span>
运行 <span>grep</span> <span>"1133*"</span>  tstfile                  <span># Match.</span>
                                            <span># No match.</span>
                                            <span># No match.</span>
This line contains the number <span>113</span>.          <span># Match.</span>
This line contains the number <span>13</span>.           <span># No match.</span>
This line contains the number <span>133</span>.          <span># No match.</span>
This line contains the number <span>1133</span>.         <span># Match.</span>
This line contains the number <span>113312</span>.       <span># Match.</span>
This line contains the number <span>1112</span>.         <span># No match.</span>
This line contains the number <span>113312312</span>.    <span># Match.</span>
This line contains no numbers at all.       <span># No match.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code>bash$ <span>grep</span> <span>"1133*"</span> tstfile
Run   <span>grep</span> <span>"1133*"</span>  on this file.           <span># Match.</span>
 This line contains the number <span>113</span>.          <span># Match.</span>
 This line contains the number <span>1133</span>.         <span># Match.</span>
 This line contains the number <span>113312</span>.       <span># Match.</span>
 This line contains the number <span>113312312</span>.    <span># Match.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注解</p>
<p><a href="http://tldp.org/LDP/abs/html/x17129.html#FTN.AEN17134" target="_blank" rel="noopener noreferrer">[1]</a> 元意义指的是一个词组或者表达式在更高层次的抽象上的意义。例如，正则表达式的字面意思就是所有人接受其用法的普通表达式。元意义则完全不同，正如在本章最终讨论的那样。
<a href="http://tldp.org/LDP/abs/html/x17129.html#AEN17189" target="_blank" rel="noopener noreferrer">[2]</a>
Since sed, awk, and grep process single lines, there will usually not be a newline to match. In those cases where there is a newline in a multiple line expression, the dot will match the newline.</p>
<div><pre><code><span>#!/bin/bash</span>

<span>sed</span> -e <span>'N;s/.*/[&amp;]/'</span> <span>&lt;&lt;</span> <span>EOF<span>   <span># Here Document</span></span>
line1
line2
EOF</span>
<span># OUTPUT:</span>
<span># [line1</span>
<span># line2]</span>



<span>echo</span>

<span>awk</span> <span>'{ <span>$0</span>=<span>$1</span> "<span title="\n">\n</span>" <span>$2</span>; if (/line.1/) {print}}'</span> <span>&lt;&lt;</span> <span>EOF
line 1
line 2
EOF</span>
<span># OUTPUT:</span>
<span># line</span>
<span># 1</span>


<span># Thanks, S.C.</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">18.2文件名替换</title>
    <id>https://clay-wangzhi.com/code/shell/part5/18_2_globbing/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/18_2_globbing/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_18-2文件名替换"> 18.2文件名替换</h1>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">18.3 正则表达式对照表</title>
    <id>https://clay-wangzhi.com/code/shell/part5/18_3_regular_expression_comparison_table/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/18_3_regular_expression_comparison_table/"/>
    <updated>2021-05-11T06:20:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_18-3-正则表达式对照表"> 18.3 正则表达式对照表</h1>
<p>正则表达式分为三类（man grep可以看到，分别是basic RegExs，extended RegExs，perl RegExs）</p>
<h2 id="正则表达式分类"> 正则表达式分类：</h2>
<ul>
<li>基本的正则表达式（Basic Regular Expression 又叫 Basic RegEx 简称 BREs）</li>
<li>扩展的正则表达式（Extended Regular Expression 又叫 Extended RegEx 简称 EREs）</li>
<li>Perl 的正则表达式（Perl Regular Expression 又叫 Perl RegEx 简称 PREs）</li>
</ul>
<h2 id="linux-中常用文本工具与正则表达式的关系"> Linux 中常用文本工具与正则表达式的关系</h2>
<ul>
<li>
<p>grep 支持：BREs、EREs、PREs 正则表达式
grep 指令后不跟任何参数，则表示要使用 ”BREs“
grep 指令后跟 ”-E&quot; 参数，则表示要使用 “EREs“
grep 指令后跟 “-P&quot; 参数，则表示要使用 “PREs&quot;</p>
</li>
<li>
<p>egrep 支持：EREs、PREs 正则表达式
egrep 指令后不跟任何参数，则表示要使用 “EREs”
egrep 指令后跟 “-P&quot; 参数，则表示要使用 “PREs&quot;</p>
</li>
<li>
<p>sed 正则表达式特点
sed 文本工具支持：BREs、EREs
sed 指令默认是使用&quot;BREs&quot;
sed 命令参数 “-r ” ，则表示要使用“EREs&quot;</p>
</li>
<li>
<p>Awk（gawk）正则表达式特点
Awk 文本工具支持：EREs
awk 指令默认是使用 “EREs&quot;</p>
</li>
</ul>
<h2 id="正则表示式对照表"> 正则表示式对照表</h2>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
<th>Basic RegEx</th>
<th>Extended RegEx</th>
<th>python RegEx</th>
<th>Perl regEx</th>
</tr>
</thead>
<tbody>
<tr>
<td>转义</td>
<td></td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td>^</td>
<td>匹配行首，例如'^dog'匹配以字符串dog开头的行（注意：awk 指令中，'^'则是匹配字符串的开始）</td>
<td>^</td>
<td>^</td>
<td>^</td>
<td>^</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾，例如：'^、dog<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.946332em;vertical-align:-0.19444em;"></span><span><span></span><span><span><span><span style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>匹配以字符串</span><span>d</span><span>o</span><span style="margin-right:0.03588em;">g</span><span>为结尾的行（注意：</span><span>a</span><span style="margin-right:0.02691em;">w</span><span style="margin-right:0.03148em;">k</span><span>指令中</span><span><span>，</span><span><span><span><span style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>′</span></span></span></span></span></span></span></span></span></span></span></span>'则是匹配字符串的结尾）</td>
<td>$</td>
<td>$</td>
<td>$</td>
<td>$</td>
</tr>
<tr>
<td>^$</td>
<td>匹配空行</td>
<td>^$</td>
<td>^$</td>
<td>^$</td>
<td>^$</td>
</tr>
<tr>
<td>^string$</td>
<td>匹配行，例如：'^dog$'匹配只含一个字符串 dog 的行</td>
<td>^string$</td>
<td>^string$</td>
<td>^string$</td>
<td>^string$</td>
</tr>
<tr>
<td>&lt;</td>
<td>匹配单词，例如：'&lt;frog' （等价于'\bfrog'），匹配以 frog 开头的单词</td>
<td>&lt;</td>
<td>&lt;</td>
<td>不支持</td>
<td>不支持（但可以使用\b来匹配单词，例如：'\bfrog'）</td>
</tr>
<tr>
<td>&gt;</td>
<td>匹配单词，例如：'frog&gt;'（等价于'frog\b '），匹配以 frog 结尾的单词</td>
<td>&gt;</td>
<td>&gt;</td>
<td>不支持</td>
<td>不支持（但可以使用\b来匹配单词，例如：'frog\b'）</td>
</tr>
<tr>
<td>&lt;x&gt;</td>
<td>匹配一个单词或者一个特定字符，例如：'&lt;frog&gt;'（等价于'\bfrog\b'）、'&lt;G&gt;'</td>
<td>&lt;x&gt;</td>
<td>&lt;x&gt;</td>
<td>不支持</td>
<td>不支持（但可以使用\b来匹配单词，例如：'\bfrog\b'</td>
</tr>
<tr>
<td>()</td>
<td>匹配表达式，例如：不支持'（frog）'</td>
<td>不支持（但可以使用，如：dog</td>
<td>()</td>
<td>()</td>
<td>()</td>
</tr>
<tr>
<td></td>
<td>匹配表达式，例如：不支持'（frog）'</td>
<td></td>
<td>不支持（同())</td>
<td>不支持（同())</td>
<td>不支持（同())</td>
</tr>
<tr>
<td>？</td>
<td>匹配前面的子表达式 0 次或 1 次（等价于{0,1}），例如：where(is)?能匹配&quot;where&quot; 以及&quot;whereis&quot;</td>
<td>不支持（同?)</td>
<td>？</td>
<td>？</td>
<td>？</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式 0 次或 1 次（等价于'{0,1}'），例如：'whereis? '能匹配 &quot;where&quot;以及&quot;whereis&quot;</td>
<td>?</td>
<td>不支持（同?)</td>
<td>不支持（同?)</td>
<td>不支持（同?)</td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符（*, +, ?, {n},{n,}, {n,m}） 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 &quot;oooo&quot;，'o+?' 将匹配单个&quot;o&quot;，而 'o+' 将匹配所有 'o'</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符（'\n'）之外的任意单个字符（注意：awk 指令中的句点能匹配换行符）</td>
<td>.</td>
<td>.（如果要匹配包括“\n”在内的任何一个字符，请使用：'(^$)|（.）</td>
<td>.</td>
<td>.（如果要匹配包括“\n”在内的任何一个字符，请使用：' [.\n] '</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式 0 次或多次（等价于{0, }），例如：zo* 能匹配 &quot;z&quot;以及 &quot;zoo&quot;</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式 1 次或多次（等价于'{1, }'），例如：'whereis+ '能匹配 &quot;whereis&quot;以及&quot;whereisis&quot;</td>
<td>+</td>
<td>不支持（同+)</td>
<td>不支持（同+)</td>
<td>不支持（同+)</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式 1 次或多次（等价于{1, }），例如：zo+能匹配 &quot;zo&quot;以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;</td>
<td>不支持（同+)</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>{n}</td>
<td>n 必须是一个 0 或者正整数，匹配子表达式 n 次，例如：zo{2}能匹配</td>
<td>不支持（同{n})</td>
<td>{n}</td>
<td>{n}</td>
<td>{n}</td>
</tr>
<tr>
<td>{n,}</td>
<td>&quot;zooz&quot;，但不能匹配 &quot;Bob&quot;n 必须是一个 0 或者正整数，匹配子表达式大于等于 n次，例如：go{2,}</td>
<td>不支持（同{n,})</td>
<td>{n,}</td>
<td>{n,}</td>
<td>{n,}</td>
</tr>
<tr>
<td>{n,m}</td>
<td>能匹配 &quot;good&quot;，但不能匹配 godm 和 n 均为非负整数，其中 n &lt;= m，最少匹配 n 次且最多匹配 m 次 ，例如：o{1,3}将配&quot;fooooood&quot; 中的前三个 o（请注意在逗号和两个数之间不能有空格）</td>
<td>不支持（同{n,m})</td>
<td>{n,m}</td>
<td>{n,m}</td>
<td>{n,m}</td>
</tr>
<tr>
<td>x|y</td>
<td>匹配 x 或 y，例如： 不支持'z|（food）' 能匹配 &quot;z&quot; 或&quot;food&quot;；'（z|f）ood' 则匹配&quot;zood&quot; 或 &quot;food&quot;</td>
<td>不支持（同x|y)</td>
<td>x|y</td>
<td>x|y</td>
<td>x|y</td>
</tr>
<tr>
<td>[0-9]</td>
<td>匹配从 0 到 9 中的任意一个数字字符（注意：要写成递增）</td>
<td>[0-9]</td>
<td>[0-9]</td>
<td>[0-9]</td>
<td>[0-9]</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合，匹配所包含的任意一个字符，例如：'[abc]'可以匹配&quot;lay&quot; 中的 'a'（注意：如果元字符，例如：. *等，它们被放在[ ]中，那么它们将变成一个普通字符）</td>
<td>[xyz]</td>
<td>[xyz]</td>
<td>[xyz]</td>
<td>[xyz]</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>负值字符集合，匹配未包含的任意一个字符（注意：不包括换行符），例如：'[^abc]' 可以匹配 &quot;Lay&quot; 中的'L'（注意：[^xyz]在awk 指令中则是匹配未包含的任意一个字符+换行符）</td>
<td>[^xyz]</td>
<td>[^xyz]</td>
<td>[^xyz]</td>
<td>[^xyz]</td>
</tr>
<tr>
<td>[A-Za-z]</td>
<td>匹配大写字母或者小写字母中的任意一个字符（注意：要写成递增）</td>
<td>[A-Za-z]</td>
<td>[A-Za-z]</td>
<td>[A-Za-z]</td>
<td>[A-Za-z]</td>
</tr>
<tr>
<td>[^A-Za-z]</td>
<td>匹配除了大写与小写字母之外的任意一个字符（注意：写成递增）</td>
<td>[^A-Za-z]</td>
<td>[^A-Za-z]</td>
<td>[^A-Za-z]</td>
<td>[^A-Za-z]</td>
</tr>
<tr>
<td>\d</td>
<td>匹配从 0 到 9 中的任意一个数字字符（等价于 [0-9]）</td>
<td>不支持</td>
<td>不支持</td>
<td>\d</td>
<td>\d</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字字符（等价于 [^0-9]）</td>
<td>不支持</td>
<td>不支持</td>
<td>\D</td>
<td>\D</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符（等价于[^\f\n\r\t\v]）</td>
<td>不支持</td>
<td>不支持</td>
<td>\S</td>
<td>\S</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等（等价于[ \f\n\r\t\v]）</td>
<td>不支持</td>
<td>不支持</td>
<td>\s</td>
<td>\s</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符 (等价于[^A-Za-z0-9_])</td>
<td>\W</td>
<td>\W</td>
<td>\W</td>
<td>\W</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符（等价于[A-Za-z0-9_]）</td>
<td>\w</td>
<td>\w</td>
<td>\w</td>
<td>\w</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界，例如：'er\B' 能匹配 &quot;verb&quot; 中的'er'，但不能匹配&quot;never&quot; 中的'er'</td>
<td>\B</td>
<td>\B</td>
<td>\B</td>
<td>\B</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置，例如： 'er\b' 可以匹配&quot;never&quot; 中的 'er'，但不能匹配 &quot;verb&quot; 中的'er'</td>
<td>\b</td>
<td>\b</td>
<td>\b</td>
<td>\b</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个横向制表符（等价于 \x09和 \cI）</td>
<td>不支持</td>
<td>不支持</td>
<td>\t</td>
<td>\t</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符（等价于 \x0b和 \cK）</td>
<td>不支持</td>
<td>不支持</td>
<td>\v</td>
<td>\v</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符（等价于 \x0a 和\cJ）</td>
<td>不支持</td>
<td>不支持</td>
<td>\n</td>
<td>\n</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符（等价于\x0c 和\cL）</td>
<td>不支持</td>
<td>不支持</td>
<td>\f</td>
<td>\f</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符（等价于 \x0d 和\cM）</td>
<td>不支持</td>
<td>不支持</td>
<td>\r</td>
<td>\r</td>
</tr>
<tr>
<td>\</td>
<td>匹配转义字符本身&quot;&quot;</td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td>\cx</td>
<td>匹配由 x 指明的控制字符，例如：\cM匹配一个Control-M 或回车符，x 的值必须为A-Z 或 a-z 之一，否则，将 c 视为一个原义的 'c' 字符</td>
<td>不支持</td>
<td>不支持</td>
<td></td>
<td>\cx</td>
</tr>
<tr>
<td>\xn</td>
<td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长，例如：'\x41' 匹配 &quot;A&quot;。'\x041' 则等价于'\x04' &amp; &quot;1&quot;。正则表达式中可以使用 ASCII 编码</td>
<td>不支持</td>
<td>不支持</td>
<td></td>
<td>\xn</td>
</tr>
<tr>
<td>\num</td>
<td>匹配 num，其中 num是一个正整数。表示对所获取的匹配的引用</td>
<td>不支持</td>
<td>\num</td>
<td>\num</td>
<td></td>
</tr>
<tr>
<td>[:alnum:]</td>
<td>匹配任何一个字母或数字（[A-Za-z0-9]），例如：'[[:alnum:]] '</td>
<td>[:alnum:]</td>
<td>[:alnum:]</td>
<td>[:alnum:]</td>
<td>[:alnum:]</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>匹配任何一个字母（[A－Za－z]）， 例如：' [[:alpha:]] '</td>
<td>[:alpha:]</td>
<td>[:alpha:]</td>
<td>[:alpha:]</td>
<td>[:alpha:]</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>匹配任何一个数字（[0-9]），例如：'[[:digit:]] '</td>
<td>[:digit:]</td>
<td>[:digit:]</td>
<td>[:digit:]</td>
<td>[:digit:]</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>匹配任何一个小写字母（[a-z]）， 例如：' [[:lower:]] '</td>
<td>[:lower:]</td>
<td>[:lower:]</td>
<td>[:lower:]</td>
<td>[:lower:]</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>匹配任何一个大写字母（[A-Z]）</td>
<td>[:upper:]</td>
<td>[:upper:]</td>
<td>[:upper:]</td>
<td>[:upper:]</td>
</tr>
<tr>
<td>[:space:]</td>
<td>任何一个空白字符： 支持制表符、空格，例如：' [[:space:]] '</td>
<td>[:space:]</td>
<td>[:space:]</td>
<td>[:space:]</td>
<td>[:space:]</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格和制表符（横向和纵向），例如：'[[:blank:]]'ó'[\s\t\v]'</td>
<td>[:blank:]</td>
<td>[:blank:]</td>
<td>[:blank:]</td>
<td>[:blank:]</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>任何一个可以看得见的且可以打印的字符（注意：不包括空格和换行符等），例如：'[[:graph:]] '</td>
<td>[:graph:]</td>
<td>[:graph:]</td>
<td>[:graph:]</td>
<td>[:graph:]</td>
</tr>
<tr>
<td>[:print:]</td>
<td>任何一个可以打印的字符（注意：不包括：[:cntrl:]、字符串结束符'\0'、EOF 文件结束符（-1）， 但包括空格符号），例如：'[[:print:]] '</td>
<td>[:print:]</td>
<td>[:print:]</td>
<td>[:print:]</td>
<td>[:print:]</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>任何一个控制字符（ASCII 字符集中的前 32 个字符，即：用十进制表示为从 0 到31，例如：换行符、制表符等等），例如：' [[:cntrl:]]'</td>
<td>[:cntrl:]</td>
<td>[:cntrl:]</td>
<td>[:cntrl:]</td>
<td>[:cntrl:]</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>任何一个标点符号（不包括：[:alnum:]、[:cntrl:]、[:space:]这些字符集）</td>
<td>[:punct:]</td>
<td>[:punct:]</td>
<td>[:punct:]</td>
<td>[:punct:]</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>任何一个十六进制数（即：0-9，a-f，A-F）</td>
<td>[:xdigit:]</td>
<td>[:xdigit:]</td>
<td>[:xdigit:]</td>
<td>[:xdigit:]</td>
</tr>
</tbody>
</table>
<h2 id="常用正则表达式"> 常用正则表达式</h2>
<div><pre><code>1.验证用户名和密码：（&quot;^[a-zA-Z]\w{5,15}$&quot;）正确格式：&quot;[A-Z][a-z]_[0-9]&quot;组成,并且第一个字必须为字母6~16位；
2.验证电话号码：（&quot;^(\d{3,4}-)\d{7,8}$&quot;）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx；
3.验证手机号码：&quot;^1[3|4|5|7|8][0-9]\\d{8}$&quot;；
4.验证身份证号（15位或18位数字）：&quot;\d{14}[[0-9],0-9xX]&quot;；
5.验证Email地址：(&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;)；
6.只能输入由数字和26个英文字母组成的字符串：(&quot;^[A-Za-z0-9]+$&quot;)；
7.整数或者小数：^[0-9]+([.][0-9]+){0,1}$
8.只能输入数字：&quot;^[0-9]*$&quot;。
9.只能输入n位的数字：&quot;^\d{n}$&quot;。
10.只能输入至少n位的数字：&quot;^\d{n,}$&quot;。
11.只能输入m~n位的数字：&quot;^\d{m,n}$&quot;。
12.只能输入零和非零开头的数字：&quot;^(0|[1-9][0-9]*)$&quot;。
13.只能输入有两位小数的正实数：&quot;^[0-9]+(\.[0-9]{2})?$&quot;。
14.只能输入有1~3位小数的正实数：&quot;^[0-9]+(\.[0-9]{1,3})?$&quot;。
15.只能输入非零的正整数：&quot;^\+?[1-9][0-9]*$&quot;。
16.只能输入非零的负整数：&quot;^\-[1-9][0-9]*$&quot;。
17.只能输入长度为3的字符：&quot;^.{3}$&quot;。
18.只能输入由26个英文字母组成的字符串：&quot;^[A-Za-z]+$&quot;。
19.只能输入由26个大写英文字母组成的字符串：&quot;^[A-Z]+$&quot;。
20.只能输入由26个小写英文字母组成的字符串：&quot;^[a-z]+$&quot;。
21.验证是否含有^%&amp;&#39;,;=?$\&quot;等字符：&quot;[%&amp;&#39;,;=?$\\^]+&quot;。
22.验证一年的12个月：&quot;^(0?[1-9]|1[0-2])$&quot;正确格式为：&quot;01&quot;～&quot;09&quot;和&quot;10&quot;～&quot;12&quot;。
23.验证一个月的31天：&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;正确格式为；&quot;01&quot;～&quot;09&quot;、&quot;10&quot;～&quot;29&quot;和“30”~“31”。
24.获取日期正则表达式：\\d{4}[年|\-|\.]\d{\1-\12}[月|\-|\.]\d{\1-\31}日?评注：可用来匹配大多数年月日信息。
25.匹配空白行的正则表达式：\n\s*\r评注：可以用来删除空白行
26匹配HTML标记的正则表达式：&lt;(\S*?)\[^&gt;]*&gt;.*?&lt;/&gt;|&lt;.*? /&gt;评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
27.匹配首尾空白字符的正则表达式：^\s*|\s*$评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
28.匹配网址URL的正则表达式：[a-zA-z]+://\[^\s]*评注：网上流传的版本功能很有限，上面这个基本可以满足需求
29.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$评注：表单验证时很实用
30.匹配腾讯QQ号：[1-9][0-9]{4,}评注：腾讯QQ号从10 000 开始
31.匹配中国邮政编码：[1-9]\\d{5}(?!\d)评注：中国邮政编码为6位数字
32.匹配ip地址：([0-9]{1,3}\.){3}[0-9]。评注：提取ip地址时有用
33.匹配MAC地址：([A-Fa-f0-9]{2}\:){5}[A-Fa-f0-9]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>一、校验数字的表达式</p>
<div><pre><code>


• 数字：^[0-9]*$

• n位的数字：^d{n}$

• 至少n位的数字：^d{n,}$

• m-n位的数字：^d{m,n}$

• 零和非零开头的数字：^(0|[1-9][0-9]*)$

• 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$

• 带1-2位小数的正数或负数：^(-)?d+(.d{1,2})?$

• 正数、负数、和小数：^(-|+)?d+(.d+)?$

• 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$

• 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$

• 非零的正整数：^[1-9]d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^+?[1-9][0-9]*$

• 非零的负整数：^-[1-9][]0-9″*$ 或 ^-[1-9]d*$

• 非负整数：^d+$ 或 ^[1-9]d*|0$

• 非正整数：^-[1-9]d*|0$ 或 ^((-d+)|(0+))$

• 非负浮点数：^d+(.d+)?$ 或 ^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$

• 非正浮点数：^((-d+(.d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$

• 正浮点数：^[1-9]d*.d*|0.d*[1-9]d*$ 或 ^(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*))$

• 负浮点数：^-([1-9]d*.d*|0.d*[1-9]d*)$ 或 ^(-(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*)))$

• 浮点数：^(-?d+)(.d+)?$ 或 ^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>二、校验字符的表达式</p>
<div><pre><code>• 汉字：^[一-龥]{0,}$

• 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$

• 长度为3-20的所有字符：^.{3,20}$

• 由26个英文字母组成的字符串：^[A-Za-z]+$

• 由26个大写英文字母组成的字符串：^[A-Z]+$

• 由26个小写英文字母组成的字符串：^[a-z]+$

• 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$

• 由数字、26个英文字母或者下划线组成的字符串：^w+$ 或 ^w{3,20}$

• 中文、英文、数字包括下划线：^[一-龥A-Za-z0-9_]+$

• 中文、英文、数字但不包括下划线等符号：^[一-龥A-Za-z0-9]+$ 或 ^[一-龥A-Za-z0-9]{2,20}$

• 可以输入含有^%&amp;’,;=?$”等字符：[^%&amp;&#39;,;=?$&quot;]+

• 禁止输入含有~的字符：[^~&quot;]+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>三、特殊需求表达式</p>
<div><pre><code>


• Email地址：^w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$

• 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?

• InternetURL：[a-zA-z]+://[^s]* 或 ^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$

• 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])d{8}$

• 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^($$d{3,4}-)|d{3.4}-)?d{7,8}$

• 国内电话号码(0511-4405222、021-87888822)：d{3}-d{8}|d{4}-d{7}

• 身份证号(15位、18位数字)：^d{15}|d{18}$

• 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$

• 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

• 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]w{5,17}$

• 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

• 日期格式：^d{4}-d{1,2}-d{1,2}

• 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$

• 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$

• 钱的输入格式：

• 有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：^[1-9][0-9]*$

• 这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]*)$

• 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$

• 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$

• 必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：^[0-9]+(.[0-9]{2})?$

• 这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]{1,2})?$

• 这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$

• 1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$

• 备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里

• xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+.[x|X][m|M][l|L]$

• 中文字符的正则表达式：[一-龥]

• 双字节字符：[^-ÿ] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))

• 空白行的正则表达式：s* (可以用来删除空白行)

• HTML标记的正则表达式：&lt;(S*?)[^&gt;]*&gt;.*?&lt;/&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)

• 首尾空白字符的正则表达式：^s*|s*$或(^s*)|(s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)

• 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)

• 中国邮政编码：[1-9]d{5}(?!d) (中国邮政编码为6位数字)

• IP地址：d+.d+.d+.d+ (提取IP地址时有用)

• IP地址：((?:(?:25[0-5]|2[0-4]d|[01]?d?d).){3}(?:25[0-5]|2[0-4]d|[01]?d?d))
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">18 正则表达式</title>
    <id>https://clay-wangzhi.com/code/shell/part5/18_regular_expressions/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/18_regular_expressions/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_18-正则表达式"> 18 正则表达式</h1>
<blockquote>
<p><em>...the intellectual activity associated with software development is largely one of gaining insight.</em>
<em>--Stowe Boyd</em></p>
</blockquote>
<p>目录</p>
<ul>
<li><a href="http://tldp.org/LDP/abs/html/x17129.html" target="_blank" rel="noopener noreferrer">18.1 正则表达式简介</a></li>
<li><a href="http://tldp.org/LDP/abs/html/globbingref.html" target="_blank" rel="noopener noreferrer">18.2 文件名替换</a></li>
</ul>
<p>为了充分利用shell脚本，您需要熟练掌握正则表达式。有一些在脚本中常用的特定的命令和工具，例如grep、expr、sed和awk，这些命令会解释和使用正则表达式。版本三的bash实现了它独特的正则匹配符：=~。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">19 嵌入文档</title>
    <id>https://clay-wangzhi.com/code/shell/part5/19_here_documents/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/19_here_documents/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_19-嵌入文档"> 19 嵌入文档</h1>
<blockquote>Here and now, boys.
&emsp;&emsp;&emsp;&emsp;--Aldous Huxley, Island</blockquote>
<p>嵌入文档是一段有特殊作用的代码块，它用 <a href="http://tldp.org/LDP/abs/html/io-redirection.html#IOREDIRREF" target="_blank" rel="noopener noreferrer">I/O 重定向</a> 在交互程序和交互命令中传递和反馈一个命令列表，例如 <a href="http://tldp.org/LDP/abs/html/communications.html#FTPREF" target="_blank" rel="noopener noreferrer">ftp</a>，<a href="http://tldp.org/LDP/abs/html/basic.html#CATREF" target="_blank" rel="noopener noreferrer">cat</a> 或者是 ex 文本编辑器</p>
<div><pre><code>COMMAND &lt;&lt;InputComesFromHERE
...
...
...
InputComesFromHERE
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>嵌入文档用限定符作为命令列表的边界，在限定符前需要一个指定的标识符 <code>&lt;&lt;</code>，这会将一个程序或命令的标准输入(stdin)进行重定向，它类似 <code>交互程序 &lt; 命令文件</code> 的方式，其中命令文件内容如下</p>
<div><pre><code>command #1
command #2
...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>嵌入文档的格式大致如下</p>
<div><pre><code>interactive-program &lt;&lt;LimitString
command #1
command #2
...
LimitString
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>限定符的选择必须保证特殊以确保不会和命令列表里的内容发生混淆。</p>
<p>注意嵌入文档有时候用作非交互的工具和命令有着非常好的效果，例如 <a href="http://tldp.org/LDP/abs/html/system.html#WALLREF" target="_blank" rel="noopener noreferrer">wall</a></p>
<p>样例 19-1. broadcast: 给每个登陆者发送信息</p>
<div><pre><code>#!/bin/bash

wall &lt;&lt;zzz23EndOfMessagezzz23
E-mail your noontime orders for pizza to the system administrator.
    (Add an extra dollar for anchovy or mushroom topping.)
# 额外的信息文本.
# 注意: &#39;wall&#39; 会打印注释行.
zzz23EndOfMessagezzz23

# 更有效的做法是通过
#         wall &lt; 信息文本
#  然而, 在脚本里嵌入信息模板不乏是一种迅速而又随性的解决方式.

exit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>样例: 19-2. dummyfile：创建一个有两行内容的虚拟文件</p>
<div><pre><code>#!/bin/bash

# 非交互的使用 `vi` 编辑文件.
# 仿照 &#39;sed&#39;.

E_BADARGS=85

if [ -z &quot;$1&quot; ]
then
  echo &quot;Usage: `basename $0` filename&quot;
  exit $E_BADARGS
fi

TARGETFILE=$1

# 插入两行到文件中保存
#--------Begin here document-----------#
vi $TARGETFILE &lt;&lt;x23LimitStringx23
i
This is line 1 of the example file.
This is line 2 of the example file.
^[
ZZ
x23LimitStringx23
#----------End here document-----------#

#  注意 &quot;^&quot; 对 &quot;[&quot; 进行了转义 
#+ 这段起到了和键盘上按下 Control-V &lt;Esc&gt; 相同的效果.

#  Bram Moolenaar 指出这种情况下 &#39;vim&#39; 可能无法正常工作
#+ 因为在与终端交互的过程中可能会出现问题.

exit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>上述脚本实现了 <code>ex</code> 的功能, 而不是 <code>vi</code>. 嵌入文档包含了 <code>ex</code> 足够通用的命令列表来形成自有的类别, 所以又称之为 <code>ex</code> 脚本.</p>
<div><pre><code>#!/bin/bash
#  替换所有的以 &quot;.txt&quot; 后缀结尾的文件的 &quot;Smith&quot; 为 &quot;Jones&quot;

ORIGINAL=Smith
REPLACEMENT=Jones

for word in $(fgrep -l $ORIGINAL *.txt)
do
  # -------------------------------------
  ex $word &lt;&lt;EOF
  :%s/$ORIGINAL/$REPLACEMENT/g
  :wq
EOF
  # :%s is the &quot;ex&quot; substitution command.
  # :wq is write-and-quit.
  # -------------------------------------
done
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>类似的 <code>ex 脚本</code> 是 <code>cat 脚本</code>.</p>
<p>样例 19-3. 使用 <code>cat</code> 的多行信息</p>
<div><pre><code>#!/bin/bash

#  &#39;echo&#39; 可以输出单行信息,
#+  但是如果是输出消息块就有点问题了.
#   &#39;cat&#39; 嵌入文档却能解决这个局限.

cat &lt;&lt;End-of-message
-------------------------------------
This is line 1 of the message.
This is line 2 of the message.
This is line 3 of the message.
This is line 4 of the message.
This is the last line of the message.
-------------------------------------
End-of-message

#  替换上述嵌入文档内的 7 行文本
#+   cat &gt; $Newfile &lt;&lt;End-of-message
#+       ^^^^^^^^^^
#+ 将输出追加到 $Newfile, 而不是标准输出.

exit 0


#--------------------------------------------
# 由于上面的 &quot;exit 0&quot;，下面的代码将不会生效.

# S.C. points out that the following also works.
echo &quot;-------------------------------------
This is line 1 of the message.
This is line 2 of the message.
This is line 3 of the message.
This is line 4 of the message.
This is the last line of the message.
-------------------------------------&quot;
# 然而, 文本可能不包括双引号除非出现了字符串逃逸.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p><code>-</code> 的作用是标记了一个嵌入文档限制符 (&lt;&lt;-LimitString) ，它能抑制输出的行首的 <code>tab</code> (非空格). 这在脚本可读性方面可能非常有用.</p>
<p>样例 19-4. 抑制 tab 的多行信息</p>
<div><pre><code>#!/bin/bash
# 和之前的样例一样, 但...

#  嵌入文档内的 &#39;-&#39; ，也就是 &lt;&lt;-
#+ 抑制了文档行首的 &#39;tab&#39;,
#+ 但 *不是* 空格.

cat &lt;&lt;-ENDOFMESSAGE
	This is line 1 of the message.
	This is line 2 of the message.
	This is line 3 of the message.
	This is line 4 of the message.
	This is the last line of the message.
ENDOFMESSAGE
# 脚本的输出将左对齐.
# 行首的 tab 将不会输出.

# 上面 5 行的 &quot;信息&quot; 以 tab 开始, 不是空格.
# 空格不会受影响 &lt;&lt;- .

# 注意这个选项对 *内嵌的* tab 没有影响.

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>嵌入文档支持参数和命令替换. 因此可以向嵌入文档传递不同的参数,变向的改其输出.</p>
<p>样例 19-5. 可替换参数的嵌入文档</p>
<div><pre><code>#!/bin/bash
# 另一个使用参数替换的 &#39;cat&#39; 嵌入文档.

# 试一试没有命令行参数,   ./scriptname
# 试一试一个命令行参数,   ./scriptname Mortimer
# 试试用一两个单词引用命令行参数,
#                           ./scriptname &quot;Mortimer Jones&quot;

CMDLINEPARAM=1     #  Expect at least command-line parameter.

if [ $# -ge $CMDLINEPARAM ]
then
  NAME=$1          #  If more than one command-line param,
                   #+ then just take the first.
else
  NAME=&quot;John Doe&quot;  #  Default, if no command-line parameter.
fi  

RESPONDENT=&quot;the author of this fine script&quot;  
  

cat &lt;&lt;Endofmessage

Hello, there, $NAME.
Greetings to you, $NAME, from $RESPONDENT.

# 这个注释在输出时显示 (为什么?).

Endofmessage

# 注意输出了空行.
# 所以可以这样注释.

exit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>这个包含参数替换的嵌入文档是相当有用的</p>
<p>样例 19-6. 上传文件对到 <code>Sunsite</code> 入口目录</p>
<div><pre><code>#!/bin/bash
# upload.sh

#  上传文件对 (Filename.lsm, Filename.tar.gz)
#+ 到 Sunsite/UNC (ibiblio.org) 的入口目录.
#  Filename.tar.gz 是个 tarball.
#  Filename.lsm is 是个描述文件.
#  Sunsite 需要 &quot;lsm&quot; 文件, 否则将会退回给发送者


E_ARGERROR=85

if [ -z &quot;$1&quot; ]
then
  echo &quot;Usage: `basename $0` Filename-to-upload&quot;
  exit $E_ARGERROR
fi  


Filename=`basename $1`           # Strips pathname out of file name.

Server=&quot;ibiblio.org&quot;
Directory=&quot;/incoming/Linux&quot;
#  脚本里不需要硬编码,
#+ 但最好可以替换命令行参数.

Password=&quot;your.e-mail.address&quot;   # Change above to suit.

ftp -n $Server &lt;&lt;End-Of-Session
# -n 禁用自动登录

user anonymous &quot;$Password&quot;       #  If this doesn&#39;t work, then try:
                                 #  quote user anonymous &quot;$Password&quot;
binary
bell                             # Ring &#39;bell&#39; after each file transfer.
cd $Directory
put &quot;$Filename.lsm&quot;
put &quot;$Filename.tar.gz&quot;
bye
End-Of-Session

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>在嵌入文档头部引用或转义&quot;限制符&quot;来禁用参数替换.原因是 <code>引用/转义</code> 限定符能有效的<a href="http://tldp.org/LDP/abs/html/escapingsection.html#ESCP" target="_blank" rel="noopener noreferrer">转义</a>  &quot;$&quot;, &quot;`&quot;, 和 &quot;&quot; 这些<a href="http://tldp.org/LDP/abs/html/special-chars.html#SCHARLIST" target="_blank" rel="noopener noreferrer">特殊符号</a>, 使他们维持字面上的意思. (感谢 Allen Halsey 指出这点.)</p>
<p>样例 19-7. 禁用参数替换</p>
<div><pre><code>#!/bin/bash
#  A &#39;cat&#39; here-document, but with parameter substitution disabled.

NAME=&quot;John Doe&quot;
RESPONDENT=&quot;the author of this fine script&quot;  

cat &lt;&lt;&#39;Endofmessage&#39;

Hello, there, $NAME.
Greetings to you, $NAME, from $RESPONDENT.

Endofmessage

#   当&#39;限制符&#39;引用或转义时不会有参数替换.
#   下面的嵌入文档也有同样的效果
#   cat &lt;&lt;&quot;Endofmessage&quot;
#   cat &lt;&lt;\Endofmessage



#   同样的:

cat &lt;&lt;&quot;SpecialCharTest&quot;

Directory listing would follow
if limit string were not quoted.
`ls -l`

Arithmetic expansion would take place
if limit string were not quoted.
$((5 + 3))

A a single backslash would echo
if limit string were not quoted.
\\

SpecialCharTest


exit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>生成脚本或者程序代码时可以用禁用参数的方式来输出文本.</p>
<p>样例 19-8. 生成其他脚本的脚本</p>
<div><pre><code>#!/bin/bash
# generate-script.sh
# Based on an idea by Albert Reiner.

OUTFILE=generated.sh         # Name of the file to generate.


# -----------------------------------------------------------
# &#39;嵌入文档涵盖了生成脚本的主体部分.
(
cat &lt;&lt;&#39;EOF&#39;
#!/bin/bash

echo &quot;This is a generated shell script.&quot;
#  注意我们现在在一个子 shell 内,
#+ 我们不能访问 &quot;外部&quot; 脚本变量.

echo &quot;Generated file will be named: $OUTFILE&quot;
#  上面这行并不能按照预期的正常工作
#+ 因为参数扩展已被禁用.
#  相反的, 结果是文字输出.

a=7
b=3

let &quot;c = $a * $b&quot;
echo &quot;c = $c&quot;

exit 0
EOF
) &gt; $OUTFILE
# -----------------------------------------------------------

#  在上述的嵌入文档内引用&#39;限制符&#39;防止变量扩展

if [ -f &quot;$OUTFILE&quot; ]
then
  chmod 755 $OUTFILE
  # 生成可执行文件.
else
  echo &quot;Problem in creating file: \&quot;$OUTFILE\&quot;&quot;
fi

#  这个方法适用于生成 C, Perl, Python, Makefiles 等等

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>可以从嵌入文档的输出设置一个变量的值. 这实际上是种灵活的 <a href="http://tldp.org/LDP/abs/html/commandsub.html#COMMANDSUBREF" target="_blank" rel="noopener noreferrer">命令替换</a>.</p>
<div><pre><code>variable=$(cat &lt;&lt;SETVAR
This variable
runs over multiple lines.
SETVAR
)

echo &quot;$variable&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>同样的脚本里嵌入文档可以作为函数的输入.</p>
<p>样例 19-9. 嵌入文档和函数</p>
<div><pre><code>#!/bin/bash
# here-function.sh

GetPersonalData ()
{
  read firstname
  read lastname
  read address
  read city 
  read state 
  read zipcode
} # 可以肯定的是这应该是个交互式的函数, 但 . . .


# 作为函数的输入.
GetPersonalData &lt;&lt;RECORD001
Bozo
Bozeman
2726 Nondescript Dr.
Bozeman
MT
21226
RECORD001


echo
echo &quot;$firstname $lastname&quot;
echo &quot;$address&quot;
echo &quot;$city, $state $zipcode&quot;
echo

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>可以这样使用: 作为一个虚构的命令接受嵌入文档的输出. 这样实际上就创建了一个 &quot;匿名&quot; 嵌入文档.</p>
<p>样例 19-10. &quot;匿名&quot; 嵌入文档</p>
<div><pre><code>#!/bin/bash

: &lt;&lt;TESTVARIABLES
${HOSTNAME?}${USER?}${MAIL?}  # Print error message if one of the variables not set.
TESTVARIABLES

exit $?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>上面技巧的一种变体允许 &quot;可添加注释&quot; 的代码块.</li>
</ul>
<p>样例 19-11. 可添加注释的代码块</p>
<div><pre><code>#!/bin/bash
# commentblock.sh

: &lt;&lt;COMMENTBLOCK
echo &quot;This line will not echo.&quot;
这些注释没有 &quot;#&quot; 前缀.
则是另一种没有 &quot;#&quot; 前缀的注释方法.

&amp;*@!!++=
上面这行不会产生报错信息,
因为 bash 解释器会忽略它.

COMMENTBLOCK

echo &quot;Exit value of above \&quot;COMMENTBLOCK\&quot; is $?.&quot;   # 0
# 没有错误输出.
echo

#  上面的技巧经常用于工作代码的注释用作排错目的
#  这省去了在每一行开头加上 &quot;#&quot; 前缀,
#+ 然后调试完不得不删除每行的前缀的重复工作.
#  注意我们用了 &quot;:&quot;, 在这之上，是可选的.

echo &quot;Just before commented-out code block.&quot;
#  下面这个在双破折号之间的代码不会被执行.
#  ===================================================================
: &lt;&lt;DEBUGXXX
for file in *
do
 cat &quot;$file&quot;
done
DEBUGXXX
#  ===================================================================
echo &quot;Just after commented-out code block.&quot;

exit 0



######################################################################
#  注意, 然而, 如果将变量中包含一个注释的代码块将会引发问题
#  例如:


#/!/bin/bash

  : &lt;&lt;COMMENTBLOCK
  echo &quot;This line will not echo.&quot;
  &amp;*@!!++=
  ${foo_bar_bazz?}
  $(rm -rf /tmp/foobar/)
  $(touch my_build_directory/cups/Makefile)
COMMENTBLOCK


$ sh commented-bad.sh
commented-bad.sh: line 3: foo_bar_bazz: parameter null or not set

# 有效的补救办法就是在 49 行的位置加上单引号，变为 &#39;COMMENTBLOCK&#39;.

  : &lt;&lt;&#39;COMMENTBLOCK&#39;

# 感谢 Kurt Pfeifle 指出这一点.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><ul>
<li>另一个漂亮的方法使得&quot;自文档化&quot;的脚本成为可能</li>
</ul>
<p>样例 19-12. 自文档化的脚本</p>
<div><pre><code>#!/bin/bash
# self-document.sh: self-documenting script
# Modification of &quot;colm.sh&quot;.

DOC_REQUEST=70

if [ &quot;$1&quot; = &quot;-h&quot;  -o &quot;$1&quot; = &quot;--help&quot; ]     # 请求帮助.
then
  echo; echo &quot;Usage: $0 [directory-name]&quot;; echo
  sed --silent -e &#39;/DOCUMENTATIONXX$/,/^DOCUMENTATIONXX$/p&#39; &quot;$0&quot; |
  sed -e &#39;/DOCUMENTATIONXX$/d&#39;; exit $DOC_REQUEST; fi


: &lt;&lt;DOCUMENTATIONXX
List the statistics of a specified directory in tabular format.
---------------------------------------------------------------
The command-line parameter gives the directory to be listed.
If no directory specified or directory specified cannot be read,
then list the current working directory.

DOCUMENTATIONXX

if [ -z &quot;$1&quot; -o ! -r &quot;$1&quot; ]
then
  directory=.
else
  directory=&quot;$1&quot;
fi  

echo &quot;Listing of &quot;$directory&quot;:&quot;; echo
(printf &quot;PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n&quot; \
; ls -l &quot;$directory&quot; | sed 1d) | column -t

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>使用 <a href="http://tldp.org/LDP/abs/html/here-docs.html#CATSCRIPTREF" target="_blank" rel="noopener noreferrer">cat script</a> 是另一种可行的方法.</p>
<div><pre><code>DOC_REQUEST=70

if [ &quot;$1&quot; = &quot;-h&quot;  -o &quot;$1&quot; = &quot;--help&quot; ]     # Request help.
then                                       # Use a &quot;cat script&quot; . . .
  cat &lt;&lt;DOCUMENTATIONXX
List the statistics of a specified directory in tabular format.
---------------------------------------------------------------
The command-line parameter gives the directory to be listed.
If no directory specified or directory specified cannot be read,
then list the current working directory.

DOCUMENTATIONXX
exit $DOC_REQUEST
fi
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>
<p>另请参阅 <a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#ISSPAMMER2" target="_blank" rel="noopener noreferrer">样例 A-28</a>, <a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#PETALS" target="_blank" rel="noopener noreferrer">样例 A-40</a>, <a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#QKY" target="_blank" rel="noopener noreferrer">样例 A-41</a>, and <a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#NIM" target="_blank" rel="noopener noreferrer">样例 A-42</a> 更多样例请阅读脚本附带的注释文档.</p>
</blockquote>
<ul>
<li>嵌入文档创建了临时文件, 但这些文件在打开且不可被其他程序访问后删除.</li>
</ul>
<div><pre><code>bash$ bash -c &#39;lsof -a -p $$ -d0&#39; &lt;&lt; EOF
&gt; EOF
lsof    1213 bozo    0r   REG    3,5    0 30386 /tmp/t1213-0-sh (deleted)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>
<p>某些工具在嵌入文档内部并不能正常运行.</p>
</li>
<li>
<p>在嵌入文档的最后关闭限定符必须在起始的第一个字符的位置开始.行首不能是空格. 限制符后尾随空格同样会导致意想不到的行为.空格可以防止限制符被当做其他用途. <a href="http://tldp.org/LDP/abs/html/here-docs.html#FTN.AEN17822" target="_blank" rel="noopener noreferrer">[1]</a></p>
</li>
</ul>
<div><pre><code>#!/bin/bash

echo &quot;----------------------------------------------------------------------&quot;

cat &lt;&lt;LimitString
echo &quot;This is line 1 of the message inside the here document.&quot;
echo &quot;This is line 2 of the message inside the here document.&quot;
echo &quot;This is the final line of the message inside the here document.&quot;
     LimitString
#^^^^限制符的缩进. 出错! 这个脚本将不会如期运行.

echo &quot;----------------------------------------------------------------------&quot;

#  这些评论在嵌入文档范围外并不能输出

echo &quot;Outside the here document.&quot;

exit 0

echo &quot;This line had better not echo.&quot;  # 紧跟着个 &#39;exit&#39; 命令.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><ul>
<li>有些人非常聪明的使用了一个单引号(!)做为限制符. 但这并不是个好主意</li>
</ul>
<div><pre><code># 这个可以运行.
cat &lt;&lt;!
Hello!
! Three more exclamations !!!
!


# 但是 . . .
cat &lt;&lt;!
Hello!
Single exclamation point follows!
!
!
# Crashes with an error message.


# 然而, 下面这样也能运行.
cat &lt;&lt;EOF
Hello!
Single exclamation point follows!
!
EOF
# 使用多字符限制符更为安全.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>为嵌入文档设置这些任务有些复杂, 可以考虑使用 <code>expect</code>, 一种专门用来和程序进行交互的脚本语言。</p>
<p><strong>Notes:</strong>
  除此之外, Dennis Benzinger 指出,  <a href="http://tldp.org/LDP/abs/html/here-docs.html#LIMITSTRDASH" target="_blank" rel="noopener noreferrer">使用 &lt;&lt;- 抑制 tab.</a></p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">20.1 使用 exec</title>
    <id>https://clay-wangzhi.com/code/shell/part5/20_1_use_exec/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/20_1_use_exec/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_20-1-使用-exec"> 20.1 使用 exec</h1>
<p>一个 <code>exec &lt; filename</code> 命令重定向了 <code>标准输入</code> 到一个文件。自此所有 <code>标准输入</code> 都来自该文件而不是默认来源(通常是键盘输入)。在使用 <a href="http://tldp.org/LDP/abs/html/sedawk.html#SEDREF" target="_blank" rel="noopener noreferrer">sed</a> 和 <a href="http://tldp.org/LDP/abs/html/awk.html#AWKREF" target="_blank" rel="noopener noreferrer">awk</a> 时候这种方式可以逐行读文件并逐行解析。</p>
<p>样例 20-1. 使用 <code>exec</code> 重定向 标准输入</p>
<div><pre><code>#!/bin/bash
# 使用 &#39;exec&#39; 重定向 标准输入 .


exec 6&lt;&amp;0          # 链接文件描述符 #6 到标准输入.
                   # .

exec &lt; data-file   # 标准输入被文件 &quot;data-file&quot; 替换

read a1            # 读取文件 &quot;data-file&quot; 首行.
read a2            # 读取文件 &quot;data-file&quot; 第二行

echo
echo &quot;Following lines read from file.&quot;
echo &quot;-------------------------------&quot;
echo $a1
echo $a2

echo; echo; echo

exec 0&lt;&amp;6 6&lt;&amp;-
#  现在在之前保存的位置将从文件描述符 #6 将 标准输出 恢复.
#+ 且关闭文件描述符 #6 ( 6&lt;&amp;- ) 让其他程序正常使用.
#
# &lt;&amp;6 6&lt;&amp;-    also works.

echo -n &quot;Enter data  &quot;
read b1  # 现在按预期的，从正常的标准输入 &quot;read&quot;.
echo &quot;Input read from stdin.&quot;
echo &quot;----------------------&quot;
echo &quot;b1 = $b1&quot;

echo

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>同理, <code>exec &gt;filename</code> 重定向 标准输出 到指定文件. 他将所有的命令输出通常是 标准输出 重定向到指定的位置.</p>
<p><code>exec N &gt; filename</code> 影响整个脚本或当前 shell。<a href="http://tldp.org/LDP/abs/html/special-chars.html#PROCESSIDREF" target="_blank" rel="noopener noreferrer">PID</a> 从重定向脚本或 shell 的那时候已经发生了改变. 然而 <code>N &gt; filename</code> 影响的就是新派生的进程，而不是整个脚本或 shell。</p>
<p>样例 20-2. 使用 exec 重定向标准输出</p>
<div><pre><code>#!/bin/bash
# reassign-stdout.sh

LOGFILE=logfile.txt

exec 6&gt;&amp;1           # 链接文件描述符 #6 到标准输出.
                    # 保存标准输出.

exec &gt; $LOGFILE     # 标准输出被文件 &quot;logfile.txt&quot; 替换.

# ----------------------------------------------------------- #
# 所有在这个块里的命令的输出都会发送到文件 $LOGFILE.

echo -n &quot;Logfile: &quot;
date
echo &quot;-------------------------------------&quot;
echo

echo &quot;Output of \&quot;ls -al\&quot; command&quot;
echo
ls -al
echo; echo
echo &quot;Output of \&quot;df\&quot; command&quot;
echo
df

# ----------------------------------------------------------- #

exec 1&gt;&amp;6 6&gt;&amp;-      # 关闭文件描述符 #6 恢复 标准输出.

echo
echo &quot;== stdout now restored to default == &quot;
echo
ls -al
echo

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>样例 20-3. 用 exec 在一个脚本里同时重定向 标准输入 和 标准输出</p>
<div><pre><code>#!/bin/bash
# upperconv.sh
# 转化指定的输入文件成大写.

E_FILE_ACCESS=70
E_WRONG_ARGS=71

if [ ! -r &quot;$1&quot; ]     # 指定的输入文件是否可读?
then
  echo &quot;Can&#39;t read from input file!&quot;
  echo &quot;Usage: $0 input-file output-file&quot;
  exit $E_FILE_ACCESS
fi                   #  同样的错误退出
                     #+ 等同如果输入文件 ($1) 未指定 (为什么?).

if [ -z &quot;$2&quot; ]
then
  echo &quot;Need to specify output file.&quot;
  echo &quot;Usage: $0 input-file output-file&quot;
  exit $E_WRONG_ARGS
fi


exec 4&lt;&amp;0
exec &lt; $1            # 将从输入文件读取.

exec 7&gt;&amp;1
exec &gt; $2            # 将写入输出文件.
                     # 假定输出文件可写 (增加检测?).

# -----------------------------------------------
    cat - | tr a-z A-Z   # 转化大写.
#   ^^^^^                # 读取标准输入.
#           ^^^^^^^^^^   # 写到标准输出.
# 然而标准输入和标准输出都会被重定向.
# 注意 &#39;cat&#39; 可能会被遗漏.
# -----------------------------------------------

exec 1&gt;&amp;7 7&gt;&amp;-       # 恢复标准输出.
exec 0&lt;&amp;4 4&lt;&amp;-       # 恢复标准输入.

# 恢复后, 下面这行会预期从标准输出打印.
echo &quot;File \&quot;$1\&quot; written to \&quot;$2\&quot; as uppercase conversion.&quot;

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>I/O 重定向是种明智的规避 <a href="http://tldp.org/LDP/abs/html/subshells.html#PARVIS" target="_blank" rel="noopener noreferrer">inaccessible variables within a subshell</a> 问题的方法.</p>
<p>样例 20-4. 规避子 shell</p>
<div><pre><code>#!/bin/bash
# avoid-subshell.sh
# Matthew Walker 的建议.

Lines=0

echo

cat myfile.txt | while read line;
                 do {
                   echo $line
                   (( Lines++ ));  #  递增变量的值趋近外层循环
                                   #  使用子 shell 会有问题.
                 }
                 done

echo &quot;Number of lines read = $Lines&quot;     # 0
                                         # 报错!

echo &quot;------------------------&quot;


exec 3&lt;&gt; myfile.txt
while read line &lt;&amp;3
do {
  echo &quot;$line&quot;
  (( Lines++ ));                   #  递增变量的值趋近外层循环.
                                   #  没有子 shell，就不会有问题.
}
done
exec 3&gt;&amp;-

echo &quot;Number of lines read = $Lines&quot;     # 8

echo

exit 0

# 下面的行并不在脚本里.

$ cat myfile.txt

Line 1.
Line 2.
Line 3.
Line 4.
Line 5.
Line 6.
Line 7.
Line 8.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">20.2 重定向代码块</title>
    <id>https://clay-wangzhi.com/code/shell/part5/20_2_redirecting_code_blocks/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/20_2_redirecting_code_blocks/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_20-2-重定向代码块"> 20.2 重定向代码块</h1>
<p>有如 <a href="http://tldp.org/LDP/abs/html/loops1.html#WHILELOOPREF" target="_blank" rel="noopener noreferrer">while</a>, <a href="http://tldp.org/LDP/abs/html/loops1.html#FORLOOPREF1" target="_blank" rel="noopener noreferrer">until</a>, 和 <a href="http://tldp.org/LDP/abs/html/loops1.html#UNTILLOOPREF" target="_blank" rel="noopener noreferrer">for</a> 循环, 甚至 <a href="http://tldp.org/LDP/abs/html/tests.html#IFTHEN" target="_blank" rel="noopener noreferrer">if/then</a> 也可以重定向 标准输入 测试代码块. 甚至连一个函数都可以用这个方法进行重定向 (见 <a href="http://tldp.org/LDP/abs/html/complexfunct.html#REALNAME" target="_blank" rel="noopener noreferrer">样例 24-11</a>).  代码块的末尾部分的 &quot;&lt;&quot; 就是用来完成这个的.</p>
<p>样例 20-5. while 循环的重定向</p>
<div><pre><code>#!/bin/bash
# redir2.sh

if [ -z &quot;$1&quot; ]
then
  Filename=names.data       # 如果不指定文件名的默认值.
else
  Filename=$1
fi  
#+ Filename=${1:-names.data}
#  can replace the above test (parameter substitution).

count=0

echo

while [ &quot;$name&quot; != Smith ]  # 为什么变量 &quot;$name&quot; 加引号?
do
  read name                 # 从 $Filename 读取值, 而不是 标准输入.
  echo $name
  let &quot;count += 1&quot;
done &lt;&quot;$Filename&quot;           # 重定向标准输入到文件 $Filename. 
#    ^^^^^^^^^^^^

echo; echo &quot;$count names read&quot;; echo

exit 0

#  注意在一些老的脚本语言中,
#+ 循环的重定向会跑在子 shell 的环境中.
#  因此, $count 返回 0, 在循环外已经初始化过值.
#  Bash 和 ksh *只要可能* 会避免启动子 shell ,
#+ 所以这个脚本作为样例运行成功.
#  (感谢 Heiner Steven 指出这点.)

#  然而 . . .
#  Bash 有时候 *能* 在 &quot;只读的 while&quot; 循环启动子进程 ,
#+ 不同于 &quot;while&quot; 循环的重定向.

abc=hi
echo -e &quot;1\n2\n3&quot; | while read l
     do abc=&quot;$l&quot;
        echo $abc
     done
echo $abc

#  感谢, Bruno de Oliveira Schneider 上面的演示代码.
#  也感谢 Brian Onn 纠正了注释的错误.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p>样例 20-6. 另一种形式的 while 循环重定向</p>
<div><pre><code>#!/bin/bash

# 这是之前的另一种形式的脚本.

#  Heiner Steven 提议在重定向循环时候运行在子 shell 可以作为一个变通方案
#+ 因此直到循环终止时循环内部的变量不需要保证他们的值


if [ -z &quot;$1&quot; ]
then
  Filename=names.data     # 如果不指定文件名的默认值.
else
  Filename=$1
fi  


exec 3&lt;&amp;0                 # 保存标准输入到文件描述符 3.
exec 0&lt;&quot;$Filename&quot;        # 重定向标准输入.

count=0
echo


while [ &quot;$name&quot; != Smith ]
do
  read name               # 从重定向的标准输入($Filename)读取值.
  echo $name
  let &quot;count += 1&quot;
done                      #  从 $Filename 循环读
                          #+ 因为第 20 行.

#  这个脚本的早期版本在 &quot;while&quot; 循环 done &lt;&quot;$Filename&quot; 终止
#  练习:
#  为什么这个没必要?


exec 0&lt;&amp;3                 # 恢复早前的标准输入.
exec 3&lt;&amp;-                 # 关闭临时的文件描述符 3.

echo; echo &quot;$count names read&quot;; echo

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>样例 20-7. until 循环的重定向</p>
<div><pre><code>#!/bin/bash
# 同先前的脚本一样, 不过用的是 &quot;until&quot; 循环.

if [ -z &quot;$1&quot; ]
then
  Filename=names.data         # 如果不指定文件的默认值.
else
  Filename=$1
fi  

# while [ &quot;$name&quot; != Smith ]
until [ &quot;$name&quot; = Smith ]     # 变  !=  为 =.
do
  read name                   # 从 $Filename 读取值, 而不是标准输入.
  echo $name
done &lt;&quot;$Filename&quot;             # 重定向标准输入到文件 &quot;$Filename&quot;. 
#    ^^^^^^^^^^^^

# 和之前的 &quot;while&quot; 循环样例相同的结果.

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>样例 20-8. for 循环的重定向</p>
<div><pre><code>
#!/bin/bash

if [ -z &quot;$1&quot; ]
then
  Filename=names.data          # 如果不指定文件的默认值.
else
  Filename=$1
fi  

line_count=`wc $Filename | awk &#39;{ print $1 }&#39;`
#           目标文件的行数.
#
#  非常作和不完善, 然而这只是证明 &quot;for&quot; 循环中的重定向标准输入是可行的
#+ 如果你足够聪明的话.
#
# 简介的做法是     line_count=$(wc -l &lt; &quot;$Filename&quot;)


for name in `seq $line_count`  # 回忆下 &quot;seq&quot; 可以输入数组序列.
# while [ &quot;$name&quot; != Smith ]   --   比 &quot;while&quot; 循环更复杂的循环   --
do
  read name                    # 从 $Filename 读取值, 而不是标准输入.
  echo $name
  if [ &quot;$name&quot; = Smith ]       # 这需要所有这些额外的设置.
  then
    break
  fi  
done &lt;&quot;$Filename&quot;              # 重定向标准输入到文件 &quot;$Filename&quot;. 
#    ^^^^^^^^^^^^

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>我们可以修改先前的样例也可以重定向循环的输出.</p>
<p>样例 20-9. for 循环的重定向 (同时重定向标准输入和标准输出)</p>
<div><pre><code>#!/bin/bash

if [ -z &quot;$1&quot; ]
then
  Filename=names.data          # 如果不指定文件的默认值.
else
  Filename=$1
fi  

Savefile=$Filename.new         # 报错的结果的文件名.
FinalName=Jonah                # 停止 &quot;read&quot; 的终止字符.

line_count=`wc $Filename | awk &#39;{ print $1 }&#39;`  # 目标文件行数.


for name in `seq $line_count`
do
  read name
  echo &quot;$name&quot;
  if [ &quot;$name&quot; = &quot;$FinalName&quot; ]
  then
    break
  fi  
done &lt; &quot;$Filename&quot; &gt; &quot;$Savefile&quot;     # 重定向标准输入到文件 $Filename,
#    ^^^^^^^^^^^^^^^^^^^^^^^^^^^       并且报错结果到备份文件.

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>样例 20-10. if/then test的重定向</p>
<div><pre><code>#!/bin/bash

if [ -z &quot;$1&quot; ]
then
  Filename=names.data   # 如果不指定文件的默认值.
else
  Filename=$1
fi  

TRUE=1

if [ &quot;$TRUE&quot; ]          # if true    和   if :   都可以工作.
then
 read name
 echo $name
fi &lt;&quot;$Filename&quot;
#  ^^^^^^^^^^^^

# 只读取文件的首行.
# &quot;if/then&quot; test 除非嵌入在循环内部否则没办法迭代.

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>样例 20-11. 上述样例的数据文件 names.data</p>
<div><pre><code>
Aristotle
Arrhenius
Belisarius
Capablanca
Dickens
Euler
Goethe
Hegel
Jonah
Laplace
Maroczy
Purcell
Schmidt
Schopenhauer
Semmelweiss
Smith
Steinmetz
Tukhashevsky
Turing
Venn
Warshawski
Znosko-Borowski

#+ 这是 &quot;redir2.sh&quot;, &quot;redir3.sh&quot;, &quot;redir4.sh&quot;, &quot;redir4a.sh&quot;, &quot;redir5.sh&quot; 的数据文件.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>代码块的标准输出的重定向影响了保存到文件的输出. 见样例 <a href="http://tldp.org/LDP/abs/html/special-chars.html#RPMCHECK" target="_blank" rel="noopener noreferrer">样例 3-2</a>.</p>
<p><a href="http://tldp.org/LDP/abs/html/here-docs.html#HEREDOCREF" target="_blank" rel="noopener noreferrer">嵌入文档</a> 是种特别的重定向代码块的方法. 既然如此,它使得在 while 循环的标准输入里传入嵌入文档的输出变得可能.</p>
<div><pre><code># 这个样例来自 Albert Siersema
# 得到了使用许可 (感谢!).

function doesOutput()
 # 当然这也是个外部命令.
 # 这里用函数进行演示会更好一点.
{
  ls -al *.jpg | awk &#39;{print $5,$9}&#39;
}


nr=0          #  我们希望在 &#39;while&#39; 循环里可以操作这些
totalSize=0   #+ 并且在 &#39;while&#39; 循环结束时看到改变.

while read fileSize fileName ; do
  echo &quot;$fileName is $fileSize bytes&quot;
  let nr++
  totalSize=$((totalSize+fileSize))   # Or: &quot;let totalSize+=fileSize&quot;
done&lt;&lt;EOF
$(doesOutput)
EOF

echo &quot;$nr files totaling $totalSize bytes&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">20.3 应用程序</title>
    <id>https://clay-wangzhi.com/code/shell/part5/20_3_applications/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/20_3_applications/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_20-3-应用程序"> 20.3 应用程序</h1>
<p>使用 I/O 重定向可以同时解析和固定命令输出的片段(see <a href="http://tldp.org/LDP/abs/html/internal.html#READREDIR" target="_blank" rel="noopener noreferrer">样例 15-7</a>). 这也使得可以生成报告和日志文件.</p>
<p>样例 20-12. 日志记录事件</p>
<div><pre><code>#!/bin/bash
# logevents.sh
# 作者: Stephane Chazelas.
# 用于 ABS 许可指南.

# 事件记录到文件.
# 必须 root 身份执行 (可以写入 /var/log).

ROOT_UID=0     # 只有 $UID 为 0 的用户具有 root 权限.
E_NOTROOT=67   # 非 root 会报错.


if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]
then
  echo &quot;Must be root to run this script.&quot;
  exit $E_NOTROOT
fi  


FD_DEBUG1=3
FD_DEBUG2=4
FD_DEBUG3=5

# === 取消下面两行注释来激活脚本. ===
# LOG_EVENTS=1
# LOG_VARS=1


log()  # 时间和日期写入日志文件.
{
echo &quot;$(date)  $*&quot; &gt;&amp;7     # *追加* 日期到文件.
#     ^^^^^^^  命令替换
                           # 见下文.
}



case $LOG_LEVEL in
 1) exec 3&gt;&amp;2         4&gt; /dev/null 5&gt; /dev/null;;
 2) exec 3&gt;&amp;2         4&gt;&amp;2         5&gt; /dev/null;;
 3) exec 3&gt;&amp;2         4&gt;&amp;2         5&gt;&amp;2;;
 *) exec 3&gt; /dev/null 4&gt; /dev/null 5&gt; /dev/null;;
esac

FD_LOGVARS=6
if [[ $LOG_VARS ]]
then exec 6&gt;&gt; /var/log/vars.log
else exec 6&gt; /dev/null                     # 清空输出.
fi

FD_LOGEVENTS=7
if [[ $LOG_EVENTS ]]
then
  # exec 7 &gt;(exec gawk &#39;{print strftime(), $0}&#39; &gt;&gt; /var/log/event.log)
  # 上述行在最近高于 bash 2.04 版本会失败，为什么?
  exec 7&gt;&gt; /var/log/event.log              # 追加到 &quot;event.log&quot;.
  log                                      # 写入时间和日期.
else exec 7&gt; /dev/null                     # 清空输出.
fi

echo &quot;DEBUG3: beginning&quot; &gt;&amp;${FD_DEBUG3}

ls -l &gt;&amp;5 2&gt;&amp;4                             # 命令1 &gt;&amp;5 2&gt;&amp;4

echo &quot;Done&quot;                                # 命令2 

echo &quot;sending mail&quot; &gt;&amp;${FD_LOGEVENTS}
# 输出信息 &quot;sending mail&quot; 到文件描述符 #7.


exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">20 I/O 重定向</title>
    <id>https://clay-wangzhi.com/code/shell/part5/20_io_redirection/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/20_io_redirection/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_20-i-o-重定向"> 20 I/O 重定向</h1>
<p>目录</p>
<ul>
<li><a href="http://tldp.org/LDP/abs/html/x17974.html" target="_blank" rel="noopener noreferrer">20.1 使用 exec</a></li>
<li><a href="http://tldp.org/LDP/abs/html/redircb.html" target="_blank" rel="noopener noreferrer">20.2 重定向代码块</a></li>
<li><a href="http://tldp.org/LDP/abs/html/redirapps.html" target="_blank" rel="noopener noreferrer">20.3 应用程序</a></li>
</ul>
<p>有三个默认打开的文件<a href="http://tldp.org/LDP/abs/html/io-redirection.html#FTN.AEN17884" target="_blank" rel="noopener noreferrer">[1]</a>, <code>stdin</code>(标准输入，键盘),<code>stdout</code>(标准输出， 屏幕)和 <code>stderr</code>(标准错误，屏幕上输出的错误信息)。这些和任何其他打开的文件都可以被重定向。重定向仅仅意味着捕获输出文件，命令，脚本，甚至是一个脚本的代码块(<a href="http://tldp.org/LDP/abs/html/special-chars.html#EX8" target="_blank" rel="noopener noreferrer">样例 3-1</a>)和(<a href="http://tldp.org/LDP/abs/html/special-chars.html#EX8" target="_blank" rel="noopener noreferrer">样例 3-2</a>) 作为另一个文件，命令，程序或脚本的输入。</p>
<p>每个打开的文件都有特定的文件描述符。<a href="http://tldp.org/LDP/abs/html/io-redirection.html#FTN.AEN17894" target="_blank" rel="noopener noreferrer">[2]</a>,而 <code>stdin</code>，<code>stdout</code>，<code>stderr</code> 的文件描述符分别为 0,1,2。当然了，还有附件的文件描述符 3 - 9。有时候为<code>stdin</code>，<code>stdout</code>，<code>stderr</code>临时性的复制链接分配这些附加的文件描述符会非常有用.<a href="http://tldp.org/LDP/abs/html/io-redirection.html#FTN.AEN17906" target="_blank" rel="noopener noreferrer">[3]</a>。这简化了复杂重定向和重组后的恢复(见<a href="http://tldp.org/LDP/abs/html/x17974.html#REDIR1" target="_blank" rel="noopener noreferrer">样例 20-1</a>)</p>
<div><pre><code>   COMMAND_OUTPUT &gt;
      # 重定向标准输出到一个文件.
      # 如果文件不存在则创建，否则覆盖.

      ls -lR &gt; dir-tree.list
      # 创建了一个包含目录树列表的文件.

   : &gt; filename
      # &quot;&gt;&quot; 清空了文件.
      # 如果文件不存在，则创建了个空文件 (效果类似 &#39;touch&#39;).
      # &quot;:&quot; 是个虚拟占位符, 不会有输出.

   &gt; filename    
      # &quot;&gt;&quot; 清空了文件.
      # 如果文件不存在，则创建了个空文件 (效果类似 &#39;touch&#39;).
      # (结果和上述的 &quot;: &gt;&quot; 一样， 但在某些 shell 环境中不能正常运行.)

   COMMAND_OUTPUT &gt;&gt;
      # 重定向标准输出到一个文件.
      # 如果文件不存在则创建，否则新内容在文件末尾追加.


      # 单行重定向命令 (只作用于本身所在的那行):
      # --------------------------------------------------------------------

   1&gt;filename
      # 以覆盖的方式将 标准错误 重定向到文件 &quot;filename.&quot;
   1&gt;&gt;filename
      # 以追加的方式将 标准输出 重定向到文件 &quot;filename.&quot;
   2&gt;filename
      # 以覆盖的方式将 标准错误 重定向到文件 &quot;filename.&quot;
   2&gt;&gt;filename
      # 以追加的方式将 标准错误 重定向到文件 &quot;filename.&quot;
   &amp;&gt;filename
      # 以覆盖的方式将 标准错误 和 标准输出 同时重定向到文件 &quot;filename.&quot;
      # 在 bash 4 中才有这个新功能.

   M&gt;N
     # &quot;M&quot; 是个文件描述符, 如果不明确指定，默认为 1.
     # &quot;N&quot; 是个文件名.
     # 文件描述符 &quot;M&quot; 重定向到文件 &quot;N.&quot;
   M&gt;&amp;N
     # &quot;M&quot; 是个文件描述符, 如果不设置默认为 1.
     # &quot;N&quot; 是另一个文件描述符.

      #==============================================================================

      # 重定向 标准输出，一次一行.
      LOGFILE=script.log

      echo &quot;This statement is sent to the log file, \&quot;$LOGFILE\&quot;.&quot; 1&gt;$LOGFILE
      echo &quot;This statement is appended to \&quot;$LOGFILE\&quot;.&quot; 1&gt;&gt;$LOGFILE
      echo &quot;This statement is also appended to \&quot;$LOGFILE\&quot;.&quot; 1&gt;&gt;$LOGFILE
      echo &quot;This statement is echoed to stdout, and will not appear in \&quot;$LOGFILE\&quot;.&quot;
      # 这些重定向命令在每行结束后自动&quot;重置&quot;.



      # 重定向 标准错误，一次一行.
      ERRORFILE=script.errors

      bad_command1 2&gt;$ERRORFILE       #  Error message sent to $ERRORFILE.
      bad_command2 2&gt;&gt;$ERRORFILE      #  Error message appended to $ERRORFILE.
      bad_command3                    #  Error message echoed to stderr,
                                      #+ and does not appear in $ERRORFILE.
      # 这些重定向命令每行结束后会自动“重置”.
	#=======================================================================
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><div><pre><code>   2&gt;&amp;1
      # 重定向 标准错误 到 标准输出.
      # 错误信息发送到标准输出相同的位置.
        &gt;&gt;filename 2&gt;&amp;1
            bad_command &gt;&gt;filename 2&gt;&amp;1
            # 同时将 标准输出 和 标准错误 追加到文件 &quot;filename&quot; 中 ...
        2&gt;&amp;1 | [command(s)]
            bad_command 2&gt;&amp;1 | awk &#39;{print $5}&#39;   # found
            # 通过管道传递 标准错误.
            # bash 4 中可以将 &quot;2&gt;&amp;1 |&quot; 缩写为 &quot;|&amp;&quot;.

   i&gt;&amp;j
      # 重定向文件描述符 i 到 j.
      # 文件描述符 i 指向的文件输出将会重定向到文件描述符 j 指向的文件

   &gt;&amp;j
      # 默认的标准输出 (stdout) 重定向到 j.
      # 所有的标准输出将会重定向到 j 指向的文件.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code>   0&lt; FILENAME
    &lt; FILENAME
      # 从文件接收输入.
      # 类似功能命令是 &quot;&gt;&quot;, 经常会组合使用.
      #
      # grep search-word &lt;filename


   [j]&lt;&gt;filename
      #  打开并读写文件 &quot;filename&quot; ,
      #+ 并且分配文件描述符 &quot;j&quot;.
      #  如果 &quot;filename&quot; 不存在则创建.
      #  如果文件描述符 &quot;j&quot; 未指定, 默认分配文件描述符 0, 标准输入.
      #
      #  这是一个写指定文件位置的应用程序. 
      echo 1234567890 &gt; File    # 写字符串到 &quot;File&quot;.
      exec 3&lt;&gt; File             # 打开并分配文件描述符 3 给 &quot;File&quot; .
      read -n 4 &lt;&amp;3             # 读取 4 字符.
      echo -n . &gt;&amp;3             # 写一个小数点.
      exec 3&gt;&amp;-                 # 关闭文件描述符 3.
      cat File                  # ==&gt; 1234.67890
      #  随机访问.



   |
      # 管道.
      # 一般是命令和进程的链接工具.
      # 类似 &quot;&gt;&quot;, 但更一般.
      # 在连接命令，脚本，文件和程序方面非常有用.
      cat *.txt | sort | uniq &gt; result-file
      # 所有 .txt 文件输出进行排序并且删除复制行,
      # 最终保存结果到 &quot;result-file&quot;.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>可以用单个命令行表示输入和输出的多个重定向或管道.</p>
<div><pre><code>command &lt; input-file &gt; output-file
# 或者等价:
&lt; input-file command &gt; output-file   # 尽管这不标准.

command1 | command2 | command3 &gt; output-file
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>更多详情见<a href="http://tldp.org/LDP/abs/html/filearchiv.html#DERPM" target="_blank" rel="noopener noreferrer">样例 16-31</a> and <a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#FIFO" target="_blank" rel="noopener noreferrer">样例 A-14</a>.</p>
<p>多个输出流可以重定向到一个文件.</p>
<div><pre><code>ls -yz &gt;&gt; command.log 2&gt;&amp;1
#  捕获不合法选项 &quot;yz&quot; 的结果到文件 &quot;command.log.&quot;
#  因为 标准错误输出 被重定向到了文件,
#+ 任何错误信息都会在这.

#  注意, 然而, 接下来的这个案例并 &quot;不能&quot; 同样的结果.
ls -yz 2&gt;&amp;1 &gt;&gt; command.log
#  输出一条错误信息，但是不会写入到文件.
#  恰恰的, 命令输出(这个例子里为空)写入到文件, 但错误信息只会在 标准输出 输出.

#  如果同时重定向 标准输出 和 标准错误输出,
#+ 命令的顺序不同会导致不同.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>关闭文件描述符</p>
<div><pre><code>n&lt;&amp;-
	关闭输入文件描述符 n.

0&lt;&amp;-, &lt;&amp;-
	关闭标准输入.

n&gt;&amp;-
	关闭输出文件描述符 n.

1&gt;&amp;-, &gt;&amp;-
	关闭标准输出.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>子进程能继承文件描述符.这就是管道符能工作的原因.通过关闭文件描述符来防止继承 .</p>
<div><pre><code># 只重定向到 标准错误 到管道.

exec 3&gt;&amp;1                              # 保存当前 标准输出 &quot;值&quot;.

ls -l 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | grep bad 3&gt;&amp;-    # 关闭 &#39;grep&#39; 文件描述符 3 (但不是 &#39;ls&#39;).
#              ^^^^   ^^^^
exec 3&gt;&amp;-                              # 现在关闭它.

# 感谢, S.C.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>更多关于 I/O 重定向详情见 <a href="http://tldp.org/LDP/abs/html/ioredirintro.html" target="_blank" rel="noopener noreferrer">Appendix F</a>.</p>
<h4 id="注意"> 注意</h4>
<p><a href="http://tldp.org/LDP/abs/html/io-redirection.html#AEN17884" target="_blank" rel="noopener noreferrer">[1]</a>	 在 UNIX 和 Linux 中, 数据流和周边外设(<a href="http://tldp.org/LDP/abs/html/devref1.html#DEVFILEREF" target="_blank" rel="noopener noreferrer">device files</a>) 都被看做文件.</p>
<p><a href="http://tldp.org/LDP/abs/html/io-redirection.html#AEN17894" target="_blank" rel="noopener noreferrer">[2]</a>	 <code>文件描述符</code> 仅仅是操作系统分配的一个可追踪的打开的文件号. 可以认为是一个简化的文件指针. 类似于 C 语言的 <code>文件句柄</code>.</p>
<p><a href="http://tldp.org/LDP/abs/html/io-redirection.html#AEN17906" target="_blank" rel="noopener noreferrer">[3]</a>	当 bash 创建一个子进程的时候使用 <code>文件描述符 5</code> 会有问题. 例如 <a href="http://tldp.org/LDP/abs/html/internal.html#EXECREF" target="_blank" rel="noopener noreferrer">exec</a>, 子进程继承了文件描述符 5 (详情见 Chet Ramey's 归档的 e-mail, <a href="https://groups.google.com/forum/#!topic/gnu.bash.bug/E5Vdqv3tO1w" target="_blank" rel="noopener noreferrer">SUBJECT: RE: File descriptor 5 is held open</a>). 最好将这个文件描述符单独规避.</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第二十一章 子shell</title>
    <id>https://clay-wangzhi.com/code/shell/part5/21_subshells/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/21_subshells/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第二十一章-子shell"> 第二十一章 子shell</h1>
<p>运行一个shell脚本会启动一个新的进程，即<em>子shell</em>。</p>
<p><strong>定义</strong>： 一个<em>子shell</em>是由一个shell（或<em>shell脚本</em>）触发的<a href="http://tldp.org/LDP/abs/html/othertypesv.html#CHILDREF2" target="_blank" rel="noopener noreferrer">子进程</a>。</p>
<p>一个子shell是命令处理器（-- 在终端或者<em>xtrem</em>窗口给出提示符的<em>shell</em>）的一个独立的例子。正如你的命令在命令行提示符处被理解执行一样，一个脚本<a href="http://tldp.org/LDP/abs/html/timedate.html#BATCHPROCREF" target="_blank" rel="noopener noreferrer">批处理</a>一组命令。每一个shell脚本运行实际上是<a href="http://tldp.org/LDP/abs/html/internal.html#FORKREF" target="_blank" rel="noopener noreferrer">父</a>shell的一个支线进程（<em>子进程</em>）。</p>
<p>一个shell脚本可以自己启动多个子进程。这些子进程使得脚本进行并行处理，实际上是多个支线任务同事进行。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># subshell-test.sh</span>

<span>(</span>
<span># 在圆括号内，因此是一个子shell . . .</span>
<span>while</span> <span>[</span> <span>1</span> <span>]</span>   <span># 无限循环.</span>
<span>do</span>
  <span>echo</span> <span>"Subshell running . . ."</span>
<span>done</span>
<span>)</span>

<span>#  脚本会永远运行，或者至少直到由Ctl-C终止。</span>

<span>exit</span> <span>$?</span>  <span># 脚本结束 （但是永远无法到达这里）。</span>



现在，运行这个脚本：
<span>sh</span> subshell-test.sh

另外，在脚本运行的同时， 从另一个xterm运行：
<span>ps</span> -ef <span>|</span> <span>grep</span> subshell-test.sh

<span>UID</span>       PID   <span>PPID</span>  C STIME TTY      TIME     CMD
<span>500</span>       <span>2698</span>  <span>2502</span>  <span>0</span> <span>14</span>:26 pts/4    00:00:00 <span>sh</span> subshell-test.sh
<span>500</span>       <span>2699</span>  <span>2698</span> <span>21</span> <span>14</span>:26 pts/4    00:00:24 <span>sh</span> subshell-test.sh

          ^^^^

分析：
PID <span>2698</span>, 脚本, 启动 PID <span>2699</span>, 子shell.

注释: “<span>UID</span> <span>..</span>.”这一列可以通过“grep”命令筛去，但是由于说明的目的而显示在这里。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>一般来说，脚本的一个<a href="http://tldp.org/LDP/abs/html/external.html#EXTERNALREF" target="_blank" rel="noopener noreferrer">外部命令</a>会使得子进程产生<a href="http://tldp.org/LDP/abs/html/internal.html#FORKREF" target="_blank" rel="noopener noreferrer">分叉</a>，[^1] 但是一个Bash内建命令不会如此。</p>
<p><strong>在圆括号内的命令列</strong></p>
<p>(命令1; 命令1; 命令3; ...)</p>
<div><pre><code>放在圆括号内的一列命令作为子shell运行。
</code></pre>
</div><p>子shell的变量<em>不能</em>被这个子shell内代码区块之外的部分看见。这些变量不能被<a href="http://tldp.org/LDP/abs/html/internal.html#FORKREF" target="_blank" rel="noopener noreferrer">父进程</a>中调用，也不能被启动次子shell的shell调用。这些变量实际上是<em>子进程</em>的<a href="http://tldp.org/LDP/abs/html/localvar.html#LOCALREF" target="_blank" rel="noopener noreferrer">局部变量</a>。</p>
<p><strong>例21-1.子shell的变量范围</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span># subshell.sh</span>

<span>echo</span>

<span>echo</span> <span>"We are outside the subshell."</span>
<span>echo</span> <span>"Subshell level OUTSIDE subshell = <span>$BASH_SUBSHELL</span>"</span>
<span># Bash, 版本3，增加新变量                 $BASH_SUBSHELL 。</span>
<span>echo</span><span>;</span> <span>echo</span>

<span>outer_variable</span><span>=</span>Outer
<span>global_variable</span><span>=</span>
<span>#  定义全局变量来”存储“子shell变量值。</span>

<span>(</span>
<span>echo</span> <span>"We are inside the subshell."</span>
<span>echo</span> <span>"Subshell level INSIDE subshell = <span>$BASH_SUBSHELL</span>"</span>
<span>inner_variable</span><span>=</span>Inner

<span>echo</span> <span>"From inside subshell, <span title="\&quot;">\"</span>inner_variable<span title="\&quot;">\"</span> = <span>$inner_variable</span>"</span>
<span>echo</span> <span>"From inside subshell, <span title="\&quot;">\"</span>outer<span title="\&quot;">\"</span> = <span>$outer_variable</span>"</span>

<span>global_variable</span><span>=</span><span>"<span>$inner_variable</span>"</span>   <span>#  这会允许”输出“ 一个子shell变量吗？</span>
<span>)</span>

<span>echo</span><span>;</span> <span>echo</span>
<span>echo</span> <span>"We are outside the subshell."</span>
<span>echo</span> <span>"Subshell level OUTSIDE subshell = <span>$BASH_SUBSHELL</span>"</span>
<span>echo</span>

<span>if</span> <span>[</span> -z <span>"<span>$inner_variable</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"inner_variable undefined in main body of shell"</span>
<span>else</span>
  <span>echo</span> <span>"inner_variable defined in main body of shell"</span>
<span>fi</span>

<span>echo</span> <span>"From main body of shell, <span title="\&quot;">\"</span>inner_variable<span title="\&quot;">\"</span> = <span>$inner_variable</span>"</span>
<span>#  $inner_variable 会显示为空白 （未初始化） </span>
<span>#+ 因为定义在子shell的变量是“局部变量”。</span>
<span>#  有办法改正这一点吗？</span>
<span>echo</span> <span>"global_variable = "</span><span>$global_variable</span><span>""</span>  <span># 为什么这不行？</span>

<span>echo</span>

<span># =======================================================================</span>

<span># 另外 ...</span>

<span>echo</span> <span>"-----------------"</span><span>;</span> <span>echo</span>

<span>var</span><span>=</span><span>41</span>                                                 <span># 全局变量。</span>

<span>(</span> <span>let</span> <span>"var+=1"</span><span>;</span> <span>echo</span> <span>"\<span>$var</span> INSIDE subshell = <span>$var</span>"</span> <span>)</span>  <span># 42</span>

<span>echo</span> <span>"\<span>$var</span> OUTSIDE subshell = <span>$var</span>"</span>                   <span># 41</span>
<span># 子shell内的变量操作，即使是对全局变量，不影响变量在子shell外的值！</span>


<span>exit</span> <span>0</span>

<span>#  问题：</span>
<span>#  --------</span>
<span>#  一旦执行一个子shell，</span>
<span>#+ 是否有办法再次进入这个子shell以便修改或调用子shell的变量？ </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><p>同样参看 <a href="http://tldp.org/LDP/abs/html/internalvariables.html#BASHPIDREF" target="_blank" rel="noopener noreferrer">$BASHPID</a> 和 <a href="http://tldp.org/LDP/abs/html/gotchas.html#SUBPIT" target="_blank" rel="noopener noreferrer">例34-2</a>。</p>
<p><strong>定义</strong>： 变量的<em>范围</em>是指其有意义的上下文内容，在此变量<em>值</em>可以被引用。比如说，<a href="http://tldp.org/LDP/abs/html/localvar.html#LOCALREF1" target="_blank" rel="noopener noreferrer">局部变量</a>的范围只在函数、代码区块或子shell内的相应定义范围内，而<em>全局</em>变量的范围则是其出现的整个脚本区域。</p>
<p>内部变量 <a href="http://tldp.org/LDP/abs/html/internalvariables.html#BASHSUBSHELLREF" target="_blank" rel="noopener noreferrer">$BASH_SUBSHELL</a> 指出一个子shell的嵌套层级时，而变量 <a href="http://tldp.org/LDP/abs/html/internalvariables.html#SHLVLREF" target="_blank" rel="noopener noreferrer">$SHLVL</a> 指示在子shell内<em>不变</em>的层级。</p>
<div><pre><code><span>echo</span> <span>" \<span>$BASH_SUBSHELL</span> outside subshell       = <span>$BASH_SUBSHELL</span>"</span>           <span># 0</span>
  <span>(</span> <span>echo</span> <span>" \<span>$BASH_SUBSHELL</span> inside subshell        = <span>$BASH_SUBSHELL</span>"</span> <span>)</span>     <span># 1</span>
  <span>(</span> <span>(</span> <span>echo</span> <span>" \<span>$BASH_SUBSHELL</span> inside nested subshell = <span>$BASH_SUBSHELL</span>"</span> <span>)</span> <span>)</span> <span># 2</span>
<span># ^ ^                          ***  嵌套   ***                        ^ ^</span>

<span>echo</span>

<span>echo</span> <span>" \<span>$SHLVL</span> outside subshell = <span>$SHLVL</span>"</span>       <span># 3</span>
<span>(</span> <span>echo</span> <span>" \<span>$SHLVL</span> inside subshell  = <span>$SHLVL</span>"</span> <span>)</span>   <span># 3 (不变！)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>子shell内的路径改变不会带入到父shell中。</p>
<p><strong>例21-2. 列出用户信息</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span># allprofs.sh: 打印所有用户信息.</span>

<span># 此脚本作者 Heiner Steven，由文件作者修改。</span>

<span>FILE</span><span>=</span>.bashrc  <span>#  包含用户信息的文件是".profile"的原始脚本。</span>

<span>for</span> <span>home</span> <span>in</span> <span><span>`</span><span>awk</span> -F: <span>'{print <span>$6</span>}'</span> /etc/passwd<span>`</span></span>
<span>do</span>
  <span>[</span> -d <span>"<span>$home</span>"</span> <span>]</span> <span>||</span> <span>continue</span>    <span># 如果没有home目录，到下一个。</span>
  <span>[</span> -r <span>"<span>$home</span>"</span> <span>]</span> <span>||</span> <span>continue</span>    <span># 如果没有读取权限，到下一个。</span>
  <span>(</span>cd <span>$home</span><span>;</span> <span>[</span> -e <span>$FILE</span> <span>]</span> <span>&amp;&amp;</span> <span>less</span> <span>$FILE</span><span>)</span>
<span>done</span>

<span># 脚本终止时， 不需要使用命令'cd'回到初始目录，因为'cd $home'只在子shell发生。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>一个子shell可以用来为一个命令组设定一个“特定环境”。</p>
<div><pre><code>命令1
命令2
命令3
<span>(</span>
  <span><span>IFS</span></span><span>=</span>:
  <span><span>PATH</span></span><span>=</span>/bin
  <span>unset</span> TERMINFO
  <span>set</span> -C
  <span>shift</span> <span>5</span>
  命令4
  命令5
  <span>exit</span> <span>3</span> <span># 只退出子shell！</span>
<span>)</span>
<span># 父shell不受影响， 且环境保留。</span>
命令6
命令7
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>从这里可以看出，命令 <a href="http://tldp.org/LDP/abs/html/internal.html#EXITREF" target="_blank" rel="noopener noreferrer">exit</a> 只终止正在运行的子shell，并不终止父shell或脚本。</p>
<p>这样的“特定环境”的一个应用是检查一个变量是否被定义。</p>
<div><pre><code><span>if</span> <span>(</span>set -u<span>;</span> <span>:</span> <span>$variable</span><span>)</span> <span><span>2</span>></span> /dev/null
<span>then</span>
  <span>echo</span> <span>"Variable is set."</span>
<span>fi</span>     <span>#  变量已在当前脚本被设定， </span>
       <span>#+ 或者变量是一个Bash内部变量，</span>
       <span>#+ 或者变量在环境变量中（在export命令后）。</span>

<span># 也可以写成  [[ ${variable-x} != x || ${variable-y} != y ]]</span>
<span># 或者       [[ ${variable-x} != x$variable ]]</span>
<span># 或者       [[ ${variable+x} = x ]]</span>
<span># 或者       [[ ${variable-x} != x ]]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>另一个应用是检查一个锁定文件。</p>
<div><pre><code><span>if</span> <span>(</span>set -C<span>;</span> <span>:</span> <span>></span> lock_file<span>)</span> <span><span>2</span>></span> /dev/null
<span>then</span>
  <span>:</span>   <span># lock_file不存在：没有用户运行此脚本</span>
<span>else</span>
  <span>echo</span> <span>"Another user is already running that script."</span>
<span>exit</span> <span>65</span>
<span>fi</span>

<span>#  代码段作者 Stéphane Chazelas,</span>
<span>#+ 修改者 Paulo Marcel Coelho Aragao。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li></li>
</ul>
<p>多个进程可以在不同子shell内并行执行。这样就可以将一个复杂的任务分解成多个子部分同时处理。</p>
<p><strong>例21-3. 在子shell中运行并行进程</strong></p>
<div><pre><code>	<span>(</span>cat list1 list2 list3 <span>|</span> <span>sort</span> <span>|</span> <span>uniq</span> <span>></span> list123<span>)</span> <span>&amp;</span>
	<span>(</span>cat list4 list5 list6 <span>|</span> <span>sort</span> <span>|</span> <span>uniq</span> <span>></span> list456<span>)</span> <span>&amp;</span>
	<span># 同时合并和排列两组列表。</span>
	<span># 在后台运行以确保并行执行。</span>
	<span>#</span>
	<span># 同样效果如下</span>
	<span>#   cat list1 list2 list3 | sort | uniq > list123 &amp;</span>
	<span>#   cat list4 list5 list6 | sort | uniq > list456 &amp;</span>
	
	<span>wait</span>   <span># 在子shell结束前不执行之后命令。</span>
	
	<span>diff</span> list123 list456
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>向子shell的I/O重定向使用管道算符&quot;|&quot;，正如 ls -al | (命令)</p>
<p>在花括号间的代码块不会启动一个子shell。</p>
<p>{ 命令1； 命令2； 命令3； ...命令N； }</p>
<div><pre><code><span>var1</span><span>=</span><span>23</span>
<span>echo</span> <span>"<span>$var1</span>"</span>   <span># 23</span>

<span>{</span> <span>var1</span><span>=</span><span>76</span><span>;</span> <span>}</span>
<span>echo</span> <span>"<span>$var1</span>"</span>   <span># 76</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="notes"> <strong>Notes</strong></h3>
<p>[^1] 和 <a href="http://tldp.org/LDP/abs/html/internal.html#EXECREF" target="_blank" rel="noopener noreferrer">exec</a> 命令一起触发的外部命令（通常）不会分叉一个子进程 / 子shell</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第二十二章. 限制模式的Shell</title>
    <id>https://clay-wangzhi.com/code/shell/part5/22_Restricted_Shells/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/22_Restricted_Shells/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第二十二章-限制模式的shell"> 第二十二章. 限制模式的Shell</h1>
<h4 id="限制模式下被禁用的命令"> 限制模式下被禁用的命令</h4>
<ul>
<li>在限制模式下运行一个脚本或部分脚本将禁用一些命令，尽管这些命令在正常模式下是可用的。这是个安全措施，可以限制脚本用户的权限，减少运行脚本可能带来的损害。</li>
</ul>
<p>被禁用的命令和功能：</p>
<ul>
<li>使用 <em>cd</em> 来改变工作目录。</li>
<li>修改 <em><span class='katex-error' title='ParseError: KaTeX parse error: Double subscript at position 8: PATH_, _̲'>PATH_, _</span>SHELL</em>, *<span class='katex-error' title='ParseError: KaTeX parse error: Expected group after &#039;_&#039; at position 13: BASH_ENV* 或 _̲'>BASH_ENV* 或 _</span>ENV_ 等<a href="http://tldp.org/LDP/abs/html/othertypesv.html#ENVREF" target="_blank" rel="noopener noreferrer">环境变量</a></li>
<li>读取或修改 <em>$SHELLOPTS</em>，shell环境选项。</li>
<li>输出重定向。</li>
<li>调用包含 / 的命令。</li>
<li>调用 <a href="http://tldp.org/LDP/abs/html/internal.html#EXECREF" target="_blank" rel="noopener noreferrer">exec</a> 来替代shell进程。</li>
<li>其他各种会造成混乱或颠覆脚本用途的命令。</li>
<li>在脚本中跳出限制模式。</li>
</ul>
<h4 id="例-22-1-在限制模式运行脚本"> 例 22-1. 在限制模式运行脚本</h4>
<div><pre><code>#!/bin/bash

#  在脚本开头用&quot;#!/bin/bash -r&quot;
#+ 可以让整个脚本在限制模式运行。

echo

echo &quot;改变目录。&quot;
cd /usr/local
echo &quot;现在是在 `pwd`&quot;
echo &quot;回到家目录。&quot;
cd
echo &quot;现在是在 `pwd`&quot;
echo

# 到此为止一切都是正常的，非限制模式。

set -r
# set --restricted 效果相同。
echo &quot;==&gt; 现在是限制模式 &lt;==&quot;

echo
echo

echo &quot;在限制模式试图改变目录。&quot;
cd ..
echo &quot;依旧在 `pwd`&quot;

echo
echo

echo &quot;\$SHELL = $SHELL&quot;
echo &quot;试图在限制模式改变Shell 。&quot;
SHELL=&quot;/bin/ash&quot;
echo
echo &quot;\$SHELL= $SHELL&quot;

echo
echo

echo &quot;试图在限制模式重定向输出内容。&quot;
ls -l /usr/bin &gt; bin.files
ls -l bin.files    # 尝试列出试图创建的文件。

echo

exit 0

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第二十三章. 进程替换</title>
    <id>https://clay-wangzhi.com/code/shell/part5/23_Process_Substitution/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/23_Process_Substitution/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第二十三章-进程替换"> 第二十三章. 进程替换</h1>
<p>用<a href="http://tldp.org/LDP/abs/html/special-chars.html#PIPEREF" target="_blank" rel="noopener noreferrer">管道</a> 将一个命令的 <code>标准输出</code> 输送到另一个命令的 <code>标准输入</code> 是个强大的技术。但是如果你需要用管道输送_多个_命令的 <code>标准输出</code> 怎么办？这时候 <em>进程替换</em> 就派上用场了。</p>
<p><em>进程替换</em> 把一个（或多个）<a href="http://tldp.org/LDP/abs/html/special-chars.html#PROCESSREF" target="_blank" rel="noopener noreferrer">进程</a> 的输出送到另一个进程的 <code>标准输入</code>。</p>
<p><strong>样板</strong>
命令列表要用括号括起来</p>
<div><pre><code>&gt;(command_list)
&lt;(command_list)
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>进程替换使用 <code>/dev/fd/&lt;n&gt;</code> 文件发送括号内进程的结果到另一个进程。[1]</p>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif">&quot;&lt;&quot;或&quot;&gt;&quot;与括号之间没有空格，加上空格或报错。</p>
<div><pre><code>bash$ echo &gt;(true)
/dev/fd/63

bash$ echo &lt;(true)
/dev/fd/63

bash$ echo &gt;(true) &lt;(true)
/dev/fd/63 /dev/fd/62

bash$ wc &lt;(cat /usr/share/dict/linux.words)
 483523  483523 4992010 /dev/fd/63

bash$ grep script /usr/share/dict/linux.words | wc
    262     262    3601

bash$ wc &lt;(grep script /usr/share/dict/linux.words)
    262     262    3601 /dev/fd/63
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/note.gif">Bash用两个文件描述符创建管道，<code>--fIn 和 fOut--</code> 。<a href="http://tldp.org/LDP/abs/html/internal.html#TRUEREF" target="_blank" rel="noopener noreferrer">true</a> 的<code>标准输入</code>连接 fOut(dup2(fOut, 0))，然后Bash 传递一个 <code>/dev/fd/fIn</code> 参数给 <strong>echo</strong> 。在不使用 <code>/dev/fd/&lt;n&gt;</code> 的系统里，Bash可以用临时文件（感谢 S.C. 指出这点）。</p>
<p>进程替换可以比较两个不同命令的输出，或者同一个命令使用不同选项的输出。</p>
<div><pre><code>bash$ comm &lt;(ls -l) &lt;(ls -al)
total 12
-rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
-rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
-rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh
        total 20
        drwxrwxrwx    2 bozo bozo     4096 Mar 10 18:10 .
        drwx------   72 bozo bozo     4096 Mar 10 17:58 ..
        -rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
        -rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
        -rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>进程替换可以比较两个目录的内容——来检查哪些文件在这个目录而不在那个目录。</p>
<div><pre><code>diff &lt;(ls $first_directory) &lt;(ls $second_directory)
</code></pre>
<div><span>1</span><br></div></div><p>进程替换的一些其他用法：</p>
<div><pre><code>read -a list &lt; &lt;( od -Ad -w24 -t u2 /dev/urandom )
#  从 /dev/urandom 读取一个随机数列表
#+ 用 &quot;od&quot; 处理
#+ 输送到 &quot;read&quot; 的标准输入. . .
#  来自 &quot;insertion-sort.bash&quot; 示例脚本。
#  致谢：JuanJo Ciarlante。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code>PORT=6881   # bittorrent（BT端口）

#  扫描端口，确保没有恶意行为
netcat -l $PORT | tee&gt;(md5sum -&gt;mydata-orig.md5) |
gzip | tee&gt;(md5sum - | sed &#39;s/-$/mydata.lz2/&#39;&gt;mydata-gz.md5)&gt;mydata.gz

#  检查解压缩结果：
  gzip -d&lt;mydata.gz | md5sum -c mydata-orig.md5)
#  对原件的MD5校验用来检查标准输入，并且探测压缩当中出现的问题。

#  Bill Davidsen 贡献了这个例子
#+ （ABS指南作者做了轻微修改）。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code>cat &lt;(ls -l)
# 等价于	ls -l | cat

sort -k 9 &lt;(ls -l /bin) &lt;(ls -l /usr/bin) &lt;(ls -l /usr/X11R6/bin)
#  列出 3 个主要 &#39;bin&#39; 目录的文件，按照文件名排序。
#  注意，有三个（数一下）单独的命令输送给了 &#39;sort&#39;。

diff &lt;(command1) &lt;(command2)    # 比较命令输出结果的不同之处。

tar cf &gt;(bzip2 -c &gt; file.tar.bz2) $directory_name

#  调用 &quot;tar cf /dev/fd/?? $directory_name&quot;，然后 &quot;bzip2 -c &gt; file.tar.bz2&quot;。
#
#  因为 /dev/fd/&lt;n&gt; 系统特性
#  不需要在两个命令之间使用管道符
#
#  这个可以模拟
#
bzip2 -c &lt; pipe &gt; file.tar.bz2&amp;
tar cf pipe $directory_name
rm pipe
#	或者
exec 3&gt;&amp;1
tar cf /dev/fd/4 $directory_name 4&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | bzip2 -c &gt; file.tar.bz2 3&gt;&amp;-
exec 3&gt;&amp;-

# 致谢：Stéphane Chazelas
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>在子shell中 <a href="http://tldp.org/LDP/abs/html/gotchas.html#BADREAD0" target="_blank" rel="noopener noreferrer">echo 命令用管道输送给 while-read 循环</a>时会出现问题，下面是避免的方法：</p>
<p><strong>例23-1 不用 fork 的代码块重定向。</strong></p>
<div><pre><code>#!/bin/bash

#  wr-ps.bash: 使用进程替换的 while-read 循环。

#  示例由 Tomas Pospisek 贡献。
# （ABS指南作者做了大量改动。）

echo

echo &quot;random input&quot; | while read i
do
  global=3D&quot;: Not available outside the loop.&quot;
  # ... 因为在子 shell 中运行。
done

echo &quot;\$global (从子进程之外) = $global&quot;
# $global (从子进程之外) =

echo; echo &quot;--&quot;; echo

while read i
do
  echo $i
  global=3D&quot;: Available outside the loop.&quot;
  # ... 因为没有在子 shell 中运行。
done &lt; &lt;( echo &quot;random input&quot; )
#    ^ ^

echo &quot;\$global (使用进程替换) = $global&quot;
#  随机输入
#  $global (使用进程替换)= 3D: Available outside the loop.


echo; echo &quot;##########&quot;; echo



# 同样道理 . . .

declare -a inloop
index=0
cat $0 | while read line
do
  inloop[$index]=&quot;$line&quot;
  ((index++))
  # 在子 shell 中运行，所以 ...
done
echo &quot;OUTPUT = &quot;
echo ${inloop[*]}           # ... 什么也没有显示。


echo; echo &quot;--&quot;; echo


declare -a outloop
index=0
while read line
do
  outloop[$index]=&quot;$line&quot;
  ((index++))
  # 没有在子 shell 中运行，所以 ...
done &lt; &lt;( cat $0 )
echo &quot;OUTPUT = &quot;
echo ${outloop[*]}          # ... 整个脚本的结果显示出来。

exit $?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br></div></div><p>下面是个类似的例子。</p>
<p><strong>例 23-2. 重定向进程替换的输出到一个循环内</strong></p>
<div><pre><code>#!/bin/bash
# psub.bash
#  受 Diego Molina 启发（感谢！）。

declare -a array0
while read
do
  array0[${#array0[@]}]=&quot;$REPLY&quot;
done &lt; &lt;( sed -e &#39;s/bash/CRASH-BANG!/&#39; $0 | grep bin | awk &#39;{print $1}&#39; )
#  由进程替换来设置&#39;read&#39;默认变量（$REPLY）。
#+ 然后将变量复制到一个数组。

echo &quot;${array0[@]}&quot;

exit $?

# ====================================== #
# 运行结果：
bash psub.bash

#!/bin/CRASH-BANG! done #!/bin/CRASH-BANG!
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>一个读者发来一个有趣的进程替换例子，如下：</p>
<div><pre><code># SuSE 发行版中提取的脚本片段：

# --------------------------------------------------------------#
while read  des what mask iface; do
# 一些命令 ...
done &lt; &lt;(route -n)  
#    ^ ^  第一个 &lt; 是重定向，第二个是进程替换。

#  为了测试，我们让它来做点儿事情。
while read  des what mask iface; do
  echo $des $what $mask $iface
done &lt; &lt;(route -n)  

# 输出内容:
# Kernel IP routing table
# Destination Gateway Genmask Flags Metric Ref Use Iface
# 127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo
# --------------------------------------------------------------#

#  正如 Stéphane Chazelas 指出的,
#+ 一个更容易理解的等价代码如下：
route -n |
  while read des what mask iface; do   # 通过管道输出设置的变量
    echo $des $what $mask $iface
  done  #  这段代码的结果更上面的相同。
        #  但是，Ulrich Gayer 指出 . . .
        #+ 这段简化版等价代码在 while 循环里用了子 shell，
        #+ 因此当管道终止时变量都消失了。

# --------------------------------------------------------------#

#  然而，Filip Moritz 说上面的两个例子有一个微妙的区别，
#+ 见下面的代码

(
route -n | while read x; do ((y++)); done
echo $y # $y is still unset

while read x; do ((y++)); done &lt; &lt;(route -n)
echo $y # $y has the number of lines of output of route -n
)

#  更通俗地说（译者注：原文本行少了注释符）
(
: | x=x
# 似乎启动了子 shell ，就像
: | ( x=x )
# 而
x=x &lt; &lt;(:)
# 并没有。
)
#  这个方法在解析 csv 和类似格式时很有用。
#  也就是在效果上，原始 SuSE 系统的代码片段就是做这个用的。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>注解 [1]
这个与命名管道（使用临时文件）的效果相同，而且事实上，进程替换也曾经用过命名管道。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">24.1 复杂函数和函数复杂性</title>
    <id>https://clay-wangzhi.com/code/shell/part5/24_1_complex_functions_and_function_complexities/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/24_1_complex_functions_and_function_complexities/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_24-1-复杂函数和函数复杂性"> 24.1 复杂函数和函数复杂性</h1>
<p>函数可以处理传递给它的参数，并且能返回它的<a href="http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF" target="_blank" rel="noopener noreferrer">退出状态码</a>给脚本，以便后续处理。</p>
<div><pre><code>function_name $arg1 $arg2
</code></pre>
<div><span>1</span><br></div></div><p>函数通过位置来引用传递过来的参数（就好像它们是<a href="http://tldp.org/LDP/abs/html/internalvariables.html#POSPARAMREF" target="_blank" rel="noopener noreferrer">位置参数</a>），例如，$1, $2，等等。</p>
<p>例子 24-2. 带参数的函数</p>
<div><pre><code>#!/bin/bash
# 函数和参数

DEFAULT=default                 # 默认参数值。D

func2 () {
    if [ -z &quot;$1&quot; ]              # 第一个参数长度是否为零？
    then
        echo &quot;-Parameter #1 is zero length.-&quot;  # 或者没有参数传递进来。
    else
        echo &quot;-Parameter #1 is \&quot;$1\&quot;.-&quot;
    fi

    variable=${1-$DEFAULT}
    echo &quot;variable = $variable&quot;     #  这里的参数替换
                                    #+ 表示什么？
                                    #  ---------------------------
                                    #  为了区分没有参数的情况
                                    #+ 和只有一个null参数的情况。

    if [ &quot;$2&quot; ]
    then
        echo &quot;-Parameter #2 is \&quot;$2\&quot;.-&quot;
    fi

    return 0
}

echo

echo &quot;Nothing passed.&quot;
func2                          # 不带参数调用
echo


echo &quot;Zero-length parameter passed.&quot;
func2 &quot;&quot;                        # 使用0长度的参数进行调用
echo

echo &quot;Null parameter passed.&quot;
func2 &quot;$uninitialized_param&quot;    # 使用未初始化的参数进行调用
echo


echo &quot;One parameter passed.&quot;
func2 first           # 带一个参数的调用
echo

echo &quot;Two parameters passed.&quot;
func2 first second    # 带两个参数的调用
echo

echo &quot;\&quot;\&quot; \&quot;second\&quot; passed.&quot;
func2 &quot;&quot; second       # 第一个调用参数为0长度参数，
echo                  # 第二个是ASCII码的字符串参数。

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="notice" /> 也可以使用<a href="http://tldp.org/LDP/abs/html/othertypesv.html#SHIFTREF" target="_blank" rel="noopener noreferrer">shift</a>命令来处理传递给函数的参数（请参考<a href="http://tldp.org/LDP/abs/html/assortedtips.html#MULTIPLICATION" target="_blank" rel="noopener noreferrer">例子 33-18</a>.
但是，传递给脚本的命令行参数怎么办？在函数内部，可以看见这些命令行参数么？好，现在让我们弄清楚这个困惑。</p>
<p>例子 34-3. 函数以及传递给脚本的命令行参数。</p>
<div><pre><code>#!/bin/bash
# func-cmdlinearg.sh
#  带一个命令行参数来执行这个脚本，
#+ 类似于 $0 arg1.


func ()
{
    echo &quot;$1&quot;   # 显示传递给这个函数的第一个参数。
}               # 命令行参数可以么？

echo &quot;First call to function: no arg passed.&quot;
echo &quot;See if command-line arg is seen.&quot;
func
# 不! 没有见到命令行参数.

echo &quot;============================================================&quot;
echo
echo &quot;Second call to function: command-line arg passed explicitly.&quot;

func $1
# 现在，见到命令行参数了！

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>和其它的编程语言相比，shell脚本一般只会传值给函数。如果把变量名（事实上就是指针）作为参数传递给函数的话，那将被解释为字面含义，也就是被看做字符串。 函数只会以字面含义来解释函数参数。</p>
<p><a href="http://tldp.org/LDP/abs/html/ivr.html#IVRREF" target="_blank" rel="noopener noreferrer">变量的间接引用</a>（请参考<a href="http://tldp.org/LDP/abs/html/bashver2.html#EX78" target="_blank" rel="noopener noreferrer">例子 37-2</a>）提供了一种笨拙的机制，来将变量指针传递给函数。</p>
<p>例子 24-4. 将一个间接引用传递给函数</p>
<div><pre><code>#!/bin/bash
# ind-func.sh: 将一个间接引用传递给函数。

echo_var ()
{
    echo &quot;$1&quot;
}

message=Hello
Hello=Goodbye

echo_var &quot;$message&quot;         # Hello
# 现在，让我们传递一个间接引用给函数。
echo_var &quot;${!message}&quot;     # Goodbye
echo &quot;-------------&quot;

# 如果我们改变“hello”的值会发生什么？
Hello=&quot;Hello, again!&quot;
echo_var &quot;$message&quot;        # Hello
echo_var &quot;${!message}&quot;     # Hello, again!

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>接下来的一个逻辑问题就是，将参数传递给函数之后，参数能否被解除引用。</p>
<p>例子 24-5. 对一个传递给函数的参数进行解除引用的操作</p>
<div><pre><code>#!/bin/bash
# dereference.sh
# 对一个传递给函数的参数进行解除引用的操作。
# 此脚本由Bruce W. Clare编写.

dereference ()
{
    y=\$&quot;$1&quot;   # 变量名（而不是值）.
    echo $y    # $Junk

    x=`eval &quot;expr \&quot;$y\&quot; &quot;`
    echo $1=$x
    eval &quot;$1=\&quot;Some Different Text \&quot;&quot;  # 赋新值.
}

Junk=&quot;Some Text&quot;
echo $Junk &quot;before&quot;         # Some Text before

dereference Junk
echo $Junk &quot;after&quot;          # Some Different Text after

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>例子 24-6. 再来一次，对一个传递给函数的参数进行解除引用的操作</p>
<div><pre><code>#!/bin/bash
# ref-params.sh: 解除传递给函数的参数引用。
#                (复杂的例子C)

ITERATIONS=3  # 取得输入的次数。
icount=1

my_read () {
    #  用my_read varname这种形式来调用,
    #+ 将之前用括号括起的值作为默认值输出,
    #+ 然后要求输入一个新值.

    local local_var

    echo -n &quot;Enter a value &quot;
    eval &#39;echo -n &quot;[$&#39;$1&#39;] &quot;&#39;  #  之前的值.
# eval echo -n &quot;[\$$1] &quot;     #  更容易理解,
                             #+ 但会丢失用户在尾部输入的空格。
    read local_var
    [ -n &quot;$local_var&quot; ] &amp;&amp; eval $1=\$local_var

    # &quot;与列表&quot;: 如果 &quot;local_var&quot; 的测试结果为true，则把变量&quot;$1&quot;的值赋给它。
}

echo

while [ &quot;$icount&quot; -le &quot;$ITERATIONS&quot; ]
do
    my_read var
    echo &quot;Entry #$icount = $var&quot;
    let &quot;icount += 1&quot;
    echo
done

# 感谢Stephane Chazelas 提供这个例子。

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h2 id="退出与返回码"> 退出与返回码</h2>
<h3 id="退出状态码"> 退出状态码</h3>
<p>函数返回一个值，被称为退出状态码。这和一条命令返回的<a href="http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF" target="_blank" rel="noopener noreferrer">退出状态码</a>类似。退出状态码可以由<strong>return</strong> 命令明确指定，也可以由函数中最后一条命令的退出状态码来指定（如果成功，则返回0，否则返回非0值）。可以在脚本中使用<a href="http://tldp.org/LDP/abs/html/internalvariables.html#XSTATVARREF" target="_blank" rel="noopener noreferrer">$?</a>来引用<a href="http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF" target="_blank" rel="noopener noreferrer">退出状态码</a>。 因为有了这种机制，所以脚本函数也可以像C函数一样有“返回值”。</p>
<h3 id="return"> return</h3>
<p>终止一个函数。一个return命令<a href="http://tldp.org/LDP/abs/html/complexfunct.html#FTN.AEN18474" target="_blank" rel="noopener noreferrer">1</a> 可选的允许带一个整形参数，这个整形参数将作为函数的“退出状态码”返回给调用这个函数的脚本，并且这个证书也被赋值给变量<a href="http://tldp.org/LDP/abs/html/internalvariables.html#XSTATVARREF" target="_blank" rel="noopener noreferrer">$?</a>.</p>
<p>例子 24-7. 取两个数中的最大值</p>
<div><pre><code>#!/bin/bash
# max.sh: 取两个Maximum of two integers.
E_PARAM_ERR=250    # 如果传给函数的参数少于两个时，就返回这个值。
EQUAL=251          # 如果两个参数相等时，就返回这个值。
#  任意超出范围的
#+ 参数值都可能传递到函数中。

max2 ()             # 返回两个数中的最大值。
{                   # 注意：参与比较的数必须小于250.
    if [ -z &quot;$2&quot; ]
    then
        return $E_PARAM_ERR
    fi

    if [ &quot;$1&quot; -eq &quot;$2&quot; ]
    then
        return $EQUAL
    else
        if [ &quot;$1&quot; -gt &quot;$2&quot; ]
        then
            return $1
        else
            return $2
        fi
    fi
}

max2 33 34
return_val=$?

if [ &quot;$return_val&quot; -eq $E_PARAM_ERR ]
then
    echo &quot;Need to pass two parameters to the function.&quot;
elif [ &quot;$return_val&quot; -eq $EQUAL ]
then
    echo &quot;The two numbers are equal.&quot;
else
    echo &quot;The larger of the two numbers is $return_val.&quot;
fi

exit 0
#  练习 (easy):
￼#  ---------------
#  把这个脚本转化为交互脚本，
#+ 也就是，修改这个脚本，让其要求调用者输入2个数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/tip.gif" alt="info" /> 为了让函数可以返回字符串或者是数组，可以使用一个在函数外可见的专用全局变量。</p>
<div><pre><code>count_lines_in_etc_passwd()
{
    [[ -r /etc/passwd ]] &amp;&amp; REPLY=$(echo $(wc -l &lt; /etc/passwd))
    #  如果 /etc/passwd 可读，让 REPLY 等于 文件的行数.
    #  这样就可以同时返回参数值与状态信息。
    #  &#39;echo&#39; 看上去没什么用，可是...
    #+ 它的作用是删除输出中的多余空白符。
}

if count_lines_in_etc_passwd
then
    echo &quot;There are $REPLY lines in /etc/passwd.&quot;
else
    echo &quot;Cannot count lines in /etc/passwd.&quot;
fi

# 感谢, S.C.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>例子 24-8. 将阿拉伯数字转化为罗马数字</p>
<div><pre><code>#!/bin/bash
# 将阿拉伯数字转化为罗马数字。
# 范围：0 - 200
# 比较粗糙，但可以正常工作。
# 扩展范围, 并且完善这个脚本, 作为练习.
# 用法: roman number-to-convert

LIMIT=200
E_ARG_ERR=65
E_OUT_OF_RANGE=66

if [ -z &quot;$1&quot; ]
then
    echo &quot;Usage: `basename $0` number-to-convert&quot;
exit $E_ARG_ERR
fi

num=$1
if [ &quot;$num&quot; -gt $LIMIT ]
then
    echo &quot;Out of range!&quot;
    exit $E_OUT_OF_RANGE
fi

to_roman ()             # 在第一次调用函数前必须先定义它。
{
    number=$1
    factor=$2
    rchar=$3
    let &quot;remainder = number - factor&quot;
    while [ &quot;$remainder&quot; -ge 0 ]
    do
        echo -n $rchar
        let &quot;number -= factor&quot;
        let &quot;remainder = number - factor&quot;
    done

    return $number
        # 练习:
        # ---------
        # 1) 解释这个函数如何工作
        #    提示: 依靠不断的除，来分割数字。
        # 2) 扩展函数的范围：
        #    提示: 使用echo和substitution命令.
}

to_roman $num 100 C
num=$?
to_roman $num 90 LXXXX
num=$?
to_roman $num 50 L
num=$?
to_roman $num 40 XL
num=$?
to_roman $num 10 X
num=$?
to_roman $num 9 IX
num=$?
to_roman $num 5 V
num=$?
to_roman $num 4 IV
num=$?
to_roman $num 1 I
# 成功调用了转换函数。
# 这真的是必须的么？ 这个可以简化么？

echo

exit 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><p>也可以参见<a href="http://tldp.org/LDP/abs/html/testbranch.html#ISALPHA" target="_blank" rel="noopener noreferrer">例子 11-29</a></p>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="notice" /> 函数所能返回最大的正整数是255. return命令和<a href="http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF" target="_blank" rel="noopener noreferrer">退出状态码</a>的概念紧密联系在一起，并且退出状态码的值受此限制。 幸运的是，如果想让函数返回大整数的话，有好多种不同的<a href="http://tldp.org/LDP/abs/html/assortedtips.html#RVT" target="_blank" rel="noopener noreferrer">变通方法</a> 能够应对这个情况。</p>
<p>例子24-9. 测试函数最大的返回值</p>
<div><pre><code>#!/bin/bash
# return-test.sh
# 函数所能返回的最大正整数为255.

return_test ()         # 传给函数什么值，就返回什么值。
{
    return $1
}

return_test 27          # o.k.
echo $?                 # 返回27.

return_test 255         # Still o.k.
echo $?                 # 返回 255.

return_test 257         # 错误!
echo $?                 # 返回 1 (对应各种错误的返回码).

# =========================================================
return_test -151896    # 能返回一个大负数么?
echo $?                # 能否返回 -151896?
                        # 不行! 返回的是 168.

#  Bash 2.05b 之前的版本
#+ 允许返回大负数。
#  这可能是个有用的特性。
#  Bash之后的新版本修正了这个漏洞。
#  这可能会影响以前所编写的脚本。
#  一定要小心!
# =========================================================

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>如果你想获得大整数“返回值”的话，简单的方法就是将“要返回的值”保存到一个全局变量中。</p>
<div><pre><code>Return_Val=   # 用于保存函数特大返回值的全局变量。

alt_return_test ()
{
    fvar=$1
    Return_Val=$fvar
    return   # 返回 0 (成功).
}

alt_return_test 1
echo $?             #0
echo &quot;return value = $Return_Val&quot;            #1

alt_return_test 256
echo &quot;return value = $Return_Val&quot;           # 256

alt_return_test 257
echo &quot;return value = $Return_Val&quot;           # 257

alt_return_test 25701
echo &quot;return value = $Return_Val&quot;           #25701
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>一种更优雅的做法是在函数中使用echo命令将&quot;返回值输出到stdout“，然后用<a href="http://tldp.org/LDP/abs/html/commandsub.html#COMMANDSUBREF" target="_blank" rel="noopener noreferrer">命令替换</a>来捕捉此值。请参考<a href="http://tldp.org/LDP/abs/html/assortedtips.html" target="_blank" rel="noopener noreferrer">36.7小节</a> 中<a href="http://tldp.org/LDP/abs/html/assortedtips.html#RVT" target="_blank" rel="noopener noreferrer">关于这种用法的讨论</a>。</p>
<p>例子 24-10. 比较两个大整数</p>
<div><pre><code>#!/bin/bash
# max2.sh: 取两个大整数中的最大值。

#  这是前一个例子 &quot;max.sh&quot; 的修改版,
#+ 这个版本可以比较两个大整数。

EQUAL=0             # 如果两个值相等，那就返回这个值。
E_PARAM_ERR=-99999  # 没有足够多的参数，那就返回这个值。
#           ^^^^^^    任意超出范围的参数都可以传递进来。

max2 ()             # &quot;返回&quot; 两个整数中最大的那个。
{
    if [ -z &quot;$2&quot; ]
    then
        echo $E_PARAM_ERR
        return
    fi

    if [ &quot;$1&quot; -eq &quot;$2&quot; ]
    then
        echo $EQUAL
        return
    else
        if [ &quot;$1&quot; -gt &quot;$2&quot; ]
        then
            retval=$1
        else
            retval=$2
        fi
    fi

    echo $retval            # 输出 (到 stdout), 而没有用返回值。
                            # 为什么?
}


return_val=$(max2 33001 33997)
#            ^^^^             函数名
#                 ^^^^^ ^^^^^ 传递进来的参数
#  这其实是命令替换的一种形式：
#+ 可以把函数看作一个命令，
#+ 然后把函数的stdout赋值给变量“return_val&quot;.


# ========================= OUTPUT ========================
if [ &quot;$return_val&quot; -eq &quot;$E_PARAM_ERR&quot; ]
then
    echo &quot;Error in parameters passed to comparison function!&quot;
elif [ &quot;$return_val&quot; -eq &quot;$EQUAL&quot; ]
then
    echo &quot;The two numbers are equal.&quot;
else
    echo &quot;The larger of the two numbers is $return_val.&quot;
fi
# =========================================================

exit 0

#  练习:
#  ---------
#  1) 找到一种更优雅的方法，
#+    去测试传递给函数的参数。
#  2) 简化”输出“段的if/then结构。
#  3) 重写这个脚本，使其能够从命令行参数中获得输入。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><p>这是另一个能够捕捉函数”返回值“的例子。要想搞明白这个例子，需要一些<a href="http://tldp.org/LDP/abs/html/awk.html#AWKREF" target="_blank" rel="noopener noreferrer">awk</a>的知识。</p>
<div><pre><code>month_length ()  # 把月份作为参数。
{                # 返回该月包含的天数。
    monthD=&quot;31 28 31 30 31 30 31 31 30 31 30 31&quot;  # 作为局部变量声明？
    echo &quot;$monthD&quot; | awk &#39;{ print $&#39;&quot;${1}&quot;&#39; }&#39;    # 小技巧.
#                             ^^^^^^^^^
# 传递给函数的参数  ($1 -- 月份), 然后传给 awk.
# Awk 把参数解释为&quot;print $1 . . . print $12&quot; (这依赖于月份号)
# 这是一个模板，用于将参数传递给内嵌awk的脚本：
#                                 $&#39;&quot;${script_parameter}&quot;&#39;
#    这里是一个简单的awk结构：
#    echo $monthD | awk -v month=$1 &#39;{print $(month)}&#39;
#    使用awk的-v选项，可以把一个变量值赋给
#+   awk程序块的执行体。
#    感谢 Rich.
#  需要做一些错误检查，来保证月份好正确，在范围（1-12）之间， 
#+ 别忘了检查闰年的二月。
}
# ----------------------------------------------
# 用例：
month=4        # 以四月为例。
days_in=$(month_length $month)
echo $days_in  # 30
# ----------------------------------------------
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>也请参考<a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#DAYSBETWEEN" target="_blank" rel="noopener noreferrer">例子 A-7</a> 和<a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#STDDEV" target="_blank" rel="noopener noreferrer">例子A-37</a>.</p>
<p>练习:使用目前我们已经学到的知识，来扩展之前的例子 <a href="">将阿拉伯数字转化为罗马数字</a>，让它能够接受任意大的输入。</p>
<p>重定向
重定向函数的stdin
函数本质上其实就是一个<a href="http://tldp.org/LDP/abs/html/special-chars.html#CODEBLOCKREF" target="_blank" rel="noopener noreferrer">代码块</a>,这就意味着它的stdin可以被重定向（比如<a href="http://tldp.org/LDP/abs/html/special-chars.html#EX8" target="_blank" rel="noopener noreferrer">例子3-1</a>)。</p>
<p>例子 24-11. 从username中取得用户的真名</p>
<div><pre><code>#!/bin/bash
# realname.sh
#
# 依靠username，从/etc/passwd 中获得“真名”.


ARGCOUNT=1       # 需要一个参数.
E_WRONGARGS=85

file=/etc/passwd
pattern=$1

if [ $# -ne &quot;$ARGCOUNT&quot; ]
then
    echo &quot;Usage: `basename $0` USERNAME&quot;
    exit $E_WRONGARGS
fi

file_excerpt ()    # 按照要求的模式来扫描文件,
{                  #+ 然后打印文件的相关部分。
    while read line  # &quot;while&quot; 并不一定非得有 [ 条件 ] 不可。
    do
        echo &quot;$line&quot; | grep $1 | awk -F&quot;:&quot; &#39;{ print $5 }&#39;
        # awk用&quot;:&quot; 作为界定符。
    done
    } &lt;$file  # 重定向到函数的stdin。

file_excerpt $pattern
# 是的，整个脚本其实可以被缩减为
#       grep PATTERN /etc/passwd | awk -F&quot;:&quot; &#39;{ print $5 }&#39;
# or
#       awk -F: &#39;/PATTERN/ {print $5}&#39;
# or
#       awk -F: &#39;($1 == &quot;username&quot;) { print $5 }&#39; # 从username中获取真名
# 但是，这些起不到示例的作用。

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>还有一个办法，或许能够更好的理解重定向函数的stdin。 它在函数内添加了一对大括号，并且将重定向stdin的行为放在这对添加的大括号上。</p>
<div><pre><code># 用下面的方法来代替它:
Function ()
{
    ...
} &lt; file

# 试试这个:
Function ()
{
    { 
        ...
    } &lt; file 
}

# 同样的,

Function ()  # 没问题.
{
    {
        echo $*
    } | tr a b 
}

Function ()  # 不行.
{
    echo $*
} | tr a b   # 这儿的内嵌代码块是被强制的。
# 感谢, S.C.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> Emmanuel Rouat的 <a href="http://tldp.org/LDP/abs/html/sample-bashrc.html" target="_blank" rel="noopener noreferrer">sample bash</a> 文件包含了一些很有指导性意义的函数例子。</p>
<h3 id="echo"> echo</h3>
<p>shell中函数返回值，个人觉得可以用<code>echo</code></p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">24.2 局部变量</title>
    <id>https://clay-wangzhi.com/code/shell/part5/24_2_local_variables/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/24_2_local_variables/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_24-2-局部变量"> 24.2 局部变量</h1>
<p>怎样使一个变量变成“局部”变量？</p>
<p>局部变量
如果变量用local来声明，那么它就只能够在该变量被声明的<a href="http://tldp.org/LDP/abs/html/special-chars.html#CODEBLOCKREF" target="_blank" rel="noopener noreferrer">代码块</a>中可见。 这个代码块就是局部<a href="http://tldp.org/LDP/abs/html/subshells.html#SCOPEREF" target="_blank" rel="noopener noreferrer">范围</a>。 在一个函数中，一个局部变量只有在函数代码中才有意义.<a href="http://tldp.org/LDP/abs/html/localvar.html#FTN.AEN18568" target="_blank" rel="noopener noreferrer">[1]</a></p>
<p>例子 24-12. 局部变量的可见范围</p>
<div><pre><code>#!/bin/bash
# ex62.sh: 函数内部的局部变量与全局变量。

func () {
    local loc_var=23       # 声明为局部变量。
    echo                   # 使用&#39;local&#39;内建命令
    echo &quot;\&quot;loc_var\&quot; in function = $loc_var&quot;
    global_var=999         # 没有声明为局部变量。
    # 默认为全局变量。

    echo &quot;\&quot;global_var\&quot; in function = $global_var&quot;
}

func

# 现在，来看看局部变量“loc_var”在函数外部是否可见。

echo
echo &quot;\&quot;loc_var\&quot; outside function = $loc_var&quot;
                                    # $loc_var outside function =
                                    # 不行, $loc_var 不是全局可见的.
echo &quot;\&quot;global_var\&quot; outside function = $global_var&quot;
                                    # $在函数外部global_var = 999
                                    # $global_var 是全局可见的.
echo

exit 0
#  与C语言相比，在函数内声明的Bash变量
#+ 除非它被明确声明为local时，它才是局部的。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="notice" /> 在函数被调用之前，所有在函数中声明的变量，在函数外部都是不可见的，当然也包括那些被明确声明为local的变量。</p>
<div><pre><code>#!/bin/bash

func ()
{
    global_var=37    #  变量只在函数体内可见
                     #+ 在函数被调用之前。
}                    #  函数结束

echo &quot;global_var = $global_var&quot;  # global_var =
                                 #  函数 &quot;func&quot; 还没被调用，
                                 #+ 所以$global_var 在这里还不是可见的.
func
echo &quot;global_var = $global_var&quot;  # global_var = 37
                                 # 已经在函数调用的时候设置。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 正如Evgeniy Ivanov指出的那样，当在一条命令中定义和给一个局部变量赋值时，显然操作的顺序首先是给变量赋值，之后限定变量的局部范围。这可以通过<a href="http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF" target="_blank" rel="noopener noreferrer">返回值</a>来反应。</p>
<div><pre><code>#!/bin/bash

echo &quot;==OUTSIDE Function (global)==&quot;
t=$(exit 1)
echo $?     # 1
            # 如预期一样.

echo
function0 ()
{
    echo &quot;==INSIDE Function==&quot;
    echo &quot;Global&quot;
    t0=$(exit 1)
    echo $?      # 1
                 # 如预期一样.

    echo
    echo &quot;Local declared &amp; assigned in same command.&quot;
    local t1=$(exit 1)
    echo $?      # 0
                 # 意料之外!
#  显然，变量赋值发生在Apparently, 
#+ 局部声明之前。
#+ 返回值是为了latter.

    echo
    echo &quot;Local declared, then assigned (separate commands).&quot;
    local t2
    t2=$(exit 1)
    echo $?
}

function0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h2 id="_24-2-1-局部变量和递归"> 24.2.1 局部变量和递归</h2>
<p>递归是一个有趣并且有时候非常有用的自己调用自己的形式。 <a href="http://tldp.org/LDP/abs/html/biblio.html#MAYERREF" target="_blank" rel="noopener noreferrer">Herbert Mayer</a> 是这样定义递归的，“。。。表示一个算法通过使用一个简单的相同算法版本。。。”</p>
<p>想象一下，一个定义是从自身考虑的，<a href="http://tldp.org/LDP/abs/html/localvar.html#FTN.AEN18607" target="_blank" rel="noopener noreferrer">[2]</a> 一个表达包含了自身的表达， <a href="http://tldp.org/LDP/abs/html/localvar.html#FTN.AEN18610" target="_blank" rel="noopener noreferrer">[3]</a> 一条蛇吞下自己的尾巴， <a href="http://tldp.org/LDP/abs/html/localvar.html#FTN.AEN18614" target="_blank" rel="noopener noreferrer">[4]</a> 或者 。。。 一个函数调用自身。<a href="http://tldp.org/LDP/abs/html/localvar.html#FTN.AEN18617" target="_blank" rel="noopener noreferrer">[5]</a></p>
<p>例子 24-13. 一个简单的递归函数表示</p>
<div><pre><code>#!/bin/bash
# recursion-demo.sh
# 递归演示.

RECURSIONS=9   # 递归的次数.
r_count=0      # 必须是全局变量，为什么？

recurse ()
{
    var=&quot;$1&quot;

    while [ &quot;$var&quot; -ge 0 ]
    do
        echo &quot;Recursion count = &quot;$r_count&quot;  +-+  \$var = &quot;$var&quot;&quot;
        (( var-- )); (( r_count++ ))
        recurse &quot;$var&quot;  #  函数调用自身(递归)
    done              #+ 直到遇到什么样的终止条件？
}

recurse $RECURSIONS

exit $?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>例子 24-14. 另一个简单的例子</p>
<div><pre><code>#!/bin/bash
# recursion-def.sh
# 另外一个描述递归的比较生动的脚本。

RECURSIONS=10
r_count=0
sp=&quot; &quot;

define_recursion ()
{
    ((r_count++))
    sp=&quot;$sp&quot;&quot; &quot;
    echo -n &quot;$sp&quot;
    echo &quot;\&quot;The act of recurring ... \&quot;&quot;        # Per 1913 Webster&#39;s dictionary.

    while [ $r_count -le $RECURSIONS ]
    do
        define_recursion
    done
}

echo
echo &quot;Recursion: &quot;
define_recursion
echo

exit $?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>局部变量是一个写递归代码有效的工具，但是这种方法一般会包含大量的计算负载，显然在shell脚本中并不推荐递归.<a href="http://tldp.org/LDP/abs/html/localvar.html#FTN.AEN18632" target="_blank" rel="noopener noreferrer">[6]</a></p>
<p>例子24-15. 使用局部变量进行递归</p>
<div><pre><code>#!/bin/bash

# 阶乘
# ---------

# Bash允许递归么？
# 恩，允许，但是...
# 他太慢了，所以恐怕你难以忍受。

MAX_ARG=5
E_WRONG_ARGS=85
E_RANGE_ERR=86


if [ -z &quot;$1&quot; ]
then
    echo &quot;Usage: `basename $0` number&quot;
    exit $E_WRONG_ARGS
fi

if [ &quot;$1&quot; -gt $MAX_ARG ]
then
    echo &quot;Out of range ($MAX_ARG is maximum).&quot;
    #  现在让我们来了解一些实际情况。
    #  如果你想计算比这个更大的范围的阶乘，
    #+ 应该用真正的编程语言来重写它。
    exit $E_RANGE_ERR
fi

fact () 
{
    local number=$1
    #  变量&quot;number&quot; 必须被定义为局部变量，
    #+ 否则不能正常工作。
    if [ &quot;$number&quot; -eq 0 ]
    then
        factorial=1    # 0的阶乘为1.
    else
        let &quot;decrnum = number - 1&quot;
        fact $decrnum  # 递归的函数调用 (就是函数调用自己).
        let &quot;factorial = $number * $?&quot;
    fi
    return $factorial
}

fact $1
echo &quot;Factorial of $1 is $?.&quot;

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><p>也可以参考<a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#PRIMES" target="_blank" rel="noopener noreferrer">例子 A-15</a>，一个包含递归例子的脚本。我们意识到递归同时也意味着巨大的资源消耗和缓慢的运行速度，因此它并不适合在脚本中使用。</p>
<h2 id="注释"> 注释</h2>
<p><a href="http://tldp.org/LDP/abs/html/localvar.html#AEN18568" target="_blank" rel="noopener noreferrer">[1]</a> 然而，如Thomas Braunberger 指出的那样，一个函数里定义的局部变量对于调用它的父函数也是可见的。</p>
<div><pre><code>#!/bin/bash

function1 ()
{
  local func1var=20

  echo &quot;Within function1, \$func1var = $func1var.&quot;

  function2
}

function2 ()
{
  echo &quot;Within function2, \$func1var = $func1var.&quot;
}

function1

exit 0


# 脚本的输出:

# Within function1, $func1var = 20.
# Within function2, $func1var = 20.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>在Bash手册里是这样描述的：</p>
<blockquote>
<p>&quot;局部变量只能在函数内部使用; 它让变量名的可见范围限制在了函数内部以及它的孩子里&quot; [emphasis added]
The ABS Guide的作者认为这个行为一个bug.</p>
</blockquote>
<p><a href="http://tldp.org/LDP/abs/html/localvar.html#AEN18607" target="_blank" rel="noopener noreferrer">[2]</a> 被熟知为冗余。</p>
<p><a href="http://tldp.org/LDP/abs/html/localvar.html#AEN18610" target="_blank" rel="noopener noreferrer">[3]</a> 被熟知为同义反复。</p>
<p><a href="http://tldp.org/LDP/abs/html/localvar.html#AEN18614" target="_blank" rel="noopener noreferrer">[4]</a> 被熟知为暗喻。</p>
<p><a href="http://tldp.org/LDP/abs/html/localvar.html#AEN18617" target="_blank" rel="noopener noreferrer">[5]</a> 被熟知为递归函数。</p>
<p><a href="http://tldp.org/LDP/abs/html/localvar.html#AEN18632" target="_blank" rel="noopener noreferrer">[6]</a> 太多的递归层次可能会引发一个脚本的段错误。</p>
<div><pre><code>#!/bin/bash

#  提醒: 运行这个脚本可能会让你的系统卡死。
#  如果你够好运的话，在耗尽可用内存之前，它会发生一个段错误。

recursive_function ()		   
{
echo &quot;$1&quot;     # 让函数做一些事情，加快发生段错误。
(( $1 &lt; $2 )) &amp;&amp; recursive_function $(( $1 + 1 )) $2;
#  只要第一个参数小于第二个参数，
#+ 让第一个参数加1，然后递归。
}

recursive_function 1 50000  # 递归 50,000层!
#  很可能发生段错误(依赖于栈的大小，通过ulimit -m可以设置栈的大小)

#  即使是C语言，递归调用这么多层也会发生段错误，
#+ 通过分配栈耗尽所有的内存。


echo &quot;This will probably not print.&quot;
exit 0  # 这个脚本可能不会正常退出。

#  感谢, Stéphane Chazelas.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">24.3 不使用局部变量的递归</title>
    <id>https://clay-wangzhi.com/code/shell/part5/24_3_recursion_without_local_variables/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/24_3_recursion_without_local_variables/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_24-3-不使用局部变量的递归"> 24.3 不使用局部变量的递归</h1>
<p>即使不适用局部变量，函数也可以递归的调用自身。</p>
<p>例子24-16. 斐波那契序列</p>
<div><pre><code>#!/bin/bash
# fibo.sh : 斐波那契序列 (递归)
# 作者: M. Cooper
# License: GPL3

# ----------算法--------------
# Fibo(0) = 0
# Fibo(1) = 1
# else
#   Fibo(j) = Fibo(j-1) + Fibo(j-2)
# ---------------------------------

MAXTERM=15       # 要产生的计算次数。
MINIDX=2         # 如果下标小于2，那么 Fibo(idx) = idx.

Fibonacci ()
{
    idx=$1   # 不需要是局部变量，为什么？
    if [ &quot;$idx&quot; -lt &quot;$MINIDX&quot; ]
    then
        echo &quot;$idx&quot;  # 前两个下标是0和1 ... 从上面的算法可以看出来。
    else
        (( --idx ))  # j-1
        term1=$( Fibonacci $idx )   #  Fibo(j-1)
        (( --idx ))  # j-2
        term2=$( Fibonacci $idx )   #  Fibo(j-2)
        echo $(( term1 + term2 ))
    fi
    #  一个丑陋的实现
    #  C语言里，一个更加优雅的斐波那契递归实现
    #+ 是一个简单的只需要7-10代码的算法翻译。
}

for i in $(seq 0 $MAXTERM)
do  # 计算 $MAXTERM+1 次.
    FIBO=$(Fibonacci $i)
    echo -n &quot;$FIBO &quot;
done
# 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610
# 要花费一段时间，不是么？ 一个递归脚本是有些慢的。

echo

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>例子 24-17. 汉诺塔</p>
<div><pre><code>#! /bin/bash
#
# 汉诺塔
# Bash script
# Copyright (C) 2000 Amit Singh. All Rights Reserved.
# http://hanoi.kernelthread.com
#
# 在 Bash version 2.05b.0(13)-release下通过测试.
# 同样在Bash3.x版本下工作正常。
#
#  在 &quot;Advanced Bash Scripting Guide&quot; 一书中使用
#+ 经过了脚本作者的许可。
#  ABS的作者对脚本进行了轻微的修改和注释。
#=================================================================#
#  汉诺塔是由Edouard Lucas,提出的数学谜题， 
#+  他是19世纪的法国数学家。
#
# 有三个直立的柱子竖在地面上。
# 第一个柱子上有一组盘子套在上面。
# 这些盘子是平的，中间有孔，
#+ 可以套在柱子上面。
# 这些盘子的直径不同，它们从下而上， 
#+ 按照尺寸递减的顺序摆放。
# 也就是说，最小的在最上边，最大的在最下面。
#
# 现在的任务是要把这组盘子  
#+ 从一个柱子上全部搬到另一个柱子上 
# 你每次只能将一个盘子从一个柱子移到另一个柱子上。
# 你也可以把盘子从其他的柱子上移回到原来的柱子上。
# 你只能把小的盘子放到大的盘子上。
#+ 反过来就不行。
# 切记，绝对不能把大盘子放到小盘子的上面。
# 如果盘子的数量比较少，那么移不了几次就能完成。
#+ 但是随着盘子数量的增加，
#+ 移动次数几乎成倍的增长，
#+ 而且移动的“策略”也会变得越来越复杂。
#
# 想了解更多信息的话，请访问http://hanoi.kernelthread.com
#+ 或者 pp. 186-92 of _The Armchair Universe_ by A.K. Dewdney.
#
#
#           ...             ...         ...
#           | |             | |         | |
#          _|_|_            | |         | |
#         |_____|           | |         | |
#        |_______|          | |         | |
#       |_________|         | |         | |
#      |___________|        | |         | |
#     |             |       | |         | |
# .--------------------------------------------------------------. 
# |**************************************************************| 
#            #1              #2          #3
# #=================================================================#

E_NOPARAM=66  # 没有参数传给脚本。
E_BADPARAM=67 # 传给脚本的盘子个数不符合要求。
Moves=        # 保存移动次数的全局变量。
              # 这里修改了原来的脚本。

dohanoi() {   # 递归函数
    case $1 in
    0)
        ;;
    *)
        dohanoi &quot;$(($1-1))&quot; $2 $4 $3
        echo move $2 &quot;--&gt;&quot; $3
        ((Moves++))          # 这里修改了原来的脚本。
        dohanoi &quot;$(($1-1))&quot; $4 $3 $2
        ;;
    esac 
}

case $# in
    1) case $(($1&gt;0)) in     # 至少要有一个盘子
        1)  # Nested case statement.
            dohanoi $1 1 3 2
            echo &quot;Total moves = $Moves&quot;     # 2^n - 1, where n = # of disks.
            exit 0;
            ;; 
        *)    
            echo &quot;$0: illegal value for number of disks&quot;;
            exit $E_BADPARAM;
            ;;
        esac ;;
    *)
        echo &quot;usage: $0 N&quot;
        echo &quot;       Where \&quot;N\&quot; is the number of disks.&quot;
        exit $E_NOPARAM;
        ;;
    esac

# 练习:
# ---------
# 1) 这个位置以下的代码会不会执行？ 
#    为什么不(容易)
# 2) 解释一下这个 &quot;dohanoi&quot; 函数的运行原理.
#    (比较难 可以参考上面的Dewdney 的引用)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">24 函数</title>
    <id>https://clay-wangzhi.com/code/shell/part5/24_functions/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/24_functions/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_24-函数"> 24 函数</h1>
<h3 id="本章目录"> 本章目录</h3>
<ul>
<li><a href="./24_1_complex_functions_and_function_complexities.html">24.1 复杂函数和函数复杂性</a></li>
<li><a href="./24_2_local_variables.html">24.2 局部变量</a></li>
<li><a href="./24_3_recursion_without_local_variables.html">24.3 不使用局部变量的递归</a></li>
</ul>
<p>和其它“真正”的编程语言一样，Bash也有函数，尽管它在实现方面有一些限制。一个函数就是一个子程序，实现一系列操作的<a href="http://tldp.org/LDP/abs/html/special-chars.html#CODEBLOCKREF" target="_blank" rel="noopener noreferrer">代码块</a>，执行一个特定任务的“黑盒子”。有重复代码的地方，当一个过程只需要轻微修改任务就会重复执行的时候，那么你就需要考虑使用函数了。</p>
<div><pre><code>function function_name {
command...
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>或者</p>
<div><pre><code>function_name () { 
command...
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第二种形式可能会更受C程序员的喜爱（并且它更具有<a href="http://tldp.org/LDP/abs/html/portabilityissues.html" target="_blank" rel="noopener noreferrer">可移植性</a>）。
在C语言里面，函数的圆括号可以出现在第二行。</p>
<div><pre><code>function_name () {
command...
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 一个函数可能被“压缩”到一个单独行里。</p>
<div><pre><code>￼fun () { echo &quot;This is a function&quot;; echo; } 
#                                 ^     ^
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>然而，在这种情况下，函数里的最后一个命令必须跟有一个分号。</p>
<div><pre><code>fun () { echo &quot;This is a function&quot;; echo } # Error! 
#                                       ^
fun2 () { echo &quot;Even a single-command function? Yes!&quot;; } 
#                                                    ^
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>只需要引用函数名字就可以调用或者触发函数。一个函数调用相当于一个命令。</p>
<p>例子 24-1. 简单的函数</p>
<div><pre><code>#!/bin/bash
# ex59.sh: 练习函数(简单的).

JUST_A_SECOND=1

funky ()
{ # 这是一个简单的函数
    echo &quot;This is a funky function.&quot;
    echo &quot;Now exiting funky function.&quot;
} # 函数必须在调用前声明.


fun ()
{   # 一个稍微复杂点的函数.
    i=0
    REPEATS=30

    echo
    echo &quot;And now the fun really begins.&quot;
    echo

    sleep $JUST_A_SECOND    # Hey, 等一秒钟!
    while [ $i -lt $REPEATS ]
    do
        echo &quot;----------FUNCTIONS----------&gt;&quot;
        echo &quot;&lt;------------ARE-------------&quot;
        echo &quot;&lt;------------FUN------------&gt;&quot;
        echo
        let &quot;i+=1&quot;
    done
}

# 现在，调用这些函数.

funky
fun

exit $?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>函数定义必须在第一次函数调用之前。没有声明函数的方法，比如像C语言中一样。</p>
<div><pre><code>f1
# 将会产生一个错误消息，因为“f1”函数还没有定义。

declare -f f1      # 这样也不会有帮助。
f1                 # 仍然会产生一个错误消息。

# 然而...


f1 () {
    echo &quot;Calling function \&quot;f2\&quot; from within function \&quot;f1\&quot;.&quot;
    f2 
}

f2 () {
    echo &quot;Function \&quot;f2\&quot;.&quot;
}

f1  #  在此之前，事实上函数“f2”是没有被调用的，
    #+ 尽管在它定义之前被引用了。
    #  这是可以的。
    # 感谢, S.C.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" />  函数不能为空！</p>
<div><pre><code>#!/bin/bash
# empty-functionn.sh

empty () 
{
}

exit 0  # 这里将不会退出!


# $ sh empty-function.sh
# empty-function.sh: line 6: syntax error near unexpected token `}&#39;
# empty-function.sh: line 6: `}&#39;

# $ echo $? 
# 2

# 请注意，只包含注释的函数也是空函数。

func () 
{
    # 注释 1.
    # 注释 2.
    # 这仍然是一个空函数。
    # 感谢, Mark Bova将这一点指出来。
}
# 结果会出现和上面一样的错误信息。

# 然而 ...

not_quite_empty ()
{
    illegal_command
} #  一个包含这个函数的脚本将不会出错
    #+ 只要这个函数没有被调用。
not_empty ()
{
    :
} # 包含一个 : (空命令符），这样是可以的。

# 感谢, Dominick Geyer 和 Thiemo Kellner.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>甚至，把一个函数嵌套在另外一个函数里也是可行的，尽管这并没有什么用。</p>
<div><pre><code>f1 () 
{
    f2 () # 嵌套函数
    {
        echo &quot;Function \&quot;f2\&quot;, inside \&quot;f1\&quot;.&quot;
    }
}

f2  #  将会产生一个错误消息。
    #  即使有一个前置的 &quot;declare -f f2&quot; 也不会有什么作用。

echo

f1  #  不会做任何事情，因为调用“f1”的时候，并不会自动调用“f2”。
    #  现在，调用“f2”是可以的，
    #+ 因为通过调用“f1”，它的定义现在已是可见的。

    # 感谢, S.C.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>函数定义可能出现在不太可能出现的地方，甚至出现在本应该是命令出现的地方。</p>
<div><pre><code>ls -l | foo() { echo &quot;foo&quot;; }  # 可行的，尽管没有什么作用。


if [ &quot;$USER&quot; = bozo ]
then
    bozo_greet ()   # 函数定义嵌套在if/then的结构体中。
    {
        echo &quot;Hello, Bozo.&quot;
    }
fi

bozo_greet        # 只有Bozo用户工作，其它用户会得到一个错误消息。


# 在某些场景中，像下面这些东西可能会很有用。
NO_EXIT=1   # 将会激活下面的函数定义。

[[ $NO_EXIT -eq 1 ]] &amp;&amp; exit() { true; }     # 函数定义出现在“与列表”中。
# 如果 $NO_EXIT 等于 1, 定义 &quot;exit ()&quot;.
# 通过把exit函数别名为“true”，这样把内置的exit命令给禁用了。

exit  # 调用 &quot;exit ()&quot; 函数, 而不是内置的 &quot;exit&quot; 命令。


# 或者，类似地:
filename=file1

[ -f &quot;$filename&quot; ] &amp;&amp;
foo () { rm -f &quot;$filename&quot;; echo &quot;File &quot;$filename&quot; deleted.&quot;; } ||
foo () { echo &quot;File &quot;$filename&quot; not found.&quot;; touch bar; }

foo

# 感谢, S.C. 和 Christopher Head
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>函数名字可以呈现各种奇怪的形式。</p>
<div><pre><code>_(){ for i in {1..10}; do echo -n &quot;$FUNCNAME&quot;; done; echo; }
# ^^^         函数名字和圆括号之间没有空格。
#             这并不会总是会正常工作。为什么呢？

# 现在，我们来调用函数。
_         # __________
#           ^^^^^^^^^^   10 个下划线（10 倍的函数名字）！
# 一个“假”的下划线也是一个可以接受的函数名字。

# 事实上，一个分号也是一个可以接受的函数名字。

:(){ echo &quot;:&quot;; }; :

# 这有什么作用呢？
# 这是一个狡诈的方式去混淆脚本中的代码。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>也可以参见 <a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#GRONSFELD" target="_blank" rel="noopener noreferrer">Example A-56</a></p>
<p>小提示：当一个函数的不同版本出现在一个脚本中，会发生什么事情呢？</p>
<div><pre><code>#  正如Yan Chen 指出的那样,
#  当一个函数被多次定义的时候，
#  最后一个函数是被调用的那个。
#  然而这并不是特别有用。

func () 
{
    echo &quot;First version of func ().&quot;
}

func () 
{
    echo &quot;Second version of func ().&quot;
}

func   # 调用的是第二个 func () 函数版本。

exit $?

#  甚至，可能用函数去覆盖
#+ 或者占用系统命令。
#  当然，这并不是可取的。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">25. 别名</title>
    <id>https://clay-wangzhi.com/code/shell/part5/25_aliases/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/25_aliases/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_25-别名"> 25. 别名</h1>
<p>Bash <code>别名</code> 本质上不外乎是键盘上的快捷键，缩写呢是避免输入很长的命令串的一种手段.举个例子, 在 <a href="http://tldp.org/LDP/abs/html/sample-bashrc.html" target="_blank" rel="noopener noreferrer">~/.bashrc</a> 文件中包含别名 <code>lm=&quot;ls -l | more</code>, 而后每个命令行输入的 lm <a href="http://tldp.org/LDP/abs/html/aliases.html#FTN.AEN18669" target="_blank" rel="noopener noreferrer">[1]</a> 将会自动被替换成 <code>ls -l | more</code>. 这可以节省大量的命令行输入和避免记住复杂的命令和选项. 设定别名 <code>rm=&quot;rm -i&quot;</code> (交互的删除模式) 防止无意的删除重要文件，也许可以少些悲痛.</p>
<p>脚本中别名作用十分有限. 如果别名可以有一些 C 预处理器的功能会更好, 例如宏扩展, 但不幸的是 bash 别名中没有扩展参数. <a href="http://tldp.org/LDP/abs/html/aliases.html#FTN.AEN18676" target="_blank" rel="noopener noreferrer">[2]</a> 另外, 脚本在 &quot;复合结构&quot; 中并不能扩展自身的别名，例如 <a href="http://tldp.org/LDP/abs/html/tests.html#IFTHEN" target="_blank" rel="noopener noreferrer">if/then</a>, 循环和函数. 另一个限制是，别名不能递归扩展. 基本上是我们无论怎么喜欢用别名都不如函数 <a href="http://tldp.org/LDP/abs/html/functions.html#FUNCTIONREF" target="_blank" rel="noopener noreferrer">function</a> 来的更有效.</p>
<p>样例 25-1. 脚本中的别名</p>
<div><pre><code>#!/bin/bash
# alias.sh

shopt -s expand_aliases
# 必须设置此选项, 否则脚本不能别名扩展.


# 首先来点好玩的东西.
alias Jesse_James=&#39;echo &quot;\&quot;Alias Jesse James\&quot; was a 1959 comedy starring Bob Hope.&quot;&#39;
Jesse_James

echo; echo; echo;

alias ll=&quot;ls -l&quot;
# 可以任意使用单引号 (&#39;) 或双引号 (&quot;) 把别名括起来.

echo &quot;Trying aliased \&quot;ll\&quot;:&quot;
ll /usr/X11R6/bin/mk*   #* 别名可以运行.

echo

directory=/usr/X11R6/bin/
prefix=mk*  # See if wild card causes problems.
echo &quot;Variables \&quot;directory\&quot; + \&quot;prefix\&quot; = $directory$prefix&quot;
echo

alias lll=&quot;ls -l $directory$prefix&quot;

echo &quot;Trying aliased \&quot;lll\&quot;:&quot;
lll         # 所有 /usr/X11R6/bin 文件清单以 mk 开始.
# 别名可以处理连续的变量 -- 包含 wild card -- o.k.




TRUE=1

echo

if [ TRUE ]
then
  alias rr=&quot;ls -l&quot;
  echo &quot;Trying aliased \&quot;rr\&quot; within if/then statement:&quot;
  rr /usr/X11R6/bin/mk*   #* 结果报错!
  # 别名在复合的表达式中并没有生效.
  echo &quot;However, previously expanded alias still recognized:&quot;
  ll /usr/X11R6/bin/mk*
fi  

echo

count=0
while [ $count -lt 3 ]
do
  alias rrr=&quot;ls -l&quot;
  echo &quot;Trying aliased \&quot;rrr\&quot; within \&quot;while\&quot; loop:&quot;
  rrr /usr/X11R6/bin/mk*   #* 这里的别名也没生效.
                           #  alias.sh: 行 57: rrr: 命令未找到
  let count+=1
done 

echo; echo

alias xyz=&#39;cat $0&#39;   # 列出了自身.
                     # 注意强引.
xyz
#  这看起来能工作,
#+ 尽管 bash 文档不介意这么做.
#
#  然而, Steve Jacobson 指出,
#+ &quot;$0&quot; 参数的扩展在上面的别名申明后立刻生效.

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br></div></div><p>取消别名的命令删除之前设置的别名.</p>
<p>样例 25-2. unalias: 设置和取消一个别名</p>
<div><pre><code>#!/bin/bash
# unalias.sh

shopt -s expand_aliases  # 开启别名扩展.

alias llm=&#39;ls -al | more&#39;
llm

echo

unalias llm              # 取消别名.
llm
# &#39;llm&#39; 不再被识别后的报错信息.

exit 0
bash$ ./unalias.sh
total 6
drwxrwxr-x    2 bozo     bozo         3072 Feb  6 14:04 .
drwxr-xr-x   40 bozo     bozo         2048 Feb  6 14:04 ..
-rwxr-xr-x    1 bozo     bozo          199 Feb  6 14:04 unalias.sh

./unalias.sh: llm: 命令未找到
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h4 id="注意"> 注意</h4>
<p><a href="http://tldp.org/LDP/abs/html/aliases.html#AEN18669" target="_blank" rel="noopener noreferrer">[1]</a>	... 作为命令行的第一个词. 显然别名只在命令的开始有意义.
<a href="http://tldp.org/LDP/abs/html/aliases.html#AEN18676" target="_blank" rel="noopener noreferrer">[2]</a>	然而, 别名可用来扩展位置参数.</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第二十六章. 列表结构</title>
    <id>https://clay-wangzhi.com/code/shell/part5/26_List_Constructs/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/26_List_Constructs/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第二十六章-列表结构"> 第二十六章. 列表结构</h1>
<p><em>and 列表</em> 和 <em>or 列表</em> 结构提供了连续执行若干命令的方法，可以有效地替换复杂的嵌套 <a href="http://tldp.org/LDP/abs/html/testconstructs.html#TESTCONSTRUCTS1" target="_blank" rel="noopener noreferrer">if/then</a> ，甚至 <a href="http://tldp.org/LDP/abs/html/testbranch.html#CASEESAC1" target="_blank" rel="noopener noreferrer">case</a> 语句。</p>
<h3 id="链接多个命令"> 链接多个命令</h3>
<p><strong>and 列表</strong></p>
<p><code>command-1 &amp;&amp; command-2 &amp;&amp; command-3 &amp;&amp; ... command-n</code></p>
<p>只要前一个命令返回 <em>true</em>（即 0），每一个命令就依次执行。当第一个 <em>false</em>（即 非0）返回时，命令链条即终止（第一个返回 <em>false</em> 的命令是最后一个执行的）。</p>
<p>在<a href="https://github.com/yongye" target="_blank" rel="noopener noreferrer">YongYe</a>早期版本的<a href="http://bash.deta.in/Tetris_Game.sh" target="_blank" rel="noopener noreferrer">俄罗斯方块游戏</a>脚本里，一个有趣的双条件 <em>and 列表</em> 用法：</p>
<div><pre><code>equation()

{  # core algorithm used for doubling and halving the coordinates
   [[ ${cdx} ]] &amp;&amp; ((y=cy+(ccy-cdy)${2}2))
   eval ${1}+=\&quot;${x} ${y} \&quot;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>例 26-1. 使用 <em>and 列表</em> 来测试命令行参数</strong></p>
<div><pre><code>#!/bin/bash
# and list

if [ ! -z &quot;$1&quot; ] &amp;&amp; echo &quot;Argument #1 = $1&quot; &amp;&amp; [ ! -z &quot;$2&quot; ] &amp;&amp; \
#                ^^                         ^^               ^^
echo &quot;Argument #2 = $2&quot;
then
  echo &quot;At least 2 arguments passed to script.&quot;
  # 链条内的所有命令都返回 true。
else
  echo &quot;Fewer than 2 arguments passed to script.&quot;
  # 链条内至少有一个命令返回 false。
fi  
# 注意： &quot;if [ ! -z $1 ]&quot; 是好用的，但是宣传与之等同的
#   &quot;if [ -n $1 ]&quot; 并不好用。
#  不过，用引号就能解决问题，
#   &quot;if [ -n &quot;$1&quot; ]&quot; 好用（译者注：原文本行内第一个引号位置错了）。
#           ^  ^    小心!
# 被测试的变量放在引号内总是最好的选择。


# 下面的代码功能一样，用的是“纯粹”的 if/then 语句。
if [ ! -z &quot;$1&quot; ]
then
  echo &quot;Argument #1 = $1&quot;
fi
if [ ! -z &quot;$2&quot; ]
then
  echo &quot;Argument #2 = $2&quot;
  echo &quot;At least 2 arguments passed to script.&quot;
else
  echo &quot;Fewer than 2 arguments passed to script.&quot;
fi
# 比起用“and 列表”要更长、更笨重。


exit $?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p><strong>例 26-2. 使用 <em>and 列表</em> 来测试命令行参数2</strong></p>
<div><pre><code>#!/bin/bash

ARGS=1        # 预期的参数数量。
E_BADARGS=85  # 参数数量错误时返回的值。

test $# -ne $ARGS &amp;&amp; \
#    ^^^^^^^^^^^^ 条件 #1
echo &quot;Usage: `basename $0` $ARGS argument(s)&quot; &amp;&amp; exit $E_BADARGS
#                                             ^^
#  如果条件 #1 结果为 true (传递给脚本的参数数量错误),
#+ 那么执行本行剩余的命令，脚本终止。

# 下面的代码行只有在上面的测试失败时才执行。
echo &quot;Correct number of arguments passed to this script.&quot;

exit 0

#  如果要检查退出值，脚本终止后运行 &quot;echo $?&quot;。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>当然，<em>and 列表</em> 也可以给变量设置默认值。</p>
<div><pre><code>arg1=$@ &amp;&amp; [ -z &quot;$arg1&quot; ] &amp;&amp; arg1=DEFAULT

              # 如果有命令行参数，则把参数值赋给 $arg1 。
              # 但是... 如果没有参数，则使用DEFAULT给 $arg1 赋值。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>or 列表</strong></p>
<div><pre><code>command-1 || command-2 || command-3 || ... command-n
</code></pre>
<div><span>1</span><br></div></div><p>只要前一个命令返回_false_，每一个命令就依次执行。当第一个_true_ 返回时，命令链条即终止（第一个返回_true_ 的命令是最后一个执行的）。很明显它与“and 列表”相反。</p>
<p>例 26-3. <em>or 列表</em> 与 <em>and 列表</em> 结合使用</p>
<div><pre><code>#!/bin/bash

#  delete.sh, 不那么巧妙的文件删除工具。
#  用法： delete 文件名

E_BADARGS=85

if [ -z &quot;$1&quot; ]
then
  echo &quot;Usage: `basename $0` filename&quot;
  exit $E_BADARGS  # No arg? Bail out.
else  
  file=$1          # Set filename.
fi  


[ ! -f &quot;$file&quot; ] &amp;&amp; echo &quot;File \&quot;$file\&quot; not found. \
Cowardly refusing to delete a nonexistent file.&quot;
# AND 列表，如果文件不存在则显示出错信息。
# 注意，echo 消息内容分成了两行，中间通过转义符（\）连接。

[ ! -f &quot;$file&quot; ] || (rm -f $file; echo &quot;File \&quot;$file\&quot; deleted.&quot;)
# OR 列表，删除存在的文件。

# 注意上面的逻辑颠倒。 Note logic inversion above.
# “AND 列表” 在得到 true 时执行, “OR 列表”在得到 false 时执行。

exit $?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/caution.gif"> 如果 <em>or 列表</em> 第一个命令返回 true，它<strong>会</strong>执行。</p>
<div><pre><code># ==&gt; 下面的代码段来自 /etc/rc.d/init.d/single
#+==&gt; 作者 Miquel van Smoorenburg
#+==&gt; 说明了 &quot;and&quot; 和 &quot;or&quot; 列表。
# ==&gt; 带箭头的注释是本文作者添加的。

[ -x /usr/bin/clear ] &amp;&amp; /usr/bin/clear
  # ==&gt; 如果 /usr/bin/clear 存在, 则调用它。
  # ==&gt; 调用命令之前检查它是否存在，
  #+==&gt; 可以避免出错消息和其他怪异的结果。

  # ==&gt; . . .

#  If they want to run something in single user mode, might as well run it...
for i in /etc/rc1.d/S[0-9][0-9]* ; do
        # 检查脚本是否存在。
        [ -x &quot;$i&quot; ] || continue
  # ==&gt; 如果对应的文件在 $PWD 里*没有*找到，
  #+==&gt; 则跳回到循环顶端“继续运行”。

        # 丢弃备份文件和 rpm 生成的文件。
        case &quot;$1&quot; in
                *.rpmsave|*.rpmorig|*.rpmnew|*~|*.orig)
                        continue;;
        esac
        [ &quot;$i&quot; = &quot;/etc/rc1.d/S00single&quot; ] &amp;&amp; continue
  # ==&gt; 设置脚本名，但先不要执行
        $i start
done

  # ==&gt; . . .
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><img src="http://tldp.org/LDP/abs/images/important.gif">
_and 列表_ 或 _or 列表_ 的[退出状态](http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF)就是最后一个执行的命令的退出状态。
<p>聪明地结合 <em>and 列表</em> 和 <em>or 列表</em> 是可能的，但是程序逻辑会很容易地变得令人费解，需要密切注意<a href="http://tldp.org/LDP/abs/html/opprecedence.html#OPPRECEDENCE1" target="_blank" rel="noopener noreferrer">操作符优先规则</a>，而且，会带来大量的调试工作。</p>
<div><pre><code>false &amp;&amp; true || echo false         # false

# 下面的代码结果相同
( false &amp;&amp; true ) || echo false     # false
# 但这个就不同了
false &amp;&amp; ( true || echo false )     # (什么都不显示)

#  注意语句是从左到右组合和解释的。

#  通常情况下最好避免这种复杂性。

#  感谢, S.C.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#DAYSBETWEEN" target="_blank" rel="noopener noreferrer">例 A-7</a> 和 <a href="http://tldp.org/LDP/abs/html/fto.html#BROKENLINK" target="_blank" rel="noopener noreferrer">例 7-4</a> 解释了用 <em>and 列表</em> / <em>or 列表</em> 来测试变量。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">27 数组</title>
    <id>https://clay-wangzhi.com/code/shell/part5/27_arrays/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/27_arrays/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_27-数组"> 27 数组</h1>
<p>新版本的Bash支持一维数组。 数组元素可以使用符号<strong>variable[xx]</strong> 来初始化。另外，脚本可以使用<strong>declare -a variable</strong>语句来制定一个数组。 如果想引用一个数组元素（也就是取值），可以使用大括号，访问形式为 ${element[xx]} 。</p>
<p>例子 27-1. 简单的数组使用</p>
<div><pre><code>#!/bin/bash

area[11]=23
area[13]=37
area[51]=UFOs

#  数组成员不一定非得是相邻或连续的。

#  数组的部分成员可以不被初始化。
#  数组中允许空缺元素。
#  实际上，保存着稀疏数据的数组（“稀疏数组”） 
#+ 在电子表格处理软件中是非常有用的。

echo -n &quot;area[11] = &quot;
echo ${area[11]}    #  需要{大括号}。

echo -n &quot;area[13] = &quot;
echo ${area[13]}

echo &quot;Contents of area[51] are ${area[51]}.&quot;

# 没被初始化的数组成员打印为空值（null变量）。
echo -n &quot;area[43] = &quot;
echo ${area[43]}
echo &quot;(area[43] unassigned)&quot;

echo

# 两个数组元素的和被赋值给另一个数组元素。
area[5]=`expr ${area[11]} + ${area[13]}`
echo &quot;area[5] = area[11] + area[13]&quot;
echo -n &quot;area[5] = &quot;
echo ${area[5]}

area[6]=`expr ${area[11]} + ${area[51]}`
echo &quot;area[6] = area[11] + area[51]&quot;
echo -n &quot;area[6] = &quot;
echo ${area[6]}
# 这里会失败，是因为不允许整数与字符串相加。

echo; echo; echo

# -----------------------------------------------------------------
# 另一个数组, &quot;area2&quot;.

# 另一种给数组变量赋值的方法...
# array_name=( XXX YYY ZZZ ... )

area2=( zero one two three four )

echo -n &quot;area2[0] = &quot;
echo ${area2[0]}
# 啊哈，从0开始计算数组下标（也就是，数组的第一个元素为[0],而不是[1]).

echo -n &quot;area2[1] = &quot;
echo ${area2[1]}    # [1] 是数组的第二个元素。
# -----------------------------------------------------------------

echo; echo; echo

# -----------------------------------------------
# 第三个数组， &quot;area3&quot;.
# 另外一种给数组元素赋值的方法...
# array_name=([xx]=XXX [yy]=YYY ...)

area3=([17]=seventeen [24]=twenty-four)

echo -n &quot;area3[17] = &quot;
echo ${area3[17]}

echo -n &quot;area3[24] = &quot;
echo ${area3[24]}
# -----------------------------------------------

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><p>我们可以看出，初始化整数的一个简单的方法是 array=( element1 element2 ... elementN ) 。</p>
<div><pre><code>base64_charset=( {A..Z} {a..z} {0..9} + / = )
#  使用扩展的一对范围 Using extended brace expansion
#+ 去初始化数组的元素。to initialize the elements of the array.
# 从 vladz&#39;s &quot;base64.sh&quot; 脚本中摘录过来。
#+ 在&quot;Contributed Scripts&quot; 附录中可以看到.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Bash允许把变量当成数据来操作，即使这个变量没有明确地被声明为数组。</p>
<div><pre><code>string=abcABC123ABCabc
echo ${string[@]}   # abcABC123ABCabc
echo ${string[*]}   # abcABC123ABCabc
echo ${string[0]}   # abcABC123ABCabc
echo ${string[1]}   # 没有输出！
                    # 为什么?
echo ${#string[@]}  # 1
                    # 数组中只有一个元素。
                    # 就是这个字符串本身。

# 感谢你, Michael Zick, 指出这一点.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>类似的示范可以参考 <a href="./../part2/04_3_bash_variables_are_untyped.html">Bash变量是无类型的</a> 。</p>
<p>例子 27-2. 格式化一首诗</p>
<div><pre><code>#!/bin/bash
# poem.sh: 将本书作者非常喜欢的一首诗，漂亮的打印出来。

# 诗的行数 (单节).
Line[1]=&quot;I do not know which to prefer,&quot;
Line[2]=&quot;The beauty of inflections&quot;
Line[3]=&quot;Or the beauty of innuendoes,&quot;
Line[4]=&quot;The blackbird whistling&quot;
Line[5]=&quot;Or just after.&quot;
# 注意 引用允许嵌入的空格。

# 出处.
Attrib[1]=&quot; Wallace Stevens&quot;
Attrib[2]=&quot;\&quot;Thirteen Ways of Looking at a Blackbird\&quot;&quot;
# 这首诗已经是公共版权了 (版权已经过期了).

echo

tput bold   # 粗体打印.

for index in 1 2 3 4 5    # 5行.
do
    printf &quot;     %s\n&quot; &quot;${Line[index]}&quot;
done

for index in 1 2          # 出处为2行。
do
    printf &quot;        %s\n&quot; &quot;${Attrib[index]}&quot;
done

tput sgr0       # 重置终端。Reset terminal.
                # 查看 &#39;tput&#39; 文档.
echo

exit 0

# 练习:
# --------
# 修改这个脚本，使其能够从一个文本数据文件中提取出一首诗的内容，然后将其漂亮的打印出来。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>数组元素有它们独特的语法，甚至标准Bash命令和操作符，都有特殊的选项用以配合数组操作。</p>
<p>例子 27-3. 多种数组操作</p>
<div><pre><code>#!/bin/bash
# array-ops.sh: 更多有趣的数组用法.

array=( zero one two three four five )
# 数组元素 0   1   2    3     4    5

echo ${array[0]}        #  0
echo ${array:0}         #  0
                        #  第一个元素的参数扩展,
                        #+ 从位置0(#0)开始（即第一个字符）.
echo ${array:1}         #  ero
                        #  第一个元素的参数扩扎，
                        #+ 从位置1（#1）开始（即第二个字符）。

echo &quot;--------------&quot;

echo ${#array[0]}       #  4
                        # 第一个数组元素的长度。
echo ${#array}          #4
                        # 第一个数组元素的长度。
                        #  (另一种表示形式)

echo ${#array[1]}       # 3
                        # 第二个数组元素的长度。
                        #  Bash中的数组是从0开始索引的。

echo ${#array[*]}       # 6
                        # 数组中的元素个数。
echo ${#array[@]}       # 6
                        # 数组中的元素个数.
echo &quot;--------------&quot;

array2=( [0]=&quot;first element&quot; [1]=&quot;second element&quot; [3]=&quot;fourth element&quot; )
#            ^     ^       ^     ^      ^       ^     ^      ^       ^
# 引用允许嵌入的空格,在每个单独的数组元素中。

echo ${array2[0]}       # 第一个元素
echo ${array2[1]}       # 第二个元素
echo ${array2[2]}       #
                        # 因为并没有被初始化，所以此值为null。
echo ${array2[3]}       # 第四个元素.
echo ${#array2[0]}      # 13    (第一个元素的长度)
echo ${#array2[*]}      # 3     (数组中元素的个数)

exit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>大部分标准<a href="./../part3/10_1_manipulating_strings.html">字符串操作</a> 都可以用于数组中。</p>
<p>例子27-4. 用于数组的字符串操作</p>
<div><pre><code>#!/bin/bash
# array-strops.sh: 用于数组的字符串操作。

# 本脚本由Michael Zick 所编写.
# 通过了授权在本书中使用。
# 修复: 05 May 08, 04 Aug 08.

#  一般来说，任何类似于 ${name ... }(这种形式)的字符串操作
#+ 都能够应用于数组中的所有字符串元素，
#+ 比如说${name[@] ... } 或者 ${name[*] ...} 这两种形式。 

arrayZ=( one two three four five five )

echo

# 提取尾部的子串。
echo ${arrayZ[@]:0}     # one two three four five five
#                ^       所有元素 

echo ${arrayZ[@]:1} 	# two three four five five
#                ^		element[0]后边的所有元素.

echo ${arrayZ[@]:1:2} 	# two three
#                  ^	只提取element[0]后边的两个元素.

echo &quot;---------&quot;


# 子串删除 

# 从字符串的开头删除最短的匹配。

echo ${arrayZ[@]#f*r}   # one two three five five
#               ^       # 匹配将应用于数组的所有元素。 
                        # 匹配到了&quot;four&quot;,并且将它删除。 

# 从字符串的开头删除最长的匹配
echo ${arrayZ[@]##t*e}  # one two four five five
#               ^^      # 匹配将应用于数组的所有元素
                        # 匹配到了 &quot;three&quot; ,并且将它删除。

# 从字符串的结尾删除最短的匹配
echo ${arrayZ[@]%h*e}   # one two t four five five
#               ^       # 匹配将应用于数组的所有元素
                        # 匹配到了 &quot;hree&quot; ,并且将它删除。
					
# 从字符串的结尾删除最长的匹配
echo ${arrayZ[@]%%t*e}  # one two four five five
#               ^^      # 匹配将应用于数组的所有元素
                        # 匹配到了 &quot;three&quot; ,并且将它删除。
						
echo &quot;----------------------&quot;

# 子串替换

# 第一个匹配到的子串将会被替换。
echo ${arrayZ[@]/fiv/XYZ}   # one two three four XYZe XYZe
#               ^           # 匹配将应用于数组的所有元素

# 所有匹配到的子串将会被替换。
echo ${arrayZ[@]//iv/YY}    # one two three four fYYe fYYe
                            # 匹配将应用于数组的所有元素

# 删除所有的匹配子串
# 如果没有指定替换字符串的话，那就意味着&#39;删除&#39;...
echo ${arrayZ[@]//fi/}      # one two three four ve ve
#               ^^          # 匹配将应用于数组的所有元素

# 替换字符串前端子串
echo ${arrayZ[@]/#fi/XY}    # one two three four XYve XYve
#                ^          # 匹配将应用于数组的所有元素

# 替换字符串后端子串
echo ${arrayZ[@]/%ve/ZZ}	# one two three four fiZZ fiZZ
#                ^			# 匹配将应用于数组的所有元素

echo ${arrayZ[@]/%o/XX}		# one twXX three four five five
#                ^			# 为什么?

echo &quot;-----------------------------&quot;

replacement() {
    echo -n &quot;!!!&quot;
}

echo ${arrayZ[@]/%e/$(replacement)}
#                ^  ^^^^^^^^^^^^^^
# on!!! two thre!!! four fiv!!! fiv!!!
# replacement()的标准输出就是那个替代字符串.
# Q.E.D: 替换动作实际上是一个‘赋值’。

echo &quot;------------------------------------&quot;

#  使用&quot;for-each&quot;之前:
echo ${arrayZ[@]//*/$(replacement optional_arguments)}
#                ^^ ^^^^^^^^^^^^^
# !!! !!! !!! !!! !!! !!!

#  现在，如果Bash只将匹配到的字符串
#+ 传递给被调用的函数...

echo

exit 0

#  在将处理后的结果发送到大工具之前，比如-- Perl, Python, 或者其它工具
#  回忆一下:
#    $( ... ) 是命令替换。
#    一个函数作为子进程运行。
#    一个函数将结果输出到stdout。
#    赋值，结合&quot;echo&quot;和命令替换，
#+   可以读取函数的stdout.
#    使用name[@]表示法指定了一个 &quot;for-each&quot;
#+   操作。
#  Bash比你想象的更加强力.

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br></div></div><p><a href="./../part3/12_command_substitution.html">命令替换</a> 可以构造数组的独立元素。</p>
<p>例子 27-5. 将脚本中的内容赋值给数组</p>
<div><pre><code>#!/bin/bash
# script-array.sh: 将脚本中的内容赋值给数组。 
# 这个脚本的灵感来自于 Chris Martii 的邮件 (感谢!).

script_contents=( $(cat &quot;$0&quot;) )  # 将这个脚本的内容($0） 
                                 #+ 赋值给数组
for element in $(seq 0 $((${#script_contents[@]} - 1)))
  do                #  ${#script_contents[@]}
                    #+ 表示数组元素的个数
                    #
                    #  问题:
                    #  为什么必须使用seq 0 ?
                    #  用seq 1来试一下.
  echo -n &quot;${script_contents[$element]}&quot;
                    # 在同一行上显示脚本中每个域的内容。
# echo -n &quot;${script_contents[element]}&quot; also works because of ${ ... }.
  echo -n &quot; -- &quot;    # 使用 &quot; -- &quot; 作为域分隔符。
done
echo

exit 0
# 练习:
# --------
#  修改这个脚本，
#+ 让这个脚本能够按照它原本的格式输出，
#+ 连同空格，换行，等等。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>在数组环境中，某些Bash <a href="./../part4/15_internal_commands_and_builtins.html">内建命令</a> 的含义可能会有些轻微的改变。比如，<a href="http://tldp.org/LDP/abs/html/internal.html#UNSETREF" target="_blank" rel="noopener noreferrer">unset</a> 命令可以删除数组元素，甚至能够删除整个数组。</p>
<p>例子 27-6. 一些数组的专有特性</p>
<div><pre><code>#!/bin/bash

declare -a colors
#  脚本中所有的后续命令都会把
#+ &quot;colors&quot; 当做数组 

echo &quot;Enter your favorite colors (separated from each other by a space).&quot;

read -a colors    # 至少需要键入3种颜色，以便于后边的演示。
#  &#39;read&#39;命令的特殊选项 ,
#+ 允许给数组元素赋值。

echo

element_count=${#colors[@]}
# 提取数组元素个数的特殊语法
#     用element_count=${#colors[*]} 也可以。
#
#  &quot;@&quot; 变量允许在引用中存在单次分割，
#+ (依靠空白字符来分割变量).
#
#  这就好像&quot;$@&quot; 和 &quot;$*&quot;
#+ 在位置参数中所表现出来的行为一样。

index=0

while [ &quot;$index&quot; -lt &quot;$element_count&quot; ]
do    # 列出数组中的所有元素
  echo ${colors[$index]}
  #    ${colors[index]} 也可以工作，因为它${ ... }之中.
  let &quot;index = $index + 1&quot;
  # Or:
  #    ((index++))
done
# 每个数组元素被列为单独的一行
# 如果没有这种要求的话，可以使用echo -n &quot;${colors[$index]} &quot;
#
# 也可以使用“for”循环来做:
#   for i in &quot;${colors[@]}&quot;
#   do
#     echo &quot;$i&quot;
#   done
# (Thanks, S.C.)

echo

# 再次列出数组中的所有元素，不过这次的做法更为优雅。
  echo ${colors[@]}          # echo ${colors[*]} 也可以工作.

echo

# &quot;unset&quot;命令既可以删除数组数据，也可以删除整个数组。
unset colors[1]			# 删除数组的第2个元素。
						# 作用等同于colors[1]=
echo  ${colors[@]}		# 再次列出数组内容，第2个元素没了。

unset colors			# 删除整个数组。
						#  unset colors[*] 以及
						#+ unset colors[@] 都可以.
echo; echo -n &quot;Colors gone.&quot;
echo ${colors[@]}		# 再次列出数组内容，内容为空。
exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><p>正如我们在前面的例子中所看到的，<strong><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span><span>a</span><span style="margin-right:0.02778em;">rr</span><span>a</span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>n</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>am</span><span>e</span><span>[</span><span>@</span><span>]</span></span><span style="margin-right:0.2222222222222222em;"></span><span>∗</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.68333em;vertical-align:0em;"></span><span>∗</span><span>或者</span><span style="margin-right:0.2222222222222222em;"></span><span>∗</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.46528em;vertical-align:0em;"></span><span>∗</span></span></span></span>{array_name[*]}</strong>  都与数组中的所有元素相关。同样的，为了计算数组的元素个数，可以使用 <strong><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span><span>a</span><span style="margin-right:0.02778em;">rr</span><span>a</span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>n</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>am</span><span>e</span><span>[</span><span>@</span><span>]</span></span><span style="margin-right:0.2222222222222222em;"></span><span>∗</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.68333em;vertical-align:0em;"></span><span>∗</span><span>或者</span><span style="margin-right:0.2222222222222222em;"></span><span>∗</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.46528em;vertical-align:0em;"></span><span>∗</span></span></span></span>{array_name[*]}</strong>  。 <strong><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;#&#039; at position 2: {#̲array_name}**  …'>{#array_name}**  是数组第一个元素的长度，也就是  **</span>{array_name[0]}</strong>  的长度（字符个数）。</p>
<p>例子 27-7. 空数组与包含空元素的数组</p>
<div><pre><code>#!/bin/bash
# empty-array.sh

#  感谢Stephane Chazelas制作这个例子的原始版本。 
#+ 同时感谢Michael Zick 和 Omair Eshkenazi 对这个例子所作的扩展。
#  以及感谢Nathan Coulter 作的声明和感谢。

# 空数组与包含有空元素的数组，这两个概念不同。
  
array0=( first second third )
array1=( &#39;&#39; )		# &quot;array1&quot; 包含一个空元素.
array2=( )			# 没有元素. . . &quot;array2&quot;为空 
array3=()			# 这个数组呢?

echo
ListArray()
{
	echo
	echo &quot;Elements in array0:  ${array0[@]}&quot;
	echo &quot;Elements in array1:  ${array1[@]}&quot;
	echo &quot;Elements in array2:  ${array2[@]}&quot;
	echo &quot;Elements in array3:  ${array3[@]}&quot;
	echo
	echo &quot;Length of first element in array0 = ${#array0}&quot;
	echo &quot;Length of first element in array1 = ${#array1}&quot;
	echo &quot;Length of first element in array2 = ${#array2}&quot;
	echo &quot;Length of first element in array3 = ${#array3}&quot;
	echo
	echo &quot;Number of elements in array0 = ${#array0[*]}&quot;  # 3
	echo &quot;Number of elements in array1 = ${#array1[*]}&quot;  # 1  (Surprise!)
	echo &quot;Number of elements in array2 = ${#array2[*]}&quot;  # 0
	echo &quot;Number of elements in array3 = ${#array3[*]}&quot;  # 0
}

# ===================================================================

ListArray

# 尝试扩展这些数组。

# 添加一个元素到这个数组。
array0=( &quot;${array0[@]}&quot; &quot;new1&quot; )
array1=( &quot;${array1[@]}&quot; &quot;new1&quot; )
array2=( &quot;${array2[@]}&quot; &quot;new1&quot; )
array3=( &quot;${array3[@]}&quot; &quot;new1&quot; )

ListArray

# 或者
array0[${#array0[*]}]=&quot;new2&quot;
array1[${#array1[*]}]=&quot;new2&quot;
array2[${#array2[*]}]=&quot;new2&quot;
array3[${#array3[*]}]=&quot;new2&quot;

ListArray

# 如果你按照上边的方法对数组进行扩展的话，数组比较像‘栈’
# 上边的操作就是‘压栈’
# ‘栈’的高度为：
height=${#array2[@]}
echo
echo &quot;Stack height for array2 = $height&quot;

# &#39;出栈’就是：
unset array2[${#array2[@]}-1]   # 数组从0开始索引 
height=${#array2[@]}            #+ 这就意味着数组的第一个下标是0
echo
echo &quot;POP&quot;
echo &quot;New stack height for array2 = $height&quot;

ListArray

# 只列出数组array0的第二个和第三个元素。
from=1              # 从0开始索引。
to=2
array3=( ${array0[@]:1:2} )
echo
echo &quot;Elements in array3:  ${array3[@]}&quot;

# 处理方式就像是字符串（字符数组）。
# 试试其他的“字符串”形式。

# 替换:
array4=( ${array0[@]/second/2nd} )
echo
echo &quot;Elements in array4:  ${array4[@]}&quot;

# 替换掉所有匹配通配符的字符串
array5=( ${array0[@]//new?/old} )
echo
echo &quot;Elements in array5:  ${array5[@]}&quot;

# 当你觉得对此有把握的时候...
array6=( ${array0[@]#*new} )
echo # This one might surprise you.
echo &quot;Elements in array6:  ${array6[@]}&quot;

array7=( ${array0[@]#new1} )
echo # 数组array6之后就没有惊奇了。
echo &quot;Elements in array7:  ${array7[@]}&quot;

# 看起来非常像...
array8=( ${array0[@]/new1/} )
echo
echo &quot;Elements in array8:  ${array8[@]}&quot;

# 所以，让我们怎么形容呢？

#  对数组var[@]中的每个元素The string operations are performed on
#+ 进行连续的字符串操作。each of the elements in var[@] in succession.
#  因此：Bash支持支持字符串向量操作，
#  如果结果是长度为0的字符串
#+ 元素会在结果赋值中消失不见。
#  然而，如果扩展在引用中，那个空元素会仍然存在。

#  Michael Zick:   问题--这些字符串是强引用还是弱引用？ 
#  Nathan Coulter:  没有像弱引用的东西
#!    真正发生的事情是
#!+   匹配的格式发生在
#!+   [word]的所有其它扩展之后
#!+   比如像${parameter#word}.

zap=&#39;new*&#39;
array9=( ${array0[@]/$zap/} )
echo
echo &quot;Number of elements in array9:  ${#array9[@]}&quot;
array9=( &quot;${array0[@]/$zap/}&quot; )
echo &quot;Elements in array9:  ${array9[@]}&quot;
# 此时，空元素仍然存在
echo &quot;Number of elements in array9:  ${#array9[@]}&quot;

# 当你还在认为你身在Kansas州时...
array10=( ${array0[@]#$zap} )
echo
echo &quot;Elements in array10:  ${array10[@]}&quot;
# 但是，如果被引用的话，*号将不会被解释。
array10=( ${array0[@]#&quot;$zap&quot;} )
echo
echo &quot;Elements in array10:  ${array10[@]}&quot;
# 可能，我们仍然在Kansas...
# (上面的代码块Nathan Coulter所修改.)

#  比较 array7 和array10.
#  比较array8 和array9.

#  重申: 所有所谓弱引用的东西
#  Nathan Coulter 这样解释:
#  word在${parameter#word}中的匹配格式在
#+ 参数扩展之后和引用移除之前已经完成了。
#  在通常情况下，格式匹配在引用移除之后完成。

exit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br></div></div><p><strong><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span><span>a</span><span style="margin-right:0.02778em;">rr</span><span>a</span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>n</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>am</span><span>e</span><span>[</span><span>@</span><span>]</span></span><span style="margin-right:0.2222222222222222em;"></span><span>∗</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.68333em;vertical-align:0em;"></span><span>∗</span><span>和</span><span style="margin-right:0.2222222222222222em;"></span><span>∗</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.46528em;vertical-align:0em;"></span><span>∗</span></span></span></span>{array_name[*]}</strong> 的关系非常类似于 <a href="http://tldp.org/LDP/abs/html/internalvariables.html#APPREF" target="_blank" rel="noopener noreferrer"><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.69444em;vertical-align:0em;"></span><span>@</span><span>和</span></span></span></span>*</a>。这种数组用法非常广泛。</p>
<div><pre><code># 复制一个数组
array2=( &quot;${array1[@]}&quot; )
# 或者
array2=&quot;${array1[@]}&quot;
#
# 然而，如果在“缺项”数组中使用的话，将会失败 
#+ 也就是说数组中存在空洞（中间的某个元素没赋值），
#+ 这个问题由Jochen DeSmet 指出.
# ------------------------------------------
  array1[0]=0
# array1[1] not assigned
  array1[2]=2
  array2=( &quot;${array1[@]}&quot; )       # 拷贝它？
echo ${array2[0]}      # 0
echo ${array2[2]}      # (null), 应该是 2
# ------------------------------------------
# 添加一个元素到数组。
array=( &quot;${array[@]}&quot; &quot;new element&quot; )
# 或者
array[${#array[*]}]=&quot;new element&quot;
# 感谢, S.C.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/tip.gif" alt="info" /> <strong>array=( element1 element2 ... elementN )</strong> 初始化操作，如果有<a href="./../part3/12_command_substitution.html">命令替换</a>的帮助，就可以将一个文本文件的内容加载到数组。</p>
<div><pre><code>#!/bin/bash
filename=sample_file
#            cat sample_file
#
# 			1  a  b  c
# 			2  d  e  fg

declare -a array1

array1=( `cat &quot;$filename&quot;`)		#  将$filename的内容
#         把文件内容展示到输出	#+ 加载到数组array1.
#
#  array1=( `cat &quot;$filename&quot; | tr &#39;\n&#39; &#39; &#39;`)
#                           把文件中的换行替换为空格 
# 其实这样做是没必要的，因为Bash在做单词分割的时候， 
#+将会把换行转换为空格。

echo ${array1[@]}            # 打印数组
#                              1 a b c 2 d e fg
#
#  文件中每个被空白符分割的“单词”
#+ 都被保存到数组的一个元素中。

element_count=${#array1[*]}
echo $element_count          # 8
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>出色的技巧使得数组的操作技术又多了一种。</p>
<p>例子 27-8. 初始化数组</p>
<div><pre><code>#! /bin/bash
# array-assign.bash

# 数组操作是Bash所特有的，
#+ 所以才使用&quot;.bash&quot; 作为脚本扩展名

# Copyright (c) Michael S. Zick, 2003, All rights reserved.
# License: Unrestricted reuse in any form, for any purpose.
# Version: $ID$
#
# 说明与注释由 William Park所添加.

#  基于 Stephane Chazelas所提供的例子
#+ 它是在ABS中的较早版本。

# &#39;times&#39; 命令的输出格式:
# User CPU &lt;space&gt; System CPU
# User CPU of dead children &lt;space&gt; System CPU of dead children

#  Bash有两种方法， 
#+ 可以将一个数组的所有元素都赋值给一个新的数组变量。
#  这两个方法都会丢弃数组中的“空引用“（null值）元素
#+ 在2.04和以后的Bash版本中。
#  另一种给数组赋值的方法将会被添加到新版本的Bash中，
#+ 这种方法采用[subscript]=value 形式，来维护数组下标与元素值之间的关系。 

#  可以使用内部命令来构造一个大数组，
#+ 当然，构造一个包含上千元素数组的其它方法
#+ 也能很好的完成任务

declare -a bigOne=( /dev/* )  # /dev下的所有文件 . . .
echo
echo &#39;Conditions: Unquoted, default IFS, All-Elements-Of&#39;
echo &quot;Number of elements in array is ${#bigOne[@]}&quot;

# set -vx

echo
echo &#39;- - testing: =( ${array[@]} ) - -&#39;
times
declare -a bigTwo=( ${bigOne[@]} )
# 注意括号:    ^              ^
times
echo

echo &#39;- - testing: =${array[@]} - -&#39;
times
declare -a bigThree=${bigOne[@]}
# 这次没用括号。
times
#  通过比较，可以发现第二种格式的赋值更快一些，
#+ 正如 Stephane Chazelas指出的那样
#
#  William Park 解释:
#+ bigTwo数组是作为一个单个字符串被赋值的(因为括号)
#+ 而BigThree数组，则是一个元素一个元素进行的赋值。
#  所以，实质上是:
#                   bigTwo=( [0]=&quot;...&quot; [1]=&quot;...&quot; [2]=&quot;...&quot; ... )
#                   bigThree=( [0]=&quot;... ... ...&quot; )
#
#  通过这样确认:  echo ${bigTwo[0]}
#                   echo ${bigThree[0]}
#  在本书的例子中，我还是会继续使用第一种形式， 
#+ 因为，我认为这种形式更有利于将问题阐述清楚。

#  在我所使用的例子中，在其中复用的部分，
#+ 还是使用了第二种形式，那是因为这种形式更快。

# MSZ: 很抱歉早先的疏忽。

#  注意:
#  ----
#  32和44的&quot;declare -a&quot; 语句其实不是必需的， 
#+ 因为Array=(...)形式
#+ 只能用于数组
#  然而，如果省略这些声明的话，
#+ 会导致脚本后边的相关操作变慢。
#  试试看，会发生什么.

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 在数组声明的时候添加一个额外的<strong>declare -a</strong>语句，能够加速后续的数组操作速度。</p>
<p>例子 27-9. 拷贝和连接数组</p>
<div><pre><code>#! /bin/bash
# CopyArray.sh
#
# 这个脚本由Michael Zick所编写.
# 这里已经通过作者的授权

#  如何“通过名字传值&amp;通过名字返回”
#+ 或者“建立自己的赋值语句”。

CpArray_Mac() {
	# 建立赋值命令
	echo -n &#39;eval &#39;
    echo -n &quot;$2&quot;                    # 目的名字
    echo -n &#39;=( ${&#39;
    echo -n &quot;$1&quot;                    # 源名字
    echo -n &#39;[@]} )&#39;

# 上边这些语句会构成一条命令。
# 这仅仅是形式上的问题。
}

declare -f CopyArray
CopyArray=CpArray_Mac

Hype() {
# &quot;Pointer&quot;函数
# 状态产生器
# 需要连接的数组名为$1.
# (把这个数组与字符串&quot;Really Rocks&quot;结合起来，形成一个新数组.)
# 并将结果从数组$2中返回.

    local -a TMP
    local -a hype=( Really Rocks )
    $($CopyArray $1 TMP)
    TMP=( ${TMP[@]} ${hype[@]} )
    $($CopyArray TMP $2)
}

declare -a before=( Advanced Bash Scripting )
declare -a after

echo &quot;Array Before = ${before[@]}&quot;

Hype before after

echo &quot;Array After = ${after[@]}&quot;

# 连接的太多了?

echo &quot;What ${after[@]:3:2}?&quot;
declare -a modest=( ${after[@]:2:1} ${after[@]:3:2} )
#                    ---- 子串提取 ----

echo &quot;Array Modest = ${modest[@]}&quot;

# &#39;before&#39; 发生了什么变化 ?

echo &quot;Array Before = ${before[@]}&quot;

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><p>例子27-10. 关于串联数组的更多信息</p>
<div><pre><code>#! /bin/bash
# array-append.bash

# Copyright (c) Michael S. Zick, 2003, All rights reserved.
# License: Unrestricted reuse in any form, for any purpose.
# Version: $ID$
#
#  在格式上，由M.C做了一些修改.

# 数组操作是Bash特有的属性。
# 传统的UNIX /bin/sh 缺乏类似的功能。

#  将这个脚本的输出通过管道传递给&#39;more&#39;，
#+ 这样做的目的是放止输出的内容超过终端能够显示的范围，
#  或者，重定向输出到文件中。

declare -a array1=( zero1 one1 two1 )
# 依次使用下标
declare -a array2=( [0]=zero2 [2]=two2 [3]=three2 )
# 数组中存在空缺的元素-- [1] 未定义

echo
echo &#39;- Confirm that the array is really subscript sparse. -&#39;
echo &quot;Number of elements: 4&quot;        # 为了演示，这里作了硬编码
for (( i = 0 ; i &lt; 4 ; i++ ))
do
    echo &quot;Element [$i]: ${array2[$i]}&quot;
done
# 也可以参考一个更通用的例子， basics-reviewed.bash.


declare -a dest

# 将两个数组合并到第3个数组中。
echo
echo &#39;Conditions: Unquoted, default IFS, All-Elements-Of operator&#39;
echo &#39;- Undefined elements not present, subscripts not maintained. -&#39;
# # 那些未定义的元素不会出现；组合时会丢弃这些元素。

dest=( ${array1[@]} ${array2[@]} )
# dest=${array1[@]}${array2[@]} 		# 奇怪的结果，可能是个bug。

# 现在，打印结果。
echo
echo &#39;- - Testing Array Append - -&#39;
cnt=${#dest[@]}

echo &quot;Number of elements: $cnt&quot;
for (( i = 0 ; i &lt; cnt ; i++ ))
do
    echo &quot;Element [$i]: ${dest[$i]}&quot;
done

# 将数组赋值给一个数组中的元素（两次）
dest[0]=${array1[@]}
dest[1]=${array2[@]}

# 打印结果
echo
echo &#39;- - Testing modified array - -&#39;
cnt=${#dest[@]}

echo &quot;Number of elements: $cnt&quot;
for (( i = 0 ; i &lt; cnt ; i++ ))
do
echo &quot;Element [$i]: ${dest[$i]}&quot;
done

# 检查第二个元素的修改状况.
echo
echo &#39;- - Reassign and list second element - -&#39;

declare -a subArray=${dest[1]}
cnt=${#subArray[@]}

echo &quot;Number of elements: $cnt&quot;
for (( i = 0 ; i &lt; cnt ; i++ ))
do
    echo &quot;Element [$i]: ${subArray[$i]}&quot;
done

# 如果你使用&#39;=${ ... }&#39;形式
#+ 将一个数组赋值到另一个数组的一个元素中,
#+ 那么这个数组的所有元素都会被转换为一个字符串,
#+ 这个字符串中的每个数组元素都以空格进行分隔(其实是IFS的第一个字符).

# 如果原来数组中的所有元素都不包含空白符 . . .
# 如果原来的数组下标都是连续的 . . .
# 那么我们就可以将原来的数组进行恢复.

# 从修改过的第二个元素中, 将原来的数组恢复出来.
echo
echo &#39;- - Listing restored element - -&#39;

declare -a subArray=( ${dest[1]} )
cnt=${#subArray[@]}

echo &quot;Number of elements: $cnt&quot;
for (( i = 0 ; i &lt; cnt ; i++ ))
do
    echo &quot;Element [$i]: ${subArray[$i]}&quot;
done

echo &#39;- - Do not depend on this behavior. - -&#39;
echo &#39;- - This behavior is subject to change - -&#39;
echo &#39;- - in versions of Bash newer than version 2.05b - -&#39;

# MSZ: 抱歉，之前混淆了一些要点。

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br></div></div><hr>
<p>有了数组, 我们就可以在脚本中实现一些比较熟悉的算法. 这么做, 到底是不是一个好主意, 我们在这里不做讨论, 还是留给读者决定吧.</p>
<p>例子 27-11. 冒泡排序</p>
<div><pre><code>#!/bin/bash
# bubble.sh: 一种排序方式, 冒泡排序.

# 回忆一下冒泡排序的算法. 我们在这里要实现它...

# 依靠连续的比较数组元素进行排序,
#+ 比较两个相邻元素, 如果顺序不对, 就交换这两个元素的位置.
# 当第一轮比较结束之后, 最&quot;重&quot;的元素就会被移动到最底部.
# 当第二轮比较结束之后, 第二&quot;重&quot;的元素就会被移动到次底部的位置.
# 依此类推.
# 这意味着每轮比较不需要比较之前已经&quot;沉淀&quot;好的数据.
# 因此你会注意到后边的数据在打印的时候会快一些.


exchange() {
  # 交换数组中的两个元素.
  local temp=${Countries[$1]} #  临时保存
                              #+ 要交换的那个元素 
  Countries[$1]=${Countries[$2]}
  Countries[$2]=$temp
  
  return 
}

declare -a Countries  #  声明数组,
                      #+ 此处是可选的, 因为数组在下面被初始化
#  我们是否可以使用转义符(\)
#+ 来将数组元素的值放在不同的行上?
#  可以.

Countries=(Netherlands Ukraine Zaire Turkey Russia Yemen Syria \
Brazil Argentina Nicaragua Japan Mexico Venezuela Greece England \
Israel Peru Canada Oman Denmark Wales France Kenya \
Xanadu Qatar Liechtenstein Hungary)

# &quot;Xanadu&quot; 虚拟出来的世外桃源.
#+ Kubla Khan做了个愉快的决定


clear                      # 开始之前的清屏动作

echo &quot;0: ${Countries[*]}&quot;  # 从索引0开始列出整个数组.

number_of_elements=${#Countries[@]}
let &quot;comparisons = $number_of_elements - 1&quot;

count=1 # Pass number.

while [ &quot;$comparisons&quot; -gt 0 ]          # 开始外部循环
do

  index=0  # 在每轮循环开始之前，重置索引。

  while [ &quot;$index&quot; -lt &quot;$comparisons&quot; ] # 开始内部循环。
  do
    if [ ${Countries[$index]} \&gt; ${Countries[`expr $index + 1`]} ]
	# 如果原来的排序次序不对...
	# 回想一下, 在单括号中,
	#+ \&gt;是ASCII码的比较操作符.

	# if [[ ${Countries[$index]} &gt; ${Countries[`expr $index + 1`]} ]]
	#+ 这样也行.
    then
      exchange $index `expr $index + 1`  # 交换
    fi
    let &quot;index += 1&quot;  #或者, index+=1 在Bash 3.1之后的版本才能这么用.
  done # 内部循环结束

  # ----------------------------------------------------------------------
# Paulo Marcel Coelho Aragao 建议我们可以使用更简单的for循环
#
# for (( last = $number_of_elements - 1 ; last &gt; 0 ; last-- ))
##                     Fix by C.Y. Hunt          ^   (Thanks!)
# do
#     for (( i = 0 ; i &lt; last ; i++ ))
#     do
#		[[ &quot;${Countries[$i]}&quot; &gt; &quot;${Countries[$((i+1))]}&quot; ]] \
#    		&amp;&amp; exchange $i $((i+1))
#     done
# done
# ----------------------------------------------------------------------


let &quot;comparisons -= 1&quot; #  因为最&quot;重&quot;的元素到了底部,
                       #+ 所以每轮我们可以少做一次比较。

echo
echo &quot;$count: ${Countries[@]}&quot;  # 每轮结束后, 都打印一次数组.
echo
let &quot;count += 1&quot;                # 增加传递计数.

done                            # 外部循环结束
                                # 至此, 全部完成.
exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br></div></div><hr>
<p>我们可以在数组中嵌套数组么？</p>
<div><pre><code>#!/bin/bash
# &quot;嵌套&quot; 数组.

#  Michael Zick 提供了这个用例。
#+ William Park做了一些修正和说明.

AnArray=( $(ls --inode --ignore-backups --almost-all \
        --directory --full-time --color=none --time=status \
        --sort=time -l ${PWD} ) )  # Commands and options.

# 空格是有意义的 . . . 并且不要在上边用引号引用任何东西.

SubArray=( ${AnArray[@]:11:1}  ${AnArray[@]:6:5} )
#  这个数组有六个元素:
#+     SubArray=( [0]=${AnArray[11]} [1]=${AnArray[6]} [2]=${AnArray[7]}
#      [3]=${AnArray[8]} [4]=${AnArray[9]} [5]=${AnArray[10]} )
#
#  Bash数组是字符串(char *)类型
#+ 的(循环)链表
#  因此, 这不是真正意义上的嵌套数组,
#+ 只不过功能很相似而已.

echo &quot;Current directory and date of last status change:&quot;
echo &quot;${SubArray[@]}&quot;

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><hr>
<p>如果将“嵌套数组”与<a href="http://tldp.org/LDP/abs/html/bashver2.html#VARREFNEW" target="_blank" rel="noopener noreferrer">间接引用</a> 组合起来使用的话，将会产生一些非常有趣的用法。</p>
<p>例子 27-12. 嵌套数组与间接引用</p>
<div><pre><code>#!/bin/bash
# embedded-arrays.sh
# 嵌套数组和间接引用.

# 本脚本由Dennis Leeuw 编写.
# 经过授权, 在本书中使用.
# 本书作者做了少许修改.

ARRAY1=(
        VAR1_1=value11
        VAR1_2=value12
        VAR1_3=value13
)

ARRAY2=(
        VARIABLE=&quot;test&quot;
        STRING=&quot;VAR1=value1 VAR2=value2 VAR3=value3&quot;
        ARRAY21=${ARRAY1[*]}
)       # 将ARRAY1嵌套到这个数组中.

function print () {
        OLD_IFS=&quot;$IFS&quot;
        IFS=$&#39;\n&#39;       #  这么做是为了每行
                        #+ 只打印一个数组元素.
        TEST1=&quot;ARRAY2[*]&quot;
        local ${!TEST1} # 删除这一行, 看看会发生什么?
        #  间接引用.
        #  这使得$TEST1
        #+ 只能够在函数内被访问.

        #  让我们看看还能干点什么.

        echo
        echo &quot;\$TEST1 = $TEST1&quot;       #  仅仅是变量名字.
        echo; echo
        echo &quot;{\$TEST1} = ${!TEST1}&quot;  #  变量内容.
                                      #  这就是
                                      #+ 间接引用的作用.
        echo
        echo &quot;-------------------------------------------&quot;; echo
        echo

        # 打印变量
        echo &quot;Variable VARIABLE: $VARIABLE&quot;

        # 打印一个字符串元素
        IFS=&quot;$OLD_IFS&quot;
        TEST2=&quot;STRING[*]&quot;
        local ${!TEST2}      # 间接引用(同上).
        echo &quot;String element VAR2: $VAR2 from STRING&quot;

        # Print an array element
        TEST2=&quot;ARRAY21[*]&quot;
		local ${!TEST2}      # 间接引用(同上).
		echo &quot;Array element VAR1_1: $VAR1_1 from ARRAY21&quot;
}

print
echo

exit 0

# 脚本作者注,
#+ &quot;你可以很容易的将其扩展成一个能创建hash 的Bash 脚本.&quot;
# (难) 留给读者的练习: 实现它.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><hr>
<p>数组使得埃拉托色尼素数筛子有了shell版本的实现. 当然, 如果你需要的是追求效率的应用, 那么就 应该使用编译行语言来实现, 比如C语言. 因为脚本运行的太慢了.</p>
<p>例子 27-13. 埃拉托色尼素数筛子</p>
<div><pre><code>#!/bin/bash
# sieve.sh (ex68.sh)

# 埃拉托色尼素数筛子
# 找素数的经典算法.

# 在同等数值的范围内,
#+ 这个脚本运行的速度比C版本慢的多.

LOWER_LIMIT=1       # 从1开始.
UPPER_LIMIT=1000    # 到1000.
# (如果你时间很多的话 . . . 你可以将这个数值调的很高.)

PRIME=1
NON_PRIME=0

let SPLIT=UPPER_LIMIT/2
# 优化:
# 只需要测试中间到最大的值,为什么?

declare -a Primes
# Primes[] 是个数组.


initialize ()
{
	# 初始化数组.
	i=$LOWER_LIMIT
	until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]
	do
	  Primes[i]=$PRIME
	  let &quot;i += 1&quot;
	done
	#  假定所有数组成员都是需要检查的(素数)
	#+ 直到检查完成.
}

print_primes ()
{
	# 打印出所有数组Primes[]中被标记为素数的元素.
	
	i=$LOWER_LIMIT

	until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]
	do
	  if [ &quot;${Primes[i]}&quot; -eq &quot;$PRIME&quot; ]
	  then
		printf &quot;%8d&quot; $i
		# 每个数字打印前先打印8个空格, 在偶数列才打印.
	  fi

	  let &quot;i += 1&quot;

	done
}

sift () # 查出非素数.
{
	let i=$LOWER_LIMIT+1
	# 我们从2开始.

	until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]
	do

	if [ &quot;${Primes[i]}&quot; -eq &quot;$PRIME&quot; ]
	# 不要处理已经过滤过的数字(被标识为非素数).
	then
	  t=$i

	  while [ &quot;$t&quot; -le &quot;$UPPER_LIMIT&quot; ]
	  do
		let &quot;t += $i &quot;
		Primes[t]=$NON_PRIME
		# 标识为非素数.
	  done 
	fi
	 
	let &quot;i += 1&quot;
	done
}

# ==============================================
# main ()
# 继续调用函数.
initialize
sift
print_primes
# 这里就是被称为结构化编程的东西.
# ==============================================
echo

exit 0

# -------------------------------------------------------- #
# 因为前面的&#39;exit&#39;语句, 所以后边的代码不会运行

#  下边的代码, 是由Stephane Chazelas 所编写的埃拉托色尼素数筛子的改进版本,
#+ 这个版本可以运行的快一些.

# 必须在命令行上指定参数(这个参数就是: 寻找素数的限制范围)

UPPER_LIMIT=$1                  # 来自于命令行.
let SPLIT=UPPER_LIMIT/2         # 从中间值到最大值.

Primes=( &#39;&#39; $(seq $UPPER_LIMIT) )

i=1
until (( ( i += 1 ) &gt; SPLIT ))  # 仅需要从中间值检查.
do
  if [[ -n ${Primes[i]} ]]
  then
    t=$i
    until (( ( t += i ) &gt; UPPER_LIMIT ))
    do
      Primes[t]=
    done
  fi 
done
echo ${Primes[*]}

exit $?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br></div></div><p>例子 27-14. 埃拉托色尼素数筛子，优化版</p>
<div><pre><code>#!/bin/bash
# 优化过的埃拉托色尼素数筛子
# 脚本由Jared Martin编写, ABS Guide 的作者作了少许修改.
# 在ABS Guide 中经过了许可而使用(感谢!).

# 基于Advanced Bash Scripting Guide中的脚本.
# http://tldp.org/LDP/abs/html/arrays.html#PRIMES0 (ex68.sh).

# http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf (引用)
# Check results against http://primes.utm.edu/lists/small/1000.txt

# Necessary but not sufficient would be, e.g.,
#     (($(sieve 7919 | wc -w) == 1000)) &amp;&amp; echo &quot;7919 is the 1000th prime&quot;

UPPER_LIMIT=${1:?&quot;Need an upper limit of primes to search.&quot;}

Primes=( &#39;&#39; $(seq ${UPPER_LIMIT}) )

typeset -i i t
Primes[i=1]=&#39;&#39; # 1不是素数 
until (( ( i += 1 ) &gt; (${UPPER_LIMIT}/i) ))  # 只需要ith-way 检查.
  do                                         # 为什么?
    if ((${Primes[t=i*(i-1), i]}))
    # 很少见， 但是很有指导意义, 在下标中使用算术扩展。
	then
      until (( ( t += i ) &gt; ${UPPER_LIMIT} ))
        do Primes[t]=; done
    fi
  done

# echo ${Primes[*]}
echo   # 改回原来的脚本，为了漂亮的打印(80-col. 展示).
printf &quot;%8d&quot; ${Primes[*]}
echo; echo

exit $?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>上边的这个例子是基于数组的素数产生器, 还有不使用数组的素数产生器<a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#PRIMES" target="_blank" rel="noopener noreferrer">例子A-15</a> 和<a href="http://tldp.org/LDP/abs/html/mathc.html#PRIMES2" target="_blank" rel="noopener noreferrer">例子 16-46</a>，让我们来比较一番.</p>
<hr>
<p>数组可以进行一定程度上的扩展, 这样就可以模拟一些Bash原本不支持的数据结构.</p>
<p>例子 27-15. 模拟一个压入栈</p>
<div><pre><code>#!/bin/bash
# stack.sh: 模拟压入栈

# 类似于CPU 栈, 压入栈依次保存数据项, 
#+ 但是取数据时, 却反序进行, 后进先出.

BP=100		#  栈数组的基址指针.
			#  从元素100 开始.

SP=$BP		#  栈指针.
			#  将其初始化为栈&quot;基址&quot;(栈底)

Data=		#  当前栈的数据内容.
			#  必须定义为全局变量,
			#+ 因为函数所能够返回的整数存在范围限制.

			# 100	基址				&lt;-- Base Pointer
			#  99	第一个数据元素
			#  98	第二个数据元素
			# ...	更多数据
			#		最后一个数据元素	&lt;-- Stack pointer

declare -a stack

push()		# 压栈
{
	if [ -z &quot;$1&quot; ]		# 没有可压入的数据项?
	then
		return 
	fi

	let &quot;SP -= 1&quot;		# 更新栈指针.
	stack[$SP]=$1
	return 
}

pop()	 #从栈中弹出数据项. 
{ 
	Data=						# 清空保存数据项的中间变量

	if [ &quot;$SP&quot; -eq &quot;$BP&quot; ]		# 栈空?
	then
		return 
	fi						# 这使得SP不会超过100,
							#+ 例如, 这可以防止堆栈失控.


	Data=${stack[$SP]}
	let &quot;SP += 1&quot;			# 更新栈指针
	return
}

status_report()			# 打印当前状态
{
	echo &quot;-------------------------------------&quot;
	echo &quot;REPORT&quot;
	echo &quot;Stack Pointer = $SP&quot;
	echo &quot;Just popped \&quot;&quot;$Data&quot;\&quot; off the stack.&quot;
	echo &quot;-------------------------------------&quot;
	echo
}


# =======================================================
# 现在, 来点乐子.

echo

# 看你是否能从空栈里弹出数据项来.
pop
status_report

echo

push garbage
pop
status_report			# 压入Garbage, 弹出garbage.

value1=23;			push $value1
value2=skidoo;		push $value2
value3=LAST;		push $value3

pop					# LAST
status_report
pop					# skidoo
status_report
pop					# 23
status_report		# 后进，先出!

# 注意: 栈指针在压栈时减,
#+ 在弹出时加.

echo

exit 0


# =======================================================
#
# 练习：
#
# 1) 修改&quot;push()&quot;函数，
# 	+ 使其调用一次就能够压入多个数据项。

# 2) 修改&quot;pop()&quot;函数,
#	+ 使其调用一次就能弹出多个数据项.

# 3) 给那些有临界操作的函数添加出错检查.
#	 说明白一些, 就是让这些函数返回错误码, 
#	+ 返回的错误码依赖于操作是否成功完成, 
#	+ 如果没有成功完成, 那么就需要启动合适的处理动作.

# 4) 以这个脚本为基础,
#	+ 编写一个用栈实现的四则运算计算器.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br></div></div><hr>
<p>如果想对数组&quot;下标&quot;做一些比较诡异的操作, 可能需要使用中间变量. 对于那些有这种需求的项目来说, 还是应该考虑使用功能更加强大的编程语言, 比如Perl或C。</p>
<p>例子 27-16. 复杂的数组应用: 探索一个神秘的数学序列</p>
<div><pre><code>!/bin/bash

# Douglas Hofstadter 的声名狼藉的序列&quot;Q-series&quot;:

# Q(1) = Q(2) = 1
# Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), 当 n&gt;2时

#  这是一个令人感到陌生的, 没有规律的&quot;乱序&quot;整数序列
#+ 并且行为不可预测
#  序列的头20项, 如下所示:
#  1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12

#  请参考相关书籍, Hofstadter的, &quot;_Goedel, Escher, Bach: An Eternal Golden Braid_&quot;,
#+ 第137页.


LIMIT=100     # 需要计算的数列长度.
LINEWIDTH=20  # 每行打印的个数.

Q[1]=1        # 数列的头两项都为1.
Q[2]=1

echo
echo &quot;Q-series [$LIMIT terms]:&quot;
echo -n &quot;${Q[1]} &quot;             # 输出数列头两项.
echo -n &quot;${Q[2]} &quot;

for ((n=3; n &lt;= $LIMIT; n++))  # C风格的循环条件.
do   # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]]  for n&gt;2
#    需要将表达式拆开, 分步计算,
#+   因为Bash 不能够很好的处理复杂数组的算术运算.

	let &quot;n1 = $n - 1&quot;        # n-1
	let &quot;n2 = $n - 2&quot;        # n-2

	t0=`expr $n - ${Q[n1]}`  # n - Q[n-1]
	t1=`expr $n - ${Q[n2]}`  # n - Q[n-2]

	T0=${Q[t0]}			# Q[n - Q[n-1]]
	T1=${Q[t1]}			# Q[n - Q[n-2]]


	Q[n]=`expr $T0 + $T1`	# Q[n - Q[n-1]] + Q[n - Q[n-2]]
	echo -n &quot;${Q[n]} &quot;

	if [ `expr $n % $LINEWIDTH` -eq 0 ]		# 格式化输出
	then   #      ^ 取模操作
		echo # 把每行都拆为20个数字的小块.
	fi

done

echo

exit 0

# 这是Q-series的一个迭代实现.
# 更直接明了的实现是使用递归, 请读者作为练习完成.
# 警告: 使用递归的方法来计算这个数列的话, 会花费非常长的时间.
#+ C/C++ 将会计算的快一些。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><hr>
<p>Bash仅仅支持一维数组, 但是我们可以使用一个小手段, 这样就可以模拟多维数组了.</p>
<p>例子 27-17. 模拟一个二维数组，并使它倾斜</p>
<div><pre><code>#!/bin/bash
# twodim.sh: 模拟一个二维数组.

# 一维数组由单行组成.
# 二维数组由连续的多行组成.

Rows=5
Columns=5
# 5 X 5 的数组.

declare -a alpha		# char alpha [Rows] [Columns];
						# 没必要声明. 为什么?

load_alpha ()
{
	local rc=0
	local index

	for i in A B C D E F G H I J K L M N O P Q R S T U V W X Y
	do     # 你可以随你的心意, 使用任意符号.
	  local row=`expr $rc / $Columns`
	  local column=`expr $rc % $Rows`
	  let &quot;index = $row * $Rows + $column&quot;
	  alpha[$index]=$i
	# alpha[$row][$column]
	  let &quot;rc += 1&quot;
	done
	# 更简单的方法:
	#+   declare -a alpha=( A B C D E F G H I J K L M N O P Q R S T U V W X Y )
	#+ 但是如果写的话, 就缺乏二维数组的&quot;风味&quot;了.
}

print_alpha ()
{
	local row=0
	local index
	echo
	while [ &quot;$row&quot; -lt &quot;$Rows&quot; ]   #  以&quot;行序为主&quot;进行打印:
	do                             #+ 行号不变(外层循环),							
								   #+ 列号进行增长.
	  local column=0

	  echo -n &quot;       &quot;            #  按照行方向打印&quot;正方形&quot;数组.

	  while [ &quot;$column&quot; -lt &quot;$Columns&quot; ]
	  do
		let &quot;index = $row * $Rows + $column&quot;
		echo -n &quot;${alpha[index]} &quot;  # alpha[$row][$column]
		let &quot;column += 1&quot;
	  done

	  let &quot;row += 1&quot;
	  echo
	done
	# 更简单的等价写法为:
	#     echo ${alpha[*]} | xargs -n $Columns
	echo 
}

filter ()     # 过滤掉负的数组下标.
{

	echo -n &quot;  &quot;  # 产生倾斜.
				  # 解释一下, 这是怎么做到的.
	if [[ &quot;$1&quot; -ge 0 &amp;&amp;  &quot;$1&quot; -lt &quot;$Rows&quot; &amp;&amp; &quot;$2&quot; -ge 0 &amp;&amp; &quot;$2&quot; -lt &quot;$Columns&quot; ]]
	then
		let &quot;index = $1 * $Rows + $2&quot;
		# 现在, 按照旋转方向进行打印.
		echo -n &quot; ${alpha[index]}&quot;
		#           alpha[$row][$column]
	fi 

}

rotate ()  #  将数组旋转45度 --
{          #+ 从左下角进行&quot;平衡&quot;.
	local row
	local column

	for (( row = Rows; row &gt; -Rows; row-- ))
	  do       # 反向步进数组, 为什么?
	  
	  for (( column = 0; column &lt; Columns; column++ ))
	  do

		if [ &quot;$row&quot; -ge 0 ]
		then
		  let &quot;t1 = $column - $row&quot;
		  let &quot;t2 = $column&quot;
		else
		  let &quot;t1 = $column&quot;
		  let &quot;t2 = $column + $row&quot;
		fi
		filter $t1 $t2			# 将负的数组下标过滤出来.
								# 如果你不做这一步, 将会怎样?
	  done
	  echo; echo

	done

#  数组旋转的灵感来源于Herbert Mayer 所著的
#+ &quot;Advanced C Programming on the IBM PC&quot;的例子(第143-146页)
#+ (参见参考书目).
#  由此可见, C语言能够做到的好多事情,
#+ 用shell 脚本一样能够做到.
}


#--------------- 现在, 让我们开始吧. ------------#
load_alpha			# 加载数组
print_alpha			# 打印数组.
rotate				# 逆时钟旋转45度打印.
#-----------------------------------------------------#

exit 0

# 这有点做作, 不是那么优雅.

# 练习:
# -----
#  1) 重新实现数组加载和打印函数,
#     让其更直观, 可读性更强. 
#
#  2) 详细地描述旋转函数的原理.
#     提示: 思考一下倒序索引数组的实现.
#
#  3) 重写这个脚本, 扩展它, 让不仅仅能够支持非正方形的数组.
#     比如6 X 4的数组.
#     尝试一下, 在数组旋转时, 做到最小&quot;失真&quot;.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br></div></div><p>二维数组本质上其实就是一个一维数组, 只不过是添加了行和列的寻址方式, 来引用和操作数组的元素而已.</p>
<p>这里有一个精心制作的模拟二维数组的例子, 请参考<a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#LIFESLOW" target="_blank" rel="noopener noreferrer">例子 A-10</a>.</p>
<hr>
<p>还有更多使用数组的有趣的脚本，请参考：</p>
<ul>
<li><a href="http://tldp.org/LDP/abs/html/commandsub.html#AGRAM2" target="_blank" rel="noopener noreferrer">例子 12-3</a></li>
<li><a href="http://tldp.org/LDP/abs/html/mathc.html#PRIMES2" target="_blank" rel="noopener noreferrer">例子 16-46</a></li>
<li><a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#HASHEX2" target="_blank" rel="noopener noreferrer">例子 A-22</a></li>
<li><a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#HOMEWORK" target="_blank" rel="noopener noreferrer">例子 A-44</a></li>
<li><a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#QKY" target="_blank" rel="noopener noreferrer">例子 A-41</a></li>
<li><a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#NIM" target="_blank" rel="noopener noreferrer">例子 A-42</a></li>
</ul>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">30 网络编程</title>
    <id>https://clay-wangzhi.com/code/shell/part5/30_network_programming/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/30_network_programming/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_30-网络编程"> 30 网络编程</h1>
<blockquote>The Net's a cross between an elephant and a white elephant sale: it never forgets, and it's always crap.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--Nemo</blockquote>
<p>Linux系统拥有一系列的工具，用于访问、操作和调解网络连接。我们能够把其中的一部分工具整合到脚本中 -- 这些脚本能扩展我们对网络的认知，有用的脚本还能方便网络管理。</p>
<p>以下是一个简单的CGI脚本，阐述如何连接到远程服务器。</p>
<p>例子 30-1. 打印服务器环境</p>
<div><pre><code>#!/bin/bash
# test-cgi.sh
# by Michael Zick
# Used with permission

# 您应该根据您的情况修改相应的Bash路径
# （在ISP的服务器中，Bash一般不会放在正常的位置）
# 其他位置： /usr/bin 或者 /usr/local/bin
# 甚至应该在sha-bang中不用任何路径运行它

# 取消通配符
set -f

# Http Header（译者注：此头信息是告诉浏览器服务器返回的内容格式）
echo Content-type: text/plain
echo

echo CGI/1.0 test script report:
echo

echo environment settings:
set
echo

echo whereis bash?
whereis bash
echo


echo who are we?
echo ${BASH_VERSINFO[*]}
echo

echo argc is $#. argv is &quot;$*&quot;.
echo

# CGI/1.0 预期的环境变量。

echo SERVER_SOFTWARE = $SERVER_SOFTWARE
echo SERVER_NAME = $SERVER_NAME
echo GATEWAY_INTERFACE = $GATEWAY_INTERFACE
echo SERVER_PROTOCOL = $SERVER_PROTOCOL
echo SERVER_PORT = $SERVER_PORT
echo REQUEST_METHOD = $REQUEST_METHOD
echo HTTP_ACCEPT = &quot;$HTTP_ACCEPT&quot;
echo PATH_INFO = &quot;$PATH_INFO&quot;
echo PATH_TRANSLATED = &quot;$PATH_TRANSLATED&quot;
echo SCRIPT_NAME = &quot;$SCRIPT_NAME&quot;
echo QUERY_STRING = &quot;$QUERY_STRING&quot;
echo REMOTE_HOST = $REMOTE_HOST
echo REMOTE_ADDR = $REMOTE_ADDR
echo REMOTE_USER = $REMOTE_USER
echo AUTH_TYPE = $AUTH_TYPE
echo CONTENT_TYPE = $CONTENT_TYPE
echo CONTENT_LENGTH = $CONTENT_LENGTH

exit 0

# 在这里，文档给出一些简短的指令。
:&lt;&lt;-&#39;_test_CGI_&#39;

1) 将此文档放到http://domain.name/cgi-bin的目录。
2) 然后，访问http://domain.name/cgi-bin/test-cgi.sh.

_test_CGI_
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><p>出于安全的考虑，确认连接计算机的IP地址是有用的。
例子 30-2. IP地址</p>
<div><pre><code>#!/bin/bash
# ip-addresses.sh
# 列出您的计算机所连接的IP地址。

#  受Greg Bledsoe的ddos.sh脚本所启发，
#  Linux Journal，2011年3月9号。
#    URL:
#  http://www.linuxjournal.com/content/back-dead-simple-bash-complex-ddos
#  Greg licensed his script under the GPL2,
#+ and as a derivative, this script is likewise GPL2.

connection_type=TCP      # 也可以使用UDP
field=2           # Which field of the output we&#39;re interested in.
no_match=LISTEN   # 过滤出包含此字符串的记录，为什么？
lsof_args=-ni     # -i 列出互联网相关的文件。
                  # -n 使用数值IP地址。
		  # 如果不使用-n选项，会发生什么情况？试试看。
router=&quot;[0-9][0-9][0-9][0-9][0-9]-&gt;&quot;
#       删除路由信息。

lsof &quot;$lsof_args&quot; | grep $connection_type | grep -v &quot;$no_match&quot; |
      awk &#39;{print $9}&#39; | cut -d : -f $field | sort | uniq |
      sed s/&quot;^$router&quot;//

#  Bledsoe的脚本将过滤出的IP地址结果赋给一个变量（类似上面的19行到22行）。
#  他检查连接到一个IP地址的多个连接，
#  使用：
#
#    iptables -I INPUT -s $ip -p tcp -j REJECT --reject-with tcp-reset
#
#  ... 在每一次的60秒延迟循环中，拒绝来自DDOS攻击的数据包。


#  练习：
#  --------
#  使用&#39;iptable&#39;命令扩展这个脚本
#+ 来拒绝一些来自垃圾邮件发送者的IP域名的连接请求。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><hr>
<p>更多网络编程的例子：</p>
<ul>
<li><a href="http://tldp.org/LDP/abs/html/devref1.html#NPREF" target="_blank" rel="noopener noreferrer">Getting the time from nist.gov</a></li>
<li><a href="http://tldp.org/LDP/abs/html/devref1.html#NW001" target="_blank" rel="noopener noreferrer">Downloading a URL</a></li>
<li><a href="http://tldp.org/LDP/abs/html/system.html#IPSCRIPT0" target="_blank" rel="noopener noreferrer">A GRE tunnel</a></li>
<li><a href="http://tldp.org/LDP/abs/html/communications.html#PING0" target="_blank" rel="noopener noreferrer">Checking if an Internet server is up</a></li>
<li><a href="http://tldp.org/LDP/abs/html/communications.html#ISSPAMMER" target="_blank" rel="noopener noreferrer">例子 16-41</a></li>
<li><a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#ISSPAMMER2" target="_blank" rel="noopener noreferrer">例子 A-28</a></li>
<li><a href="http://tldp.org/LDP/abs/html/contributed-scripts.html#WHX" target="_blank" rel="noopener noreferrer">例子 A-29</a></li>
<li><a href="http://tldp.org/LDP/abs/html/devref1.html#DEVTCP" target="_blank" rel="noopener noreferrer">例子 29-1</a></li>
</ul>
<p>更多资料请看<a href="http://tldp.org/LDP/abs/html/system.html" target="_blank" rel="noopener noreferrer">《System and Administrative Commands》</a>的章节<a href="http://tldp.org/LDP/abs/html/system.html#NETWORKSYS1" target="_blank" rel="noopener noreferrer">“网络命令”</a>，以及<a href="http://tldp.org/LDP/abs/html/external.html" target="_blank" rel="noopener noreferrer">《External Filters, Programs and Commands》</a>的章节<a href="http://tldp.org/LDP/abs/html/communications.html" target="_blank" rel="noopener noreferrer">“通信命令”</a>。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">32 调试</title>
    <id>https://clay-wangzhi.com/code/shell/part5/32_Debugging/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/32_Debugging/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_32-调试"> 32 调试</h1>
<blockquote>
调试代码要比写代码困难两倍。因此，你写代码时越多的使用奇技淫巧（自做聪明），顾名思义，你越难以调试它。    --Brian Kernighan
</blockquote>
<p>Bash shell中不包含内置的debug工具，甚至没有调试专用的命令和结构。当调试非功能脚本，产生语法错误或者有错别字时，往往是无用的错误提示消息。</p>
<p>例子 32-1. 一个错误脚本</p>
<div><pre><code>#!/bin/bash
# ex74.sh

# 这是一个错误脚本，但是它错在哪？

a=37

if [$a -gt 27 ]
then
  echo $a
fi  

exit $?   # 0! 为什么?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>脚本的输出:</p>
<div><pre><code>./ex74.sh: [37: command not found
</code></pre>
<div><span>1</span><br></div></div><p>上边的脚本究竟哪错了(提示: 注意if的后边)</p>
<p>例子 32-2. 缺少关键字</p>
<div><pre><code>#!/bin/bash
# missing-keyword.sh
# 这个脚本会提示什么错误信息？

for a in 1 2 3
do
  echo &quot;$a&quot;
# done     #所需关键字&#39;done&#39;在第8行被注释掉.

exit 0     # 将不会在这退出!

#在命令行执行完此脚本后
输入：echo $?    
输出：2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>脚本的输出:</p>
<div><pre><code>missing-keyword.sh: line 10: syntax error: unexpected end of file
</code></pre>
<div><span>1</span><br></div></div><p>注意, 其实不必参考错误信息中指出的错误行号. 这行只不过是Bash解释器最终认定错误的地方.
出错信息在报告产生语法错误的行号时, 可能会忽略脚本的注释行.
如果脚本可以执行, 但并不如你所期望的那样工作, 怎么办? 通常情况下, 这都是由常见的逻辑错误所
产生的.</p>
<p>例子 32-3.</p>
<div><pre><code>#!/bin/bash

#  这个脚本应该删除在当前目录下所有文件名中含有空格的文件
#  它不能正常运行，为什么？

badname=`ls | grep &#39; &#39;`

# Try this:
# echo &quot;$badname&quot;

rm &quot;$badname&quot;

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>可以通过把echo &quot;$badname&quot;行的注释符去掉，找出例子 29-3中的错误， 看一下echo出来的信息，是否按你期望的方式运行.</p>
<p>在这种特殊的情况下，rm &quot;<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.69444em;vertical-align:0em;"></span><span>ba</span><span>d</span><span>nam</span><span>e</span><span>&quot;</span><span>不能得到预期的结果，因为</span></span></span></span>badname不应该加双引号。加上双引号会让rm只有一个参数(这就只能匹配一个文件名).一种不完善的解决办法是去掉<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span>ba</span><span>d</span><span>nam</span><span>e</span><span>外面的引号</span><span>,</span><span style="margin-right:0.16666666666666666em;"></span><span>并且重新设置</span></span></span></span>IFS, 让<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span style="margin-right:0.07847em;">I</span><span style="margin-right:0.05764em;">FS</span><span>只包含一个换行符</span><span>,</span><span style="margin-right:0.16666666666666666em;"></span><span style="margin-right:0.07847em;">I</span><span style="margin-right:0.05764em;">FS</span><span style="margin-right:0.2777777777777778em;"></span><span>=</span></span></span></span>'\n'. 但是, 下面这个方法更简单.</p>
<div><pre><code># 删除包含空格的文件的正确方法.
rm *\ *
rm *&quot; &quot;*
rm *&#39; &#39;*
# 感谢. S.C.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>总结一下这个问题脚本的症状:</p>
<blockquote></blockquote>
<ol>
<li>由于&quot;syntax error&quot;(语法错误)使得脚本停止运行,</li>
<li>或者脚本能够运行, 但是并不是按照我们所期望的那样运行(逻辑错误).</li>
<li>脚本能够按照我们所期望的那样运行, 但是有烦人的副作用(逻辑炸弹).</li>
</ol>
<p>如果想调试脚本, 可以用以下方式:</p>
<ol>
<li>
<p>echo语句可以放在脚本中存在疑问的位置上, 观察变量的值, 来了解脚本运行时的情况.</p>
<div><pre><code>### debecho (debug-echo), by Stefano Falsetto ###
### Will echo passed parameters only if DEBUG is set to a value. ###
debecho () {
	if [ ! -z &quot;$DEBUG&quot; ]; then
 		echo &quot;$1&quot; &gt;&amp;2
 		# ^^^ to stderr
	fi
}

DEBUG=on
Whatever=whatnot
debecho $Whatever   # whatnot

DEBUG=
Whatever=notwhat
debecho $Whatever   # (Will not echo.)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></li>
<li>
<p>使用过滤器tee来检查临界点上的进程或数据流.</p>
</li>
<li>
<p>设置选项-n -v -x</p>
<p>sh -n scriptname不会运行脚本, 只会检查脚本的语法错误. 这等价于把set -n或set -o noexec插入脚本中. 注意, 某些类型的语法错误不会被这种方式检查出来.</p>
<p>sh -v scriptname将会在运行脚本之前, 打印出每一个命令. 这等价于把set -v或set -o verbose插入到脚本中.</p>
<p>选项-n和-v可以同时使用. sh -nv scriptname将会给出详细的语法检查.</p>
<p>sh -x scriptname会打印出每个命令执行的结果, 但只使用缩写形式. 这等价于在脚本中插入set
-x或set -o xtrace.</p>
<p>把set -u或set -o nounset插入到脚本中, 并运行它, 就会在每个试图使用未声明变量的地方给出一个unbound variable错误信息.</p>
<div><pre><code>set -u   # Or   set -o nounset

# Setting a variable to null will not trigger the error/abort.
# unset_var=

echo $unset_var   # Unset (and undeclared) variable.
echo &quot;Should not echo!&quot;

#sh t2.sh
#t2.sh: line 6: unset_var: unbound variable
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>使用“断言”功能在脚本的关键点进行测试的变量或条件。 （这是从C借来的一个想法）</p>
<p>Example 32-4. Testing a condition with an assert</p>
<div><pre><code>#!/bin/bash
# assert.sh

#######################################################################
assert ()                 #  If condition false,
{                         #+ exit from script
                          #+ with appropriate error message.
  E_PARAM_ERR=98
  E_ASSERT_FAILED=99


  if [ -z &quot;$2&quot; ]          #  Not enough parameters passed
  then                    #+ to assert() function.
    return $E_PARAM_ERR   #  No damage done.
  fi

  lineno=$2

  if [ ! $1 ] 
  then
    echo &quot;Assertion failed:  \&quot;$1\&quot;&quot;
    echo &quot;File \&quot;$0\&quot;, line $lineno&quot;    # Give name of file and line number.
    exit $E_ASSERT_FAILED
  # else
  #   return
  #   and continue executing the script.
  fi  
} # Insert a similar assert() function into a script you need to debug.    
#######################################################################


a=5
b=4
condition=&quot;$a -lt $b&quot;     #  Error message and exit from script.
                          #  Try setting &quot;condition&quot; to something else
                          #+ and see what happens.

assert &quot;$condition&quot; $LINENO
# The remainder of the script executes only if the &quot;assert&quot; does not fail.


# Some commands.
# Some more commands . . .
echo &quot;This statement echoes only if the \&quot;assert\&quot; does not fail.&quot;
# . . .
# More commands . . .

exit $?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div></li>
<li>
<p>使用变量$LINENO和内建命令caller.</p>
</li>
<li>
<p>捕获exit返回值.</p>
<p>The exit command in a script triggers a signal 0, terminating the process, 	that is, the script itself. [1] It is often useful to trap the exit, forcing 	a &quot;printout&quot; of variables, for example. The trap must be the first command 	in the script.</p>
</li>
</ol>
<p>捕获信号</p>
<p>trap
Specifies an action on receipt of a signal; also useful for debugging.</p>
<p>A signal is a message sent to a process, either by the kernel or another 	process, telling it to take some specified action (usually to terminate). 	For example, hitting a Control-C sends a user interrupt, an INT signal, to a 	running program.</p>
<p>A simple instance:</p>
<div><pre><code>trap &#39;&#39; 2
# Ignore interrupt 2 (Control-C), with no action specified. 
	
trap &#39;echo &quot;Control-C disabled.&quot;&#39; 2
# Message when Control-C pressed.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Example 32-5. Trapping at exit</p>
<div><pre><code>#!/bin/bash
# Hunting variables with a trap.

trap &#39;echo Variable Listing --- a = $a  b = $b&#39; EXIT
#  EXIT is the name of the signal generated upon exit from a script.
#
#  The command specified by the &quot;trap&quot; doesn&#39;t execute until
#+ the appropriate signal is sent.

echo &quot;This prints before the \&quot;trap\&quot; --&quot;
echo &quot;even though the script sees the \&quot;trap\&quot; first.&quot;
echo

a=39
b=36

exit 0


#  Note that commenting out the &#39;exit&#39; command makes no difference,
#+ since the script exits in any case after running out of commands.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>Example 32-6. Cleaning up after Control-C</p>
<div><pre><code>#!/bin/bash
# logon.sh: A quick &#39;n dirty script to check whether you are on-line yet.

umask 177  # Make sure temp files are not world readable.


TRUE=1
LOGFILE=/var/log/messages
#  Note that $LOGFILE must be readable
#+ (as root, chmod 644 /var/log/messages).
TEMPFILE=temp.$$
#  Create a &quot;unique&quot; temp file name, using process id of the script.
#     Using &#39;mktemp&#39; is an alternative.
#     For example:
#     TEMPFILE=`mktemp temp.XXXXXX`
KEYWORD=address
#  At logon, the line &quot;remote IP address xxx.xxx.xxx.xxx&quot;
#                      appended to /var/log/messages.
ONLINE=22
USER_INTERRUPT=13
CHECK_LINES=100
#  How many lines in log file to check.

trap &#39;rm -f $TEMPFILE; exit $USER_INTERRUPT&#39; TERM INT
#  Cleans up the temp file if script interrupted by control-c.

echo

while [ $TRUE ]  #Endless loop.
do
  tail -n $CHECK_LINES $LOGFILE&gt; $TEMPFILE
  #  Saves last 100 lines of system log file as temp file.
  #  Necessary, since newer kernels generate many log messages at log on.
  search=`grep $KEYWORD $TEMPFILE`
  #  Checks for presence of the &quot;IP address&quot; phrase,
  #+ indicating a successful logon.

  if [ ! -z &quot;$search&quot; ] #  Quotes necessary because of possible spaces.
  then
     echo &quot;On-line&quot;
     rm -f $TEMPFILE    #  Clean up temp file.
     exit $ONLINE
  else
     echo -n &quot;.&quot;        #  The -n option to echo suppresses newline,
                        #+ so you get continuous rows of dots.
  fi

  sleep 1  
done  


#  Note: if you change the KEYWORD variable to &quot;Exit&quot;,
#+ this script can be used while on-line
#+ to check for an unexpected logoff.

# Exercise: Change the script, per the above note,
#           and prettify it.

exit 0


# Nick Drage suggests an alternate method:

while true
  do ifconfig ppp0 | grep UP 1&gt; /dev/null &amp;&amp; echo &quot;connected&quot; &amp;&amp; exit 0
  echo -n &quot;.&quot;   # Prints dots (.....) until connected.
  sleep 2
done

# Problem: Hitting Control-C to terminate this process may be insufficient.
#+         (Dots may keep on echoing.)
# Exercise: Fix this.



# Stephane Chazelas has yet another alternative:

CHECK_INTERVAL=1

while ! tail -n 1 &quot;$LOGFILE&quot; | grep -q &quot;$KEYWORD&quot;
do echo -n .
   sleep $CHECK_INTERVAL
done
echo &quot;On-line&quot;

# Exercise: Discuss the relative strengths and weaknesses
#           of each of these various approaches.
Example 32-7. A Simple Implementation of a Progress Bar

#! /bin/bash
# progress-bar2.sh
# Author: Graham Ewart (with reformatting by ABS Guide author).
# Used in ABS Guide with permission (thanks!).

# Invoke this script with bash. It doesn&#39;t work with sh.

interval=1
long_interval=10

{
     trap &quot;exit&quot; SIGUSR1
     sleep $interval; sleep $interval
     while true
     do
       echo -n &#39;.&#39;     # Use dots.
       sleep $interval
     done; } &amp;         # Start a progress bar as a background process.

pid=$!
trap &quot;echo !; kill -USR1 $pid; wait $pid&quot;  EXIT        # To handle ^C.

echo -n &#39;Long-running process &#39;
sleep $long_interval
echo &#39; Finished!&#39;

kill -USR1 $pid
wait $pid              # Stop the progress bar.
trap EXIT

exit $?

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br></div></div><p>Note	
The DEBUG argument to trap causes a specified action to execute after every command in a script. This permits tracing variables, for example.</p>
<p>Example 32-8. Tracing a variable</p>
<div><pre><code>
#!/bin/bash

trap &#39;echo &quot;VARIABLE-TRACE&gt; \$variable = \&quot;$variable\&quot;&quot;&#39; DEBUG
# Echoes the value of $variable after every command.

variable=29; line=$LINENO

echo &quot;  Just initialized \$variable to $variable in line number $line.&quot;

let &quot;variable *= 3&quot;; line=$LINENO
echo &quot;  Just multiplied \$variable by 3 in line number $line.&quot;

exit 0

#  The &quot;trap &#39;command1 . . . command2 . . .&#39; DEBUG&quot; construct is
#+ more appropriate in the context of a complex script,
#+ where inserting multiple &quot;echo $variable&quot; statements might be
#+ awkward and time-consuming.

# Thanks, Stephane Chazelas for the pointer.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>Output of script:</p>
<p>VARIABLE-TRACE&gt; $variable = &quot;&quot;
VARIABLE-TRACE&gt; $variable = &quot;29&quot;
Just initialized $variable to 29.
VARIABLE-TRACE&gt; $variable = &quot;29&quot;
VARIABLE-TRACE&gt; $variable = &quot;87&quot;
Just multiplied $variable by 3.
VARIABLE-TRACE&gt; $variable = &quot;87&quot;
Of course, the trap command has other uses aside from debugging, such as disabling certain keystrokes within a script (see Example A-43).</p>
<p>Example 32-9. Running multiple processes (on an SMP box)</p>
<div><pre><code>
#!/bin/bash
# parent.sh
# Running multiple processes on an SMP box.
# Author: Tedman Eng

#  This is the first of two scripts,
#+ both of which must be present in the current working directory.




LIMIT=$1         # Total number of process to start
NUMPROC=4        # Number of concurrent threads (forks?)
PROCID=1         # Starting Process ID
echo &quot;My PID is $$&quot;

function start_thread() {
        if [ $PROCID -le $LIMIT ] ; then
                ./child.sh $PROCID&amp;
                let &quot;PROCID++&quot;
        else
           echo &quot;Limit reached.&quot;
           wait
           exit
        fi
}

while [ &quot;$NUMPROC&quot; -gt 0 ]; do
        start_thread;
        let &quot;NUMPROC--&quot;
done


while true
do

trap &quot;start_thread&quot; SIGRTMIN

done

exit 0



# ======== Second script follows ========


#!/bin/bash
# child.sh
# Running multiple processes on an SMP box.
# This script is called by parent.sh.
# Author: Tedman Eng

temp=$RANDOM
index=$1
shift
let &quot;temp %= 5&quot;
let &quot;temp += 4&quot;
echo &quot;Starting $index  Time:$temp&quot; &quot;$@&quot;
sleep ${temp}
echo &quot;Ending $index&quot;
kill -s SIGRTMIN $PPID

exit 0


# ======================= SCRIPT AUTHOR&#39;S NOTES ======================= #
#  It&#39;s not completely bug free.
#  I ran it with limit = 500 and after the first few hundred iterations,
#+ one of the concurrent threads disappeared!
#  Not sure if this is collisions from trap signals or something else.
#  Once the trap is received, there&#39;s a brief moment while executing the
#+ trap handler but before the next trap is set.  During this time, it may
#+ be possible to miss a trap signal, thus miss spawning a child process.

#  No doubt someone may spot the bug and will be writing 
#+ . . . in the future.



# ===================================================================== #



# ----------------------------------------------------------------------#



#################################################################
# The following is the original script written by Vernia Damiano.
# Unfortunately, it doesn&#39;t work properly.
#################################################################

#!/bin/bash

#  Must call script with at least one integer parameter
#+ (number of concurrent processes).
#  All other parameters are passed through to the processes started.


INDICE=8        # Total number of process to start
TEMPO=5         # Maximum sleep time per process
E_BADARGS=65    # No arg(s) passed to script.

if [ $# -eq 0 ] # Check for at least one argument passed to script.
then
  echo &quot;Usage: `basename $0` number_of_processes [passed params]&quot;
  exit $E_BADARGS
fi

NUMPROC=$1              # Number of concurrent process
shift
PARAMETRI=( &quot;$@&quot; )      # Parameters of each process

function avvia() {
         local temp
         local index
         temp=$RANDOM
         index=$1
         shift
         let &quot;temp %= $TEMPO&quot;
         let &quot;temp += 1&quot;
         echo &quot;Starting $index Time:$temp&quot; &quot;$@&quot;
         sleep ${temp}
         echo &quot;Ending $index&quot;
         kill -s SIGRTMIN $$
}

function parti() {
         if [ $INDICE -gt 0 ] ; then
              avvia $INDICE &quot;${PARAMETRI[@]}&quot; &amp;
                let &quot;INDICE--&quot;
         else
                trap : SIGRTMIN
         fi
}

trap parti SIGRTMIN

while [ &quot;$NUMPROC&quot; -gt 0 ]; do
         parti;
         let &quot;NUMPROC--&quot;
done

wait
trap - SIGRTMIN

exit $?

: &lt;&lt;SCRIPT_AUTHOR_COMMENTS
I had the need to run a program, with specified options, on a number of
different files, using a SMP machine. So I thought [I&#39;d] keep running
a specified number of processes and start a new one each time . . . one
of these terminates.

The &quot;wait&quot; instruction does not help, since it waits for a given process
or *all* process started in background. So I wrote [this] bash script
that can do the job, using the &quot;trap&quot; instruction.
  --Vernia Damiano
SCRIPT_AUTHOR_COMMENTS

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br></div></div><p>Note	
trap '' SIGNAL (two adjacent apostrophes) disables SIGNAL for the remainder of the script. trap SIGNAL restores the functioning of SIGNAL once more. This is useful to protect a critical portion of a script from an undesirable interrupt.</p>
<div><pre><code>trap &#39;&#39; 2  # Signal 2 is Control-C, now disabled.
command
command
command
trap 2     # Reenables Control-C
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">33 选项</title>
    <id>https://clay-wangzhi.com/code/shell/part5/33_options/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/33_options/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_33-选项"> 33 选项</h1>
<p>选项用来更改shell和脚本的行为.</p>
<p><a href="http://tldp.org/LDP/abs/html/internal.html#SETREF" target="_blank" rel="noopener noreferrer">set</a>命令用来打开脚本中的选项. 你可以在脚本中任何你想让选项生效的地方插入<strong>set -o option-name</strong>, 或者使用更简单的形式, <strong>set -option-abbrev</strong>. 这两种形式是等价的.</p>
<div><pre><code>#!/bin/bash

set -o verbose
# # 打印出所有执行前的命令.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code>#!/bin/bash

set -v
# 与上边的例子具有相同的效果.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="extra" /> 如果你想在脚本中禁用某个选项, 可以使用<strong>set +o option-name</strong>或<strong>set +option-abbrev</strong>.</p>
<div><pre><code>#!/bin/bash
set -o verbose
# 激活命令回显.
command
...
command

set +o verbose
# 禁用命令回显.
command
# 没有命令回显了.

set -v
# 激活命令回显.
command
...
command

set +v
# 禁用命令回显.
command

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>还有另一种可以在脚本中启用选项的方法, 那就是在脚本头部, #!的后边直接指定选项.</p>
<div><pre><code>#!/bin/bash -x
#
# 下边是脚本的主要内容.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>也可以从命令行中打开脚本的选项. 某些不能与<strong>set</strong>命令一起用的选项就可以使用这种方法来打开. - i就是其中之一, 这个选项用来强制脚本以交互的方式运行.</p>
<p><strong>bash - v script - name</strong></p>
<p><strong>bash - o verbose script - name</strong></p>
<p>下表列出了一些有用的选项. 它们都可以使用缩写的形式来指定(开头加一个破折号), 也可以使用完整名字来指定(开头加上双破折号, 或者使用-o选项来指定).</p>
<p>表格 33-1. Bash选项</p>
<table>
<thead>
<tr>
<th style="text-align:left">缩写</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-B</td>
<td style="text-align:left">brace expansion</td>
<td style="text-align:left">开启<a href="">大括号展开</a>(默认 setting = on)</td>
</tr>
<tr>
<td style="text-align:left">+B</td>
<td style="text-align:left">brace expansion</td>
<td style="text-align:left">关闭大括号展开</td>
</tr>
<tr>
<td style="text-align:left">-C</td>
<td style="text-align:left">noclobber</td>
<td style="text-align:left">防止重定向时覆盖文件(可能会被&gt;|覆盖)</td>
</tr>
<tr>
<td style="text-align:left">-D</td>
<td style="text-align:left">(none)</td>
<td style="text-align:left">列出用双引号引用起来的, 以$为前缀的字符串, 但是不执行脚本中的命令</td>
</tr>
<tr>
<td style="text-align:left">-a</td>
<td style="text-align:left">all export</td>
<td style="text-align:left">export(导出)所有定义过的变量</td>
</tr>
<tr>
<td style="text-align:left">-b</td>
<td style="text-align:left">notify</td>
<td style="text-align:left">当后台运行的作业终止时, 给出通知(脚本中并不常见)</td>
</tr>
<tr>
<td style="text-align:left">-c ...</td>
<td style="text-align:left">(none)</td>
<td style="text-align:left">从...中读取命令</td>
</tr>
<tr>
<td style="text-align:left">checkjobs</td>
<td style="text-align:left">(none)</td>
<td style="text-align:left">通知有活跃shell<a href="http://tldp.org/LDP/abs/html/x9644.html#JOBSREF" target="_blank" rel="noopener noreferrer">任务</a>的用户退出。<a href="http://tldp.org/LDP/abs/html/bashver4.html#BASH4REF" target="_blank" rel="noopener noreferrer">Bash 4</a>版本中引入，仍然处于&quot;实验&quot;阶段. 用法:shopt -s checkjobs .(注意：可能会hang！</td>
</tr>
<tr>
<td style="text-align:left">-e</td>
<td style="text-align:left">errexit</td>
<td style="text-align:left">当脚本发生第一个错误时, 就退出脚本, 换种说法就是, 当一个命令返回非零值时, 就退出脚本(除了<a href="http://tldp.org/LDP/abs/html/loops1.html#UNTILLOOPREF" target="_blank" rel="noopener noreferrer">until</a>或<a href="http://tldp.org/LDP/abs/html/loops1.html#WHILELOOPREF" target="_blank" rel="noopener noreferrer">while loops</a>, <a href="http://tldp.org/LDP/abs/html/testconstructs.html#TESTCONSTRUCTS1" target="_blank" rel="noopener noreferrer">if-tests</a>, <a href="http://tldp.org/LDP/abs/html/list-cons.html#LCONS1" target="_blank" rel="noopener noreferrer">list constructs</a>)</td>
</tr>
<tr>
<td style="text-align:left">-f</td>
<td style="text-align:left">noglob</td>
<td style="text-align:left">禁用文件名扩展(就是禁用globbing)</td>
</tr>
<tr>
<td style="text-align:left">globstar</td>
<td style="text-align:left"><a href="http://tldp.org/LDP/abs/html/bashver4.html#GLOBSTARREF" target="_blank" rel="noopener noreferrer">globbing star-match</a></td>
<td style="text-align:left">打开<a href="http://tldp.org/LDP/abs/html/globbingref.html" target="_blank" rel="noopener noreferrer">globbling</a>操作符(Bash <a href="http://tldp.org/LDP/abs/html/bashver4.html#BASH4REF" target="_blank" rel="noopener noreferrer">4+</a>). 使用方法：shopt -s globstar</td>
</tr>
<tr>
<td style="text-align:left">-i</td>
<td style="text-align:left">interactive</td>
<td style="text-align:left">让脚本以交互模式运行</td>
</tr>
<tr>
<td style="text-align:left">-n</td>
<td style="text-align:left">noexec</td>
<td style="text-align:left">从脚本中读取命令, 但是不执行它们(做语法检查)</td>
</tr>
<tr>
<td style="text-align:left">-o Option-Name</td>
<td style="text-align:left">(none)</td>
<td style="text-align:left">调用Option-Name选项</td>
</tr>
<tr>
<td style="text-align:left">-o posix</td>
<td style="text-align:left">POSIX</td>
<td style="text-align:left">修改Bash或被调用脚本的行为, 使其符合<a href="http://tldp.org/LDP/abs/html/sha-bang.html#POSIX2REF" target="_blank" rel="noopener noreferrer">POSIX</a>标准.</td>
</tr>
<tr>
<td style="text-align:left">-o pipefail</td>
<td style="text-align:left">pipe failure</td>
<td style="text-align:left">创建一个管道去返回最后一条命令的<a href="http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF" target="_blank" rel="noopener noreferrer">退出状态码</a>，这个返回值是一个非0的返回值</td>
</tr>
<tr>
<td style="text-align:left">-p</td>
<td style="text-align:left">privileged</td>
<td style="text-align:left">以&quot;suid&quot;身份来运行脚本(小心!)</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td style="text-align:left">restricted</td>
<td style="text-align:left">以受限模式来运行脚本(参考 <a href="http://tldp.org/LDP/abs/html/restricted-sh.html" target="_blank" rel="noopener noreferrer">22</a>).</td>
</tr>
<tr>
<td style="text-align:left">-s</td>
<td style="text-align:left">stdin</td>
<td style="text-align:left">从stdin 中读取命令</td>
</tr>
<tr>
<td style="text-align:left">-t</td>
<td style="text-align:left">(none)</td>
<td style="text-align:left">执行完第一个命令之后, 就退出</td>
</tr>
<tr>
<td style="text-align:left">-u</td>
<td style="text-align:left">nounset</td>
<td style="text-align:left">如果尝试使用了未定义的变量, 就会输出一个错误消息, 然后强制退出</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:left">verbose</td>
<td style="text-align:left">在执行每个命令之前, 把每个命令打印到stdout上</td>
</tr>
<tr>
<td style="text-align:left">-x</td>
<td style="text-align:left">xtrace</td>
<td style="text-align:left">与-v选项类似, 但是会打印完整命令</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">(none)</td>
<td style="text-align:left">选项结束标志. 后面的参数为<a href="http://tldp.org/LDP/abs/html/internalvariables.html#POSPARAMREF" target="_blank" rel="noopener noreferrer">位置参数</a>.</td>
</tr>
<tr>
<td style="text-align:left">--</td>
<td style="text-align:left">(none)</td>
<td style="text-align:left">unset(释放)位置参数. 如果指定了参数列表(-- arg1 arg2), 那么位置 参数将会依次设置到参数列表中.</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第34章 陷阱</title>
    <id>https://clay-wangzhi.com/code/shell/part5/34_Gotchas/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/34_Gotchas/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p># 第34章 陷阱</p>
<blockquote>
<p>Turandot: Gli enigmi sono tre, la morte una!
Caleph: No, no! Gli enigmi sono tre, una la vita!</p>
</blockquote>
<blockquote>
<p>——Puccini</p>
</blockquote>
<h3 id="以下的做法-非推荐-将让你原本平淡无奇的生活激动不已。"> 以下的做法（非推荐）将让你原本平淡无奇的生活激动不已。</h3>
<ul>
<li>将保留字或特殊字符声明为变量名。</li>
</ul>
<div><pre><code><span>case</span><span>=</span>value0       <span># 引发错误。</span>
<span>23skidoo</span><span>=</span>value1   <span># 也会引发错误。</span>
<span># 以数字开头的变量名是被shell保留使用的。</span>
<span># 试试_23skidoo=value1。以下划线开头的变量名就没问题.</span>

<span># 然而 . . .   只用一个下划线作为变量名就不行。</span>
<span>_</span><span>=</span><span>25</span>
<span>echo</span> <span>$_</span>           <span># $_是一个特殊变量, 代表最后一个命令的最后一个参数。</span>
<span># 但是，_是一个有效的函数名！</span>

xyz<span>((</span><span>!</span>*<span>=</span>value2    <span># 引起严重的错误。</span>
<span># Bash3.0之后，标点不能出现在变量名中。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li>使用连字符或其他保留字符来做变量名（或函数名）。</li>
</ul>
<div><pre><code>var-1<span>=</span><span>23</span>
<span># 用 'var_1 代替。</span>

function-whatever <span>(</span><span>)</span>   <span># 错误</span>
<span># 用 ‘function_whatever ()’ 代替。</span>

 
<span># Bash3.0之后，标点不能出现在函数名中。</span>
function.whatever <span>(</span><span>)</span>   <span># 错误</span>
<span># 用 ‘functionWhatever ()’ 代替。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>让变量名与函数名相同。 这会使得脚本的可读性变得很差。</li>
</ul>
<div><pre><code><span>do_something</span> <span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"This function does something with <span title="\&quot;">\"</span><span>$1</span><span title="\&quot;">\"</span>."</span>
<span>}</span>

<span>do_something</span><span>=</span>do_something

do_something do_something

<span># 这么做是合法的，但会让人混淆。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>不合时宜的使用[空白符][1]。与其他编程语言相比，Bash非常讲究空白符的使用。</li>
</ul>
<div><pre><code>var1 <span>=</span> <span>23</span>   <span># ‘var1=23’才是正确的。</span>
<span># 对于上边这一行来说，Bash会把“var1”当作命令来执行，</span>
<span># “=”和“23”会被看作“命令”“var1”的参数。</span>
	
<span>let</span> c <span>=</span> <span>$a</span> - <span>$b</span>   <span># ‘let c=$a-$b’或‘let "c = $a - $b"’才是正确的。</span>

<span>if</span> <span>[</span> <span>$a</span> -le <span>5</span><span>]</span>    <span># if [ $a -le 5 ]   是正确的。</span>
<span>#           ^^      if [ "$a" -le 5 ]   这么写更好。</span>
                  <span># [[ $a -le 5 ]] 也行。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>在[大括号包含的代码块][2]中，最后一条命令没有以[分号][3]结尾。</li>
</ul>
<div><pre><code><span>{</span> <span>ls</span> -l<span>;</span> <span>df</span><span>;</span> <span>echo</span> <span>"Done."</span> <span>}</span>
<span># bash: syntax error: unexpected end of file</span>

<span>{</span> <span>ls</span> -l<span>;</span> <span>df</span><span>;</span> <span>echo</span> <span>"Done."</span><span>;</span> <span>}</span>
<span>#                        ^     ### 最后的这条命令必须以分号结尾。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>假定未被初始化的变量（赋值前的变量）被“清0”。事实上，未初始化的变量值为“null”，而不是0。</li>
</ul>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"uninitialized_var = <span>$uninitialized_var</span>"</span>
<span># uninitialized_var =</span>

<span># 但是 . . .</span>
<span># if $BASH_VERSION ≥ 4.2; then</span>

<span>if</span> <span>[</span><span>[</span> <span>!</span> -v uninitialized_var <span>]</span><span>]</span>
<span>then</span>
  <span>uninitialized_var</span><span>=</span><span>0</span>   <span># Initialize it to zero!</span>
<span>fi</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ul>
<li>混淆测试符号=和-ep。请记住，=用于比较字符变量，而-ep用来比较整数。</li>
</ul>
<div><pre><code><span>if</span> <span>[</span> <span>"<span>$a</span>"</span> <span>=</span> <span>273</span> <span>]</span>      <span># $a是整数还是字符串？</span>
<span>if</span> <span>[</span> <span>"<span>$a</span>"</span> -eq <span>273</span> <span>]</span>    <span># $a为整数。</span>

<span># 有些情况下，即使你混用-ep和=，也不会产生错误的结果。</span>
<span># 然而 . . .</span>


<span>a</span><span>=</span><span>273.0</span>   <span># 不是一个整数。</span>
	   
<span>if</span> <span>[</span> <span>"<span>$a</span>"</span> <span>=</span> <span>273</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"Comparison works."</span>
<span>else</span>  
  <span>echo</span> <span>"Comparison does not work."</span>
<span>fi</span>    <span># Comparison does not work.</span>

<span># 与a=" 273"和a="0273"相同。</span>


<span># 类似的， 如果对非整数值使用“-ep”的话，就会产生问题。</span>
	   
<span>if</span> <span>[</span> <span>"<span>$a</span>"</span> -eq <span>273.0</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"a = <span>$a</span>"</span>
<span>fi</span>  <span># 产生了错误消息而退出。</span>
<span># test.sh: [: 273.0: integer expression expected</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><ul>
<li>误用了[字符串比较][4]操作符。</li>
</ul>
<p>样例 34-1. 数字比较与字符串比较并不相同</p>
<div><pre><code><span>#!/bin/bash</span>
<span># bad-op.sh: 尝试一下对整数使用字符串比较。</span>

<span>echo</span>
<span>number</span><span>=</span><span>1</span>

<span>#  下面的"while循环"有两个过错误:</span>
<span>#+ 一个比较明显，而另一个比较隐蔽。</span>

<span>while</span> <span>[</span> <span>"<span>$number</span>"</span> <span>&lt;</span> <span>5</span> <span>]</span>    <span># 错！应该是:  while [ "$number" -lt 5 ]</span>
<span>do</span>
  <span>echo</span> -n <span>"<span>$number</span> "</span>
  <span>let</span> <span>"number += 1"</span>
<span>done</span>  
<span>#  如果试图运行这个错误的脚本，就会得到一个错误信息:</span>
<span>#+ bad-op.sh: line 10: 5: No such file or directory</span>
<span>#  在单中括号结构（[ ]）中，"&lt;"必须被转义，</span>
<span>#+ 即便如此，比较两个整数仍是错误的。</span>

<span>echo</span> <span>"---------------------"</span>

<span>while</span> <span>[</span> <span>"<span>$number</span>"</span> <span>\</span><span>&lt;</span> <span>5</span> <span>]</span>    <span>#  1 2 3 4</span>
<span>do</span>                          <span>#</span>
  <span>echo</span> -n <span>"<span>$number</span> "</span>        <span>#  看起来好像可以工作，但是 . . .</span>
  <span>let</span> <span>"number += 1"</span>         <span>#+ 事实上是比较ASCII码，</span>
  <span>done</span>                      <span>#+ 而不是整数比较。</span>

<span>echo</span><span>;</span> <span>echo</span> <span>"---------------------"</span>

<span># 这么做会产生问题。比如:</span>

<span>lesser</span><span>=</span><span>5</span>
<span>greater</span><span>=</span><span>105</span>

<span>if</span> <span>[</span> <span>"<span>$greater</span>"</span> <span>\</span><span>&lt;</span> <span>"<span>$lesser</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"<span>$greater</span> is less than <span>$lesser</span>"</span>
<span>fi</span>                          <span># 105 is less than 5</span>
<span>#  事实上，在字符串比较中（按照ASCII码的顺序）</span>
<span>#+ "105"小于"5"。</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><ul>
<li>试图用[let][5]来设置字符串变量。</li>
</ul>
<div><pre><code><span>let</span> <span>"a = hello, you"</span>
<span>echo</span> <span>"<span>$a</span>"</span>   <span># 0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>
<p>有时候在“test”中括号（[ ]）结构里的变量需要被引用起来（双引号）。如果不这么做的话，可能会引起不可预料的结果。请参考[例子 7-6][6]，[例子 16-5][7]，[例子 9-6][8]。</p>
</li>
<li>
<p>[为防分隔][9]，用双引号引用一个包含空白符的变量。 有些情况下，这会产生[意想不到的后果][10]。</p>
</li>
<li>
<p>脚本中的命令可能会因为脚本宿主不具备相应的运行权限而导致运行失败。如果用户在命令行中不能调用这个命令的话，那么即使把它放到脚本中来运行，也还是会失败。这时可以通过修改命令的属性来解决这个问题，有时候甚至要给它设置suid位(当然, 要以root身份来设置)。</p>
</li>
<li>
<p>试图使用-作为作为重定向操作符（事实上它不是），通常都会导致令人不快的结果。</p>
</li>
</ul>
<div><pre><code>command1 <span><span>2</span>></span> - <span>|</span> command2
<span># 试图将command1的错误输出重定向到一个管道中 . . .</span>
<span># . . . 不会工作。</span>

command1 <span><span>2</span>>&amp;</span> - <span>|</span> command2  <span># 也没效果。</span>

感谢，S.C。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>使用[Bash 2.0或更高版本][11]的功能，可以在产生错误信息的时候，引发修复动作。但是比较老的Linux机器默认安装的可能是Bash 1.XX。</li>
</ul>
<div><pre><code><span>#!/bin/bash</span>

<span>minimum_version</span><span>=</span><span>2</span>
<span># 因为Chet Ramey经常给Bash添加一些新的特征，</span>
<span># 所以你最好将$minimum_version设置为2.XX，3.XX，或是其他你认为比较合适的值。</span>
<span>E_BAD_VERSION</span><span>=</span><span>80</span>

<span>if</span> <span>[</span> <span>"<span>$BASH_VERSION</span>"</span> <span>\</span><span>&lt;</span> <span>"<span>$minimum_version</span>"</span> <span>]</span>
<span>then</span>
  <span>echo</span> <span>"This script works only with Bash, version <span>$minimum</span> or greater."</span>
  <span>echo</span> <span>"Upgrade strongly recommended."</span>
  <span>exit</span> <span>$E_BAD_VERSION</span>
<span>fi</span>

<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>
<li>
<p>在非Linux机器上的[Bourne shell][12]脚本( <strong>#!/bin/sh</strong> )中使用Bash特有的功能，[可能会引起不可预料的行为][13]。Linux系统通常都会把<strong>bash</strong>别名化为<strong>sh</strong>，但是在一般的UNIX机器上却不一定会这么做。</p>
</li>
<li>
<p>使用Bash未文档化的特征，将是一种危险的举动。本书之前的几个版本就依赖一个这种“特征”，下面说明一下这个“特征”，虽然[exit][14]或[return][15]所能返回的最大正值为255，但是并没有限制我们使用负整数。不幸的是, Bash 2.05b之后的版本，这个漏洞消失了。请参考[例子 24-9][16]。</p>
</li>
<li>
<p>在某些情况下，会返回一个误导性的[退出状态][17]。[设置一个函数内的局部变量][18]或[分配一个算术值给一个变量][19]时，就有可能发生这种情况。</p>
</li>
<li>
<p>[算术表达式的退出状态][20]不等同于一个错误代码。</p>
</li>
</ul>
<div><pre><code><span>var</span><span>=</span><span>1</span> <span>&amp;&amp;</span> <span><span>((</span><span>--</span>var<span>))</span></span> <span>&amp;&amp;</span> <span>echo</span> <span>$var</span>
<span>#        ^^^^^^^^^ 在这里，这个与列表返回错误代码1而终止。</span>
<span>#                     不会打印$var的值！</span>
<span>echo</span> <span>$?</span>   <span># 1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>一个带有DOS风格换行符(\r\n)的脚本将会运行失败，因为**#!/bin/bash\r\n<strong>是不合法的，与我们所期望的</strong>#!/bin/bash\n**不同，解决办法就是将这个脚本转换为UNIX风格的换行符。</li>
</ul>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"Here"</span>

unix2dos <span>$0</span>    <span># 脚本先将自己改为DOS格式。</span>
<span>chmod</span> <span>755</span> <span>$0</span>   <span># 更改可执行权限。</span>
               <span># 'unix2dos'会删除可执行权限</span>

./<span>$0</span>           <span># 脚本尝试再次运行自己。</span>
               <span># 但它作为一个DOS文件，已经不能运行了。</span>

<span>echo</span> <span>"There"</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ul>
<li>
<p>以**#!/bin/sh<strong>开头的Bash脚本，不能在完整的Bash兼容模式下运行。某些Bash特定的功能可能会被禁用。如果脚本需要完整的访问所有Bash专有扩展，那么它需要使用</strong>#!/bin/bash**作为开头。</p>
</li>
<li>
<p>如果在[here document][21]中，[结尾的limit string之前加上空白字符][22]的话，将会导致脚本的异常行为。</p>
</li>
<li>
<p>在一个[输出被捕获][23]的函数中放置了不止一个echo语句。</p>
</li>
</ul>
<div><pre><code><span>add2</span> <span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"Whatever ... "</span>   <span># 删掉zhehan</span>
  <span>let</span> <span>"retval = <span>$1</span> + <span>$2</span>"</span>
    <span>echo</span> <span>$retval</span>
    <span>}</span>

    <span>num1</span><span>=</span><span>12</span>
    <span>num2</span><span>=</span><span>43</span>
    <span>echo</span> <span>"Sum of <span>$num1</span> and <span>$num2</span> = <span><span>$(</span>add2 $num1 $num2<span>)</span></span>"</span>

<span>#   Sum of 12 and 43 = Whatever ... </span>
<span>#   55</span>

<span>#        这些echo连在一起了。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>这是[行不通][24]的。</p>
<ul>
<li>脚本不能将变量export到它的[父进程]<a href="%E5%8D%B3%E8%B0%83%E7%94%A8%E8%BF%99%E4%B8%AA%E8%84%9A%E6%9C%AC%E7%9A%84shell">25</a>，或父进程的环境中。就好比我们在生物学中所学到的那样，子进程只会继承父进程, 反过来则不行。</li>
</ul>
<div><pre><code><span>WHATEVER</span><span>=</span>/home/bozo
<span>export</span> WHATEVER
<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code>bash$ <span>echo</span> <span>$WHATEVER</span>
bash$
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>
<p>可以确定的是，即使回到命令行提示符，变量$WHATEVER仍然没有被设置。</p>
</li>
<li>
<p>在[子shell][26]中设置和操作变量之后，如果尝试在子shell作用域之外使用同名变量的话, 将会产生令人不快的结果。</p>
</li>
</ul>
<p>样例 34-2. 子shell缺陷</p>
<div><pre><code><span>#!/bin/bash</span>
<span># 子shell中的变量缺陷。</span>

<span>outer_variable</span><span>=</span>outer
<span>echo</span>
<span>echo</span> <span>"outer_variable = <span>$outer_variable</span>"</span>
<span>echo</span>

<span>(</span>
<span># 开始子shell</span>

<span>echo</span> <span>"outer_variable inside subshell = <span>$outer_variable</span>"</span>
<span>inner_variable</span><span>=</span>inner  <span># Set</span>
<span>echo</span> <span>"inner_variable inside subshell = <span>$inner_variable</span>"</span>
<span>outer_variable</span><span>=</span>inner  <span># 会修改全局变量吗？</span>
<span>echo</span> <span>"outer_variable inside subshell = <span>$outer_variable</span>"</span>

<span># 如果将变量‘导出’会产生不同的结果么？</span>
<span>#    export inner_variable</span>
<span>#    export outer_variable</span>
<span># 试试看。</span>

<span># 结束子shell</span>
<span>)</span>

<span>echo</span>
<span>echo</span> <span>"inner_variable outside subshell = <span>$inner_variable</span>"</span>  <span># Unset.</span>
<span>echo</span> <span>"outer_variable outside subshell = <span>$outer_variable</span>"</span>  <span># Unchanged.</span>
<span>echo</span>

<span>exit</span> <span>0</span>

<span># 如果你去掉第19和第20行的注释会怎样？</span>
<span># 会产生不同的结果吗？</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><ul>
<li>将echo的输出通过[管道][27]传递给[read][28]命令可能会产生不可预料的结果。在这种情况下，read命令的行为就好像它在子shell中运行一样。可以使用[set][29]命令来代替(就好像[例子15-18][30]一样)。</li>
</ul>
<p>样例 34-3. 将echo的输出通过管道传递给read命令</p>
<div><pre><code><span>#!/bin/bash</span>
<span>#  badread.sh:</span>
<span>#  尝试使用'echo'和'read'命令</span>
<span>#+ 非交互的给变量赋值。</span>

<span>#   shopt -s lastpipe</span>

<span>a</span><span>=</span>aaa
<span>b</span><span>=</span>bbb
<span>c</span><span>=</span>ccc

<span>echo</span> <span>"one two three"</span> <span>|</span> <span>read</span> a b c
<span># 尝试重新给变量a，b，和c赋值。</span>

<span>echo</span>
<span>echo</span> <span>"a = <span>$a</span>"</span>  <span># a = aaa</span>
<span>echo</span> <span>"b = <span>$b</span>"</span>  <span># b = bbb</span>
<span>echo</span> <span>"c = <span>$c</span>"</span>  <span># c = ccc</span>
<span># 重新赋值失败。</span>

<span>### 但如果 . . .</span>
<span>##  去掉第6行的注释:</span>
<span>#   shopt -s lastpipe</span>
<span>##+ 就能解决这个问题！</span>
<span>### 这是Bash 4.2版本的新特性。</span>

<span># ------------------------------</span>

<span># 试试下边这种方法。</span>

<span>var</span><span>=</span><span><span>`</span><span>echo</span> <span>"one two three"</span><span>`</span></span>
<span>set</span> -- <span>$var</span>
<span>a</span><span>=</span><span>$1</span><span>;</span> <span>b</span><span>=</span><span>$2</span><span>;</span> <span>c</span><span>=</span><span>$3</span>

<span>echo</span> <span>"-------"</span>
<span>echo</span> <span>"a = <span>$a</span>"</span>  <span># a = one</span>
<span>echo</span> <span>"b = <span>$b</span>"</span>  <span># b = two</span>
<span>echo</span> <span>"c = <span>$c</span>"</span>  <span># c = three </span>
<span># 重新赋值成功。</span>

<span># ------------------------------</span>

<span>#  也请注意，echo到'read'的值只会在子shell中起作用。</span>
<span>#  所以，变量的值*只*会在子shell中被修改。</span>

<span>a</span><span>=</span>aaa          <span># 重新开始。</span>
<span>b</span><span>=</span>bbb
<span>c</span><span>=</span>ccc

<span>echo</span><span>;</span> <span>echo</span>
<span>echo</span> <span>"one two three"</span> <span>|</span> <span>(</span> <span>read</span> a b c<span>;</span>
<span>echo</span> <span>"Inside subshell: "</span><span>;</span> <span>echo</span> <span>"a = <span>$a</span>"</span><span>;</span> <span>echo</span> <span>"b = <span>$b</span>"</span><span>;</span> <span>echo</span> <span>"c = <span>$c</span>"</span> <span>)</span>
<span># a = one</span>
<span># b = two</span>
<span># c = three</span>
<span>echo</span> <span>"-----------------"</span>
<span>echo</span> <span>"Outside subshell: "</span>
<span>echo</span> <span>"a = <span>$a</span>"</span>  <span># a = aaa</span>
<span>echo</span> <span>"b = <span>$b</span>"</span>  <span># b = bbb</span>
<span>echo</span> <span>"c = <span>$c</span>"</span>  <span># c = ccc</span>
<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><p>事实上，也正如Anthony Richardson指出的那样，通过管道将输出传递到任何循环中, 都会引起类似的问题。</p>
<div><pre><code><span># 循环的管道问题。</span>
<span>#  这个例子由Anthony Richardson编写，</span>
<span>#+ 由Wilbert Berendsen补遗。</span>


<span>foundone</span><span>=</span>false
<span>find</span> <span>$HOME</span> -type f -atime +30 -size 100k <span>|</span>
<span>while</span> <span>true</span>
<span>do</span>
   <span>read</span> f
   <span>echo</span> <span>"<span>$f</span> is over 100KB and has not been accessed in over 30 days"</span>
   <span>echo</span> <span>"Consider moving the file to archives."</span>
   <span>foundone</span><span>=</span>true
   <span># ------------------------------------</span>
     <span>echo</span> <span>"Subshell level = <span>$BASH_SUBSHELL</span>"</span>
   <span># Subshell level = 1</span>
   <span># 没错, 现在是在子shell中运行。</span>
   <span># ------------------------------------</span>
<span>done</span>
   
<span>#  变量foundone在这里肯定是false，</span>
<span>#+ 因为它是在子shell中被设置为true的。</span>
<span>if</span> <span>[</span> <span>$foundone</span> <span>=</span> <span>false</span> <span>]</span>
<span>then</span>
   <span>echo</span> <span>"No files need archiving."</span>
<span>fi</span>

<span># =====================现在，下边是正确的方法:=================</span>

<span>foundone</span><span>=</span>false
<span>for</span> <span>f</span> <span>in</span> <span><span>$(</span><span>find</span> <span>$HOME</span> -type f -atime +30 -size 100k<span>)</span></span>  <span># 这里没使用管道。</span>
<span>do</span>
   <span>echo</span> <span>"<span>$f</span> is over 100KB and has not been accessed in over 30 days"</span>
   <span>echo</span> <span>"Consider moving the file to archives."</span>
   <span>foundone</span><span>=</span>true
<span>done</span>
   
<span>if</span> <span>[</span> <span>$foundone</span> <span>=</span> <span>false</span> <span>]</span>
<span>then</span>
   <span>echo</span> <span>"No files need archiving."</span>
<span>fi</span>

<span># ==================这里是另一种方法==================</span>

<span>#  将脚本中读取变量的部分放到一个代码块中，</span>
<span>#+ 这样一来，它们就能在相同的子shell中共享了。</span>
<span>#  感谢，W.B。</span>

<span>find</span> <span>$HOME</span> -type f -atime +30 -size 100k <span>|</span> <span>{</span>
     <span>foundone</span><span>=</span>false
     <span>while</span> <span>read</span> f
     <span>do</span>
       <span>echo</span> <span>"<span>$f</span> is over 100KB and has not been accessed in over 30 days"</span>
       <span>echo</span> <span>"Consider moving the file to archives."</span>
       <span>foundone</span><span>=</span>true
     <span>done</span>

     <span>if</span> <span>!</span> <span>$foundone</span>
     <span>then</span>
       <span>echo</span> <span>"No files need archiving."</span>
     <span>fi</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><ul>
<li>一个相关的问题：当你尝试将tail -f的stdout通过管道传递给[grep][31]时，会产生问题。</li>
</ul>
<div><pre><code><span>tail</span> -f /var/log/messages <span>|</span> <span>grep</span> <span>"<span>$ERROR_MSG</span>"</span> <span>>></span> error.log
<span>#  “error.log”文件将不会写入任何东西。</span>
<span>#  正如Samuli Kaipiainen指出的那样，</span>
<span>#+ 这一结果是从grep的缓冲区输出的。</span>
<span>#  解决的办法就是把“--line-buffered”参数添加到grep中。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>
<p>在脚本中使用“suid”命令是非常危险的，因为这会危及系统安全。<sup></sup></p>
</li>
<li>
<p>使用shell脚本来编写CGI程序是值得商榷的。因为Shell脚本的变量不是“类型安全”的，当CGI被关联的时候，可能会产生令人不快的行为。此外，它还很难抵挡住“破解的考验”。</p>
</li>
<li>
<p>Bash不能正确地处理[双斜线(//)字符串][32]。</p>
</li>
<li>
<p>在Linux或BSD上编写的Bash脚本，可能需要修改一下，才能使它们运行在商业的UNIX机器上。这些脚本通常都使用GNU命令和过滤工具，GNU工具通常都比一般的UNIX上的同类工具更加强大。这方面的一个非常明显的例子就是，文本处理工具[tr][33]。</p>
</li>
<li>
<p>遗憾的是，更新Bash本身就会破坏[过去工作完全正常][34]的脚本。让我们回顾一下[使用无正式文件的Bash功能有多危险][35]。</p>
</li>
</ul>
<blockquote>
<p>危险正在接近你 --
小心，小心，小心，小心。
许多勇敢的心都在沉睡。
所以一定要小心 --
小心。</p>
</blockquote>
<blockquote>
<p>——A.J. Lamb and H.W. Petrie
[1]: http://tldp.org/LDP/abs/html/special-chars.html#WHITESPACEREF
[2]: http://tldp.org/LDP/abs/html/special-chars.html#CODEBLOCKREF
[3]: http://tldp.org/LDP/abs/html/special-chars.html#SEMICOLONREF
[4]: http://tldp.org/LDP/abs/html/comparison-ops.html#SCOMPARISON1
[5]: http://tldp.org/LDP/abs/html/internal.html#LETREF
[6]: http://tldp.org/LDP/abs/html/comparison-ops.html#STRTEST
[7]: http://tldp.org/LDP/abs/html/redircb.html#REDIR2
[8]: http://tldp.org/LDP/abs/html/internalvariables.html#ARGLIST
[9]: http://tldp.org/LDP/abs/html/quotingvar.html#WSQUO
[10]: http://tldp.org/LDP/abs/html/quotingvar.html#VARSPLITTING
[11]: http://tldp.org/LDP/abs/html/bashver2.html#BASH2REF
[12]: http://tldp.org/LDP/abs/html/why-shell.html#BASHDEF
[13]: http://tldp.org/LDP/abs/html/gotchas.html#BINSH
[14]: http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF
[15]: http://tldp.org/LDP/abs/html/complexfunct.html#RETURNREF
[16]: http://tldp.org/LDP/abs/html/complexfunct.html#RETURNTEST
[17]: http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF
[18]: http://tldp.org/LDP/abs/html/localvar.html#EXITVALANOMALY01
[19]: http://tldp.org/LDP/abs/html/internal.html#EXITVALANOMALY02
[20]: http://tldp.org/LDP/abs/html/testconstructs.html#ARXS
[21]: http://tldp.org/LDP/abs/html/here-docs.html#HEREDOCREF
[22]: http://tldp.org/LDP/abs/html/here-docs.html#INDENTEDLS
[23]: http://tldp.org/LDP/abs/html/assortedtips.html#RVT
[24]: http://tldp.org/LDP/abs/html/assortedtips.html#RVTCAUTION
[25]: http://tldp.org/LDP/abs/html/internal.html#FORKREF
[26]: http://tldp.org/LDP/abs/html/subshells.html#SUBSHELLSREF
[27]: http://tldp.org/LDP/abs/html/special-chars.html#PIPEREF
[28]: http://tldp.org/LDP/abs/html/internal.html#READREF
[29]: http://tldp.org/LDP/abs/html/internal.html#SETREF
[30]: http://tldp.org/LDP/abs/html/internal.html#SETPOS
[31]: http://tldp.org/LDP/abs/html/textproc.html#GREPREF
[32]: http://tldp.org/LDP/abs/html/internal.html#DOUBLESLASHREF
[33]: http://tldp.org/LDP/abs/html/textproc.html#TRREF
[34]: http://tldp.org/LDP/abs/html/string-manipulation.html#PARAGRAPHSPACE
[35]: http://tldp.org/LDP/abs/html/gotchas.html#UNDOCF
[36]: http://tldp.org/LDP/abs/html/fto.html#SUIDREF</p>
</blockquote>
<h4 id="注意事项"> 注意事项</h4>
<hr>
<section>
<ol>
<li id="footnote1"><p>在Linux和绝大多数的UNIX机器上，给脚本设置[suid][36]权限是没用的。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">36.1 交互和非交互shell以及脚本</title>
    <id>https://clay-wangzhi.com/code/shell/part5/36_1_interactive_and_non-interactive_shells_and_scripts/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/36_1_interactive_and_non-interactive_shells_and_scripts/"/>
    <updated>2021-05-11T06:41:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_36-1-交互和非交互shell以及脚本"> 36.1 交互和非交互shell以及脚本</h1>
<p>交互shell从tty读取用户输入。shell默认会读取启动文件，显示提示符和打开任务控制等。用户可以和shell交互。</p>
<p>脚本总是运行在非交互的shell上。同样，脚本可以访问它自己的tty，这使得在脚本中依然可以模拟出交互的shell。</p>
<div><pre><code>#!/bin/bash
MY_PROMPT=&#39;$ &#39;
while :
    do
        echo -n &quot;$MY_PROMPT&quot;
        read line
        eval &quot;$line&quot;
    done

exit 0

# 这个脚本以及以上解释是由Stéphane Chazelas提供的
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>一个要求用户输入的交互脚本，通常会用到read语句（请看例15-3）。不过实际上要复杂一些，一个被用户通过console或者xterm调用的脚本，意味着这个脚本被绑定到了一个tty上。</p>
<p>初始化和启动脚本必须是非交互的，因为在运行过程中不能要求人类的介入。许多管理和系统维护脚本也同样是非交互的。要求自动运行的重复性任务也是通过非交互脚本实现的。</p>
<p>非交互的脚本可以在后台运行，而交互脚本（在后台运行）则会挂起，因为要等待永远不可能出现的“输入”。解决这个难题可以使用带有expect命令的脚本，或者将文档嵌入到后台运行的交互脚本中。最简单的例子就是将一个文件重定向到read语句，来提供“输入”。(read variable &lt; file) 这可以创造出一个在交互和非交互两种模式下通用的脚本。</p>
<p>如果脚本需要知道它是否运行在交互模式下，简单的方法就是看提示符变量是否存在，就是$PS1变量。（如果用户通过提示符输入，那么脚本就需要显示提示符，所以脚本中$PS1变量会被设置）</p>
<div><pre><code>if [ -z $PS1 ] # 是否有提示符（译注：判断脚本是否运行在交互模式下）
### if [ -v PS1 ]   # Bash 4.2+ ...
then
    # 非交互模式
    ...
else
    # 交互模式
    ...
fi
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>脚本也可以测试$-变量中是否使用了“i”选项来判读是否运行在交互模式下。</p>
<div><pre><code>case $- in
    *i*)    # 交互shell
    ;;
    *)      # 非交互shell
    ;;
# (参见 &quot;UNIX F.A.Q.,&quot; 1993)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>John Lange描述了另一种替代方法：使用test -t来测试。</p>
<div><pre><code># 关于终端的测试！

fd=0   # stdin 标准输入

# 使用test -t测试stdin或者stdout是否是一个终端（如果是则证明该脚本运行于交互模式）。
if [ -t &quot;$fd&quot; ]
then
    echo interactive # 译注：交互模式
else
    echo non-interactive # 译注：非交互模式
fi

# 但是John指出：
#     if [ -t 0 ] 仅在你本地登录时有效，
#     如果通过ssh远程调用就会失效，
#     所以还要加上对socket的判断。

if [[ -t &quot;$fd&quot; || -p /dev/stdin ]]
then
    echo interactive # 译注：交互模式
else
    echo non-interactive # 译注：非交互模式
fi
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>笔记</p>
<p>脚本可以使用-i选项或者#!/bin/bash -i的文件头强制进入交互模式执行。这可能导致古怪的脚本行为或者在没有错误的情况下显示错误信息。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">36.2 shell wrappers</title>
    <id>https://clay-wangzhi.com/code/shell/part5/36_2_shell_wrappers/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/36_2_shell_wrappers/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_36-2-shell-wrappers"> 36.2 shell wrappers</h1>
<p>wrapper是一个包含系统命令和工具的脚本，脚本会把一些参数传递给这些（脚本内的）命令。将一个复杂的命令封装成一个wrapper是为了调用它时比较简单好记，特别在使用sed和awk命令时会这么做。</p>
<p>sed或awk脚本通常在命令行下调用时是sed -e '命令'或者awk '命令'。在Bash脚本中嵌入这些命令会让它们在调用时很简单，并且能够被重用。使用这种方法可以将sed和awk的优势统一起来，比如将sed命令处理的结果通过管道传递给awk继续处理。将这些保存成为一个可执行文件，你可以重复调用它的原始版本或者修改版本，而不用在命令行里反复敲冗长的命令。</p>
<h2 id="example-36-1-shell-wrapper"> Example 36-1. shell wrapper</h2>
<div><pre><code>#!/bin/bash

# 这个脚本功能是去除文件中的空白行
# 没有做参数检查
#
# 也许你想添加下面的内容：
#
# E_NOARGS=85
# if [ -z &quot;$1&quot; ]
# then
#  echo &quot;Usage: `basename $0` target-file&quot;
#  exit $E_NOARGS
# fi

sed -e /^$/d &quot;$1&quot;
# 就像这个命令
#    sed -e &#39;/^$/d&#39; filename
# 通过命令行调用

# &#39;-e&#39;意思是后面为编辑命令（这个选项可省略）。
# &#39;^&#39;代表行首，&#39;$&#39;代表行尾。
# 这个正则表达式表示要匹配出所有行首位没有内容的行，就是空白行。
# 是删除命令（译注：就是把刚才选出来的空白行删掉）

# 将文件名中的特殊字符和空白进行转译

# 这个脚本并不会真正的修改目标文件，如果想对目标文件真正的修改，请将输出重定向

exit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="example-36-2-稍微复杂一点的-shell-wrapper"> Example 36-2. 稍微复杂一点的 shell wrapper</h2>
<div><pre><code>#!/bin/bash

#  subst.sh: 在文件中进行替换字符串的脚本
#  例如 &quot;sh subst.sh Smith Jones letter.txt&quot;
#  letter.txt 中的所有 Jones 都被替换为 Smith。

ARGS=3         # 这个脚本需要三个参数
E_BADARGS=85   # 传给脚本的参数数量不正确

if [ $# -ne &quot;$ARGS&quot; ]
then
    echo &quot;Usage: `basename $0` old-pattern new-pattern filename&quot;
    exit $E_BADARGS
fi

old_pattern=$1
new_pattern=$2

if [ -f &quot;$3&quot; ]
then
    file_name=$3
else
    echo &quot;File \&quot;$3\&quot; does not exist.&quot;
    exit $E_BADARGS
fi

# -----------------------------------------------
# 这里是最核心的部分
sed -e &quot;s/$old_pattern/$new_pattern/g&quot; $file_name
# -----------------------------------------------

# &#39;s&#39; 是sed中的替换命令
# /pattern/调用地址匹配
# &#39;g&#39; 表示要对文件中的所有匹配项目都进行替换操作，而不是仅对第一个这样干。
# 如果需要深入了解，请阅读sed命令的相关文档。

exit $?  # 将这个脚本的输出重定向到一个文件即可记录真正的结果
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h2 id="example-36-3-一个通用的写日志文件的-shell-wrapper"> Example 36-3. 一个通用的写日志文件的 shell wrapper</h2>
<div><pre><code>#!/bin/bash
#  logging-wrapper.sh
#  一个通用的shell wrapper，在进行操作的同时对操作进行日志记录

DEFAULT_LOGFILE=logfile.txt

# 设置下面两个变量的值
OPERATION=
# 可以是任意操作，比如一个awk脚本或者用管道连接的复杂命令

LOGFILE=
if [ -z &quot;$LOGFILE&quot; ]
    then     # 如果没有设置日志文件，则使用默认文件名
      LOGFILE=&quot;$DEFAULT_LOGFILE&quot;
      fi

# 对于操作命令的参数（可选）
OPTIONS=&quot;$@&quot;


# 日志记录
echo &quot;`date` + `whoami` + $OPERATION &quot;$@&quot;&quot; &gt;&gt; $LOGFILE
# 进行操作动作
exec $OPERATION &quot;$@&quot;

# 要在真正执行操作之前写日志
# 思考下为什么要先写日志，后操作。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="example-36-4-关于awk脚本的-shell-wrapper"> Example 36-4. 关于awk脚本的 shell wrapper</h2>
<div><pre><code>#!/bin/bash
# pr-ascii.sh: 打印ASCII码表格

START=33   # 可打印的ASCII码范围（十进制）
END=127    # 不会输出不可打印的ASCII码

echo &quot; Decimal   Hex     Character&quot;   # 表头
echo &quot; -------   ---     ---------&quot;

for ((i=START; i&lt;=END; i++))
do
    echo $i | awk &#39;{printf(&quot;  %3d       %2x         %c\n&quot;, $1, $1, $1)}&#39;
# Bash内置的printf命令无法完成下面的操作: （译注：所以这使用awk脚本来实现输出）
#     printf &quot;%c&quot; &quot;$i&quot;
done

exit 0


#  Decimal   Hex     Character
#  -------   ---     ---------
#    33       21         !
#    34       22         &quot;
#    35       23         #
#    36       24         $
#
#    . . .
#
#   122       7a         z
#   123       7b         {
#   124       7c         |
#   125       7d         }


# 将输出重定向到文件
# 或者用管道传递给&quot;more&quot;:  sh pr-asc.sh | more
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h2 id="example-36-5-另一个关于awk的-shell-wrapper"> Example 36-5. 另一个关于awk的 shell wrapper</h2>
<div><pre><code>#!/bin/bash

# 在目标文件中添加一个数字的特殊列
# 十进制浮点数也可以，因为awk可以处理这样的输出。

ARGS=2
E_WRONGARGS=85

if [ $# -ne &quot;$ARGS&quot; ] # Check for proper number of command-line args.
then
    echo &quot;Usage: `basename $0` filename column-number&quot;
    exit $E_WRONGARGS
fi

filename=$1
column_number=$2

# 将shell脚本的变量传递给awk有一点难办。
# 第一种方法是用引号将Bash脚本变量在awk脚本中包起来
#     $&#39;$BASH_SCRIPT_VAR&#39;
#      ^                ^
# 下面的awk脚本就是这么干的。
# 详细用法可以查阅awk文档。

# 多行的awk脚本可以写成这样
#   awk &#39;
#   ...
#   ...
#   ...
#   &#39;


# 开始awk脚本
# -----------------------------
awk &#39;

{ total += $&#39;&quot;${column_number}&quot;&#39; # 译注：这就是那个bash脚本变量
}
END {
print total
}     

&#39; &quot;$filename&quot;
# -----------------------------
# 结束awk脚本


#   将shell变量传递给awk脚本也许是不安全的
#   所以Stephane Chazelas提出了下面的替代方案：
#   ---------------------------------------
#   awk -v column_number=&quot;$column_number&quot; &#39; # 译注：将shell的值赋给一个awk变量
#   { total += $column_number
#   }
#   END {
#       print total
#   }&#39; &quot;$filename&quot;
#   ---------------------------------------


exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><p>能满足那些需要瑞士军刀般全能工具的脚本语言，就只有Perl了。Perl集合了sed和awk的能力，并且比C更加精简。它是模块化的并且能支持包括厨房洗碗槽在内的所有面向对象编程所能涉及的事物。短小的Perl脚本可以嵌入shell脚本中，甚至Perl可以完全替代shell脚本。（本书作者对此仍然抱有怀疑）</p>
<h2 id="example-36-6-perl嵌入bash脚本"> Example 36-6. Perl嵌入Bash脚本</h2>
<div><pre><code>#!/bin/bash

# shell命令先于Perl脚本执行
echo &quot;This precedes the embedded Perl script within \&quot;$0\&quot;.&quot;
echo &quot;===============================================================&quot;

perl -e &#39;print &quot;This line prints from an embedded Perl script.\n&quot;;&#39;
# 像sed命令一样，Perl使用&#39;-e&#39;选项

echo &quot;===============================================================&quot;
echo &quot;However, the script may also contain shell and system commands.&quot;

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>即使能将Bash脚本和Perl脚本合二为一，先执行Bash部分还是Perl部分仍然要取决于调用脚本的方式。</p>
<h2 id="example-36-7-bash和perl脚本合并"> Example 36-7. Bash和Perl脚本合并</h2>
<div><pre><code>#!/bin/bash
# bashandperl.sh

echo &quot;Greetings from the Bash part of the script, $0.&quot;
# 这里可以写更多的Bash命令

exit
# Bash脚本部分结束

# =======================================================

#!/usr/bin/perl
# 这部分脚本要像下面这样调用
#    perl -x bashandperl.sh

print &quot;Greetings from the Perl part of the script, $0.\n&quot;;
# Perl 看起来并不像 “echo” ...
# 这里可以写更多的Perl命令

# Perl命令部分结束
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><pre><code>bash$ bash bashandperl.sh
Greetings from the Bash part of the script.

bash$ perl -x bashandperl.sh
Greetings from the Perl part of the script.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当然还可以用shell wrapper嵌入更多的“外来户”，比如Python或者其他的...</p>
<h2 id="example-36-8-python嵌入bash脚本"> Example 36-8. Python嵌入Bash脚本</h2>
<div><pre><code>#!/bin/bash
# ex56py.sh

# shell脚本先于Python脚本执行
echo &quot;This precedes the embedded Python script within \&quot;$0.\&quot;&quot;
echo &quot;===============================================================&quot;

python -c &#39;print &quot;This line prints from an embedded Python script.\n&quot;;&#39;
# 并不像sed和Perl，Python使用&#39;-c&#39;选项
python -c &#39;k = raw_input( &quot;Hit a key to exit to outer script. &quot; )&#39;

echo &quot;===============================================================&quot;
echo &quot;However, the script may also contain shell and system commands.&quot;

exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>使用脚本封装mplayer或者Google翻译服务器的一些功能，你能做出给你反馈一些信息的小东西。</p>
<h2 id="example-36-9-会讲话的脚本"> Example 36-9. 会讲话的脚本</h2>
<div><pre><code>#!/bin/bash
#   参见:
#   http://elinux.org/RPi_Text_to_Speech_(Speech_Synthesis)

# 为了连接Google翻译服务器，这个脚本必须连接到互联网才能工作，
# 而且你的计算机上必须装有mplayer。

speak()
  {
  local IFS=+
  # 先调用mplayer，再连接Google翻译服务器。
  /usr/bin/mplayer -ao alsa -really-quiet -noconsolecontrols \
  &quot;http://translate.google.com/translate_tts?tl=en&amp;q=&quot;$*&quot;&quot;
  # 可以说话的Google翻译
  }

LINES=4

spk=$(tail -$LINES $0) # 同样的结尾
speak &quot;$spk&quot;
exit
# BRowns 很高兴与你谈话。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>有个有趣的shell wrapper例子是Martin Matusiak的undvd，为复杂的mencoder工具提供了一个简单易用的命令行接口。另一个例子是Itzchak Rehberg的Ext3Undel，它为在ext3文件系统上恢复删除的文件提供了一整套工具。</p>
<p>Notes
[1] Linux工具事实上很多是shell wrapper，比如/usr/bin/pdf2ps，/usr/bin/batch和/usr/bin/xmkmf。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">36.3 测试和比较的其他方法</title>
    <id>https://clay-wangzhi.com/code/shell/part5/36_3_tests_and_comparisons_alternatives/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/36_3_tests_and_comparisons_alternatives/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_36-3-测试和比较的其他方法"> 36.3 测试和比较的其他方法</h1>
<p>对于判断（test命令）来说，[[ ]]比[ ]更加合适。同样的，算数运算符（译注：-eq之类的）比(( ))更有优势。</p>
<div><pre><code>a=8

# 下面所有这些比较的结果都应该是相等的
test &quot;$a&quot; -lt 16 &amp;&amp; echo &quot;yes, $a &lt; 16&quot;         # &quot;and list&quot;
/bin/test &quot;$a&quot; -lt 16 &amp;&amp; echo &quot;yes, $a &lt; 16&quot; 
[ &quot;$a&quot; -lt 16 ] &amp;&amp; echo &quot;yes, $a &lt; 16&quot; 
[[ $a -lt 16 ]] &amp;&amp; echo &quot;yes, $a &lt; 16&quot;          # 为表达式添加
(( a &lt; 16 )) &amp;&amp; echo &quot;yes, $a &lt; 16&quot;             # [[ ]]和(( ))并不是必须的

city=&quot;New York&quot;
# 下面这些结果也是相等的
test &quot;$city&quot; \&lt; Paris &amp;&amp; echo &quot;Yes, Paris is greater than $city&quot;
                                  # ASCII字符比较
/bin/test &quot;$city&quot; \&lt; Paris &amp;&amp; echo &quot;Yes, Paris is greater than $city&quot; 
[ &quot;$city&quot; \&lt; Paris ] &amp;&amp; echo &quot;Yes, Paris is greater than $city&quot; 
[[ $city &lt; Paris ]] &amp;&amp; echo &quot;Yes, Paris is greater than $city&quot;
                                  # 并不需要为$city变量加引号。

# 向S.C.致谢
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">36.4 递归：可以调用自己的脚本</title>
    <id>https://clay-wangzhi.com/code/shell/part5/36_4_recursion_a_script_calling_itself/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/36_4_recursion_a_script_calling_itself/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_36-4-递归-可以调用自己的脚本"> 36.4 递归：可以调用自己的脚本</h1>
<p>脚本可以递归的调用自己吗？答案是肯定的。</p>
<h2 id="example-36-10-可以调用自己的脚本-但没什么实际用途"> Example 36-10. 可以调用自己的脚本（但没什么实际用途）</h2>
<div><pre><code>#!/bin/bash
# recurse.sh

# 脚本可以调用自己吗？
# 其实是可以的。但这样有什么实际用途吗？
# （请往下看）

RANGE=10
MAXVAL=9

i=$RANDOM
let &quot;i %= $RANGE&quot;  # 在0到$RANGE - 1的范围内产生一个随机数

if [ &quot;$i&quot; -lt &quot;$MAXVAL&quot; ]
then
    echo &quot;i = $i&quot;
    ./$0           # 脚本进行递归调用（调用自己）
fi                 # 每次被调用的脚本做同样的事情，直到$i和$MAXVAL相等。 

# 如果使用“while”循环代替“if/then”语句会出问题。请试着解释为什么。

exit 0

# 笔记:
# ----
# 这个脚本文件必须有可执行权限。
# 即使使用“sh”命令调用，这脚本也可以执行。
# 请解释原因。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id="example-36-11-一个有点用的调用自己的脚本"> Example 36-11. 一个有点用的调用自己的脚本</h2>
<div><pre><code>#!/bin/bash
# pb.sh: phone book

# 用于权限管理的脚本，由Rick Boivie编写。
# ABS作者稍有修改

MINARGS=1     # 需要至少一个参数
DATAFILE=./phonebook
              # 当前目录下必须存在名为“phonebook”的数据文件
PROGNAME=$0
E_NOARGS=70   # 没有错误

if [ $# -lt $MINARGS ]; then
    echo &quot;Usage: &quot;$PROGNAME&quot; data-to-look-up&quot;
    exit $E_NOARGS
fi      

if [ $# -eq $MINARGS ]; then
    grep $1 &quot;$DATAFILE&quot;
    # 如果$DATAFILE没有匹配则&#39;grep&#39;命令会报错。
else
    ( shift; &quot;$PROGNAME&quot; $* ) | grep $1
    # 脚本的递归调用
fi
exit 0        # 脚本结束 

# 下面是一些文件内容

# ------------------------------------------------------------------------
一个简单的&quot;phonebook&quot;数据文件:

John Doe        1555 Main St., Baltimore, MD 21228          (410) 222-3333
Mary Moe        9899 Jones Blvd., Warren, NH 03787          (603) 898-3232
Richard Roe     856 E. 7th St., New York, NY 10009          (212) 333-4567
Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678
Zoe Zenobia     4481 N. Baker St., San Francisco, SF 94338  (415) 501-1631
# ------------------------------------------------------------------------

$bash pb.sh Roe
Richard Roe     856 E. 7th St., New York, NY 10009          (212) 333-4567
Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678

$bash pb.sh Roe Sam
Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678

# 当对脚本传入多于一个参数时，脚本只显示包含所有参数的行
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="example-36-12-另一个调用自己的脚本"> Example 36-12. 另一个调用自己的脚本</h2>
<div><pre><code>#!/bin/bash
# usrmnt.sh, 由Anthony Richardson编写
# 在ABS Guide中用于权限管理

# usage:       usrmnt.sh
# description: 想使用挂载设备操作的用户，在/etc/sudoers文件中必须属于MNTUSERS组。

# ----------------------------------------------------------
# 这个脚本会返回加了sudo命令的自身。
# 如果一个有权限的用户，则只需要输入：
#   usermount /dev/fd0 /mnt/floppy
# 而不需要使用下面的方法：
#   sudo usermount /dev/fd0 /mnt/floppy

# 我对于所有需要sudo的脚本都使用了这个技术，因为我发现这让我感觉非常舒服。
# ----------------------------------------------------------

# 如果SUDO_COMMAND变量没有被设置，那证明没有使用sudo命令运行。这需要
# 再重新运行这个脚本，同时传递用户的ID和组ID...

if [ -z &quot;$SUDO_COMMAND&quot; ]
then
    mntusr=$(id -u) grpusr=$(id -g) sudo $0 $* # 译注：脚本调用自己，并且传递参数
    exit 0
fi

# 如果使用了sudo运行，就不会卡在这里了。
/bin/mount $* -o uid=$mntusr,gid=$grpusr

exit 0

# 附加说明：
# -------------------------------------------------

# 1) Linux系统允许/etc/fstab文件中列出的用户挂在移动存储设备。但在服务器上，我喜欢让更少的人访问移动存储。我发现使用sudo可以帮我做到。

# 2) 我还发现使用sudo比用组权限来实现让人感觉更加舒服。

# 3) 这种方法可以给任何有权限的人使用mount命令，所以要小心处理。
#    你也可以将这种技术用到比如mntfloppy，mntcdrom和mntsamba等脚本上来实现更优雅的挂载管理。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>过多层次的递归调用会导致脚本的栈空间溢出，引起段错误（segfault）。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">echo命令</title>
    <id>https://clay-wangzhi.com/code/shell/part5/36_5_colorizing_scripts/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/36_5_colorizing_scripts/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="echo命令"> echo命令</h2>
<ul>
<li>-e 使转义符生效 如:  解释\t \n含义</li>
<li>-n 不换行输出</li>
</ul>
<h3 id="字颜色-30-37"> 字颜色：30—–37</h3>
<p>echo -e “\033[30m 黑色字 \033[0m”</p>
<p>echo -e “\033[31m 红色字 \033[0m”</p>
<p>echo -e “\033[32m 绿色字 \033[0m”</p>
<p>echo -e “\033[33m 黄色字 \033[0m”</p>
<p>echo -e “\033[34m 蓝色字 \033[0m”</p>
<p>echo -e “\033[35m 紫色字 \033[0m”</p>
<p>echo -e “\033[36m 天蓝字 \033[0m”</p>
<p>echo -e “\033[37m 白色字 \033[0m”</p>
<h3 id="字背景颜色范围-40-47"> 字背景颜色范围：40—–47</h3>
<p>echo -e “\033[40;37m 黑底白字 \033[0m”</p>
<p>echo -e “\033[41;37m 红底白字 \033[0m”</p>
<p>echo -e “\033[42;37m 绿底白字 \033[0m”</p>
<p>echo -e “\033[43;37m 黄底白字 \033[0m”</p>
<p>echo -e “\033[44;37m 蓝底白字 \033[0m”</p>
<p>echo -e “\033[45;37m 紫底白字 \033[0m”</p>
<p>echo -e “\033[46;37m 天蓝底白字 \033[0m”</p>
<p>echo -e “\033[47;30m 白底黑字 \033[0m”</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第36章 杂项</title>
    <id>https://clay-wangzhi.com/code/shell/part5/36_miscellany/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/36_miscellany/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第36章-杂项"> 第36章 杂项</h1>
<blockquote>
<p>Nobody really knows what the Bourne shell's grammar is. Even examination of the source code is little help.
——Tom Duff</p>
</blockquote>
<p>目录</p>
<ul>
<li><a href="./36_1_interactive_and_non-interactive_shells_and_scripts.html">36.1 交互和非交互shell以及脚本</a></li>
<li><a href="./36_2_shell_wrappers.html">36.2 shell wrappers</a></li>
<li><a href="./36_3_tests_and_comparisons_alternatives.html">36.3 测试和比较的其他方法</a></li>
<li><a href="./36_4_recursion_a_script_calling_itself.html">36.4 递归：调用自己的脚本</a></li>
<li><a href="./36_5_colorizing_scripts.html">36.5 “彩色”的脚本</a></li>
<li><a href="./36_6_optimizations.html">36.6 优化</a></li>
<li><a href="./36_7_assorted_tips.html">36.7 其他技巧</a></li>
<li><a href="./36_8_security_issues.html">36.8 安全问题</a></li>
<li><a href="./36_9_portability_issues.html">36.9 可移植性问题</a></li>
<li><a href="./36_10_shell_scripting_under_windows.html">36.10 Windows系统下的脚本</a></li>
</ul>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第五部分 高级话题</title>
    <id>https://clay-wangzhi.com/code/shell/part5/</id>
    <link href="https://clay-wangzhi.com/code/shell/part5/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第五部分-高级话题"> 第五部分 高级话题</h1>
<h3 id="目录"> 目录</h3>
<ul>
<li><a href="./18_regular_expressions.html">18.正则表达式</a>
<ul>
<li><a href="./18_1_a_brief_introduction_to_regular_expressions.html">18.1正则表达式简介</a></li>
<li><a href="./18_2_globbing.html">18.2文件名替换</a></li>
</ul>
</li>
<li><a href="./19_here_documents.html">19. 嵌入文档</a></li>
<li><a href="./20_io_redirection.html">20. I/O 重定向</a>
<ul>
<li><a href="./20_1_use_exec.html">20.1 使用 exec</a></li>
<li><a href="./20_2_redirecting_code_blocks.html">20.2 重定向代码块</a></li>
<li><a href="./20_3_applications.html">20.3 应用程序</a></li>
</ul>
</li>
<li><a href="./22_Restricted_Shells.html">22. 限制模式的Shell</a></li>
<li><a href="./23_Process_Substitution.html">23. 进程替换</a></li>
<li><a href="./24_functions.html">24. 函数</a>
<ul>
<li><a href="./24_1_complex_functions_and_function_complexities.html">24.1 复杂函数和函数复杂性</a></li>
<li><a href="./24_2_local_variables.html">24.2 局部变量</a></li>
<li><a href="./24_3_recursion_without_local_variables.html">24.3 不适用局部变量的递归</a></li>
</ul>
</li>
<li><a href="./25_aliases.html">25. 别名</a></li>
<li><a href="./source/part5/26_List_Constructs.html">26. 列表结构</a></li>
<li><a href="./27_arrays.html">27. 数组</a></li>
<li><a href="./30_network_programming.html">30. 网络编程</a></li>
<li><a href="./33_options.html">33. 选项</a></li>
<li><a href="./34_Gotchsa.html">34. 陷阱</a></li>
</ul>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">第六部分 Google Shell 风格指南</title>
    <id>https://clay-wangzhi.com/code/shell/part6/</id>
    <link href="https://clay-wangzhi.com/code/shell/part6/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第六部分-google-shell-风格指南"> 第六部分 Google Shell 风格指南</h1>
<h2 id="_1-背景"> 1 背景</h2>
<h3 id="_1-1-使用哪一种shell"> 1.1 使用哪一种Shell</h3>
<blockquote>
<p>Bash是唯一被允许执行的shell脚本语言。</p>
</blockquote>
<p>可执行文件必须以<code>#!/bin/bash</code>和最小数量的标志开始。请使<code>set</code>来设置shell的选项，使得用<code>bash &lt;script_name&gt;</code>调用你的脚本时不会破坏其功能。</p>
<p>限制所有的可执行shell脚本为bash使得我们安装在所有计算机中的shell语言保持一致性。</p>
<h3 id="_1-2-什么时候使用shell"> 1.2 什么时候使用Shell</h3>
<blockquote>
<p>Shell应该仅仅被用于小功能或者简单的包装脚本。</p>
</blockquote>
<p>尽管Shell脚本不是一种开发语言，但在整个谷歌它被用于编写多种实用工具的脚本。这个风格指南更多的是认同它的使用，而不是一个建议，即它可被用于广泛部署。</p>
<p>以下是一些准则：</p>
<ul>
<li>如果你主要是在调用其他的工具并且做一些相对很小数据量的操作，那么使用shell来完成任务是一种可接受的选择。</li>
<li>如果你在乎性能，那么请选择其他工具，而不是使用shell。</li>
<li>如果你发现你需要使用数据而不是变量赋值（如 <code>${PHPESTATUS}</code> ），那么你应该使用Python脚本。</li>
<li>如果你将要编写的脚本会超过100行，那么你可能应该使用Python来编写，而不是Shell。请记住，当脚本行数增加，尽早使用另外一种语言重写你的脚本，以避免之后花更多的时间来重写。</li>
</ul>
<h2 id="_2-shell文件和解释器调用"> 2 Shell文件和解释器调用</h2>
<h3 id="_2-1-文件扩展名"> 2.1 文件扩展名</h3>
<blockquote>
<p>可执行文件应该没有扩展名（强烈建议）或者使用.sh扩展名。库文件必须使用.sh作为扩展名，而且应该是不可执行的。</p>
</blockquote>
<p>当执行一个程序时，并不需要知道它是用什么语言编写的。而且shell脚本也不要求有扩展名。所以我们更喜欢可执行文件没有扩展名。</p>
<p>然而，对于库文件，知道其用什么语言编写的是很重要的，有时候会需要使用不同语言编写的相似的库文件。使用.sh这样特定语言后缀作为扩展名，就使得用不同语言编写的具有相同功能的库文件可以采用一样的名称。</p>
<h3 id="_2-2-suid-sgid"> 2.2 SUID/SGID</h3>
<blockquote>
<p>SUID(Set User ID)和SGID(Set Group ID)在shell脚本中是被禁止的。</p>
</blockquote>
<p>shell存在太多的安全问题，以致于如果允许SUID/SGID会使得shell几乎不可能足够安全。虽然bash使得运行SUID非常困难，但在某些平台上仍然有可能运行，这就是为什么我们明确提出要禁止它。</p>
<p>如果你需要较高权限的访问请使用<code>sudo</code>。</p>
<h2 id="_3-环境"> 3 环境</h2>
<h3 id="_3-1-stdout-vs-stderr"> 3.1 STDOUT vs STDERR</h3>
<blockquote>
<p>所有的错误信息都应该被导向STDERR。</p>
</blockquote>
<p>这使得从实际问题中分离出正常状态变得更容易。</p>
<p>推荐使用类似如下函数，将错误信息和其他状态信息一起打印出来。</p>
<div><pre><code><span>err</span><span>(</span><span>)</span> <span>{</span>
  <span>echo</span> <span>"[<span><span>$(</span><span>date</span> + <span>'%Y-%m-%dT%H:%M:%S%z'</span><span>)</span></span>]: <span>$@</span>"</span> <span>></span><span>&amp;2</span>
<span>}</span>

<span>if</span> <span>!</span> do_something<span>;</span><span>then</span>
  err <span>"Unable to do_someting"</span>
  <span>exit</span> <span>"<span>${E_DID_NOTHING}</span>"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="_4-注释"> 4 注释</h2>
<h3 id="_4-1-文件头"> 4.1 文件头</h3>
<blockquote>
<p>每个文件的开头是其文件内容的描述。</p>
</blockquote>
<p>每个文件必须包含一个顶层注释，对其内容进行简要概述。版权声明和作者信息是可选的。</p>
<p>例如：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>#</span>
<span># Perform hot backups of Oracle databases.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_4-2-功能注释"> 4.2 功能注释</h3>
<blockquote>
<p>任何不是既明显又短的函数都必须被注释。任何库函数无论其长短和复杂性都必须被注释。</p>
</blockquote>
<p>其他人通过阅读注释（和帮助信息，如果有的话）就能够学会如何使用你的程序或库函数，而不需要阅读代码。</p>
<p>所有的函数注释应该包含：</p>
<ul>
<li>函数的描述</li>
<li>全局变量的使用和修改</li>
<li>使用的参数说明</li>
<li>返回值，而不是上一条命令运行后默认的退出状态</li>
</ul>
<p>例如：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>#</span>
<span># Perform hot backups of Oracle databases.</span>

<span>export</span> <span><span>PATH</span></span><span>=</span><span>'/usr/xpg4/bin:/usr/bin:/opt/csw/bin:/opt/goog/bin'</span>

<span>#######################################</span>
<span># Cleanup files from the backup dir</span>
<span># Globals:</span>
<span>#   BACKUP_DIR</span>
<span>#   ORACLE_SID</span>
<span># Arguments:</span>
<span>#   None</span>
<span># Returns:</span>
<span>#   None</span>
<span>#######################################</span>
<span>cleanup</span><span>(</span><span>)</span> <span>{</span>
  <span>..</span>.
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="_4-3-实现部分的注释"> 4.3 实现部分的注释</h3>
<blockquote>
<p>注释你代码中含有技巧、不明显、有趣的或者重要的部分。</p>
</blockquote>
<p>这部分遵循谷歌代码注释的通用做法。不要注释所有代码。如果有一个复杂的算法或者你正在做一些与众不同的，放一个简单的注释。</p>
<h3 id="_4-4-todo注释"> 4.4 TODO注释</h3>
<blockquote>
<p>使用TODO注释临时的、短期解决方案的、或者足够好但不够完美的代码。</p>
</blockquote>
<p>这与C++指南中的约定相一致。</p>
<p>TODOs应该包含全部大写的字符串TODO，接着是括号中你的用户名。冒号是可选的。最好在TODO条目之后加上 bug或者ticket 的序号。</p>
<p>例如：</p>
<div><pre><code><span># TODO(mrmonkey): Handle the unlikely edge cases (bug ####)</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="_5-格式"> 5 格式</h2>
<h3 id="_5-1-缩进"> 5.1 缩进</h3>
<blockquote>
<p>缩进两个空格，没有制表符。</p>
</blockquote>
<p>在代码块之间请使用空行以提升可读性。缩进为两个空格。无论你做什么，请不要使用制表符。对于已有文件，保持已有的缩进格式。</p>
<h3 id="_5-2-行的长度和长字符串"> 5.2 行的长度和长字符串</h3>
<blockquote>
<p>行的最大长度为80个字符。</p>
</blockquote>
<p>如果你必须写长度超过80个字符的字符串，如果可能的话，尽量使用here document或者嵌入的换行符。长度超过80个字符的文字串且不能被合理地分割，这是正常的。但强烈建议找到一个方法使其变短。</p>
<div><pre><code><span># DO use 'here document's</span>
<span>cat</span> <span>&lt;&lt;</span>END<span>;</span>
I am an exceptionally long
string.
END

<span># Embedded newlines are ok too</span>
<span>long_string</span><span>=</span><span>"I am an exceptionally
  long string."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="_5-3-管道"> 5.3 管道</h3>
<blockquote>
<p>如果一行容不下整个管道操作，那么请将整个管道操作分割成每行一个管段。</p>
</blockquote>
<p>如果一行容得下整个管道操作，那么请将整个管道操作写在同一行。</p>
<p>否则，应该将整个管道操作分割成每行一个管段，管道操作的下一部分应该将管道符放在新行并且缩进2个空格。这适用于使用管道符’|’的合并命令链以及使用’||’和’&amp;&amp;’的逻辑运算链。</p>
<div><pre><code><span># All fits on one line</span>
command1 <span>|</span> command2

<span># Long commands</span>
command1 <span>\</span>
  <span>|</span> command2 <span>\</span>
  <span>|</span> command3 <span>\</span>
  <span>|</span> command4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="_5-4-循环"> 5.4 循环</h3>
<blockquote>
<p>请将<code>; do</code> ,<code>; then</code>和<code>while</code>,<code>for</code>,<code>if</code>放在同一行。</p>
</blockquote>
<p>shell中的循环略有不同，但是我们遵循跟声明函数时的大括号相同的原则。也就是说，<code>; do</code>,<code>; then</code>应该和 if/for/while 放在同一行。<code>else</code>应该单独一行，结束语句应该单独一行并且跟开始语句垂直对齐。</p>
<p>例如：</p>
<div><pre><code><span>for</span> <span>dir</span> <span>in</span> <span>${dir_to_cleanup}</span><span>;</span> <span>do</span>
  <span>if</span> <span>[</span><span>[</span> -d <span>"<span>${dir}</span>/<span>${ORACLE_SID}</span>"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
    log_date <span>"Cleaning up old files in <span>${dir}</span>/<span>${ORACLE_SID}</span>"</span>
	<span>rm</span> <span>"<span>${dir}</span>/<span>${ORACLE_SID}</span>/"</span>*
	<span>if</span> <span>[</span><span>[</span> <span>"<span>$?</span>"</span> -ne <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
	  error_message
	<span>fi</span>
  <span>else</span>
    <span>mkdir</span> -p <span>"<span>${dir}</span>/<span>${ORACLE_SID}</span>"</span>
	<span>if</span> <span>[</span><span>[</span> <span>"<span>$?</span>"</span> -ne <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
	  error_message
	<span>fi</span>
  <span>fi</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="_5-5-case语句"> 5.5 case语句</h3>
<blockquote>
<ul>
<li>通过2个空格缩进可选项。</li>
</ul>
</blockquote>
<ul>
<li>在同一行可选项的模式右圆括号之后和结束符 <code>;;</code> 之前各需要一个空格。</li>
<li>长可选项或者多命令可选项应该被拆分成多行，模式、操作和结束符 <code>;;</code> 在不同的行。</li>
</ul>
<p>匹配表达式比<code>case</code>和<code>esac</code>缩进一级。多行操作要再缩进一级。一般情况下，不需要引用匹配表达式。模式表达式前面不应该出现左括号。避免使用 ;&amp; 和 ;;&amp; 符号。</p>
<div><pre><code><span>case</span> <span>"<span>${expression}</span>"</span> <span>in</span>
  a<span>)</span>
    <span>variable</span><span>=</span><span>"..."</span>
	some_command <span>"<span>${variable}</span>"</span> <span>"<span>${other_expr}</span>"</span> <span>..</span>.
	<span>;</span><span>;</span>
  absolute<span>)</span>
    <span>actions</span><span>=</span><span>"relative"</span>
	another_command <span>"<span>${actions}</span>"</span> <span>"<span>${other_expr}</span>"</span> <span>..</span>.
	<span>;</span><span>;</span>
  *<span>)</span>
    error <span>"Unexpected expression '<span>${expression}</span>"</span>
	<span>;</span><span>;</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>只要整个表达式可读，简单的命令可以跟模式和<code>;;</code>写在同一行。这通常适用于单字母选项的处理。当单行容不下操作时，请将模式单独放一行，然后是操作，最后结束符<code>;;</code>也单独一行。当操作在同一行时，模式的右括号之后和结束符<code>;;</code>之前请使用一个空格分隔。</p>
<div><pre><code><span>verbose</span><span>=</span><span>'false'</span>
<span>aflag</span><span>=</span><span>''</span>
<span>bflag</span><span>=</span><span>''</span>
<span>files</span><span>=</span><span>''</span>
<span>while</span> <span>getopts</span> <span>'abf:v'</span> flag<span>;</span> <span>do</span>
  <span>case</span> <span>"<span>${flag}</span>"</span> <span>in</span>
    a<span>)</span> <span>aflag</span><span>=</span><span>'true'</span> <span>;</span><span>;</span>
	b<span>)</span> <span>bflag</span><span>=</span><span>'true'</span> <span>;</span><span>;</span>
	f<span>)</span> <span>files</span><span>=</span><span>"<span>${OPTARG}</span>"</span> <span>;</span><span>;</span>
	<span>v</span><span>)</span> <span>verbose</span><span>=</span><span>'true'</span> <span>;</span><span>;</span>
	*<span>)</span> error <span>"Unexpected option <span>${flag}</span>"</span> <span>;</span><span>;</span>
   <span>esac</span>
 <span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="_5-6-变量扩展"> 5.6 变量扩展</h3>
<blockquote>
<p>按优先级顺序：保持跟你所发现的一致；引用你的变量；推荐用<code>${var}</code>而不是<code>$var</code>，详细解释如下。</p>
</blockquote>
<p>这些仅仅是指南，因为作为强制规定似乎饱受争议。</p>
<p>以下按照优先顺序列出。</p>
<ol>
<li>与现存代码中你所发现的保持一致。</li>
<li>引用变量参阅下面一节，引用。</li>
<li>除非绝对必要或者为了避免深深的困惑，否则不要用大括号将单个字符的shell特殊变量或定位变量括起来。推荐将其他所有变量用大括号括起来。</li>
</ol>
<div><pre><code><span># Section of recommended cases.</span>

<span># Preferred style for 'special' variables:</span>
<span>echo</span> <span>"Positional: <span>$1</span>"</span> <span>"<span>$5</span>"</span> <span>"<span>$3</span>"</span>
<span>echo</span> <span>"Specials: !=<span>$!</span>, -=$-, _=<span>$_</span>. ?=<span>$?</span>, #=<span>$#</span> *=<span>$*</span> @=<span>$@</span> \$=<span>$$</span> ..."</span>

<span># Braces necessary:</span>
<span>echo</span> <span>"many parameters: <span>${10}</span>"</span>

<span># Braces avoiding confusion:</span>
<span># Output is "a0b0c0"</span>
<span>set</span> -- a b c
<span>echo</span> <span>"<span>${1}</span>0<span>${2}</span>0<span>${3}</span>0"</span>

<span># Preferred style for other variables:</span>
<span>echo</span> <span>"PATH=<span>${<span>PATH</span>}</span>, PWD=<span>${<span>PWD</span>}</span>, mine=<span>${some_var}</span>"</span>
<span>while</span> <span>read</span> f<span>;</span> <span>do</span>
  <span>echo</span> <span>"file=<span>${f}</span>"</span>
<span>done</span> <span>&lt;</span> <span>&lt;</span><span>(</span><span>ls</span> -l /tmp<span>)</span>

<span># Section of discouraged cases</span>

<span># Unquoted vars, unbraced vars, brace-quoted single letter</span>
<span># shell specials.</span>
<span>echo</span> <span>a</span><span>=</span><span>$avar</span> <span>"b=<span>$bvar</span>"</span> <span>"PID=<span>${$}</span>"</span> <span>"<span>${1}</span>"</span>

<span># Confusing use: this is expanded as "${1}0${2}0${3}0",</span>
<span># not "${10}${20}${30}</span>
<span>set</span> -- a b c
<span>echo</span> <span>"<span>$10</span><span>$20</span><span>$30</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h3 id="_5-7-引用"> 5.7 引用</h3>
<blockquote>
<ul>
<li>除非需要小心不带引用的扩展，否则总是引用包含变量、命令替换符、空格或shell元字符的字符串。</li>
</ul>
</blockquote>
<ul>
<li>推荐引用是单词的字符串（而不是命令选项或者路径名）。</li>
<li>千万不要引用整数。</li>
<li>注意 [[ 中模式匹配的引用规则。</li>
<li>请使用 $@ 除非你有特殊原因需要使用 $* 。</li>
</ul>
<div><pre><code><span># 'Single' quotes indicate that no substitution is desired.</span>
<span># "Double" quotes indicate that substitution is required/tolerated.</span>

<span># Simple examples</span>
<span># "quote command substitutions"</span>
<span>flag</span><span>=</span><span>"<span><span>$(</span>some_command and its args <span>"<span>$@</span>"</span> <span>'quoted separately'</span><span>)</span></span>"</span>

<span># "quote variables"</span>
<span>echo</span> <span>"<span>${flag}</span>"</span>

<span># "never quote literal integers"</span>
<span>value</span><span>=</span><span>32</span>
<span># "quote command substitutions", even when you expect integers</span>
<span>number</span><span>=</span><span>"<span><span>$(</span>generate_number<span>)</span></span>"</span>

<span># "prefer quoting words", not compulsory</span>
<span>readonly</span> <span>USE_INTEGER</span><span>=</span><span>'true'</span>

<span># "quote shell meta characters"</span>
<span>echo</span> <span>'Hello stranger, and well met. Earn lots of <span>$$</span>$'</span>
<span>echo</span> <span>"Process <span>$$</span>: Done making \$\$\$."</span>

<span># "command options or path names"</span>
<span># ($1 is assumed to contain a value here)</span>
<span>grep</span> -li Hugo /dev/null <span>"<span>$1</span>"</span>

<span># Less simple examples</span>
<span># "quote variables, unless proven false": ccs might be empty</span>
<span>git</span> send-email --to <span>"<span>${reviewers}</span>"</span> <span>${ccs<span>:+</span>"--cc" "${ccs}</span>"<span>}</span>

<span># Positional parameter precautions: $1 might be unset</span>
<span># Single quotes leave regex as-is.</span>
<span>grep</span> -cP <span>'([Ss]pecial|\|?characters*)$'</span> <span>${1<span>:+</span>"$1"}</span>

<span># For passing on arguments,</span>
<span># "$@" is right almost everytime, and</span>
<span># $* is wrong almost everytime:</span>
<span>#</span>
<span># * $* and $@ will split on spaces, clobbering up arguments</span>
<span>#   that contain spaces and dropping empty strings;</span>
<span># * "$@" will retain arguments as-is, so no args</span>
<span>#   provided will result in no args being passed on;</span>
<span>#   This is in most cases what you want to use for passing</span>
<span>#   on arguments.</span>
<span># * "$*" expands to one argument, with all args joined</span>
<span>#   by (usually) spaces,</span>
<span>#   so no args provided will result in one empty string</span>
<span>#   being passed on.</span>
<span># (Consult 'man bash' for the nit-grits ;-)</span>

<span>set</span> -- <span>1</span> <span>"2 two"</span> <span>"3 three tres"</span><span>;</span> <span>echo</span> <span>$#</span> <span>;</span> <span>set</span> -- <span>"<span>$*</span>"</span><span>;</span> <span>echo</span> <span>"<span>$#</span>, <span>$@</span>"</span><span>)</span>
<span>set</span> -- <span>1</span> <span>"2 two"</span> <span>"3 three tres"</span><span>;</span> <span>echo</span> <span>$#</span> <span>;</span> <span>set</span> -- <span>"<span>$@</span>"</span><span>;</span> <span>echo</span> <span>"<span>$#</span>, <span>$@</span>"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h2 id="_6-特性及错误"> 6 特性及错误</h2>
<h3 id="_6-1-命令替换"> 6.1 命令替换</h3>
<blockquote>
<p>使用 <code>$(command)</code> 而不是反引号。</p>
</blockquote>
<p>嵌套的反引号要求用反斜杠转义内部的反引号。而 <code>$(command)</code> 形式嵌套时不需要改变，而且更易于阅读。</p>
<p>例如：</p>
<div><pre><code><span># This is preferred:</span>
<span>var</span><span>=</span><span>"$(command "<span><span>$(</span>command1<span>)</span></span>"</span><span>)</span><span>"

# This is not:
var="</span><span><span>`</span><span>command</span> <span>\</span><span>`</span></span>command1<span>\</span>``"
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_6-2-test-和"> 6.2 test, [和[[</h3>
<blockquote>
<p>推荐使用 <code>[[ ... ]]</code> ，而不是 <code>[</code> , <code>test</code> , 和 <code>/usr/bin/ [</code> 。</p>
</blockquote>
<p>因为在<code>[[</code>和<code>]]</code>之间不会有路径名称扩展或单词分割发生，所以使用<code>[[ ... ]]</code>能够减少错误。而且<code>[[ ... ]]</code>允许正则表达式匹配，而<code>[ ... ]</code>不允许。</p>
<div><pre><code><span># This ensures the string on the left is made up of characters in the</span>
<span># alnum character class followed by the string name.</span>
<span># Note that the RHS should not be quoted here.</span>
<span># For the gory details, see</span>
<span># E14 at http://tiswww.case.edu/php/chet/bash/FAQ</span>
<span>if</span> <span>[</span><span>[</span> <span>"filename"</span> <span>=</span>~ ^<span>[</span><span>[</span>:alnum:<span>]</span><span>]</span>+name <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Match"</span>
<span>fi</span>

<span># This matches the exact pattern "f*" (Does not match in this case)</span>
<span>if</span> <span>[</span><span>[</span> <span>"filename"</span> <span>==</span> <span>"f*"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Match"</span>
<span>fi</span>

<span># This gives a "too many arguments" error as f* is expanded to the</span>
<span># contents of the current directory</span>
<span>if</span> <span>[</span> <span>"filename"</span> <span>==</span> f* <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Match"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="_6-3-测试字符串"> 6.3 测试字符串</h3>
<blockquote>
<p>尽可能使用引用，而不是过滤字符串。</p>
</blockquote>
<p>Bash足以在测试中处理空字符串。所以，请使用空（非空）字符串测试，而不是过滤字符，使得代码更易于阅读。</p>
<div><pre><code><span># Do this:</span>
<span>if</span> <span>[</span><span>[</span> <span>"<span>${my_var}</span>"</span> <span>=</span> <span>"some_string"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  do_something
<span>fi</span>

<span># -z (string length is zero) and -n (string length is not zero) are</span>
<span># preferred over testing for an empty string</span>
<span>if</span> <span>[</span><span>[</span> -z <span>"<span>${my_var}</span>"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  do_something
<span>fi</span>

<span># This is OK (ensure quotes on the empty side), but not preferred:</span>
<span>if</span> <span>[</span><span>[</span> <span>"<span>${my_var}</span>"</span> <span>=</span> <span>""</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  do_something
<span>fi</span>

<span># Not this:</span>
<span>if</span> <span>[</span><span>[</span> <span>"<span>${my_var}</span>X"</span> <span>=</span> <span>"some_stringX"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  do_something
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>为了避免对你测试的目的产生困惑，请明确使用<code>-z</code>或者<code>-n</code></p>
<div><pre><code><span># Use this</span>
<span>if</span> <span>[</span><span>[</span> -n <span>"<span>${my_var}</span>"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  do_something
<span>fi</span>

<span># Instead of this as errors can occur if ${my_var} expands to a test</span>
<span># flag</span>
<span>if</span> <span>[</span><span>[</span> <span>"<span>${my_var}</span>"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  do_something
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="_6-4-文件名的通配符扩展"> 6.4 文件名的通配符扩展</h3>
<blockquote>
<p>当进行文件名的通配符扩展时，请使用明确的路径。</p>
</blockquote>
<p>为文件名可能以 <code>-</code> 开头，所以使用扩展通配符 <code>./*</code> 比<code>*</code> 来得安全得多。</p>
<div><pre><code><span># Here's the contents of the directory:</span>
<span># -f  -r  somedir  somefile</span>

<span># This deletes almost everything in the directory by force</span>
psa@bilby$ <span>rm</span> -v *
removed directory: <span><span>`</span>somedir'
removed <span>`</span></span>somefile<span>'

# As opposed to:
psa@bilby$ rm -v ./*
removed <span><span>`</span>./-f'
removed <span>`</span></span>./-r'</span>
rm: cannot remove <span><span>`</span>./somedir': Is a directory
removed <span>`</span></span>./somefile'
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="_6-5-eval"> 6.5 Eval</h3>
<blockquote>
<p>应该避免使用eval。</p>
</blockquote>
<p>当用于给变量赋值时，Eval解析输入，并且能够设置变量，但无法检查这些变量是什么。</p>
<div><pre><code><span># What does this set?</span>
<span># Did it succeed? In part or whole?</span>
<span>eval</span> <span><span>$(</span>set_my_variables<span>)</span></span>

<span># What happens if one of the returned values has a space in it?</span>
<span>variable</span><span>=</span><span>"<span><span>$(</span><span>eval</span> some_function<span>)</span></span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_6-6-管道导向while循环"> 6.6 管道导向while循环</h3>
<blockquote>
<p>请使用过程替换或者for循环，而不是管道导向while循环。在while循环中被修改的变量是不能传递给父shell的，因为循环命令是在一个子shell中运行的。</p>
</blockquote>
<p>管道导向while循环中的隐式子shell使得追踪bug变得很困难。</p>
<div><pre><code><span>last_line</span><span>=</span><span>'NULL'</span>
your_command <span>|</span> <span>while</span> <span>read</span> line<span>;</span> <span>do</span>
  <span>last_line</span><span>=</span><span>"<span>${line}</span>"</span>
<span>done</span>

<span># This will output 'NULL'</span>
<span>echo</span> <span>"<span>${last_line}</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果你确定输入中不包含空格或者特殊符号（通常意味着不是用户输入的），那么可以使用一个for循环。</p>
<div><pre><code><span>total</span><span>=</span><span>0</span>
<span># Only do this if there are no spaces in return values.</span>
<span>for</span> <span>value</span> <span>in</span> <span><span>$(</span><span>command</span><span>)</span></span><span>;</span> <span>do</span>
  <span>total</span><span>+=</span><span>"<span>${value}</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用过程替换允许重定向输出，但是请将命令放入一个显式的子shell中，而不是bash为while循环创建的隐式子shell。</p>
<div><pre><code><span>total</span><span>=</span><span>0</span>
<span>last_file</span><span>=</span>
<span>while</span> <span>read</span> count filename<span>;</span> <span>do</span>
  <span>total</span><span>+=</span><span>"<span>${count}</span>"</span>
  <span>last_file</span><span>=</span><span>"<span>${filename}</span>"</span>
<span>done</span> <span>&lt;</span> <span>&lt;</span><span>(</span>your_command <span>|</span> <span>uniq</span> -c<span>)</span>

<span># This will output the second field of the last line of output from</span>
<span># the command.</span>
<span>echo</span> <span>"Total = <span>${total}</span>"</span>
<span>echo</span> <span>"Last one = <span>${last_file}</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>当不需要传递复杂的结果给父shell时可以使用while循环。这通常需要一些更复杂的“解析”。请注意简单的例子使用如awk这类工具可能更容易完成。当你特别不希望改变父shell的范围变量时这可能也是有用的。</p>
<div><pre><code><span># Trivial implementation of awk expression:</span>
<span>#   awk '$3 == "nfs" { print $2 " maps to " $1 }' /proc/mounts</span>
<span>cat</span> /proc/mounts <span>|</span> <span>while</span> <span>read</span> src dest <span>type</span> opts rest<span>;</span> <span>do</span>
  <span>if</span> <span>[</span><span>[</span> <span>${type}</span> <span>==</span> <span>"nfs"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"NFS <span>${dest}</span> maps to <span>${src}</span>"</span>
  <span>fi</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="_7-命名约定"> 7 命名约定</h2>
<h3 id="_7-1-函数名"> 7.1 函数名</h3>
<blockquote>
<p>使用小写字母，并用下划线分隔单词。使用双冒号<code>::</code>分隔库。函数名之后必须有圆括号。关键词<code>function</code>是可选的，但必须在一个项目中保持一致。</p>
</blockquote>
<p>如果你正在写单个函数，请用小写字母来命名，并用下划线分隔单词。如果你正在写一个包，使用双冒号<code>::</code>来分隔包名。大括号必须和函数名位于同一行（就像在Google的其他语言一样），并且函数名和圆括号之间没有空格。</p>
<div><pre><code><span># Single function</span>
<span>my_func</span><span>(</span><span>)</span> <span>{</span>
  <span>..</span>.
<span>}</span>

<span># Part of a package</span>
mypackage::<span>my_func</span><span>(</span><span>)</span> <span>{</span>
  <span>..</span>.
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>当函数名后存在 () 时，关键词 function 是多余的。但是其促进了函数的快速辨识。</p>
<h3 id="_7-2-变量名"> 7.2 变量名</h3>
<blockquote>
<p>如函数名</p>
</blockquote>
<p>循环的变量名应该和循环的任何变量同样命名。</p>
<div><pre><code><span>for</span> <span>zone</span> <span>in</span> <span>${zones}</span><span>;</span> <span>do</span>
  something_with <span>"<span>${zone}</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_7-3-常量和环境变量名"> 7.3 常量和环境变量名</h3>
<blockquote>
<p>全部大写，用下划线分隔，声明在文件的顶部。</p>
</blockquote>
<p>常量和任何导出到环境中的都应该大写。</p>
<div><pre><code><span># Constant</span>
<span>readonly</span> <span>PATH_TO_FILES</span><span>=</span><span>'/some/path'</span>

<span># Both constant and environment</span>
<span>declare</span> -xr <span>ORACLE_SID</span><span>=</span><span>'PROD'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第一次设置时有一些就变成了常量（例如，通过getopts）。因此，可以在getopts中或基于条件来设定常量，但之后应该立即设置其为只读。值得注意的是，在函数中<code>declare</code>不会对全局变量进行操作。所以推荐使用<code>readonly</code>和<code>export</code>来代替。</p>
<div><pre><code><span>VERBOSE</span><span>=</span><span>'false'</span>
<span>while</span> <span>getopts</span> <span>'v'</span> flag<span>;</span> <span>do</span>
  <span>case</span> <span>"<span>${flag}</span>"</span> <span>in</span>
    <span>v</span><span>)</span> <span>VERBOSE</span><span>=</span><span>'true'</span> <span>;</span><span>;</span>
  <span>esac</span>
<span>done</span>
<span>readonly</span> VERBOSE
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_7-4-源文件名"> 7.4 源文件名</h3>
<blockquote>
<p>小写，如果需要的话使用下划线分隔单词。</p>
</blockquote>
<p>这是为了和在Google中的其他代码风格保持一致：<code>maketemplate</code>或者<code>make_template</code>，而不是<code>make-template</code>。</p>
<h3 id="_7-5-只读变量"> 7.5 只读变量</h3>
<blockquote>
<p>使用 readonly 或者 declare -r 来确保变量只读。</p>
</blockquote>
<p>因为全局变量在shell中广泛使用，所以在使用它们的过程中捕获错误是很重要的。当你声明了一个变量，希望其只读，那么请明确指出。</p>
<div><pre><code><span>zip_version</span><span>=</span><span>"<span><span>$(</span>dpkg --status <span>zip</span> <span>|</span> <span>grep</span> Version: <span>|</span> <span>cut</span> -d <span>' '</span> -f <span>2</span><span>)</span></span>"</span>
<span>if</span> <span>[</span><span>[</span> -z <span>"<span>${zip_version}</span>"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  error_message
<span>else</span>
  <span>readonly</span> zip_version
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_7-6-使用本地变量"> 7.6 使用本地变量</h3>
<blockquote>
<p>使用<code>local</code>声明特定功能的变量。声明和赋值应该在不同行。</p>
</blockquote>
<p>使用<code>local</code>来声明局部变量以确保其只在函数内部和子函数中可见。这避免了污染全局命名空间和不经意间设置可能具有函数之外重要性的变量。</p>
<p>当赋值的值由命令替换提供时，声明和赋值必须分开。因为内建的<code>local</code>不会从命令替换中传递退出码。</p>
<div><pre><code><span>my_func2</span><span>(</span><span>)</span> <span>{</span>
  <span>local</span> <span>name</span><span>=</span><span>"<span>$1</span>"</span>

  <span># Separate lines for declaration and assignment:</span>
  <span>local</span> my_var
  <span>my_var</span><span>=</span><span>"<span><span>$(</span>my_func<span>)</span></span>"</span> <span>||</span> <span>return</span>

  <span># DO NOT do this: $? contains the exit code of 'local', not my_func</span>
  <span>local</span> <span>my_var</span><span>=</span><span>"<span><span>$(</span>my_func<span>)</span></span>"</span>
  <span>[</span><span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>]</span> <span>||</span> <span>return</span>

  <span>..</span>.
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="_7-7-函数位置"> 7.7 函数位置</h3>
<blockquote>
<p>将文件中所有的函数一起放在常量下面。不要在函数之间隐藏可执行代码。</p>
</blockquote>
<p>如果你有函数，请将他们一起放在文件头部。只有includes，<code>set</code>声明和常量设置可能在函数声明之前完成。不要在函数之间隐藏可执行代码。如果那样做，会使得代码在调试时难以跟踪并出现意想不到的讨厌结果。</p>
<h3 id="_7-8-主函数main"> 7.8 主函数main</h3>
<blockquote>
<p>对于包含至少一个其他函数的足够长的脚本，需要称为<code>main</code>的函数。</p>
</blockquote>
<p>为了方便查找程序的开始，将主程序放入一个称为<code>main</code>的函数，作为最下面的函数。这使其和代码库的其余部分保持一致性，同时允许你定义更多变量为局部变量（如果主代码不是一个函数就不能这么做）。文件中最后的非注释行应该是对<code>main</code>函数的调用。</p>
<div><pre><code>main <span>"<span>$@</span>"</span>
</code></pre>
<div><span>1</span><br></div></div><p>显然，对于仅仅是线性流的短脚本， <code>main</code> 是矫枉过正，因此是不需要的。</p>
<h2 id="_8-调用命令"> 8 调用命令</h2>
<h3 id="_8-1-检查返回值"> 8.1 检查返回值</h3>
<blockquote>
<p>总是检查返回值，并给出信息返回值。</p>
</blockquote>
<p>对于非管道命令，使用 <code>$?</code> 或直接通过一个 <code>if</code> 语句来检查以保持其简洁。</p>
<p>例如：</p>
<div><pre><code><span>if</span> <span>!</span> <span>mv</span> <span>"<span>${file_list}</span>"</span> <span>"<span>${dest_dir}</span>/"</span> <span>;</span> <span>then</span>
  <span>echo</span> <span>"Unable to move <span>${file_list}</span> to <span>${dest_dir}</span>"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>"<span>${E_BAD_MOVE}</span>"</span>
<span>fi</span>

<span># Or</span>
<span>mv</span> <span>"<span>${file_list}</span>"</span> <span>"<span>${dest_dir}</span>/"</span>
<span>if</span> <span>[</span><span>[</span> <span>"<span>$?</span>"</span> -ne <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Unable to move <span>${file_list}</span> to <span>${dest_dir}</span>"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>"<span>${E_BAD_MOVE}</span>"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>Bash也有<code>PIPESTATUS</code>变量，允许检查从管道所有部分返回的代码。如果仅仅需要检查整个管道是成功还是失败，以下的方法是可以接受的：</p>
<div><pre><code><span>tar</span> -cf - ./* <span>|</span> <span>(</span> <span>cd</span> <span>"<span>${dir}</span>"</span> <span>&amp;&amp;</span> <span>tar</span> -xf - <span>)</span>
<span>if</span> <span>[</span><span>[</span> <span>"<span>${<span>PIPESTATUS</span><span>[</span>0<span>]</span>}</span>"</span> -ne <span>0</span> <span>||</span> <span>"<span>${<span>PIPESTATUS</span><span>[</span>1<span>]</span>}</span>"</span> -ne <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Unable to tar files to <span>${dir}</span>"</span> <span>></span><span>&amp;2</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可是，只要你运行任何其他命令，<code>PIPESTATUS</code>将会被覆盖。如果你需要基于管道中发生的错误执行不同的操作，那么你需要在运行命令后立即将<code>PIPESTATUS</code>赋值给另一个变量（别忘了 <code>[</code> 是一个会将<code>PIPESTATUS</code>擦除的命令）。</p>
<div><pre><code><span>tar</span> -cf - ./* <span>|</span> <span>(</span> <span>cd</span> <span>"<span>${DIR}</span>"</span> <span>&amp;&amp;</span> <span>tar</span> -xf - <span>)</span>
<span>return_codes</span><span>=</span><span>(</span><span>${<span>PIPESTATUS</span><span>[</span>*<span>]</span>}</span><span>)</span>
<span>if</span> <span>[</span><span>[</span> <span>"<span>${return_codes<span>[</span>0<span>]</span>}</span>"</span> -ne <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  do_something
<span>fi</span>
<span>if</span> <span>[</span><span>[</span> <span>"<span>${return_codes<span>[</span>1<span>]</span>}</span>"</span> -ne <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  do_something_else
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="_8-2-内建命令和外部命令"> 8.2 内建命令和外部命令</h3>
<blockquote>
<p>可以在调用shell内建命令和调用另外的程序之间选择，请选择内建命令。</p>
</blockquote>
<p>我们更喜欢使用内建命令，如在 <code>bash(1)</code> 中参数扩展函数。因为它更强健和便携（尤其是跟像 <code>sed</code> 这样的命令比较）</p>
<p>例如：</p>
<div><pre><code><span># Prefer this:</span>
<span>addition</span><span>=</span><span><span>$((</span>${X} <span>+</span> ${Y}<span>))</span></span>
<span>substitution</span><span>=</span><span>"<span>${string<span>/</span><span>#</span>foo<span>/</span>bar}</span>"</span>

<span># Instead of this:</span>
<span>addition</span><span>=</span><span>"<span><span>$(</span><span>expr</span> $<span>{</span>X<span>}</span> + $<span>{</span>Y<span>}</span><span>)</span></span>"</span>
<span>substitution</span><span>=</span><span>"<span><span>$(</span><span>echo</span> <span>"<span>${string}</span>"</span> <span>|</span> <span>sed</span> -e <span>'s/^foo/bar/'</span><span>)</span></span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content>
    <author>
      <name>Google</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Google</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Google</rights>
  </entry>
  <entry>
    <title type="html">开机集成zabbix和jumpserver脚本</title>
    <id>https://clay-wangzhi.com/code/shell/part7/shili/</id>
    <link href="https://clay-wangzhi.com/code/shell/part7/shili/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="开机集成zabbix和jumpserver脚本"> 开机集成zabbix和jumpserver脚本</h2>
<div><pre><code><span>#!/bin/bash</span>
<span>LOCAL_PASS</span><span>=</span><span>"****"</span>
<span>ANS_PASS</span><span>=</span><span>"****"</span>
<span>INVENTORY_FILE</span><span>=</span><span>"/etc/ansible/playbook/zabbix/inventory/zabbix.yml"</span>
<span>ZABBIX_PALYBOOK_FILE</span><span>=</span><span>"/etc/ansible/playbook/zabbix/new-zabbix-agent.yml"</span>
<span>IP</span><span>=</span><span><span>$(</span><span>ifconfig</span> <span>|</span> <span>grep</span> broadcast <span>|</span> <span>awk</span> <span>'{ print <span>$2</span> }'</span><span>)</span></span>
<span>LAST_TWO_IP</span><span>=</span><span><span>$(</span><span>echo</span> $IP <span>|</span> <span>cut</span> -d. -f3-4<span>)</span></span>

<span>node</span><span>=</span><span>"f6d2228f-c474-4b1e-ac8b-5c7d10e63b53"</span>

<span>update_ssh</span><span>(</span><span>)</span> <span>{</span>
  <span>sed</span> -i <span>'s/PasswordAuthentication no/PasswordAuthentication yes/g'</span> /etc/ssh/sshd_config
  systemctl restart sshd <span>></span> /dev/null <span><span>2</span>></span><span>&amp;1</span>
  <span>echo</span> <span>"<span>${LOCAL_PASS}</span>"</span> <span>|</span> <span>passwd</span> root --stdin  <span>></span> /dev/null <span><span>2</span>></span><span>&amp;1</span>
<span>}</span>

<span>integrate_jms</span><span>(</span><span>)</span> <span>{</span>
  <span>if</span> <span>[</span><span>[</span> <span>"<span>${1}</span>"</span> <span>==</span> <span>"csp"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>node</span><span>=</span><span>"b256f30b-896e-44cd-90f0-0fc28984afe9"</span>
  <span>elif</span> <span>[</span><span>[</span> <span>"<span>${1}</span>"</span> <span>==</span> <span>"bes"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>node</span><span>=</span><span>"b594957e-d6e8-4c85-92e6-b89757792e1a"</span>
  <span>fi</span> 
  <span>curl</span> -XPOST -H <span>'Authorization: Token d54c30e98f49de8e4e75bd3c28f214d0dea761ca'</span> <span>\</span>
    -H <span>"Content-Type:application/json"</span> http://192.168.162.10/api/v1/assets/assets/ <span>\</span>
    -d <span>"{ <span title="\&quot;">\"</span>ip<span title="\&quot;">\"</span>: <span title="\&quot;">\"</span><span>${IP}</span><span title="\&quot;">\"</span>, <span title="\&quot;">\"</span>hostname<span title="\&quot;">\"</span>: <span title="\&quot;">\"</span><span>${LAST_TWO_IP}</span>-<span>${2}</span><span title="\&quot;">\"</span>, 
        <span title="\&quot;">\"</span>protocol<span title="\&quot;">\"</span>: <span title="\&quot;">\"</span>ssh<span title="\&quot;">\"</span>, <span title="\&quot;">\"</span>port<span title="\&quot;">\"</span>: 22, <span title="\&quot;">\"</span>protocols<span title="\&quot;">\"</span>: [ <span title="\&quot;">\"</span>ssh/22<span title="\&quot;">\"</span> ], 
        <span title="\&quot;">\"</span>platform<span title="\&quot;">\"</span>: <span title="\&quot;">\"</span>Linux<span title="\&quot;">\"</span>, <span title="\&quot;">\"</span>is_active<span title="\&quot;">\"</span>: true, 
        <span title="\&quot;">\"</span>admin_user<span title="\&quot;">\"</span>: <span title="\&quot;">\"</span>59bb8ee8-98ad-4aac-a1a7-3e1b2b83f38f<span title="\&quot;">\"</span>, 
        <span title="\&quot;">\"</span>nodes<span title="\&quot;">\"</span>: [ <span title="\&quot;">\"</span><span>${node}</span><span title="\&quot;">\"</span> ]}"</span>
<span>}</span>

<span>integrate_ans_zbx</span><span>(</span><span>)</span> <span>{</span>
  /usr/bin/expect <span>&lt;&lt;</span><span>EOF
  set timeout 180
  spawn ssh root@192.168.162.1
  expect {
    "(yes/no)?" {
      send "yes<span title="\r">\r</span>";
      expect "password:";
      send "<span>${ANS_PASS}</span><span title="\r">\r</span>";
      exp_continue;
    }
    "password:" {
      send "<span>${ANS_PASS}</span><span title="\r">\r</span>";
      exp_continue;
    }
    "*#" {
      send "sed -i '/# <span>${1}</span> insert/i\  <span>${IP}</span>:' <span>${INVENTORY_FILE}</span><span title="\r">\r</span>";
      send "sed -i 's/<span>${IP}</span>/        <span>${IP}</span>/g' <span>${INVENTORY_FILE}</span><span title="\r">\r</span>";
      send " ansible-playbook -i <span>${INVENTORY_FILE}</span> <span>${ZABBIX_PALYBOOK_FILE}</span> \
             -l <span>${IP}</span> --skip-tags 'sangoma,debian,suse,windows,docker'<span title="\r">\r</span>";
    }
  }
  expect eof
EOF</span>
<span>}</span>

<span>main</span><span>(</span><span>)</span> <span>{</span>
  update_ssh
  integrate_jms <span>"<span>$@</span>"</span>
  integrate_ans_zbx <span>"<span>$@</span>"</span> 
<span>}</span>

main <span>"<span>$@</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">《Advanced Bash-Scripting Guide》 in Chinese</title>
    <id>https://clay-wangzhi.com/code/shell/</id>
    <link href="https://clay-wangzhi.com/code/shell/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="《advanced-bash-scripting-guide》-in-chinese"> 《Advanced Bash-Scripting Guide》 in Chinese</h1>
<blockquote>
<p>本教程内容转载自：https://github.com/LinuxStory/Advanced-Bash-Scripting-Guide-in-Chinese</p>
<p>感谢开源翻译！！！</p>
</blockquote>
<p><a href="https://gitter.im/Advanced-Bash-Scripting-Guide-in-Chinese/" target="_blank" rel="noopener noreferrer"><img src="https://badges.gitter.im/gitterHQ/gitter.png" alt="Gitter chat" /></a></p>
<p>《高级Bash脚本编程指南》Revision 10中文版</p>
<h2 id="原著及早期翻译作品"> 原著及早期翻译作品</h2>
<h3 id="原著"> 原著</h3>
<ul>
<li>原著链接：http://tldp.org/LDP/abs/html/</li>
<li>原作：Mendel Cooper</li>
<li>原著版本：Revision 10, 10 Mar 2014</li>
</ul>
<h3 id="译著"> 译著</h3>
<ul>
<li>早期译著连接：http://www.linuxsir.org/bbs/thread256887.html</li>
<li>译者：杨春敏 黄毅</li>
<li>译著版本：Revision 3.7, 23 Oct 2005</li>
<li>最新 Revision 10 由 Linux Story 社区的 imcmy 同学发起并组织翻译</li>
<li>Linux Story 通告地址 ：http://www.linuxstory.org/asdvanced-bash-scripting-guide-in-chinese/</li>
</ul>
<h2 id="翻译作品"> 翻译作品</h2>
<p>翻译作品放在<a href="https://linuxstory.gitbook.io/advanced-bash-scripting-guide-in-chinese/" target="_blank" rel="noopener noreferrer">GitBook</a>上，欢迎指正！</p>
<h2 id="翻译进度"> 翻译进度</h2>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-0"><label for="task-item-0"> 第一部分 初见Shell[@imcmy][@zihengcat]</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-1"><label for="task-item-1"> 1\. 为什么使用shell编程[@imcmy][@zihengcat]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-2"><label for="task-item-2"> 2\. Sha-Bang（#!）一起出发[@imcmy][@zihengcat]</label></li>
</ul>
</li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-3"><label for="task-item-3"> 第二部分 Shell基础[@imcmy][@zihengcat]</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-4"><label for="task-item-4"> 3\. 特殊字符[@imcmy][@zihengcat]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-5"><label for="task-item-5"> 4\. 变量与参数[@imcmy][@zihengcat]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-6"><label for="task-item-6"> 5\. 引用[@mr253727942][@zihengcat]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-7"><label for="task-item-7"> 6\. 退出与退出状态[@samita2030][@zihengcat]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-8"><label for="task-item-8"> 7\. 测试[@imcmy][@zihengcat]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-9"><label for="task-item-9"> 8\. 运算符相关话题[@samita2030][@zihengcat]</label></li>
</ul>
</li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-10"><label for="task-item-10"> 第三部分 Shell进阶[@imcmy]</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-11"><label for="task-item-11"> 9\. 换个角度看变量[@imcmy]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-12"><label for="task-item-12"> 10\. 变量处理[@imcmy]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-13"><label for="task-item-13"> 11\. 循环与分支[@imcmy]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-14"><label for="task-item-14"> 12\. 命令替换[@imcmy]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-15"><label for="task-item-15"> 13\. 算术扩展[@imcmy]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-16"><label for="task-item-16"> 14\. 休息时间[@imcmy]</label></li>
</ul>
</li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-17"><label for="task-item-17"> 第四部分. 命令[@imcmy]</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-18"><label for="task-item-18"> 15\. 内建命令[@imcmy]</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-19"><label for="task-item-19"> 16\. 外部过滤器，程序与命令[@hsupu]</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-20"><label for="task-item-20"> 16.1 基本命令[@hsupu]</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-21"><label for="task-item-21"> 16.2 复杂命令</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-22"><label for="task-item-22"> 16.3 时间与日期命令</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-23"><label for="task-item-23"> 16.4 文本处理命令</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-24"><label for="task-item-24"> 16.5 文件与归档命令</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-25"><label for="task-item-25"> 16.6 通信命令</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-26"><label for="task-item-26"> 16.7 终端控制命令</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-27"><label for="task-item-27"> 16.8 数学命令</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-28"><label for="task-item-28"> 16.9 杂项命令</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-29"><label for="task-item-29"> 17\. 系统与高级命令</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-30"><label for="task-item-30"> 第五章. 高级话题</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-31"><label for="task-item-31"> 18\. 正则表达式[@Zjie]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-32"><label for="task-item-32"> 19\. 嵌入文档[@mingmings]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-33"><label for="task-item-33"> 20\. I/O 重定向[@mingmings]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-34"><label for="task-item-34"> 21\. Subshells[@ysun90]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-35"><label for="task-item-35"> 22\. 限制模式的Shell[@panblack]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-36"><label for="task-item-36"> 23\. 进程替换[@panblack]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-37"><label for="task-item-37"> 24\. 函数[@zy416548283]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-38"><label for="task-item-38"> 25\. 别名[@mingmings]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-39"><label for="task-item-39"> 26\. 列表结构[@panblack]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-40"><label for="task-item-40"> 27\. 数组[@zy416548283]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-41"><label for="task-item-41"> 28\. 间接引用[@plutonji]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-42"> 29. <code>/dev</code> 和 <code>/proc</code><label for="task-item-42"> 29\. `/dev` 和 `/proc`[@plutonji]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-43"><label for="task-item-43"> 30\. 网络编程[@Zjie]</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-44"><label for="task-item-44"> 31\. Of Zeros and Nulls</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-45"><label for="task-item-45"> 32\. 调试[@wuqichao]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-46"><label for="task-item-46"> 33\. 选项[@zy416548283]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-47"><label for="task-item-47"> 34\. 陷阱[@liuburn]</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-48"><label for="task-item-48"> 35\. Scripting With Style</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-49"><label for="task-item-49"> 36\. 杂项[@richard-ma]</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-50"><label for="task-item-50"> 37\. Bash, versions 2, 3, and 4</label></li>
</ul>
</li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-51"><label for="task-item-51"> 38\. 后记[@zy416548283]</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-52"><label for="task-item-52"> Bibliography</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-53"><label for="task-item-53"> 附录</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-54"><label for="task-item-54"> A\. Contributed Scripts</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-55"><label for="task-item-55"> B\. Reference Cards</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-56"><label for="task-item-56"> C\. A Sed and Awk Micro-Primer[@wuqichao]</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-57"><label for="task-item-57"> C.1 Sed[@wuqichao]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-58"><label for="task-item-58"> C.2 Awk[@wuqichao]</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-59"><label for="task-item-59"> D\. Parsing and Managing Pathnames</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-60"><label for="task-item-60"> E\. 带有特殊意义的退出代码[@ShadowRZ]</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-61"><label for="task-item-61"> F\. I/O 与 I/O 重定向详细介绍[@ShadowRZ]</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-62"><label for="task-item-62"> G\. Command-Line Options</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-63"><label for="task-item-63"> G.1 Standard Command-Line Options</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-64"><label for="task-item-64"> G.2 Bash Command-Line Options</label></li>
</ul>
</li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-65"><label for="task-item-65"> H\. 重要文件[@ShadowRZ]</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-66"><label for="task-item-66"> I\. Important System Directories</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-67"><label for="task-item-67"> J\. An Introduction to Programmable Completion</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-68"><label for="task-item-68"> K\. Localization</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-69"><label for="task-item-69"> L\. History Commands</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-70"><label for="task-item-70"> M\. 示例 ~/.bashrc 与 ~/.bash_profile[@ShadowRZ]</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-71"><label for="task-item-71"> N\. Converting DOS Batch Files to Shell Scripts</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-72"><label for="task-item-72"> O\. Exercises</label>
<ul>
<li>O.1 Analyzing Scripts</li>
<li>O.2 Writing Scripts</li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-73"><label for="task-item-73"> P\. Revision History</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-74"><label for="task-item-74"> Q\. Download and Mirror Sites</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-75"><label for="task-item-75"> R\. To Do List</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-76"><label for="task-item-76"> S\. Copyright</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-77"><label for="task-item-77"> T\. ASCII 表[@ShadowRZ]</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-78"><label for="task-item-78"> Index</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-79"><label for="task-item-79"> List of Tables</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-80"><label for="task-item-80"> List of Examples</label></li>
</ul>
<h2 id="翻译校审流程"> 翻译校审流程</h2>
<h3 id="初始化"> 初始化</h3>
<ol>
<li>首先fork项目</li>
<li>把fork过去的项目clone到本地</li>
<li>命令行下运行 <code>git checkout -b dev</code> 创建一个新分支</li>
<li>运行 <code>git remote add upstream https://github.com/LinuxStory/Advanced-Bash-Scripting-Guide-in-Chinese.git</code> 添加远端库</li>
<li>运行 <code>git remote update</code>更新</li>
<li>运行 <code>git fetch upstream master</code> 拉取更新到本地</li>
<li>运行 <code>git rebase upstream/master</code> 将更新合并到你的分支</li>
</ol>
<p>初始化只需要做一遍，之后请在dev分支进行修改。</p>
<p>如果修改过程中项目有更新，请重复5、6、7步。</p>
<h3 id="翻译校审流程-2"> 翻译校审流程</h3>
<ol>
<li>
<p>保证在dev分支中</p>
</li>
<li>
<p>打开README.md，在翻译进度后加上你自己的github名</p>
<blockquote>
<p>1. Shell Programming! [@翻译人][@校审人]</p>
</blockquote>
</li>
<li>
<p>本地提交修改，写明提交信息</p>
</li>
<li>
<p>push到你fork的项目中，然后登录GitHub</p>
</li>
<li>
<p>在你fork的项目的首页可以看到一个 <code>pull request</code> 按钮，点击它，填写说明信息，然后提交即可</p>
<blockquote>
<p>为了不重复工作，请等待我们确认了你的pull request(即你的名字出现在项目中时)，再进行翻译校审工作</p>
</blockquote>
</li>
<li>
<p>进行翻译校审，重复3-5步提交翻译校审的作品</p>
</li>
</ol>
<blockquote>
<p>新手可以参阅针对github小白的<a href="https://github.com/LinuxStory/Advanced-Bash-Scripting-Guide-in-Chinese/wiki/%E7%BF%BB%E8%AF%91%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3" target="_blank" rel="noopener noreferrer">《翻译流程详解》</a>,妹子写的呦～</p>
</blockquote>
<h2 id="翻译校审建议"> 翻译校审建议</h2>
<ol>
<li>使用markdown进行翻译校审，文件名必须使用英文</li>
<li>翻译校审后的文档请放到source文件夹下的对应章节中，然后pull request即可</li>
<li>有任何问题随时欢迎发issue</li>
<li>术语尽量保证和已翻译的一致，也可以查询<a href="https://www.microsoft.com/zh-cn/language/search" target="_blank" rel="noopener noreferrer">微软术语搜索</a>或<a href="https://github.com/LCTT/TranslateProject/blob/master/Dict.md" target="_blank" rel="noopener noreferrer">Linux中国术语词典</a></li>
<li>你可以将你认为是术语的词汇加入术语表<code>TERM.md</code>中</li>
</ol>
<h2 id="样式规范"> 样式规范</h2>
<p>根据原文中不同的注释类型，可以使用 <code>&gt;</code> 或下列html代码进行注释。</p>
<div><pre><code>{% hint style="info" %}
Hello world
{% endhint %}
​```

所有的脚注footnote都需使用html代码进行注释。

## 关于版权

根据原著作者的要求，翻译成果属于公有领域(CC0)，翻译参与人员及原著作者Mendel Cooper享有署名权

翻译参与人员（按名称排序）：

- @chuchingkai
- @hsupu
- @imcmy
- @liuburn
- @mingmings
- @mr253727942
- @panblack
- @plutonji
- @richard-ma
- @samita2030
- @ShadowRZ
- @wuqichao
- @ysun90
- @zhaozq
- @zihengcat
- @Zjie
- @zy416548283
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div>]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">Harbor 搭建</title>
    <id>https://clay-wangzhi.com/container/Docker/docker_harbor/</id>
    <link href="https://clay-wangzhi.com/container/Docker/docker_harbor/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="harbor-搭建"> Harbor 搭建</h1>
<h1 id="harbor创建"> Harbor创建</h1>
<h2 id="安装依赖软件"> 安装依赖软件</h2>
<div><pre><code>yum -y install openssl
</code></pre>
<div><span>1</span><br></div></div><h2 id="installation-steps"> Installation Steps</h2>
<p>1）Offline installer:</p>
<p>从github上下载官方最新包，然后上传到服务器上</p>
<p>2）解压</p>
<div><pre><code>tar xvf harbor-offline-installer-&lt;version&gt;.tgz  -C /usr/local/
</code></pre>
<div><span>1</span><br></div></div><p>3）修改配置文件</p>
<div><pre><code># cd /usr/local/harbor
# vim harbor.yml
# 将hostname改为对应的本机地址（not localhost or 127.0.0.1）
# 修改harbor_admin_password管理用户密码，只能在这里改，改后不可再改
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>hostname一定要用域名</p>
</blockquote>
<p>4）安装启动</p>
<div><pre><code>./install
</code></pre>
<div><span>1</span><br></div></div><h1 id="configuring-harbor-with-https-access"> Configuring Harbor with HTTPS Access</h1>
<h2 id="getting-certificate-authority"> Getting Certificate Authority</h2>
<div><pre><code># hostnamectl set-hostname sdqcharbor.com
# echo &quot;本机地址 sdqcharbor.com&quot; &gt;&gt; /etc/hosts
# mkdir -p /opt/certs
# cd /opt/certs
# openssl genrsa -out ca.key 4096
# openssl req -x509 -new -nodes -sha512 -days 3650 \
  -subj &quot;/CN=sdqcharbor.com&quot; \
  -key ca.key \
  -out ca.crt

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="getting-server-certificate"> Getting Server Certificate</h2>
<p><strong>1) Create your own Private Key:</strong></p>
<div><pre><code>openssl genrsa -out sdqcharbor.com.key 4096
</code></pre>
<div><span>1</span><br></div></div><p><strong>2) Generate a Certificate Signing Request:</strong></p>
<div><pre><code>openssl req -sha512 -new \
  -subj &quot;/CN=sdqcharbor.com&quot; \
  -key sdqcharbor.com.key \
  -out sdqcharbor.com.csr
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>3) Generate the certificate of your registry host:</strong></p>
<div><pre><code>cat &gt; v3.ext &lt;&lt;-EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth 
subjectAltName = @alt_names

[alt_names]
DNS.1=sdqcharbor.com
DNS.2=192.168.162.45
EOF
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code>openssl x509 -req -sha512 -days 3650     -extfile v3.ext     -CA ca.crt -CAkey ca.key -CAcreateserial     -in sdqcharbor.com.csr     -out sdqcharbor.com.crt
</code></pre>
<div><span>1</span><br></div></div><h2 id="configuration-and-installation"> Configuration and Installation</h2>
<div><pre><code>mkdir /data/cert
cp sdqcharbor.com.crt /data/cert/
cp sdqcharbor.com.key /data/cert/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2) Configure Server Certificate, Key and CA for Docker</strong></p>
<div><pre><code>openssl x509 -inform PEM -in sdqcharbor.com.crt -out sdqcharbor.com.cert
</code></pre>
<div><span>1</span><br></div></div><p>Delpoy .com.cert<code>,</code>yourdomain.com.key<code>, and</code>ca.crt` for Docker:</p>
<div><pre><code>mkdir /etc/docker/certs.d/sdqcharbor.com
cp sdqcharbor.com.cert sdqcharbor.com.key ca.crt /etc/docker/certs.d/sdqcharbor.com
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>3) Configure Harbor</strong></p>
<p>vim /usr/local/harbor/harbor.yml</p>
<p>修改为以下内容</p>
<div><pre><code>hostname: sdqcharbor.com
https:
  certificate: /data/cert/sdqcharbor.com.crt
  private_key: /data/cert/sdqcharbor.com.key
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>If Harbor is already running, stop and remove the existing instance. Your image data remain in the file system</p>
<div><pre><code>docker-compose down -v
rm -rf /data/database/
rm -rf /data/registry/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>编辑docker中配置文件，<code>daemon.json</code>，去掉<code>&quot;insecure-registries&quot;: [&quot;sdqcharbor.com&quot;]</code>这一行</p>
<p>重启docker</p>
<div><pre><code>systemctl daemon-reload
systemctl restart docker
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>预编译</p>
<div><pre><code>./prepare
docker-compose -f ./docker-compose.yml up -d
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>登录</p>
<div><pre><code>docker login sdqcharbor.com
</code></pre>
<div><span>1</span><br></div></div><p>上传镜像</p>
<div><pre><code>docker tag centos:latest sdqcharbor.com/library/centos:latest
docker push sdqcharbor.com/library/centos:latest 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h1 id="参考文档"> 参考文档</h1>
<blockquote>
<p><a href="https://goharbor.io/docs/1.10/install-config/download-installer/" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="常见服务的搭建"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Harbor 高可用搭建</title>
    <id>https://clay-wangzhi.com/container/Docker/docker_harbor_ha/</id>
    <link href="https://clay-wangzhi.com/container/Docker/docker_harbor_ha/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="harbor-高可用搭建"> Harbor 高可用搭建</h1>
<h2 id="harbor简介"> Harbor简介</h2>
<p><a href="https://goharbor.io/" target="_blank" rel="noopener noreferrer">Harbor</a>是一个用于存储和分发<code>Docker镜像</code>的企业级<code>Registry</code>服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。</p>
<p>作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。</p>
<p>提升用户使用Registry构建和运行环境传输镜像的效率。</p>
<p>Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中， 确保数据和知识产权在公司内部网络中管控。</p>
<p>另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。</p>
<h2 id="高可用架构-双主复制"> 高可用架构：双主复制</h2>
<h3 id="主从同步"> 主从同步</h3>
<p>harbor官方默认提供主从复制的方案来解决镜像同步问题，通过复制的方式，我们可以实时将测试环境harbor仓库的镜像同步到生产环境harbor，类似于如下流程：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/harbor_CI.png" alt="img" /></p>
<p>在实际生产运维的中，往往需要把镜像发布到几十或上百台集群节点上。这时，单个Registry已经无法满足大量节点的下载需求，因此要配置多个Registry实例做负载均衡。手工维护多个Registry实例上的镜像，将是十分繁琐的事情。Harbor可以支持一主多从的镜像发布模式，可以解决大规模镜像发布的难题：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/harbor_ab.png" alt="img" /></p>
<p>只要往一台Harbor上发布，镜像就会像&quot;仙女散花&quot;般地同步到多个Registry中，高效可靠。</p>
<p>如果是地域分布较广的集群，还可以采用层次型发布方式，比如从集团总部机房同步到分公司1机房，再从分公司1机房同步到分公司2机房：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/harbor_cl.png" alt="img" /></p>
<p>然而单靠主从同步，仍然解决不了harbor主节点的单点问题。</p>
<h3 id="双主复制说明"> 双主复制说明</h3>
<p>所谓的双主复制其实就是复用主从同步实现两个harbor节点之间的双向同步，来保证数据的一致性，然后在两台harbor前端顶一个负载均衡器将进来的请求分流到不同的实例中去，只要有一个实例中有了新的镜像，就是自动的同步复制到另外的的实例中去，这样实现了负载均衡，也避免了单点故障，在一定程度上实现了Harbor的高可用性：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/harbor_st.png" alt="img" /></p>
<p>这个方案有一个问题就是有可能两个Harbor实例中的数据不一致。假设如果一个实例A挂掉了，这个时候有新的镜像进来，那么新的镜像就会在另外一个实例B中，后面即使恢复了挂掉的A实例，Harbor实例B也不会自动去同步镜像，这样只能手动的先关掉Harbor实例B的复制策略，然后再开启复制策略，才能让实例B数据同步，让两个实例的数据一致。另外，这里还需要多吐槽一句：<strong>在实际生产使用中，主从复制十分的不靠谱！！<strong>所以这里</strong>推荐使用下面要说的这种方案</strong>。</p>
<h2 id="高可用架构-多实例共享后端存储"> 高可用架构：多实例共享后端存储</h2>
<h3 id="方案说明"> 方案说明</h3>
<p>共享后端存储算是一种比较标准的方案，就是多个Harbor实例共享同一个后端存储，任何一个实例持久化到存储的镜像，都可被其他实例中读取。通过前置LB进来的请求，可以分流到不同的实例中去处理，这样就实现了负载均衡，也避免了单点故障。</p>
<p>本次搭建以NFS作为共享存储存放Harbor相关data，并分离PostgreSQL与Redis为多个Harbor共同连接使用，使用Nginx做负载均衡。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/harbor_ha_r.png" alt="img" /></p>
<p>如果最终生产环境集群中服务器较多，依赖做完LB的Harbor也无法完全达到需求时，可以使用如下架构，部署下级Harbor节点从主节点同步镜像，然后再分发给生产服务器。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/harbor_ha_l.png" alt="img" /></p>
<p>这个方案在实际生产环境中部署需要考虑三个问题：</p>
<p><strong>1.</strong> 共享存储的选取，Harbor的后端存储目前支持AWS S3、Openstack Swift, Ceph等，在下面的实验环境里，暂且直接使用nfs。</p>
<p><strong>2.</strong> Session在不同的实例上共享，这个现在其实已经不是问题了，在最新的harbor中，默认session会存放在redis中，只需要将redis独立出来即可。可以通过redis sentinel或者redis cluster等方式来保证redis的可用性。在下面的实验环境里，暂且使用单台redis。</p>
<p><strong>3.</strong> Harbor多实例数据库问题，这个也只需要将harbor中的数据库拆出来独立部署即可。让多实例共用一个外部数据库，数据库的高可用也可以通过数据库的高可用方案保证。</p>
<h3 id="环境说明"> 环境说明</h3>
<ul>
<li>操作系统：<code>CentOS 7.6</code></li>
<li>演示环境软件版本</li>
</ul>
<table>
<thead>
<tr>
<th>软件</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker</td>
<td>19.03.8</td>
</tr>
<tr>
<td>docker-compose</td>
<td>1.25.5</td>
</tr>
<tr>
<td>Harbor</td>
<td>1.10.2</td>
</tr>
<tr>
<td>Nginx</td>
<td>1.14.0</td>
</tr>
<tr>
<td>PostgreSQL</td>
<td>9.6.17</td>
</tr>
<tr>
<td>Redis</td>
<td>3.2.12</td>
</tr>
</tbody>
</table>
<ul>
<li>演示环境网络</li>
</ul>
<p>这里主要做Harbor高可用演示，真实生产环境请按需分离NFS与DB单独部署。</p>
<table>
<thead>
<tr>
<th>IP</th>
<th>主机名</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.16.141</td>
<td>Nginx</td>
</tr>
<tr>
<td>192.168.166.122</td>
<td>NFS</td>
</tr>
<tr>
<td>192.168.166.203</td>
<td>postgresql</td>
</tr>
<tr>
<td>192.168.166.245</td>
<td>Redis</td>
</tr>
<tr>
<td>192.168.166.81</td>
<td>Harbor-01</td>
</tr>
<tr>
<td>192.168.166.212</td>
<td>Harbor-02</td>
</tr>
</tbody>
</table>
<h2 id="多实例共享后端存储-部署"> 多实例共享后端存储 部署</h2>
<h3 id="docker"> Docker</h3>
<p>1）安装依赖包：</p>
<div><pre><code>yum <span>install</span> -y yum-utils <span>\</span>
  device-mapper-persistent-data <span>\</span>
  lvm2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>2）官方一键脚本安装</p>
<div><pre><code><span>curl</span> -fsSL get.docker.com -o get-docker.sh
<span>sh</span> get-docker.sh --mirror Aliyun
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>3）添加内核参数</p>
<div><pre><code><span>tee</span> -a /etc/sysctl.conf <span>&lt;&lt;-</span><span>EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>将<code>net.ipv4.ip_forward</code>赋值为<code>1</code></p>
<p>然后刷新内核参数</p>
<div><pre><code>sysctl -p
</code></pre>
<div><span>1</span><br></div></div><p>4）修改Docker仓库为国内镜像站</p>
<div><pre><code><span>curl</span> -sSL https://get.daocloud.io/daotools/set_mirror.sh <span>|</span> <span>sh</span> -s https://pclhthp0.mirror.aliyuncs.com
</code></pre>
<div><span>1</span><br></div></div><p>5）启动Docker</p>
<div><pre><code>systemctl <span>enable</span> docker <span>&amp;&amp;</span> systemctl start docker
</code></pre>
<div><span>1</span><br></div></div><h3 id="compose"> Compose</h3>
<p><a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener noreferrer">compose</a>是Docker提供的一个命令行工具，用来定义和运行由多个容器组成的应用。使用compose，我们可以通过YAML文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。</p>
<p>由于国内政策原因，可能在海外网站上下载文件速度较慢，建议下载本地后上传至服务器</p>
<p>1）下载<code>docker-compose</code>并赋予可执行权限</p>
<div><pre><code><span># curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose</span>
<span># chmod +x /usr/local/bin/docker-compose</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>cd</span> /usr/local/bin
<span>scp</span> <span>192.168</span>.166.96:/usr/local/bin/docker-compose <span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>注意：由于我其他服务器已经存在，所以我直接拷贝了</p>
</blockquote>
<p>2）安装bash补全命令</p>
<div><pre><code><span># curl -L https://raw.githubusercontent.com/docker/compose/1.24.1/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>scp 192.168.166.96:/etc/bash_completion.d/docker-compose /etc/bash_completion.d/
</code></pre>
<div><span>1</span><br></div></div><p>重新连接终端即生效</p>
<blockquote>
<p>注意：由于我其他服务器已经存在，所以我直接拷贝了</p>
</blockquote>
<h3 id="nfs"> NFS</h3>
<h4 id="服务端"> 服务端</h4>
<p>1）安装必需的RPM包</p>
<div><pre><code>yum -y <span>install</span> nfs-utils rpcbind   
</code></pre>
<div><span>1</span><br></div></div><p>2）创建NFS共享目录</p>
<div><pre><code><span>mkdir</span> -p /data/harbor_data
<span>chown</span> nobody:nobody /data/harbor_data/ 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>3）修改NFS服务配置文件</p>
<div><pre><code><span>echo</span> <span>"/data/harbor_data 192.168.166.0/24(rw,sync,no_root_squash)"</span>  <span>>></span> /etc/exports
</code></pre>
<div><span>1</span><br></div></div><p>4）启动NFS服务器</p>
<div><pre><code>systemctl <span>enable</span> rpcbind <span>&amp;&amp;</span> systemctl restart rpcbind
systemctl <span>enable</span> nfs <span>&amp;&amp;</span> systemctl restart nfs
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="客户端"> 客户端</h4>
<p>1）安装nfs-utils</p>
<div><pre><code>yum -y <span>install</span> nfs-utils
</code></pre>
<div><span>1</span><br></div></div><p>2）在NFS客户端上查看NFS的连通性</p>
<div><pre><code><span># showmount -e 192.168.166.122</span>
Export list <span>for</span> <span>192.168</span>.166.122:
/data/harbor_data <span>192.168</span>.166.0/24
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>3）挂载NFS共享存储</p>
<p>创建挂载目录</p>
<div><pre><code>mkdir /data
</code></pre>
<div><span>1</span><br></div></div><p>修改/etc/fstab配置文件加入以下内容</p>
<div><pre><code>192.168.166.122:/data/harbor_data  /data  nfs defaults 0 0
</code></pre>
<div><span>1</span><br></div></div><p>mount挂载</p>
<div><pre><code>mount -a
</code></pre>
<div><span>1</span><br></div></div><h3 id="postgresql"> PostgreSQL</h3>
<p>1）下载PostgreSQL官方YUM源配置文件包并安装</p>
<div><pre><code><span>wget</span> https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm
<span>rpm</span> -ivh pgdg-redhat-repo-latest.noarch.rpm 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>2）安装PostgreSQL</p>
<div><pre><code>yum  -y <span>install</span> postgresql96-server postgresql96-contrib 
</code></pre>
<div><span>1</span><br></div></div><p>3）初始化数据库</p>
<div><pre><code>/usr/pgsql-9.6/bin/postgresql96-setup initdb  
</code></pre>
<div><span>1</span><br></div></div><p>4）启动数据库</p>
<div><pre><code>systemctl <span>enable</span> postgresql-9.6 <span>&amp;&amp;</span> systemctl restart postgresql-9.6
</code></pre>
<div><span>1</span><br></div></div><p>5）PostgreSQL数据库配置</p>
<ol>
<li>
<p>修改密码</p>
<div><pre><code><span># su - postgres</span>
-bash-4.2$ psql
psql <span>(</span><span>9.6</span>.17<span>)</span>
Type <span>"help"</span> <span>for</span> help.
<span>postgres</span><span>=</span><span># ALTER USER postgres WITH PASSWORD 'postgres';</span>
ALTER ROLE
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>开启远程访问</p>
<p><code>vi /var/lib/pgsql/9.6/data/postgresql.conf</code></p>
<p># listen_addresses = 'localhost' 改为 listen_addresses='*'</p>
</li>
<li>
<p>信任远程连接</p>
<p><code>vim /var/lib/pgsql/9.6/data/pg_hba.conf</code></p>
<p>加入:</p>
<div><pre><code><span>host</span>    all  all  <span>192.168</span>.166.203/32 trust
<span>host</span>    all  all  <span>192.168</span>.166.81/32 trust
<span>host</span>    all  all  <span>192.168</span>.166.212/32 trust
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
<p>6）重启PostgreSQL服务</p>
<div><pre><code>systemctl restart postgresql-9.6
</code></pre>
<div><span>1</span><br></div></div><p>7）验证服务</p>
<div><pre><code>psql -h 192.168.166.203 -p 5432 -U postgres
</code></pre>
<div><span>1</span><br></div></div><p>8）迁移数据库</p>
<ol>
<li>在postgresql所在服务器，先启动一套harbor环境</li>
</ol>
<p>简要步骤如下：</p>
<div><pre><code># yum install -y yum-utils   device-mapper-persistent-data   lvm2
# curl -fsSL get.docker.com -o get-docker.sh
# sh get-docker.sh --mirror Aliyun
#curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s https://pclhthp0.mirror.aliyuncs.com
# systemctl enable docker &amp;&amp; systemctl start docker
# cd /usr/local/bin
# scp 192.168.166.96:/usr/local/bin/docker-compose .
# scp 192.168.166.96:/etc/bash_completion.d/docker-compose /etc/bash_completion.d/
# cd ~
# scp 192.168.166.96:/root/harbor-offline-installer-v1.10.2.tgz .
# tar -xvf harbor-offline-installer-v1.10.2.tgz -C /usr/local/
# cd /usr/local/harbor/
# vim harbor.yml ###修改hostname: 192.168.166.203  ####注释掉https段即可
# ./prepare 
# ./install.sh 
# docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ol start="2">
<li>
<p>进入harbor-db容器导出相关表及数据</p>
<div><pre><code><span># docker container exec -it harbor-db /bin/bash</span>
pg_dump -U postgres registry <span>></span> /tmp/registry.sql 
pg_dump -U postgres notarysigner <span>></span> /tmp/notarysigner.sql  
pg_dump -U postgres notaryserver <span>></span> /tmp/notaryserver.sql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>导出数据库</p>
<div><pre><code>docker container <span>cp</span> harbor-db:/tmp/registry.sql /tmp
docker container <span>cp</span> harbor-db:/tmp/notarysigner.sql /tmp
docker container <span>cp</span> harbor-db:/tmp/notaryserver.sql /tmp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>将数据导入至外部PostgreSQL数据库</p>
<div><pre><code><span># psql -h 192.168.166.203 -U postgres</span>
<span>postgres</span><span>=</span><span># create database registry;</span>
CREATE DATABASE
<span>postgres</span><span>=</span><span># create database notarysigner;</span>
CREATE DATABASE
<span>postgres</span><span>=</span><span># create database notaryserver;</span>
CREATE DATABASE
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code>psql -h <span>192.168</span>.166.203 -U postgres registry <span>&lt;</span> /tmp/registry.sql
psql -h <span>192.168</span>.166.203 -U postgres notarysigner  <span>&lt;</span> /tmp/notarysigner.sql
psql -h <span>192.168</span>.166.203 -U postgres notaryserver <span>&lt;</span> /tmp/notaryserver.sql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
<h3 id="redis"> Redis</h3>
<p>1）安装redis</p>
<div><pre><code>yum -y <span>install</span> redis
</code></pre>
<div><span>1</span><br></div></div><p>2） 修改配置参数</p>
<div><pre><code><span>sed</span> -i <span>'s/bind 127.0.0.1/bind 0.0.0.0/g'</span> /etc/redis.conf   
<span>sed</span> -i <span>'s/daemonize no/daemonize yes/g'</span> /etc/redis.conf   
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>3）启动并测试redis连接</p>
<div><pre><code>systemctl <span>enable</span> redis <span>&amp;&amp;</span> systemctl restart redis
redis-cli 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="harbor"> Harbor</h3>
<p>下载<a href="https://github.com/goharbor/harbor/releases" target="_blank" rel="noopener noreferrer">Harbor</a>离线安装包，离线安装包文件较大（约为：590M），建议在本地使用多线程工具下载后上传服务器使用。</p>
<p>1）下载</p>
<div><pre><code><span>cd</span> ~
<span>scp</span> <span>192.168</span>.166.96:/root/harbor-offline-installer-v1.10.2.tgz <span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>2）解压</p>
<div><pre><code><span>tar</span> -xvf harbor-offline-installer-v1.10.2.tgz -C /usr/local/
</code></pre>
<div><span>1</span><br></div></div><p>3）修改配置文件</p>
<div><pre><code># cd /usr/local/harbor/
# vim harbor.yml 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>修改的内容有</p>
<ul>
<li><code>hostname</code>修改为本机ip</li>
<li>注释掉https</li>
<li>修改harbor默认的admin账号密码</li>
<li>数据存储位置，改为nfs挂载目录，因为我们本来就挂载到了<code>/data</code>目录下，所以不用动</li>
<li>注释掉<code>database</code></li>
<li>注释掉<code>clair</code></li>
<li>打开<code>external_database</code>和<code>external_redis</code>块的注释，并改为刚刚部署的地址</li>
</ul>
<p>修改完的样例文件，如下</p>
<div><pre><code>hostname: 192.168.166.81
http:
  port: 80
harbor_admin_password: Harbor12345
data_volume: /data
jobservice:
  max_job_workers: 10
notification:
  webhook_job_max_retry: 10
chart:
  absolute_url: disabled
log:
  level: info
  local:
    rotate_count: 50
    rotate_size: 200M
    location: /var/log/harbor
_version: 1.10.0
external_database:
  harbor:
    host: 192.168.166.203
    port: 5432
    db_name: registry
    username: postgres
    password: postgres
    ssl_mode: disable
    max_idle_conns: 2
    max_open_conns: 0
  clair:
    host: 192.168.166.203
    port: 5432
    db_name: clair
    username: postgres
    password: postgres
    ssl_mode: disable
  notary_signer:
    host: 192.168.166.203
    port: 5432
    db_name: notarysigner
    username: postgres
    password: postgres
    ssl_mode: disable
  notary_server:
    host: 192.168.166.203
    port: 5432
    db_name: notaryserver
    username: postgres
    password: postgres
    ssl_mode: disable
external_redis:
  host: 192.168.166.245
  port: 6379
  password:
  registry_db_index: 1
  jobservice_db_index: 2
  chartmuseum_db_index: 3
  clair_db_index: 4
proxy:
  http_proxy:
  https_proxy:
  no_proxy:
  components:
    - core
    - jobservice
    - clair
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><p>4）生成harbor运行的必要文件（环境）以及<code>docker-compose.yml</code>文件；执行后会通过网络获取Docker Image，建议提前修改好国内镜像站加速。</p>
<div><pre><code>./prepare 
</code></pre>
<div><span>1</span><br></div></div><p>5）安装Harbor</p>
<div><pre><code>./install.sh 
</code></pre>
<div><span>1</span><br></div></div><h3 id="nginx"> Nginx</h3>
<p>1）安装nginx</p>
<p>安装可以参考https://wiki.clay-wangzhi.com/7-nginx/1.-chu-shi-nginx#4-bian-yi-an-zhuang-nginx</p>
<p>这里我就不再详细讲了</p>
<p>2）编写配置文件</p>
<div><pre><code><span># cat harbor.schengle.com.conf </span>
<span>upstream</span> harbor <span>{</span>
    <span>ip_hash</span><span>;</span>
    <span>server</span> <span>192.168</span><span>.166</span><span>.81</span><span>:</span><span>80</span><span>;</span>
    <span>server</span> <span>192.168</span><span>.166</span><span>.212</span><span>:</span><span>80</span><span>;</span>
<span>}</span>
<span>server</span> <span>{</span>
    <span>listen</span>       <span>80</span><span>;</span>
    <span>server_name</span>  harbor<span>.</span><span>*</span><span>*</span><span>*</span><span>.</span>com<span>;</span>
    <span>rewrite</span> <span>^</span><span>(</span><span>.</span><span>*</span><span>)</span> <span>https</span><span>:</span><span>/</span><span>/</span><span>$server_name</span>$<span>1</span> permanent<span>;</span>
<span>}</span>
<span>server</span> <span>{</span>
    <span>listen</span>  <span>443</span> <span>ssl</span><span>;</span>
    <span>server_name</span> harbor<span>.</span>schengle<span>.</span>com<span>;</span>
    
    <span>ssl_certificate</span> <span>*</span><span>*</span><span>*</span><span>.</span>crt<span>;</span>
    <span>ssl_certificate_key</span> <span>*</span><span>*</span><span>*</span><span>.</span>key<span>;</span>
    <span>client_max_body_size</span> <span>0</span><span>;</span>
    <span>chunked_transfer_encoding</span> on<span>;</span>

    <span>location</span> <span>/</span> <span>{</span>
        <span>proxy_set_header</span> X<span>-</span>Forwarded<span>-</span>For <span>$proxy_add_x_forwarded_for</span><span>;</span>
        <span>#proxy_set_header Host $host;</span>
        <span>proxy_set_header</span> X<span>-</span>Forwarded<span>-</span>Proto <span>https</span><span>;</span>
        <span>proxy_redirect</span> off<span>;</span>
        proxy_ssl_verify off<span>;</span>
        <span>proxy_ssl_session_reuse</span> on<span>;</span>
        <span>proxy_pass</span> <span>http</span><span>:</span><span>/</span><span>/</span>harbor<span>;</span>
		<span>proxy_redirect</span> default<span>;</span>
        <span>proxy_http_version</span> <span>1.1</span><span>;</span>
<span>}</span>
    <span>location</span> <span>/</span>v2<span>/</span> <span>{</span>
        <span>proxy_pass</span> <span>http</span><span>:</span><span>/</span><span>/</span>harbor<span>/</span>v2<span>/</span><span>;</span>
		<span>proxy_redirect</span> default<span>;</span>
        <span>#proxy_set_header Host $host;</span>
        <span>proxy_set_header</span> X<span>-</span>Real<span>-</span>IP <span>$remote_addr</span><span>;</span>
        <span>proxy_set_header</span> X<span>-</span>Forwarded<span>-</span>For <span>$proxy_add_x_forwarded_for</span><span>;</span>
        <span>proxy_set_header</span> X<span>-</span>Forwarded<span>-</span>Proto <span>$scheme</span><span>;</span>
        proxy_ssl_verify off<span>;</span>
        <span>proxy_ssl_session_reuse</span> on<span>;</span>
        <span>proxy_buffering</span> off<span>;</span>
        proxy_request_buffering off<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>3）平滑重启nginx</p>
<div><pre><code>nginx -s reload
</code></pre>
<div><span>1</span><br></div></div><h2 id="参考文章"> 参考文章</h2>
<blockquote>
<p>https://www.cnblogs.com/kevingrace/p/11422710.html</p>
<p>https://juejin.im/post/5d973e246fb9a04dfa0963fb#heading-18</p>
<p>https://mp.weixin.qq.com/s?__biz=MzU5Mzg4NTYyOA==&amp;mid=2247483698&amp;idx=1&amp;sn=79db67ba94f7de4a681f5827b32495c3&amp;chksm=fe08e1e1c97f68f79ce3c1de437d25a0262acdf6e50295d7b05f25fd9090c05ae17547f582c9&amp;mpshare=1&amp;scene=24&amp;srcid=0426o4pE2rlbV9jiC0uU7bbf&amp;sharer_sharetime=1587898963958&amp;sharer_shareid=9b928482ebeb2f07e6828859301773b2&amp;key=0c8b8599c39815a077ababf632218cf4dd47c3300ac756d5d1f91cab59a40607f01f1490e733f7642923a35122555c5af376a556d629fd23b6d57045ab998c4c8ef4c0069aaa95360699b46822a279da&amp;ascene=1&amp;uin=MjIyMjY5MjcyMg%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=ATu2VmD5qWBN%2BODgGFu%2BLRg%3D&amp;pass_ticket=UKe3uNkZN8oXGdb8m9nzjnYYPVa%2B6oSRKUVpiOMdQ%2BemAGGjU653K0yx2yLVIF6J</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="常见服务的搭建"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">docker 安装rabbitmq集群</title>
    <id>https://clay-wangzhi.com/container/Docker/docker_rabbitmq/</id>
    <link href="https://clay-wangzhi.com/container/Docker/docker_rabbitmq/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-安装rabbitmq集群"> docker 安装rabbitmq集群</h1>
<h2 id="rabbitmq-高可用集群架构"> RabbitMQ 高可用集群架构</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/rabbitmq_ha.png" alt="img" /></p>
<p>将两个 RabbitMQ 磁盘节点和一个 RabbitMQ 内存节点组成一个内建集群，之所以要用两个磁盘节点是防止，唯一的磁盘节点挂掉后，不能重建队列，交换器。用 HAProxy 作为 RabbitMQ 集群的负载均衡。为了防止 HAProxy 单点故障，用 Keepalived 将两个 HAProxy 节点做成一主一备。应用使用 VIP（虚拟IP） 访问 HAProxy 服务时，默认连接主机（Master）的 HAProxy，当主机（Master）上的 HAProxy 故障时，VIP 会漂移到备机（Backup）上，就会连接备机（Backup）上的 HAProxy 服务。</p>
<h2 id="服务器规划"> 服务器规划</h2>
<table>
<thead>
<tr>
<th>角色</th>
<th>数量</th>
<th>ip地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>RabbitMQ Disc Node</td>
<td>2</td>
<td>192.168.125.26，192.168.125.190</td>
</tr>
<tr>
<td>RabbitMQ RAM Node</td>
<td>1</td>
<td>192.168.125.176</td>
</tr>
<tr>
<td>HAProxy</td>
<td>2</td>
<td>192.168.125.222，192.168.125.168</td>
</tr>
<tr>
<td>虚拟ip</td>
<td>1</td>
<td>192.168.125.245</td>
</tr>
</tbody>
</table>
<h2 id="准备工作"> 准备工作</h2>
<h3 id="安装docker和docker-compose"> 安装Docker和Docker Compose</h3>
<ol>
<li>
<p>安装配置Docker</p>
<p>使用官方脚本安装 Docker</p>
<div><pre><code><span>curl</span> -fsSL <span>"https://get.docker.com/"</span> <span>|</span> <span>bash</span> -s -- --mirror Aliyun
</code></pre>
<div><span>1</span><br></div></div><p>加载br_netfilter</p>
<div><pre><code>modprobe br_netfilter
</code></pre>
<div><span>1</span><br></div></div><p>设置下系统内核参数</p>
<div><pre><code>cat<span>&lt;&lt;</span><span>EOF<span> <span>></span> /etc/sysctl.d/docker.conf</span>
# 要求iptables不对bridge的数据进行处理
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-arptables = 1
# 开启转发
net.ipv4.ip_forward = 1
EOF</span>
sysctl -p /etc/sysctl.d/docker.conf
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>⚠️ 慎用<code>sysctl --system</code>命令，如果参数在不同文件中设置，会有优先级问题，目前看来<code>/etc/sysctl.conf</code>的优先级最高</p>
</blockquote>
<p>配置docker镜像站</p>
<div><pre><code><span>curl</span> -sSL https://get.daocloud.io/daotools/set_mirror.sh <span>|</span> <span>sh</span> -s http://f1361db2.m.daocloud.io
</code></pre>
<div><span>1</span><br></div></div><p>启动docker服务</p>
<div><pre><code>systemctl <span>enable</span> docker <span>&amp;&amp;</span> systemctl start docker
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>安装配置Docker Compose</p>
<p>二进制方式 安装Docker Compose</p>
<div><pre><code><span>curl</span> -L https://github.com/docker/compose/releases/download/1.27.4/docker-compose-<span><span>$(</span><span>uname</span> -s<span>)</span></span>-<span><span>$(</span><span>uname</span> -m<span>)</span></span> <span>></span> /usr/local/bin/docker-compose
<span>chmod</span> +x /usr/local/bin/docker-compose
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>配置bash补全命令</p>
<div><pre><code><span>curl</span> -L https://raw.githubusercontent.com/docker/compose/1.27.4/contrib/completion/bash/docker-compose <span>></span> /etc/bash_completion.d/docker-compose
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>如果网络不可达，可先下载到本地，然后上传到内网ftp服务器上，进行下载，以下是笔者自己的内网ftp下载地址</p>
</blockquote>
<div><pre><code><span>curl</span> -L ftp://192.168.166.21/docker-compose <span>></span> /etc/bash_completion.d/docker-compose
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
<h3 id="下载rabbitmq和haproxy镜像"> 下载rabbitmq和haproxy镜像</h3>
<p>下载镜像</p>
<div><pre><code>docker pull rabbitmq:3.8.9-management
docker pull haproxy:2.1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="部署rabbitmq集群"> 部署rabbitmq集群</h2>
<h3 id="部署192-168-125-26节点"> 部署<code>192.168.125.26</code>节点</h3>
<p>创建目录</p>
<div><pre><code><span>mkdir</span> -p /app/clay/rabbitmq
<span>cd</span> /app/clay/rabbitmq
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>查看服务编排文件<code>clay-rabbitmq-node1.yaml</code></p>
<div><pre><code><span>version</span><span>:</span> <span>'3'</span>
<span>services</span><span>:</span>
  <span>rabbitmq</span><span>:</span>
    <span>container_name</span><span>:</span> clay<span>-</span>rabbitmq
    <span>image</span><span>:</span> rabbitmq<span>:</span>3.8.9<span>-</span>management
    <span>restart</span><span>:</span> always
    <span>ports</span><span>:</span>
      <span>-</span> 4369<span>:</span><span>4369</span>
      <span>-</span> 5671<span>:</span><span>5671</span>
      <span>-</span> 5672<span>:</span><span>5672</span>
      <span>-</span> 15672<span>:</span><span>15672</span>
      <span>-</span> 25672<span>:</span><span>25672</span>
    <span>environment</span><span>:</span>
      <span>-</span> TZ=Asia/Shanghai
      <span>-</span> RABBITMQ_ERLANG_COOKIE=iweru238roseire
      <span>-</span> RABBITMQ_DEFAULT_USER=clay_admin
      <span>-</span> RABBITMQ_DEFAULT_PASS=clay_admin_123
      <span>-</span> RABBITMQ_DEFAULT_VHOST=clay_vhost
    <span>hostname</span><span>:</span> rabbitmq1
    <span>extra_hosts</span><span>:</span>
      <span>-</span> rabbitmq1<span>:</span>192.168.125.26
      <span>-</span> rabbitmq2<span>:</span>192.168.125.190
      <span>-</span> rabbitmq3<span>:</span>192.168.125.176
    <span>volumes</span><span>:</span>
      <span>-</span> ./data<span>:</span>/var/lib/rabbitmq
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>部署</p>
<div><pre><code>docker-compose -f clay-rabbitmq-node1.yaml up -d
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>⚠️ 三个节点 RABBITMQ_ERLANG_COOKIE 保持一致。一定要有 extra_hosts 配置，否则在搭建集群的过程中会连接不到其他 rabbitmq 节点服务。此节点</p>
<p>作为集群根节点。</p>
</blockquote>
<h3 id="部署192-168-125-190节点"> 部署<code>192.168.125.190</code>节点</h3>
<p>创建目录</p>
<div><pre><code><span>mkdir</span> -p /app/clay/rabbitmq
<span>cd</span> /app/clay/rabbitmq
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>编写<code>rabbitmq.sh</code>启动脚本（磁盘节点）</p>
<div><pre><code><span>cat</span> <span>></span> rabbitmq.sh <span>&lt;&lt;</span><span>EOF
rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl join_cluster rabbit@rabbitmq1
rabbitmqctl start_app
EOF</span>
<span>chmod</span> +x rabbitmq.sh 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>查看服务编排文件<code>clay-rabbitmq-node2.yaml</code></p>
<div><pre><code><span>version</span><span>:</span> <span>'3'</span>
<span>services</span><span>:</span>
  <span>rabbitmq</span><span>:</span>
    <span>container_name</span><span>:</span> clay<span>-</span>rabbitmq
    <span>image</span><span>:</span> rabbitmq<span>:</span>3.8.9<span>-</span>management
    <span>restart</span><span>:</span> always
    <span>ports</span><span>:</span>
      <span>-</span> 4369<span>:</span><span>4369</span>
      <span>-</span> 5671<span>:</span><span>5671</span>
      <span>-</span> 5672<span>:</span><span>5672</span>
      <span>-</span> 15672<span>:</span><span>15672</span>
      <span>-</span> 25672<span>:</span><span>25672</span>
    <span>environment</span><span>:</span>
      <span>-</span> TZ=Asia/Shanghai
      <span>-</span> RABBITMQ_ERLANG_COOKIE=iweru238roseire
      <span>-</span> RABBITMQ_DEFAULT_USER=clay_admin
      <span>-</span> RABBITMQ_DEFAULT_PASS=clay_admin_123
      <span>-</span> RABBITMQ_DEFAULT_VHOST=clay_vhost
    <span>hostname</span><span>:</span> rabbitmq2
    <span>extra_hosts</span><span>:</span>
      <span>-</span> rabbitmq1<span>:</span>192.168.125.26
      <span>-</span> rabbitmq2<span>:</span>192.168.125.190
      <span>-</span> rabbitmq3<span>:</span>192.168.125.176
    <span>volumes</span><span>:</span>
      <span>-</span> ./rabbitmq.sh<span>:</span>/home/rabbitmq.sh
      <span>-</span> ./data<span>:</span>/var/lib/rabbitmq
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>部署</p>
<div><pre><code>docker-compose -f clay-rabbitmq-node2.yaml up -d
</code></pre>
<div><span>1</span><br></div></div><p>节点启动完成后，通过命令进入<code>rabbitmq2</code>节点的容器中，执行<code>/home/rabbitmq.sh</code>脚本</p>
<div><pre><code>docker container <span>exec</span> -it clay-rabbitmq /bin/bash
./home/rabbitmq.sh 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="部署192-168-125-176节点"> 部署<code>192.168.125.176</code>节点</h3>
<p>创建目录</p>
<div><pre><code><span>mkdir</span> -p /app/clay/rabbitmq
<span>cd</span> /app/clay/rabbitmq
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>编写<code>rabbitmq-ram.sh</code>启动脚本（内存节点）</p>
<div><pre><code><span>cat</span> <span>></span> rabbitmq-ram.sh <span>&lt;&lt;</span><span>EOF
rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl join_cluster --ram rabbit@rabbitmq1
rabbitmqctl start_app
EOF</span>
<span>chmod</span> +x rabbitmq-ram.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>查看服务编排文件<code>clay-rabbitmq-node3.yaml</code></p>
<div><pre><code><span>version</span><span>:</span> <span>'3'</span>
<span>services</span><span>:</span>
  <span>rabbitmq</span><span>:</span>
    <span>container_name</span><span>:</span> clay<span>-</span>rabbitmq
    <span>image</span><span>:</span> rabbitmq<span>:</span>3.8.9<span>-</span>management
    <span>restart</span><span>:</span> always
    <span>ports</span><span>:</span>
      <span>-</span> 4369<span>:</span><span>4369</span>
      <span>-</span> 5671<span>:</span><span>5671</span>
      <span>-</span> 5672<span>:</span><span>5672</span>
      <span>-</span> 15672<span>:</span><span>15672</span>
      <span>-</span> 25672<span>:</span><span>25672</span>
    <span>environment</span><span>:</span>
      <span>-</span> TZ=Asia/Shanghai
      <span>-</span> RABBITMQ_ERLANG_COOKIE=iweru238roseire
      <span>-</span> RABBITMQ_DEFAULT_USER=clay_admin
      <span>-</span> RABBITMQ_DEFAULT_PASS=clay_admin_123
      <span>-</span> RABBITMQ_DEFAULT_VHOST=clay_vhost
    <span>hostname</span><span>:</span> rabbitmq3
    <span>extra_hosts</span><span>:</span>
      <span>-</span> rabbitmq1<span>:</span>192.168.125.26
      <span>-</span> rabbitmq2<span>:</span>192.168.125.190
      <span>-</span> rabbitmq3<span>:</span>192.168.125.176
    <span>volumes</span><span>:</span>
      <span>-</span> ./rabbitmq<span>-</span>ram.sh<span>:</span>/home/rabbitmq<span>-</span>ram.sh
      <span>-</span> ./data<span>:</span>/var/lib/rabbitmq
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>部署</p>
<div><pre><code>docker-compose -f clay-rabbitmq-node3.yaml up -d
</code></pre>
<div><span>1</span><br></div></div><p>在启动<code>rabbitmq3</code>节点，启动后，进入容器内部，执行 <code>/home/rabbitmq-ram.sh</code> 脚本添加内存节点到集群中</p>
<div><pre><code>docker container <span>exec</span> -it clay-rabbitmq /bin/bash
./home/rabbitmq-ram.sh 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在容器内部使用<code>rabbitmqctl cluster_status</code>命令查看集群状态，以下是输出</p>
<div><pre><code>Basics

Cluster name: rabbit@rabbitmq3

Disk Nodes

rabbit@rabbitmq1
rabbit@rabbitmq2

RAM Nodes

rabbit@rabbitmq3

Running Nodes

rabbit@rabbitmq1
rabbit@rabbitmq2
rabbit@rabbitmq3

Versions

rabbit@rabbitmq1: RabbitMQ 3.8.9 on Erlang 23.1.1
rabbit@rabbitmq2: RabbitMQ 3.8.9 on Erlang 23.1.1
rabbit@rabbitmq3: RabbitMQ 3.8.9 on Erlang 23.1.1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>也可以通过 http://192.168.125.26:15672/ 进入管理端查看集群状态</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/rabbitmqclay.png" alt="rabbitmq_ha" /></p>
<h2 id="haproxy-负载均衡"> HaProxy 负载均衡</h2>
<p>在<code>192.168.125.222</code>，<code>192.168.125.168</code>两个节点同时操作</p>
<p>创建目录</p>
<div><pre><code><span>mkdir</span> -p /app/clay/haproxy
<span>cd</span> /app/clay/haproxy
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>查看服务编排文件<code>clay-haproxy.yaml</code></p>
<div><pre><code><span>version</span><span>:</span> <span>'3'</span>
<span>services</span><span>:</span>
  <span>haproxy</span><span>:</span>
    <span>container_name</span><span>:</span> clay<span>-</span>haproxy
    <span>image</span><span>:</span> haproxy<span>:</span><span>2.1</span>
    <span>restart</span><span>:</span> always
    <span>ports</span><span>:</span>
      <span>-</span> 8100<span>:</span><span>8100</span>
      <span>-</span> 15670<span>:</span><span>5670</span>
    <span>environment</span><span>:</span>
      <span>-</span> TZ=Asia/Shanghai
    <span>extra_hosts</span><span>:</span>
      <span>-</span> rabbitmq1<span>:</span>192.168.125.26
      <span>-</span> rabbitmq2<span>:</span>192.168.125.190
      <span>-</span> rabbitmq3<span>:</span>192.168.125.176
    <span>volumes</span><span>:</span>
      <span>-</span> ./haproxy.cfg<span>:</span>/usr/local/etc/haproxy/haproxy.cfg<span>:</span>ro
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>
<p>重点是设置 extra_hosts（rabbitmq 集群节点 ip） 和 volumes（使用自定义的配置文件）</p>
</blockquote>
<p>haproxy 配置文件内容：</p>
<div><pre><code>global
    log 127.0.0.1 local0 info
    maxconn 4096

defaults
    log     global
    mode    tcp
    option  tcplog
    retries 3
    option  redispatch
    maxconn 2000
    timeout connect 5s
    timeout client 120s
    timeout server 120s

# ssl for rabbitmq
# frontend ssl_rabbitmq
    # bind *:5673 ssl crt /root/rmqha_proxy/rmqha.pem
    # mode tcp
    # default_backend rabbitmq

# web 管理界面
listen stats
    bind *:8100
    mode http
    stats enable
    stats realm Haproxy\ Statistics
    stats uri /
    stats auth admin:admin123
# 配置负载均衡
listen rabbitmq
    bind *:5670
    mode tcp
    balance roundrobin
    server  rabbitmq1 rabbitmq1:5672  check inter 5s rise 2 fall 3
    server  rabbitmq2 rabbitmq2:5672  check inter 5s rise 2 fall 3
    server  rabbitmq3 rabbitmq3:5672  check inter 5s rise 2 fall 3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>部署</p>
<div><pre><code>docker-compose -f clay-haproxy.yaml up -d
</code></pre>
<div><span>1</span><br></div></div><p>登录 HAProxy 的管理端查看集群状态：http://192.168.125.222:8100/</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/haproxyauth.png" alt="haproxyauth" /></p>
<h2 id="使用-keepalived-给-haproxy-做主备"> 使用 Keepalived 给 HAProxy 做主备</h2>
<p>在<code>192.168.125.222</code>，<code>192.168.125.168</code>两个节点安装<code>keepalived</code></p>
<div><pre><code>yum -y <span>install</span> keepalived
<span># 安装killall命令</span>
yum -y <span>install</span> psmisc
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>Master 节点配置：</strong></p>
<div><pre><code>vrrp_script chk_haproxy {
    script &quot;killall -0 haproxy&quot;  # verify haproxy&#39;s pid existance
    interval 5                   # check every 5 seconds
    weight -2                    # if check failed, priority will minus 2
}
vrrp_instance VI_1 {
    # 主机: MASTER
    # 备机: BACKUP
    state MASTER
    # 实例绑定的网卡, 用ip a命令查看网卡编号
    interface eth0
    # 虚拟路由标识，这个标识是一个数字(1-255)，在一个VRRP实例中主备服务器ID必须一样
    virtual_router_id 51
    # 优先级，数字越大优先级越高，在一个实例中主服务器优先级要高于备服务器
    priority 101
    # 虚拟IP地址,可以有多个，每行一个
    virtual_ipaddress {
        192.168.125.245
    }
    track_script {               # Scripts state we monitor
        chk_haproxy
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><code>eth0</code>是网卡名，<code>ifconfig</code> 命令查看服务器网卡，找到和本机服务 ip 对应的网卡，<code>virtual_router_id</code> 的值要和 backup 节点上的配置保持一致。</p>
<p><code>killall -0 haproxy</code> 命令的意思是，如果 haproxy 服务存在执行该命令，什么都不会发生，如果服务不存在，执行该命令会报找不到进程 <code>haproxy: no process found</code>。</p>
<p>master 节点的 priority 在减去 weight 后要比 backup 节点的 priority 低才行，否则主备切换不成功。</p>
<p><strong>Backup节点配置：</strong></p>
<div><pre><code>vrrp_script chk_haproxy {
    script &quot;killall -0 haproxy&quot;  # verify haproxy&#39;s pid existance
    interval 5                   # check every 5 seconds
    weight -2                    # if check failed, priority will minus 2
}
vrrp_instance VI_1 {
    # 主机: MASTER
    # 备机: BACKUP
    state BACKUP
    # 实例绑定的网卡, 用ip a命令查看网卡编号
    interface eth0
    # 虚拟路由标识，这个标识是一个数字(1-255)，在一个VRRP实例中主备服务器ID必须一样
    virtual_router_id 51
    # 优先级，数字越大优先级越高，在一个实例中主服务器优先级要高于备服务器
    priority 100
    # 虚拟IP地址,可以有多个，每行一个
    virtual_ipaddress {
        192.168.125.245
    }
    track_script {               # Scripts state we monitor
        chk_haproxy
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>创建完配置，启动 keepalived。</p>
<div><pre><code>systemctl restart keepalived.service 
</code></pre>
<div><span>1</span><br></div></div><p><strong>测试 Keepalived</strong></p>
<p>在 Master，Backup 节点上，使用 <code>ip addr</code> 命令看下 vip 在哪台机器的 eth0 网卡上。</p>
<p>默认在 master 主机上，停掉 master 主机的 haproxy 服务，然后在用 <code>ip addr</code> 查看虚拟 ip 在哪个机器上，如果漂移到备份主机上则代表热备生效。</p>
<p>在开启 master 主机的 haproxy 服务，<code>ip addr</code> 查看虚拟 ip 应该重新漂移回 master 主机上。</p>
<p>测试服务，使用虚拟 ip 加服务端口号访问 HAProxy 服务。</p>
<p>至此，高可用的 rabbitmq 集群 和 haproxy 软负载就搭建完成。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="常见服务的搭建"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">使用方法</title>
    <id>https://clay-wangzhi.com/container/dockerfile/fastdfs/</id>
    <link href="https://clay-wangzhi.com/container/dockerfile/fastdfs/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="使用方法"> 使用方法</h2>
<p>需要注意的是 你需要在运行容器的时候制定宿主机的<code>ip</code> 用参数<code>PUBIP</code> 来指定</p>
<div><pre><code><span>mkdir</span> -p /data/fastdfs
docker pull wangzhichidocker/fastdfs:1.0.0
docker container run -d --name fdfs-test --network <span>host</span> -e <span>PUBIP</span><span>=</span>xxx --mount <span>type</span><span>=</span>bind,source<span>=</span>/data/fastdfs,target<span>=</span>/data/fastdfs wangzhichidocker/fastdfs:1.0.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="客户端测试"> 客户端测试</h2>
<p>拷贝一个图片到容器内</p>
<div><pre><code>docker container cp favicon.png fdfs-test:/tmp
</code></pre>
<div><span>1</span><br></div></div><p>进入容器上传图片</p>
<div><pre><code>docker container exec -it fdfs-test /bin/bash
fdfs_upload_file /etc/fdfs/client.conf /tmp/favicon.png 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>返回值为<code>group1/M00/00/00/wKh932A9-xCAcK7FAAGO_BH5JHs036.png</code></p>
<p>在浏览器访问<code>http://宿主机IP:8888/group1/M00/00/00/wKh932A9-xCAcK7FAAGO_BH5JHs036.png</code>，如果访问图片正常，则测试成功</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">8 AB复制</title>
    <id>https://clay-wangzhi.com/db/mysql/ab-copy/</id>
    <link href="https://clay-wangzhi.com/db/mysql/ab-copy/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_8-ab复制"> 8 AB复制</h1>
<h2 id="mysql-ab简介"> MySQL AB简介</h2>
<p>AB复制又称主从复制，实现的是数据同步。</p>
<p>如果要做MySQL AB复制，数据库版本尽量保持一致。如果版本不一致，从服务器版本高于主服务器，但是版本不一致不能做双向复制。</p>
<p>MySQL AB复制有什么好处呢？</p>
<ul>
<li>解决宕机带来的数据不一致，因为MySQL AB复制可以实时备份数据；</li>
<li>减轻数据库服务器压力，多台服务器的性能一般比单台要好。但是MySQL AB复制不适用于大数据量，如果是大数据环境，推荐使用集群。</li>
</ul>
<p>​    MySQL复制（replication）是一个异步的复制，从一个MySQL实例（Master）复制到另一个MySQL（Slave）。实现整个主从复制，需要由Master服务器上的IO进程，和Slave服务器上的Sql进程和IO进程共同完成。</p>
<h2 id="主从复制的过程"> 主从复制的过程</h2>
<p>​    要实现主从复制，首先必须打开Master端的binary log(bin-log)功能，因为整个MySQL复制过程实际上就是Slave从Master端获取相应的二进制日志，然后再在自己slave端完全顺序的执行日志中所有记录的各种操作。
主从复制的基本过程：
​    1）MySQL Slave端的IO进程连接上Master，向Master请求指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</p>
<p>​    2）Master接收到来自Slave的IO进程的请求后，负责复制的IO进程根据Slave的请求信息，读取相应日志内容，返回给Slave的IO的进程。并将本次请求读到的bin-log文件名及位置一起返回给Slave端。</p>
<p>​    3）Slave的IO进程接收到信息后，将接收到的日志内容依次添加Slave端的realy-log文件的最末端，并将读取到的Master端的bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我；”</p>
<p>​    4）Slave的Sql进程监测到relay-log中新增了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行。</p>
<h3 id="主服务器操作"> 主服务器操作</h3>
<h4 id="全备-并在从机恢复数据"> 全备，并在从机恢复数据</h4>
<h4 id="开启binlog日志"> 开启binlog日志</h4>
<div><pre><code>vim /etc/my.cnf
[mysqld]
log-bin = master
log-bin-index = master
server-id = 1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>service mysqld restart
</code></pre>
<div><span>1</span><br></div></div><h4 id="授权从服务器"> 授权从服务器</h4>
<p>授权从服务器，可以传输binlog日志</p>
<div><pre><code>grant replication slave on *.* to slave@&#39;从服务器&#39; identified by &#39;123&#39;;
</code></pre>
<div><span>1</span><br></div></div><h3 id="从服务器操作"> 从服务器操作</h3>
<h4 id="导入主服务器的数据"> 导入主服务器的数据</h4>
<div><pre><code>mysql -u root &lt; all.sql
</code></pre>
<div><span>1</span><br></div></div><h4 id="改配置文件"> 改配置文件</h4>
<div><pre><code>vim /etc/my.cnf
[mysqld]
server-id = 2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="配置主服务器的信息"> 配置主服务器的信息</h4>
<div><pre><code>&gt;stop slave;
&gt;change master to
-&gt; master_host = &#39;主服务器&#39;，
-&gt;master_user = &#39;slave&#39;,
-&gt;master_password = &#39;123&#39;,
-&gt;master_port = 3306,
-&gt;master_log_file = &#39;mysql-bin.000001&#39;,
-&gt; master_log_pos=120;
&gt;start slave;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="校验"> 校验</h3>
<div><pre><code>&gt; show slave status\G
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>表示成功</p>
<p>​</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">7 备份恢复</title>
    <id>https://clay-wangzhi.com/db/mysql/back/</id>
    <link href="https://clay-wangzhi.com/db/mysql/back/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_7-备份恢复"> 7 备份恢复</h1>
<p>对于任何数据库来说，备份都是非常重要的</p>
<p><strong>数据库复制不能取代备份的作用</strong></p>
<p>比如我们由于误操作，在主数据库上删除了一些数据，由于主从复制的时间很短，在发现时，从数据库上的数据可能也已经被删除了，
我们不能使用从数据库上的数据来恢复主数据库上的数据，只能通过备份进行误删除数据的恢复</p>
<h2 id="_1-备份的分类"> 1 备份的分类</h2>
<h3 id="_1-1-按备份的结果来分"> 1.1 按备份的结果来分</h3>
<h4 id="_1-1-1-逻辑备份"> 1.1.1 逻辑备份</h4>
<p>其备份结果为SQL语句，适合于所有存储引擎，恢复时需要较多时间，逻辑备份时，对于MyISAM存储引擎是需要进行锁表操作的，通过使用的mysqldump就是一种逻辑备份工具</p>
<h4 id="_1-1-2-物理备份"> 1.1.2 物理备份</h4>
<p>是对数据库目录的拷贝，其备份结果的大小通常也与备份数据的数据目录大小相同，物理备份和恢复通常比逻辑备份要快，因为只需要对mysql数据目录拷贝即可，也正是因为这点，对于内存表只能备份其结构，无法备份数据(因为其数据存储在内存中，没有实际的物理数据文件)</p>
<p><strong>物理备份的方式</strong></p>
<p>进行物理备份，我们可以采用离线备份和在线备份的方式进行备份</p>
<ul>
<li>离线备份：需要对数据库进行停机，或对整个数据库进行锁定的情况下进行</li>
<li>在线备份：需要使用第三方工具，如  XtraBackup</li>
</ul>
<h3 id="_1-2-按备份的数据库的内容来分"> 1.2 按备份的数据库的内容来分</h3>
<h4 id="_1-2-1-全量备份"> 1.2.1 全量备份</h4>
<p>是对整个数据库的一个完整备份</p>
<h4 id="_1-2-2-增量备份"> 1.2.2 增量备份</h4>
<p>是在上次全量或增量备份的基础上，对更改过的数据进行的备份</p>
<blockquote>
<p>注意：</p>
<p><strong>Mysql官方提供的mysqldump命令并不支持增量备份</strong></p>
<p>通常情况要使用mysqldump来进行增量备份的话，增量备份只能通过备份Mysql的二进制日志来实现</p>
<p>XtraBackup本身就提供了增量备份的功能，所以对于Innodb来说，使用XtraBackup进行备份更加安全高效</p>
<p>无论是使用XtraBackup还是Mysqldump 进行备份，要进行基于时间点的恢复时都需要利用Mysql的二进制日志，所以通常情况下我们需要对Mysql的二进制日志也进行备份</p>
</blockquote>
<h2 id="_2-使用mysqldump进行备份"> 2 使用mysqldump进行备份</h2>
<p>mysqldump 是mysql官方提供的逻辑备份工具，其备份结果是可读的SQL文件</p>
<p>mysqldump 支持多种语法</p>
<h3 id="_2-1-常用语法"> 2.1 常用语法</h3>
<h4 id="_2-1-1-对一个数据库下的一个或多个表进行备份"> 2.1.1 对一个数据库下的一个或多个表进行备份</h4>
<div><pre><code>mysqldump [OPTIONS] database [tables]
</code></pre>
<div><span>1</span><br></div></div><p>备份多个表时，table直接用空格进行分隔</p>
<h4 id="_2-1-2-对指定的多个数据库进行备份"> 2.1.2 对指定的多个数据库进行备份</h4>
<div><pre><code>mysqldump [OPTIONS] --database [OPTIONS] DB1 [DB2..]
</code></pre>
<div><span>1</span><br></div></div><h4 id="_2-1-3-对整个mysql实例下的所有数据库进行备份"> 2.1.3 对整个mysql实例下的所有数据库进行备份</h4>
<div><pre><code>mysqldump [OPTIONS] --all-database [OPTIONS]
</code></pre>
<div><span>1</span><br></div></div><h3 id="_2-2-常用参数"> 2.2 常用参数</h3>
<div><pre><code>-u，--user = name    #  指定备份时所使用的数据库账号
-p. --password [=name]    # 指定账号的密码
--single-transaction  # 使用此参数会在备份前先执行start transaction命令启动一个事务，以此来获得数据库备份时的数据的一致性，由于是通过事务保证数据的一致性，所以此参数只对Innodb存储引擎有效；当使用此参数进行备份时，要确保没有任何DDL语句在执行，因为Innodb的数据一致性的隔离级别并不能隔离DDL操作

-l, --lock-tables  # 如果没有使用非事务存储引擎，使用此参数保证备份时数据的一致性，在备份时会依次锁住每个数据库下的所有表，一般用于MyISAM存储引擎的备份，使用了此参数，在数据库备份时，只能进行读操作，由于此参数是锁住一个数据库下的所有表，备份时可以保证一个数据库下的所有表的数据一致性，但不能保证整个Mysql实例下的所有数据库的所有表的数据一致性，这也是为什么推荐使用Innodb引擎的一个原因

lock-tables 与 single-transaction 参数是互斥的，不能同时使用，所以数据库中如果混合使用了Innodb表和MyISAM表就只能使用lock-tables来进行备份了

-x, --lock-all-tables  # 此参数可以对整个Mysql实例下的所有数据库进行加锁，可以避免lock-tables不能保证整个Mysql实例下的所有数据库的所有表的数据一致性的问题，备份时同样会将数据库变为只读的状态

--master-data = [1/2]    # 无论是时间恢复还是新建slave实例都要用到这个参数，此参数有两个可选值，当值为1时，备份中只记录change_master语句，当值为2时，change_master语句会以注释的形式出现在备份文件中；默认值为1，且当使用了此参数时会忽略lock-tables参数，在备份时如果使用了此参数，但是没有使用single-transaction参数，则会自动使用lock-all-tables参数

如果我们要备份的数据库中包含了存储过程，触发器，数据库调度事件时，要备份这些数据库对象时，必须指定以下参数才能对相应数据库进行备份

-R, --routines     # 指定要备份的数据库中存在的的存储过程
--triggers     # 指定要备份的数据库中存在的的触发器
-E,--events      # 指定要备份的数据库中存在的的调度事件

除了以上参数，还有一些参数在备份时也会用到

--hex-blob    # 因为mysqldump备份导出的是文本文件，如果导出的数据中含有以上类型，在文本格式下，有些字符是不可见的，如果使用了此参数使，将会对数据库中所存在binary、varbinary、blob类型的数据以16进制的形式保存，就不会出现有些字符不可见的情况了
--tab =path    # 使用了此参数会在指定的路径下对数据库的每个表生成两个文件，一个文件用于存储表结构，另一个用于存储表中的数据
-w, --where = &#39;过滤条件&#39;    # 导出指定条件的数据（只支持单表数据条件导出）


 备份账号所需要的权限 ： SELECT, RELOAD, LOCK TABLES, REPLICATION CLIENT, SHOW VIEW, PROCESS
如果使用--tab参数则还需要：FILE权限
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="_2-3-演示"> 2.3 演示</h3>
<h4 id="_2-3-1-创建备份用户"> 2.3.1 创建备份用户</h4>
<div><pre><code>create user &#39;backup&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;
</code></pre>
<div><span>1</span><br></div></div><h4 id="_2-3-2-赋予用户备份权限"> 2.3.2 赋予用户备份权限</h4>
<div><pre><code>grant select,reload,lock tables,replication client,show view,event,process on *.*  to &#39;backup&#39;@&#39;localhost&#39;;
</code></pre>
<div><span>1</span><br></div></div><h4 id="_2-3-3-使用mysqldump进行全量备份"> 2.3.3 使用mysqldump进行全量备份</h4>
<h5 id="_2-3-3-1-备份某个数据库"> 2.3.3.1 备份某个数据库</h5>
<div><pre><code>[root@localhost db_backup]# mysqldump -ubackup -p --master-data=2 --single-transaction --routines --triggers --events mc_orderdb &gt; mc_orderdb.sql
</code></pre>
<div><span>1</span><br></div></div><h6 id="如果遇到以下问题"> 如果遇到以下问题</h6>
<div><pre><code>mysqldump: Error: Binlogging on server not active
</code></pre>
<div><span>1</span><br></div></div><p>MySQL中二进制日志功能默认是关闭，去/etc/my.cnf 文件中加入下面配置，开启log_bin(数据库的操作日志)功能，然后重启mysql即可解决问题</p>
<div><pre><code>log_bin=mysql-bin
</code></pre>
<div><span>1</span><br></div></div><p>之后使用 “systemctl start mysql” 重启服务器，报错</p>
<div><pre><code>Job for mysql.service failed because the control process exited with error code. See &quot;systemctl status mysql.service&quot; and &quot;journalctl -xe&quot; for details.
</code></pre>
<div><span>1</span><br></div></div><h6 id="解决方法"> 解决方法：</h6>
<p>在设置 log-bin 的时候同时需要设置 server-id 变量，即在配置文件中添加：</p>
<div><pre><code>[mysqld]  
log-bin=mysql  
server-id=1  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后再次重启即可</p>
<h6 id="补充知识"> 补充知识</h6>
<div><pre><code>装mysql,运行一段时间后，在mysql目录下出现一堆类似mysql-bin.000***，从mysql-bin.000001开始一直排列下来，而且占用了大量硬盘空间，高达几十个G. 对于这些超大空间占用量的文件我们应该怎么办呢?

那么mysql数据库文件夹中的mysql-bin.00001是什么文件？
mysql-bin.000001、mysql-bin.000002等文件是数据库的操作日志，例如UPDATE一个表，或者DELETE一些数据，即使该语句没有匹配的数据，这个命令也会存储到日志文件中，还包括每个语句执行的时间，也会记录进去的。

这些形如mysql-bin.00001的文件主要是用来做什么的呢?
1：数据恢复
如果你的数据库出问题了，而你之前有过备份，那么可以看日志文件，找出是哪个命令导致你的数据库出问题了，想办法挽回损失。

2：主从服务器之间同步数据 
主服务器上所有的操作都在记录日志中，从服务器可以根据该日志来进行，以确保两个同步。

如果不想要这些文件应该怎么做呢?
1：只有一个mysql服务器，那么可以简单的注释掉这个选项就行了。
vi /etc/my.cnf把里面的 log-bin 这一行注释掉，重启mysql服务即可。

2：如果你的环境是主从服务器，那么就需要做以下操作了。 
A：在每个从属服务器上，使用SHOW SLAVE STATUS来检查它正在读取哪个日志。
B：使用SHOW MASTER LOGS获得主服务器上的一系列日志。
C：在所有的从属服务器中判定最早的日志，这个是目标日志，如果所有的从属服务器是更新的，就是清单上的最后一个日志。
D：清理所有的日志，但是不包括目标日志，因为从服务器还要跟它同步。

简单地说,这些MySQL目录下的形如mysql-bin.000***的文件时MySQL的事务日志。

删除复制服务器已经拿走的binlog是安全的，一般来说网络状况好的时候，保留最新的那一个足以。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>再次执行之前的备份命令，即可成功被封mc_orderdb数据库下的所有表，我们可以查询一下备份的SQL文件中是否包含所有表</p>
<div><pre><code>[root@localhost db_backup]# grep &quot;CREATE TABLE&quot; mc_orderdb.sql
CREATE TABLE `order_cart` (
CREATE TABLE `order_customer_addr` (
CREATE TABLE `order_detail` (
CREATE TABLE `order_master` (
CREATE TABLE `region_info` (
CREATE TABLE `shipping_info` (
CREATE TABLE `warehouse_info` (
CREATE TABLE `warehouse_proudct` (
[root@localhost db_backup]# 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>通过上面结果可以看出我们的几个表都在其中</p>
<h5 id="_2-3-3-2-备份某个数据库下的某个表"> 2.3.3.2 备份某个数据库下的某个表</h5>
<div><pre><code>[root@localhost db_backup]#  mysqldump -ubackup -p --master-data=2 --single-transaction --routines --triggers --events mc_orderdb order_master &gt; order_master.sql
Enter password: 
[root@localhost db_backup]# ls
mc_orderdb.sql  order_master.sql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h5 id="_2-3-3-3-备份mysql实例下的所有数据库"> 2.3.3.3 备份MySQL实例下的所有数据库</h5>
<div><pre><code>[root@localhost db_backup]#  mysqldump -ubackup -p --master-data=1 --single-transaction --routines --triggers --events  --all-databases &gt; mc.sql
Enter password: 
[root@localhost db_backup]# ls
mc_orderdb.sql  mc.sql  order_master.sql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>由于master-data的值设置为1，change master命令并没有被注释掉，如果我们使用这个命令进行恢复，change master命令就会被执行，在一些情况下可能会造成一些错误，所以建议使用时最好还是设置为2</p>
<p>可以通过下面的命令查看，备份文件中包含哪些数据库</p>
<div><pre><code>[root@localhost db_backup]# grep &quot;Current Database&quot; mc.sql
-- Current Database: `mc_orderdb`
-- Current Database: `mc_productdb`
-- Current Database: `mc_userdb`
-- Current Database: `mysql`
[root@localhost db_backup]# 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="_2-3-4-使用-tab参数指定备份文件的位置"> 2.3.4 使用-tab参数指定备份文件的位置</h4>
<p>首先在/tmp 目录下建立一个mc_orderdb目录用来存放指定的备份文件，之所以使用在此目录下建立目录，是因为使用--tab参数时，用户必须对目标目录有可写权限，而tmp目录对任何用户都有可写权限</p>
<div><pre><code>[root@localhost db_backup]#  mkdir -p /tmp/mc_orderdb
</code></pre>
<div><span>1</span><br></div></div><p>现在我们可以使用--tab参数指定备份路径</p>
<div><pre><code>[root@localhost db_backup]# mysqldump -ubackup -p --master-data=2 --single-transaction --routines --triggers --events --tab=&quot;/tmp/mc_orderdb&quot; mc_orderdb 
Enter password: 

--
-- Position to start replication or point-in-time recovery from
--

-- CHANGE MASTER TO MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;, MASTER_LOG_POS=154;
mysqldump: Got error: 1045: Access denied for user &#39;backup&#39;@&#39;localhost&#39; (using password: YES) when executing &#39;SELECT INTO OUTFILE&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以发现，报错了，其实我们在这之前还缺少一步，由于用户需要有写文件的权限，所以我们还需要对备份用户赋予file权限</p>
<div><pre><code>mysql&gt; grant file on *.*  to &#39;backup&#39;@&#39;localhost&#39;;
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>我们再次执行上面的备份命令</p>
<div><pre><code>[root@localhost db_backup]# mysqldump -ubackup -p --master-data=2 --single-transaction --routines --triggers --events --tab=&quot;/tmp/mc_orderdb&quot; mc_orderdb 
Enter password: 

--
-- Position to start replication or point-in-time recovery from
--

-- CHANGE MASTER TO MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;, MASTER_LOG_POS=347;
mysqldump: Got error: 1290: The MySQL server is running with the --secure-file-priv option so it cannot execute this statement when executing &#39;SELECT INTO OUTFILE&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以很清楚地从提示看到是因为mysql服务启用了–secure-file-priv，所以才无法执行。
那么–secure-file-priv又是什么呢，应该如何解决才能是它可以备份呢？
--secure-file-priv=name ：
Limit LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE() to files within specified directory</p>
<p>可以看到secure-file-priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。</p>
<p>当secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出</p>
<p>当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下</p>
<p>当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制</p>
<p>查看数据库当前该参数的值</p>
<div><pre><code>mysql&gt; show global variables like &#39;%secure%&#39;; 
+--------------------------+-----------------------+
| Variable_name            | Value                 |
+--------------------------+-----------------------+
| require_secure_transport | OFF                   |
| secure_auth              | ON                    |
| secure_file_priv         | /var/lib/mysql-files/ |
+--------------------------+-----------------------+
3 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>清楚地看到secure_file_priv 的值是NULL，说明此时限制导入导出的
所以应该改变该参数
可是查看了mysql.cnf中居然没有对这个参数进行设定，就说明这个参数默认便是null
所以再mysql.cnf中的[mysqld]加入secure_file_priv =</p>
<div><pre><code>[mysqld]
#
# Remove leading # and set to the amount of RAM for the most important data
# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.
# innodb_buffer_pool_size = 128M
#
# Remove leading # to turn on a very important data integrity option: logging
# changes to the binary log between backups.
# log_bin
#
# Remove leading # to set options mainly useful for reporting servers.
# The server defaults are faster for transactions and fast SELECTs.
# Adjust sizes as needed, experiment to find the optimal values.
# join_buffer_size = 128M
# sort_buffer_size = 2M
# read_rnd_buffer_size = 2M
datadir=/home/mysql/data    # mysql数据存放的目录
socket=/var/lib/mysql/mysql.sock

# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0
log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid

log_bin=mysql-bin
server-id=1  
secure_file_priv =
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>再重启mysql服务</p>
<div><pre><code>[root@localhost tmp]# systemctl restart mysqld
</code></pre>
<div><span>1</span><br></div></div><p>然后再查一下此时参数的值</p>
<div><pre><code>mysql&gt; show global variables like &#39;%secure%&#39;;
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| require_secure_transport | OFF   |
| secure_auth              | ON    |
| secure_file_priv         |       |
+--------------------------+-------+
3 rows in set (0.01 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>已经是我们要的结果 ，现在我们再次执行备份命令</p>
<div><pre><code>[root@localhost tmp]# mysqldump -ubackup -p --master-data=2 --single-transaction --routines --triggers --events --tab=&quot;/tmp/mc_orderdb&quot; mc_orderdb 
Enter password: 

--
-- Position to start replication or point-in-time recovery from
--

-- CHANGE MASTER TO MASTER_LOG_FILE=&#39;mysql-bin.000002&#39;, MASTER_LOG_POS=154;
mysqldump: Got error: 1: Can&#39;t create/write to file &#39;/tmp/mc_orderdb/order_cart.txt&#39; (Errcode: 13 - Permission denied) when executing &#39;SELECT INTO OUTFILE&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>结果还是权限被拒绝，无法写入，我们可以查询一下目录mc_orderdb的权限，</p>
<div><pre><code>[root@localhost tmp]# ls -lh mc_orderdb/
total 4.0K
-rw-r--r-- 1 root root 1.9K Jan 10 10:51 order_cart.sql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以发现，是root用户建立的目录，我们需要修改其所属用户为mysql用户，然后再次执行备份命令</p>
<div><pre><code>[root@localhost tmp]#  chown mysql:mysql  mc_orderdb
[root@localhost tmp]# mysqldump -ubackup -p --master-data=2 --single-transaction --routines --triggers --events --tab=&quot;/tmp/mc_orderdb&quot; mc_orderdb 
Enter password: 

--
-- Position to start replication or point-in-time recovery from
--

-- CHANGE MASTER TO MASTER_LOG_FILE=&#39;mysql-bin.000002&#39;, MASTER_LOG_POS=154;

--
-- Dumping events for database &#39;mc_orderdb&#39;
--

--
-- Dumping routines for database &#39;mc_orderdb&#39;
--
[root@localhost tmp]# 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>可以发现，修改成功后即可备份成功</p>
<p>进入该目录下会发现mc_orderdb数据库下的每个表都有两种文件，一种.sql结尾记录是表结构，一种是.txt结尾的表数据</p>
<div><pre><code>[root@localhost tmp]# cd mc_orderdb/
[root@localhost mc_orderdb]# ls
order_cart.sql  order_customer_addr.sql  order_detail.sql  order_master.sql  region_info.sql  shipping_info.sql  warehouse_info.sql  warehouse_proudct.sql
order_cart.txt  order_customer_addr.txt  order_detail.txt  order_master.txt  region_info.txt  shipping_info.txt  warehouse_info.txt  warehouse_proudct.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="_2-3-5-mysqldump如何使用全备where参数"> 2.3.5 mysqldump如何使用全备where参数</h4>
<p><strong>使用场景</strong></p>
<p>假设我们要对订单id为1000到1050的主表进行修改，修改之前，我们需要先对数据进行备份，这里我们就可以使用where参数来完成此需求</p>
<p><strong>执行命令进行备份</strong></p>
<div><pre><code>[root@localhost db_backup]# mysqldump -ubackup -p --master-data=2 --single-transaction  --where &quot;order_id&gt;1000 and order_id&lt;1050&quot; mc_orderdb  order_master &gt; order_master_1000_1050.sql
Enter password: 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>查看备份文件可以发现，订单id是从1001开始的</p>
<h3 id="_2-4-定义备份脚本"> 2.4 定义备份脚本</h3>
<p>在日程工作中我们不可能一直手工备份，所以我们需要将备份进行脚本话，然后使用计划任务去执行脚本</p>
<h4 id="_2-4-1-脚本文件"> 2.4.1 脚本文件</h4>
<div><pre><code>#!/bin/bash
###############Basic parameters##########################
DAY=`date +%Y%m%d`    # 记录发生备份的当前日期
Environment=$(/sbin/ifconfig | grep &quot;inet&quot; | head -1 |grep -v &quot;127.0.0.1&quot; | awk &#39;{print $2;}&#39; )    # 当前主机的IP
USER=&quot;backup&quot;
PASSWD=&quot;123456&quot;
HostPort=&quot;3306&quot;
MYSQLBASE=&quot;/home/mysql/&quot;
DATADIR=&quot;/home/db_backup/${DAY}&quot;    # 备份存放的目录（/home/db_backup目录下的以日期命名的子目录中）
MYSQL=`/usr/bin/which mysql`    # 定义mysql命令的目录
MYSQLDUMP=`/usr/bin/which mysqldump`    # 定义mysqldump命令的目录
mkdir -p ${DATADIR}    # 创建存储目录

# 定义备份函数，使用到上面定义的变量

Dump(){
 ${MYSQLDUMP} --master-data=2 --single-transaction  --routines --triggers --events -u${USER} -p${PASSWD} -P${HostPort} ${database}  &gt; ${DATADIR}/${Environment}-${database}.sql
 cd ${DATADIR}
 gzip ${Environment}-${database}.sql    # 对文件进行了压缩
}

# 利用for循环对当前服务器下的每一个数据库（排除了一些系统视图所在的数据库）分别来调用上面的Dump函数来进行备份

for db in `echo &quot;SELECT schema_name FROM information_schema.schemata where schema_name not in (&#39;information_schema&#39;,&#39;sys&#39;,&#39;performance_schema&#39;)&quot; | ${MYSQL} -u${USER} -p${PASSWD} --skip-column-names`
do
   database=${db}
   Dump
done
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h4 id="_2-4-2-执行脚本文件"> 2.4.2 执行脚本文件</h4>
<div><pre><code>[root@localhost home]# bash backup.sh 
mysql: [Warning] Using a password on the command line interface can be insecure.
mysqldump: [Warning] Using a password on the command line interface can be insecure.
mysqldump: [Warning] Using a password on the command line interface can be insecure.
mysqldump: [Warning] Using a password on the command line interface can be insecure.
mysqldump: [Warning] Using a password on the command line interface can be insecure.
[root@localhost home]# cd db_backup/
[root@localhost db_backup]# ls
20190110  mc_orderdb.sql  mc.sql  order_master_1000_1050.sql  order_master.sql
[root@localhost db_backup]# cd 20190110/
[root@localhost 20190110]# ls
172.17.0.1-mc_orderdb.sql.gz  172.17.0.1-mc_productdb.sql.gz  172.17.0.1-mc_userdb.sql.gz  172.17.0.1-mysql.sql.gz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可以看到结果已备份，可以使用crontab命令定时执行此脚本</p>
<h2 id="_3-如何恢复mysqldump备份的数据库"> 3 如何恢复mysqldump备份的数据库</h2>
<h3 id="_3-1-方法一"> 3.1 方法一</h3>
<div><pre><code>mysql -u -p dbname &lt; backup.sql
</code></pre>
<div><span>1</span><br></div></div><h3 id="_3-2-方法二"> 3.2 方法二</h3>
<div><pre><code>mysql&gt;  source /tmp/backup.sql
</code></pre>
<div><span>1</span><br></div></div><p>使用mysqldump备份时，恢复的速度完全取决于MySQL实例执行SQL的速度和服务器的IO性能，并且恢复过程是单线程的，所以对于非常大的数据集来说，要恢复的话可能需要很长的时间</p>
<blockquote>
<p>备份恢复时，要先创建数据库</p>
</blockquote>
<h3 id="_3-3-演示"> 3.3 演示：</h3>
<p>把刚才的全备数据恢复到bak数据库中</p>
<p>创建bak_orderdb数据库</p>
<div><pre><code>[root@localhost db_backup]# mysql -uroot -p -e&quot;create database bak_orderdb&quot;
Enter password: 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>将mc_orderdb备份的数据恢复到bak数据库中</p>
<div><pre><code>[root@localhost db_backup]#  mysql -uroot -p bak_orderdb &lt; mc_orderdb.sql
Enter password: 
[root@localhost db_backup]# 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>检验恢复结果的正确性</p>
<div><pre><code>mysql&gt; SELECT COUNT(*) FROM mc_orderdb.order_master;
+----------+
| COUNT(*) |
+----------+
|    10010 |
+----------+
1 row in set (0.00 sec)

mysql&gt; SELECT COUNT(*) FROM bak_orderdb.order_master;
+----------+
| COUNT(*) |
+----------+
|    10010 |
+----------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="_3-3-1-模拟误操作并恢复数据"> 3.3.1 模拟误操作并恢复数据</h4>
<p>假设我们现在不小心删除了mc_orderdb下的order_master中的10条数据，我们现在需要通过刚刚恢复的备份数据库把这10条数据恢复回来</p>
<div><pre><code>mysql&gt; DELETE FROM mc_orderdb.order_master LIMIT 10;
Query OK, 10 rows affected (0.01 sec)

mysql&gt;  SELECT COUNT(*) FROM mc_orderdb.order_master;
+----------+
| COUNT(*) |
+----------+
|    10000 |
+----------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>首先查出被误删的数据
<code>SELECT a.* FROM bak_orderdb.order_master a LEFT JOIN mc_orderdb.order_master b ON a.order_id=b.order_id WHERE b.order_id IS NULL;</code>
然后执行insert语句将查出的数据插入回去</p>
<p>完整语句为</p>
<div><pre><code>INSERT INTO mc_orderdb.order_master(
order_id,order_sn,customer_id,shipping_user,province,city,district,address,
payment_method,order_money,district_money,shipping_money,payment_money,
shipping_comp_name,shipping_sn,create_time,shipping_time,pay_time,receive_time,
order_status,order_point,invoice_title,modified_time)
SELECT a.* FROM bak_orderdb.order_master a 
LEFT JOIN mc_orderdb.order_master b ON a.order_id=b.order_id
WHERE b.order_id IS NULL;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>执行结果：</p>
<div><pre><code>mysql&gt; INSERT INTO mc_orderdb.order_master(
    -&gt; order_id,order_sn,customer_id,shipping_user,province,city,district,address,
    -&gt; payment_method,order_money,district_money,shipping_money,payment_money,
    -&gt; shipping_comp_name,shipping_sn,create_time,shipping_time,pay_time,receive_time,
    -&gt; order_status,order_point,invoice_title,modified_time)
    -&gt; SELECT a.* FROM bak_orderdb.order_master a 
    -&gt; LEFT JOIN mc_orderdb.order_master b ON a.order_id=b.order_id
    -&gt; WHERE b.order_id IS NULL;
Query OK, 10 rows affected (0.03 sec)
Records: 10  Duplicates: 0  Warnings: 0

mysql&gt; SELECT COUNT(*) FROM mc_orderdb.order_master;
+----------+
| COUNT(*) |
+----------+
|    10010 |
+----------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>对于一些静态型数据我们可以这样进行，但是对于一些时刻有数据在往表里写的数据还原，就不能使用这种方式了</p>
<p>对于生产环境中，时刻有数据写入的表如何进行数据恢复呢？</p>
<h4 id="_3-3-2-mysqldump单表备份恢复-使用了-tab参数备份的结果集"> 3.3.2 mysqldump单表备份恢复（使用了--tab参数备份的结果集）</h4>
<p>需要进入mysql客户端中</p>
<p>先恢复表结构</p>
<div><pre><code>mysql&gt;  source /tmp/mc_orderdb/region_info.sql;
</code></pre>
<div><span>1</span><br></div></div><p>再导入数据</p>
<div><pre><code>mysql&gt; load data infile &#39;/tmp/mc_orderdb/region_info.txt&#39; info table region_info;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_3-4-如何进行指定时间点的恢复"> 3.4 如何进行指定时间点的恢复</h3>
<p>进行某一时间点的数据恢复，恢复到误操作的时间</p>
<h4 id="_3-4-1-先决条件"> 3.4.1 先决条件</h4>
<p>具有指定时间点前的mysqldump的全备
具有全备到指定时间点的mysql二进制日志</p>
<h4 id="_3-4-2-演示"> 3.4.2 演示</h4>
<p>首先我们需要有个数据库的全备，此处我们对mc_orderdb 数据库进行全备</p>
<div><pre><code>[root@localhost db_backup]# mysqldump -ubackup -p --master-data=2 --single-transaction --routines --triggers --events mc_orderdb &gt; mc_orderdb.sql
</code></pre>
<div><span>1</span><br></div></div><p>然后我们模拟一下生产环境中对数据库的操作，这样才能看到时间点恢复的效果</p>
<p>我们到mc_orderdb数据库中新建一个统计表 t, uid列是用户id,cnt 是用户的总消费金额，将统计结果插入表t中后，模拟误操作，删除表t中的100行数据</p>
<div><pre><code>mysql&gt; use mc_orderdb
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; create table t(id int auto_increment not null,uid int,cnt decimal(8,2),primary key (id));
Query OK, 0 rows affected (0.02 sec)

mysql&gt; insert into t(uid,cnt) select customer_id,sum(order_money) from order_master group by customer_id;
Query OK, 6314 rows affected (0.05 sec)
Records: 6314  Duplicates: 0  Warnings: 0

mysql&gt; select count(*) from t;
+----------+
| count(*) |
+----------+
|     6314 |
+----------+
1 row in set (0.00 sec)

mysql&gt; delete from t limit 100;
Query OK, 100 rows affected (0.01 sec)

mysql&gt; select count(*) from t;
+----------+
| count(*) |
+----------+
|     6214 |
+----------+
1 row in set (0.01 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>先恢复一个最近的全备，进行全量数据恢复</p>
<div><pre><code>[root@localhost db_backup]# mysql -uroot -p mc_orderdb &lt; mc_orderdb.sql
</code></pre>
<div><span>1</span><br></div></div><p>然后查看mc_orderdb.sql文件中change master命令中</p>
<p>在进行这个全备时Mysql二进制日志的文件名（MASTER_LOG_FILE），以及时间点（MASTER_LOG_POS）</p>
<div><pre><code>CHANGE MASTER TO MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;, MASTER_LOG_POS=154;
</code></pre>
<div><span>1</span><br></div></div><p>此处文件名为mysql-bin.000001，日志时间点为154;</p>
<p>下面我们要恢复这个时间点（154）之后到第一次删除数据之前的数据</p>
<p>要找到这个时间点（154）之后到第一次删除数据之前的数据</p>
<p>查看二进制日志，进行分析</p>
<div><pre><code>[root@localhost db_backup]# cd /home/mysql
[root@localhost mysql]# mysqlbinlog --base64-output=decode-rows -vv --start-position=154 --database=mc_orderdb mysql-bin.000001| grep -B3 DELETE | more
#190110 13:44:54 server id 1  end_log_pos 83285 CRC32 0xf679d195    Table_map: `mc_orderdb`.`t` mapped to number 119
# at 83285
#190110 13:44:54 server id 1  end_log_pos 84620 CRC32 0xa3408e6c    Delete_rows: table id 119 flags: STMT_END_F
### DELETE FROM `mc_orderdb`.`t`
--
###   @1=1 /* INT meta=0 nullable=0 is_null=0 */
###   @2=1 /* INT meta=0 nullable=1 is_null=0 */
###   @3=1042.34 /* DECIMAL(8,2) meta=2050 nullable=1 is_null=0 */
### DELETE FROM `mc_orderdb`.`t`
--
###   @1=2 /* INT meta=0 nullable=0 is_null=0 */
###   @2=3 /* INT meta=0 nullable=1 is_null=0 */
###   @3=803.37 /* DECIMAL(8,2) meta=2050 nullable=1 is_null=0 */

...省略
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>从中可以看到刚刚的二进制日志中的第一个DELETE，在它之前的日志结束点为84620</p>
<p>所以我们需要恢复的是154 到84620 之间，且数据库为mc_orderdb ，日志所在文件名 为mysql-bin.000001的数据</p>
<p>我们通过mysqlbinlog 将这些数据导出来</p>
<div><pre><code>[root@localhost mysql]# mysqlbinlog --start-position=154 --stop-position=84620 --database=mc_orderdb mysql-bin.000001 &gt; mc_order_diff.sql
</code></pre>
<div><span>1</span><br></div></div><p>将数据导入恢复</p>
<div><pre><code>[root@localhost mysql]# mysql -uroot -p mc_orderdb &lt; mc_order_diff.sql
</code></pre>
<div><span>1</span><br></div></div><h2 id="_4-实时二进制日志备份"> 4 实时二进制日志备份</h2>
<p>Mysql5.6版本之后，可以实时备份Binlog(二进制日志)</p>
<p>要使用这个功能，我们需要进行以下配置
首先新建一个用户，这个用户要有replication slave 权限</p>
<div><pre><code>mysql&gt;  grant replication slave on *.* to &#39;repl&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;
Query OK, 0 rows affected, 1 warning (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>建立一个存储备份的二进制日志文件的目录</p>
<div><pre><code>mkdir -p binlog_backup
</code></pre>
<div><span>1</span><br></div></div><p>最后在这个目录下，执行以下命令，就可以实时的进行二进制日志的备份了</p>
<div><pre><code>[root@localhost binlog_bak]# mysqlbinlog --raw --read-from-remote-server --stop-never --host localhost --port 3306 -u repl -p123456 mysql-bin.000001
mysqlbinlog: [Warning] Using a password on the command line interface can be insecure.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>raw：代表这个命令是输出的是raw格式的二进制日志
read-from-remote-server： 从mysql服务器上读取这个日志
stop-never：备份的这个进程会持续在后台运行
最后的是指定要备份的二进制文件的名称</p>
<blockquote>
<p>备份的二进制文件的名称，必须为最新的二进制备份文件</p>
</blockquote>
<p>此命令执行后这个终端会一直执行这个命令
现在打开另外一个终端，进入备份的目录进行查看</p>
<div><pre><code>[root@localhost mysql]# cd /home/binlog_bak/
[root@localhost binlog_bak]# ls
mysql-bin.000001
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到日志已经备份成功
进入mysql命令行，刷新日志</p>
<div><pre><code>mysql&gt; flush logs;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; show binary logs;
+------------------+-----------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000001 |   3560467 |
| mysql-bin.000002 |       154 |
+------------------+-----------+
2 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>现在有两个日志，我们再回到备份目录进行查看</p>
<div><pre><code>[root@localhost binlog_bak]# ls
mysql-bin.000001  mysql-bin.000002
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以看到最新的日志也已实时备份</p>
<h2 id="_5-xtrabackup"> 5 xtrabackup</h2>
<h3 id="_5-1-xtrabackup介绍"> 5.1 xtrabackup介绍</h3>
<p>xtrabackup 物理备份工具，用于在线备份innodb存储引擎的表</p>
<p>在所有表全是innodb存储引擎表的情况下：
xtrabackup 可以保证在备份过程中，不影响表的读写操作
在最初的时候，xtrabackup 本身只支持对innodb存储引擎表的备份，且只会备份数据文件，不会备份表的结构
innobackupex 是对xtrabackup 的插件，提供了备份表结构及其他配置信息的功能，并支持MyISAM表的备份，但也会锁表</p>
<p>因为在当前的mysql版本下，还有一些系统表使用的是MyISAM存储引擎，所以一般情况下使用的是innobackupex 脚本进行备份的</p>
<h3 id="_5-2-安装xtrabackup"> 5.2 安装xtrabackup</h3>
<p>下载地址：https://www.percona.com/downloads/XtraBackup/
可以在该网址下载源码包或者rpm包</p>
<div><pre><code>yum -y install libev
yum -y install perl-Digest-*
wget https://www.percona.com/downloads/Percona-XtraBackup-LATEST/Percona-XtraBackup-8.0.9/binary/redhat/7/x86_64/percona-xtrabackup-80-8.0.9-1.el7.x86_64.rpm
rpm -ivh percona-xtrabackup-80-8.0.9-1.el7.x86_64.rpm
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_5-3-利用innobackupex-进行全备"> 5.3 利用innobackupex 进行全备</h3>
<div><pre><code>innobackupex --user=backup --password=123456 --parallel=2 /home/db_backup/
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>[root@localhost home]# innobackupex --user=backup --password=123456 --parallel=2 /home/db_backup/
xtrabackup: recognized server arguments: --datadir=/home/mysql --log_bin=mysql-bin --server-id=1 --parallel=2 
xtrabackup: recognized client arguments: --datadir=home/mysql --log_bin=mysql-bin --server-id=1 --parallel=2 
190110 15:15:30 innobackupex: Starting the backup operation

IMPORTANT: Please check that the backup run completes successfully.
           At the end of a successful backup run innobackupex
           prints &quot;completed OK!&quot;.

... 省略

190110 15:15:37 [00] Writing /home/db_backup/2019-01-10_15-15-30/xtrabackup_info
190110 15:15:37 [00]        ...done
xtrabackup: Transaction log of lsn (79088947) to (79088956) was copied.
190110 15:15:37 completed OK!
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>当看到completed OK!代表备份已完成</p>
<p>和mysqldump单线程备份不同，我们可以通过parallel参数指定备份的线程数
/home/db_backup/ 是我们指定的备份文件的存储目录</p>
<p>xtrabackup 会已当前时间在目标目录中生成一个子目录用来存放当前的备份文件</p>
<p>我们进入目录中查看一下</p>
<div><pre><code>[root@localhost db_backup]# ls
20190110  2019-01-10_15-15-30  mc_orderdb.sql  mc.sql  order_master_1000_1050.sql  order_master.sql
[root@localhost db_backup]# cd 2019-01-10_15-15-30/
[root@localhost 2019-01-10_15-15-30]# ls
backup-my.cnf  ib_buffer_pool  mc_orderdb    mc_userdb  performance_schema  xtrabackup_binlog_info  xtrabackup_info
bak_orderdb    ibdata1         mc_productdb  mysql      sys                 xtrabackup_checkpoints  xtrabackup_logfile
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>
<p>xtrabackup_checkpoints ：备份类型（如完全或增量）、备份状态（如是否已经为prepared状态）和LSN(日志序列号)范围信息；</p>
<p>每个InnoDB页(通常为16k大小)都会包含一个日志序列号，即LSN。LSN是整个数据库系统的系统版本号，每个页面相关的LSN能够表明此页面最近是如何发生改变的。</p>
</li>
<li>
<p>xtrabackup_binlog_info： mysql服务器当前正在使用的二进制日志文件及至备份这一刻为止二进制日志事件的位置。</p>
</li>
<li>
<p>xtrabackup_info： xtrabackup工具在备份时记录的使用工具及数据库信息</p>
</li>
<li>
<p>backup-my.cnf —— 备份命令用到的配置选项信息；</p>
</li>
<li>
<p>xtrabackup_logfile  —— xtrabackup记录innodb事物日志的信息</p>
</li>
</ul>
<p>与原数据文件目录相比，少了ib_logfile0等日志文件</p>
<p>xtrabackup_binlog_info 比较重要，其中记录了备份的日志名和日志点，相当于mysqldump中设置master-data参数的作用</p>
<p>如果我们不想以时间戳的形式自动生成子目录，我们可以通过指定--no-timestamp参数来实现</p>
<div><pre><code>innobackupex --user=backup --password=123456 --parallel=2  /home/db_backup/2019-01-10 --no-timestamp
[root@localhost db_backup]#  innobackupex --user=backup --password=123456 --parallel=2  /home/db_backup/2019-01-10 --no-timestamp
[root@localhost db_backup]# ls
20190110  2019-01-10  2019-01-10_15-15-30  mc_orderdb.sql  mc.sql  order_master_1000_1050.sql  order_master.sql
[root@localhost db_backup]# cd 2019-01-10
[root@localhost 2019-01-10]# ls
backup-my.cnf  ib_buffer_pool  mc_orderdb    mc_userdb  performance_schema  xtrabackup_binlog_info  xtrabackup_info
bak_orderdb    ibdata1         mc_productdb  mysql      sys                 xtrabackup_checkpoints  xtrabackup_logfile
[root@localhost 2019-01-10]# 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="_5-4-利用innobackupex-进行全备的恢复"> 5.4 利用innobackupex 进行全备的恢复</h3>
<div><pre><code>innobackupex  --apply-log /path/to/BACKUP-DIR
mv /path/to/BACKUP-DIR /home/mysql/data
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>准备完全备份</strong></p>
<div><pre><code>     一般情况下，在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中可能会包含尚未提交的事务或已经提交但尚未同步至数据文件中的事务。因此，此时数据文件仍处于不一致状态。“准备”的主要作用正是通过回滚未提交的事务及同步已经提交的事务至数据文件也使得数据文件处于一致性状态。
</code></pre>
</div><p>innobakupex命令的--apply-log选项可用于实现上述功能。如下面的命令：</p>
<p>进行数据库恢复之前，我们必须把备份中产生的备份集 进行应用，此处我们使用的是备份文件的目录伪2019-01-10</p>
<div><pre><code>[root@localhost db_backup]# innobackupex --apply-log /home/db_backup/2019-01-10
[root@localhost db_backup]# cd 2019-01-10
[root@localhost 2019-01-10]# ls
backup-my.cnf   ib_logfile0  mc_productdb        sys                           xtrabackup_info
bak_orderdb     ib_logfile1  mc_userdb           xtrabackup_binlog_info        xtrabackup_logfile
ib_buffer_pool  ibtmp1       mysql               xtrabackup_binlog_pos_innodb  xtrabackup_master_key_id
ibdata1         mc_orderdb   performance_schema  xtrabackup_checkpoints
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以发现，使用了上面的命令后，备份集中多出了之前缺少的ib_logfile0等文件。</p>
<p>​         在实现“准备”的过程中，innobackupex通常还可以使用--use-memory选项来指定其可以使用的内存的大小，默认通常为100M。如果有足够的内存可用，可以多划分一些内存给prepare的过程，以提高其完成速度。</p>
<p>使用xtrabackup进行数据库恢复时，我们必须对数据库实例进行重启
先停用mysql服务</p>
<p>然后将原数据库文件所在的文件夹重命名为data_bak,然后将此时的 2019-01-10文件夹移动到data_bak所在的文件夹，并重命名为data，即覆盖了原来的文件</p>
<p>然后 chown -R mysql:mysql data
对文件夹修改所属用户</p>
<p>最后重启mysql服务即可</p>
<h3 id="_5-5-利用innobackupex-进行增量备份"> 5.5 利用innobackupex 进行增量备份</h3>
<div><pre><code>innobackupex --user=backup --password=123456 /home/db_backup    # 先进行全备

innobackupex --user=backup --password=123456 --incremental  /home/db_backup/  --incremental-basedir=/home/db_backup/2019-01-10/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>incremental ：表示我们要进行的是一个全备， 指定全备的目录
incremental-basedir ：指定增量备份所依赖的数据基础的备份目录，这个增量备份所依赖的上一个全备</p>
<h4 id="演示"> 演示</h4>
<p>先进行全备</p>
<div><pre><code>innobackupex --user=backup --password=123456 /home/db_backup  
</code></pre>
<div><span>1</span><br></div></div><p>在 /home/db_backup 目录下生产了一个新的全备子目录 2019-01-10_16-19-37</p>
<p>再依赖上个全量备份进行增量备份</p>
<div><pre><code>innobackupex --user=backup --password=123456 --incremental  /home/db_backup/  --incremental-basedir=/home/db_backup/2019-01-10_16-19-37/
</code></pre>
<div><span>1</span><br></div></div><p>此时在 /home/db_backup 目录下生产了一个增量备分的子目录2019-01-10_16-22-09
增量备份会把自上一个全备后的数据变更记录下来</p>
<p>然后再进行一次增量备份，此时的命令和前面基本相同，只是所基于的增量备份的数据目录要变成上次增量备份生成的目录</p>
<div><pre><code>innobackupex --user=backup --password=123456 --incremental  /home/db_backup/  --incremental-basedir=/home/db_backup/2019-01-10_16-22-09/
</code></pre>
<div><span>1</span><br></div></div><p>此时，第二次增量备份的生成的目录名为2019-01-10_16-24-09</p>
<h3 id="_5-6-利用innobackupex-进行增量恢复"> 5.6 利用innobackupex 进行增量恢复</h3>
<div><pre><code>innobackupex  --apply-log  --redo-only 全备目录
</code></pre>
<div><span>1</span><br></div></div><p>我们要循环的在多次增量备份中应用上面步骤</p>
<div><pre><code> innobackupex  --apply-log  --redo-only 全备目录  --incremental-dir=第一次增量目录
</code></pre>
<div><span>1</span><br></div></div><p>所有增量备份的都应有了上面的命令后，就可以像全备一样，在全备目录上再进行崩溃恢复的过程</p>
<div><pre><code>    innobackupex  --apply-log /path/to/BACKUP-DIR
    mv /path/to/BACKUP-DIR /home/mysql/data
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>最后和全备一样，要用全备目录替换mysql数据库目录</p>
<h4 id="演示-2"> 演示</h4>
<p>下面演示只恢复到第一次备份</p>
<div><pre><code>[root@localhost db_backup]#   innobackupex  --apply-log  --redo-only    /home/db_backup/2019-01-10_16-19-37

[root@localhost db_backup]#   innobackupex  --apply-log  --redo-only    /home/db_backup/2019-01-10_16-19-37  --incremental-basedir=/home/db_backup/2019-01-10_16-22-09

[root@localhost db_backup]#   innobackupex  --apply-log   /home/db_backup/2019-01-10_16-19-37 

[root@localhost db_backup]#  mv 2019-01-10_16-19-37  /home/mysql

[root@localhost db_backup]#  cd  /home/mysql

[root@localhost mysql]#  systemctl stop  mysqld

[root@localhost mysql]#  mv 2019-01-10_16-19-37 data

[root@localhost mysql]# chown -R mysql:mysql data

[root@localhost mysql]#  systemctl start mysqld
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="_5-7-备份压缩和流"> 5.7 备份压缩和流</h3>
<p>Stream模式下，Xtrabackup的STDOUT可以指定tar或者xbstream格式输出。 '
流允许，其他程序过滤备份输出，提供更大的灵活存储backup。
使用流特性，需要指--stream选项
$ innobackupex --stream=tar /tmp
innobackupex会用子程序启动xtrabackup --log-stream 定向到临时文件，然后使用tar把所有数据文件steam到STDOUT。<br>
当压缩启动，xtrabackup压缩所有输出数据，但是元数据和非innodb文件不能被压缩。现在唯一支持的压缩算法是quicklz。会生产qpress归档格式的文件。</p>
<h4 id="演示-3"> 演示</h4>
<p>使用tar备份</p>
<div><pre><code>innobackupex --user=root --password=123 --stream=tar /backup/ &gt; /backup/out.tar

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>使用tar备份到其他服务器：
依赖密钥传输数据</p>
<div><pre><code>innobackupex --user=root --password=123 --stream=tar ./ | ssh root@192.168.10.200 &quot;cat - &gt; /tmp/backup.tar&quot;
</code></pre>
<div><span>1</span><br></div></div><p>提取tar流，需要加i参数，否则容易数据丢失</p>
<div><pre><code>tar -xizf backup.tar
</code></pre>
<div><span>1</span><br></div></div><p>也可以压缩流：</p>
<div><pre><code>innobackupex --user=root --password=123 --socket=/tmp/mysql.sock --stream=tar ./ | gzip - &gt; /backup/back.tar.gz
</code></pre>
<div><span>1</span><br></div></div><p><em>xtrabckup还有部分备份和窄备份功能 略</em></p>
<blockquote>
<p>参考文章：</p>
<p>https://www.cnblogs.com/huchong/p/10238515.html#_label1</p>
<p>https://www.linuxidc.com/Linux/2019-01/156363.htm</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">14 MySQL bin-log日志清理</title>
    <id>https://clay-wangzhi.com/db/mysql/bin-log/</id>
    <link href="https://clay-wangzhi.com/db/mysql/bin-log/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_14-mysql-bin-log日志清理"> 14 MySQL bin-log日志清理</h1>
<h2 id="自动清理"> 自动清理</h2>
<h3 id="永久生效"> 永久生效</h3>
<p>需要重启mysql才能生效</p>
<p>修改<code>my.cnf</code>文件</p>
<p>添加下面一行</p>
<div><pre><code>expire_logs_days = 7
</code></pre>
<div><span>1</span><br></div></div><h3 id="临时生效"> 临时生效</h3>
<p>进入mysql，执行，下面的语句</p>
<div><pre><code>show variables like &#39;%expire_logs_days%&#39;;
set global expire_logs_days = 7;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="手动清理"> 手动清理</h2>
<p>进入mysql，查看binlog日志</p>
<div><pre><code>show binary logs;
</code></pre>
<div><span>1</span><br></div></div><p><strong>删除某个日志文件之前的所有日志文件</strong></p>
<div><pre><code>purge binary logs to &#39;mysql-bin.000035&#39;;
</code></pre>
<div><span>1</span><br></div></div><p><strong>清理2019-09-09 13:00:00前binlog日志</strong></p>
<div><pre><code>PURGE MASTER LOGS BEFORE &#39;2019-09-09 13:00:00&#39;;
</code></pre>
<div><span>1</span><br></div></div><p><strong>清除3天前的bin日志</strong></p>
<div><pre><code>PURGE MASTER LOGS BEFORE DATE_SUB(NOW( ), INTERVAL 3 DAY); 
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>注意，不要轻易手动去删除binlog，会导致binlog.index和真实存在的binlog不匹配，而导致expire_logs_day失效</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">3 数据库设计与查询语句</title>
    <id>https://clay-wangzhi.com/db/mysql/des-select/</id>
    <link href="https://clay-wangzhi.com/db/mysql/des-select/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_3-数据库设计与查询语句"> 3 数据库设计与查询语句</h1>
<h2 id="_1-数据库基本概念"> 1  数据库基本概念</h2>
<p>1、关系：两个表的公共字段</p>
<p>2、行：也称记录，也称实体</p>
<p>3、列：也称字段，也称属性</p>
<div><pre><code>就表结构而言，表分为行和列；
就表数据而言，分为记录和字段；
就面向对象而言，一个记录就是一个实体，一个字段就是一个属性。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>4、数据冗余：相同的数据存储在不同的地方</p>
<div><pre><code>脚下留心：
1、冗余只能减少，不能杜绝。
2、减少冗余的方法是分表
3、为减少数据查找的麻烦，允许数据有一定的冗余
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>5、数据完整性：正确性+准确性=数据完整性</p>
<div><pre><code>正确性：数据类型正确
准确性：数据范围要准确
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>思考：学生的年龄是整型，输入1000岁，正确性和准确性如何？</p>
<p>答：正确的，但不准确的</p>
<p>思考：年龄是整形的，收入了字符串，正确性和准确性如何？</p>
<p>答：不正确</p>
<h2 id="_2-实体和实体之间的关系"> 2  实体和实体之间的关系</h2>
<p>1、一对一</p>
<p>2、一对多 （多对一）</p>
<p>3、多对多 <img src="./images/1536975724695.png" alt="1536975724695" /></p>
<h3 id="_2-1-一对多-1-n"> 2.1 一对多 1：N</h3>
<p>1、主表中的一条记录对应从表中的多条记录。</p>
<p>2、一对多和多对一是一样的</p>
<p><img src="./images/1536976096582.png" alt="1536976096582" /></p>
<hr>
<p>如何实现一对多？</p>
<p>答：主键和非主键建关系</p>
<p>问题：说出几个一对多的关系？</p>
<p>答：班级表和学生表、      班主表和学生表</p>
<h3 id="_2-2-一对一-1-1"> 2.2 一对一（1:1）</h3>
<p>1、主表中的一条记录对应从表中的一条记录</p>
<p><img src="./images/1536976513236.png" alt="1536976513236" /></p>
<p>如何实现一对一？</p>
<p>主键和主键建关系就能实现一对一。</p>
<div><pre><code>思考：一对一两个表完全可以用一个表实现，为什么还要分成两个表？

答：在字段数量很多情况下，数据量也就很大，每次查询都需要检索大量数据，这样效率低下。我们可以将所有字段分成两个部分，“常用字段”和“不常用字段”，这样对大部分查询者来说效率提高了。【表的垂直分割】
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_2-3-多对多-n-m"> 2.3 多对多（N：M）</h3>
<p>主表中的一条记录对应从表中的多条记录，从表中的一条记录对应主表中的多条记录</p>
<p>班级和讲师的关系</p>
<p><img src="./images/1536977577667.png" alt="1536977577667" /></p>
<p>如何实现多对多？</p>
<p>答：建立第三张表来保存关系。</p>
<p>问题：说出几个多对多的关系？</p>
<p>1、科目表和学生表的关系		2、商品表和订单表         3、游戏目录表和玩家表</p>
<h2 id="_3-数据库设计的步骤"> 3 数据库设计的步骤</h2>
<p><img src="./images/1536977906540.png" alt="1536977906540" /></p>
<h3 id="_3-1-数据库设计具体步骤"> 3.1 数据库设计具体步骤</h3>
<p>1、     收集信息：与该系统有关人员进行交流、坐谈，充分理解数据库需要完成的任务</p>
<p>2、     标识对象（实体－Entity）标识数据库要管理的关键对象或实体</p>
<p>3、     标识每个实体的属性（Attribute）</p>
<p>4、     标识对象之间的关系（Relationship）</p>
<p>5、     将模型转换成数据库</p>
<p>6、     规范化</p>
<h3 id="_3-2-绘制e-r图"> 3.2 绘制E-R图</h3>
<p>E-R（Entity－Relationship）实体关系图</p>
<p>E-R图的语法</p>
<p><img src="./images/1536978470142.png" alt="1536978470142" /></p>
<p>绘制E-R图</p>
<p><img src="./images/1536978565499.png" alt="1536978565499" /></p>
<h3 id="_3-3-将e-r图转成表"> 3.3 将E-R图转成表</h3>
<p>1、     实体转成表，属性转成字段</p>
<p>2、     如果没有合适的字段做主键，给表添加一个自动增长列做主键。</p>
<h3 id="_3-4-例题"> 3.4 例题</h3>
<p>1、项目需求</p>
<div><pre><code>BBS论坛的基本功能：
用户注册和登录，后台数据库需要存放用户的注册信息和在线状态信息；
用户发贴，后台数据库需要存放贴子相关信息，如贴子内容、标题等；
用户可以对发帖进行回复；
论坛版块管理：后台数据库需要存放各个版块信息，如版主、版块名称、贴子数等；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>2、标识对象</p>
<div><pre><code>参与的对象有：用户、发的帖子、跟帖、板块
</code></pre>
</div><p>3、标识对象的属性</p>
<p><img src="./images/1536978271446.png" alt="1536978271446" /></p>
<p>4、建立关系，绘制E-R图</p>
<p><img src="./images/1536978734804.png" alt="1536978734804" /></p>
<p>5、将E-R图转出表结构</p>
<h2 id="_4-数据规范化"> 4 数据规范化</h2>
<p>Codd博士定义了6个范式来规范化数据库，范式由小到大来约束，范式越高冗余越小，但表的个数也越多。实验证明，三范式是性价比最高的。</p>
<h3 id="_4-1-第一范式-确保每列原子性"> 4.1 第一范式：确保每列原子性</h3>
<p>第一范式确保每个字段不可再分</p>
<p><img src="./images/1536979522448.png" alt="1536979522448" /></p>
<p>思考：如下表设计是否合理？</p>
<p><img src="./images/1536979672041.png" alt="1536979672041" /></p>
<p>不合理。不满足第一范式，上课时间可以再分</p>
<p><img src="./images/1536979718323.png" alt="1536979718323" /></p>
<p>思考：地址包含省、市、县、地区是否需要拆分？</p>
<p>答：如果仅仅起地址的作用，不需要统计，可以不拆分；如果有按地区统计的功能需要拆分。</p>
<p>在实际项目中，建议拆分。</p>
<h3 id="_4-2-第二范式-非键字段必须依赖于键字段"> 4.2 第二范式：非键字段必须依赖于键字段</h3>
<p>一个表只能描述一件事</p>
<p><img src="./images/1536980482113.png" alt="1536980482113" /></p>
<p>思考：如下表设计是否合理？</p>
<p><img src="./images/1536980574792.png" alt="1536980574792" /></p>
<h3 id="_4-3-第三范式-消除传递依赖"> 4.3 第三范式：消除传递依赖</h3>
<p>在所有的非键字段中，不能有传递依赖</p>
<p><img src="./images/1536981861980.png" alt="1536981861980" /></p>
<p>下列设计是否满足第三范式？</p>
<p><img src="./images/1536982061259.png" alt="1536982061259" /></p>
<p>不满足，因为语文和数学确定了，总分就确定了。</p>
<div><pre><code>多学一招：上面的设计不满足第三范式，但是高考分数表就是这样设计的，为什么？

答：高考分数峰值访问量非常大，这时候就是性能更重要。当性能和规范化冲突的时候，我们首选性能。这就是“反三范式”。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_4-4-数据库设计的例题"> 4.4 数据库设计的例题</h3>
<p>1、需求</p>
<div><pre><code>公司承担多个工程项目，每一项工程有：工程号、工程名称、施工人员等
公司有多名职工，每一名职工有：职工号、姓名、性别、职务（工程师、技术员）等
公司按照工时和小时工资率支付工资，小时工资率由职工的职务决定（例如，技术员的小时工资率与工程师不同）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>2、工资表</p>
<p><img src="./images/1536982976983.png" alt="1536982976983" /></p>
<p>3、将工资表转成数据库表</p>
<p><img src="./images/1536983011535.png" alt="1536983011535" /></p>
<p>4、这个表存在的问题</p>
<div><pre><code>A：新人入职需要虚拟一个项目

B：职务更改，小时工资率可能会忘记更改，造成数据不完整

C：有人离职，删除记录后，工程也没有了
</code></pre>
</div><p>5、规范化表</p>
<div><pre><code>第一步：这个表满足第一范式

第二步：这个表不是描述了一件事情
</code></pre>
</div><p><img src="./images/1536983332419.png" alt="1536983332419" /></p>
<div><pre><code>第三步：是否满足第三范式
</code></pre>
</div><p><img src="./images/1536983422611.png" alt="1536983422611" /></p>
<p>更改如下：</p>
<p><img src="./images/1536983406042.png" alt="1536983406042" /></p>
<h2 id="_5-查询语句"> 5 查询语句</h2>
<div><pre><code>语法：select [选项] 列名 [from 表名] [where 条件]  [group by 分组] [order by 排序][having 条件] [limit 限制]
</code></pre>
<div><span>1</span><br></div></div><h3 id="_5-1-字段表达式"> 5.1 字段表达式</h3>
<div><pre><code>mysql&gt; select &#39;锄禾日当午&#39;;
+------------+
| 锄禾日当午          |
+------------+
| 锄禾日当午          |
+------------+

mysql&gt; select 10*10;
+-------+
| 10*10 |
+-------+
|   100 |
+-------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>通过as给字段取别名</p>
<div><pre><code>mysql&gt;  select &#39;锄禾日当午&#39; as content;
+------------+
| content    |
+------------+
| 锄禾日当午          |
+------------+
1 row in set (0.00 sec)

mysql&gt; select 10*10 as result;
+--------+
| result |
+--------+
|    100 |
+--------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>多学一招：as可以省略</p>
<div><pre><code>mysql&gt; select 10*10  result;
+--------+
| result |
+--------+
|    100 |
+--------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_5-2-from子句"> 5.2 from子句</h3>
<p>from：来自，from后面跟的是数据源。数据源可以有多个。返回笛卡尔积。</p>
<p>插入测试表</p>
<div><pre><code>mysql&gt; create table t1(
    -&gt; id int,
    -&gt; name varchar(10)
    -&gt; );
Query OK, 0 rows affected (0.05 sec)

mysql&gt; create table t2(
    -&gt; field1 varchar(10),
    -&gt; field2 varchar(10)
    -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into t1 values (1,&#39;tom&#39;),(2,&#39;berry&#39;);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; insert into t2 values (&#39;333&#39;,&#39;333&#39;),(&#39;444&#39;,&#39;444&#39;);
Query OK, 2 rows affected (0.02 sec)
Records: 2  Duplicates: 0  Warnings: 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>测试多个数据源</p>
<div><pre><code>mysql&gt; select * from t1,t2;              # 返回笛卡尔积
+------+-------+--------+--------+
| id   | name  | field1 | field2 |
+------+-------+--------+--------+
|    1 | tom   | 333    | 333    |
|    2 | berry | 333    | 333    |
|    1 | tom   | 444    | 444    |
|    2 | berry | 444    | 444    |
+------+-------+--------+--------+
4 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="_5-3-dual表"> 5.3 dual表</h3>
<p>dual表是一个伪表。在有些特定情况下，没有具体的表的参与，但是为了保证select语句的完整又必须要一个表名，这时候就使用伪表。</p>
<div><pre><code>mysql&gt; select 10*10 as result from dual;  #dual表是用来保证select语句的完整性。
+--------+
| result |
+--------+
|    100 |
+--------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_5-4-where子句"> 5.4 where子句</h3>
<p>where后面跟的是条件，在数据源中进行筛选。返回条件为真记录</p>
<p>MySQL支持的运算符</p>
<ol>
<li><code>&gt;</code>	大于</li>
<li><code>&lt;</code>小于</li>
<li><code>&gt;=</code></li>
<li><code>&lt;=</code></li>
<li><code>=</code></li>
<li><code>!=</code></li>
<li>and    与</li>
<li>or      或</li>
<li>not   非</li>
</ol>
<div><pre><code>mysql&gt; select * from stu where stusex=&#39;男&#39;;		# 查找性别是男的记录
mysql&gt; select * from stu where stuage&gt;=20;		# 查找年龄不低于20的记录
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>思考：如下代码输出什么</p>
<div><pre><code>select * from stu where 1      # 返回所有数据库
select * from stu where 0		#返回空记录
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>思考：如何查找北京和上海的学生</p>
<div><pre><code>mysql&gt; select * from stu where stuaddress=&#39;上海&#39; or stuaddress=&#39;北京&#39;;
+--------+---------+--------+--------+---------+------------+------+------+
| stuNo  | stuName | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+---------+--------+--------+---------+------------+------+------+
| s25301 | 张秋丽        | 男       |     18 |       1 | 北京           |   80 | NULL |
| s25302 | 李文才       | 男       |     31 |       3 | 上海          |   77 |   76 |
| s25303 | 李斯文       | 女      |     22 |       2 | 北京           |   55 |   82 |
| s25320 | Tom     | 男       |     24 |       8 | 北京           |   65 |   67 |
+--------+---------+--------+--------+---------+------------+------+------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="_5-5-in-not-in"> 5.5  in | not in</h3>
<p>上面的查询上海和北京的学生的SQL可以通过in语句来实现</p>
<div><pre><code>mysql&gt; select * from stu where stuaddress in (&#39;北京&#39;,&#39;上海&#39;);
</code></pre>
<div><span>1</span><br></div></div><p>练习：</p>
<p>1、查找学号是s25301,s25302,s25303的学生</p>
<div><pre><code>mysql&gt; select * from stu where stuno in (&#39;s25301&#39;,&#39;s25302&#39;,&#39;s25303&#39;);
</code></pre>
<div><span>1</span><br></div></div><p>2、查找年龄是18,19,20的学生</p>
<div><pre><code>mysql&gt; select * from stu where stuage in(18,19,20);
</code></pre>
<div><span>1</span><br></div></div><p>3、查找不是北京和上海的学生</p>
<div><pre><code>mysql&gt; select * from stu where stuaddress not in (&#39;北京&#39;,&#39;上海&#39;);
</code></pre>
<div><span>1</span><br></div></div><h3 id="_5-6-between-and-not-between-and"> 5.6  between…and|not between…and</h3>
<p>查找某个范围的记录</p>
<p>1、查找年龄在18~20之间的学生</p>
<div><pre><code>mysql&gt; select * from stu where stuage&gt;=18 and stuage&lt;=20;   # 方法一

mysql&gt; select * from stu where stuage between 18 and 20;   # 方法二
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>2、查找年龄不在18~20之间的学生</p>
<div><pre><code>mysql&gt; select * from stu where stuage&lt;18 or stuage&gt;20;		#方法一

mysql&gt; select * from stu where not (stuage&gt;=18 and stuage&lt;=20);

mysql&gt; select * from stu where stuage not between 18 and 20;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_5-7-is-null-is-not-null"> 5.7 is null | is not null</h3>
<p>脚下留心：查询一个为空的字段不能用等于，必须用is null</p>
<p>查找缺考的学生</p>
<div><pre><code>mysql&gt; select * from stu where ch is null or math is null; # 查找缺考的人
+--------+----------+--------+--------+---------+------------+------+------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+----------+--------+--------+---------+------------+------+------+
| s25301 | 张秋丽         | 男       |     18 |       1 | 北京           |   80 | NULL |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           | NULL |   74 |
+--------+----------+--------+--------+---------+------------+------+------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>查找参加考试的学生</p>
<div><pre><code>mysql&gt; select * from stu where ch is not null and math is not null;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_5-8-聚合函数"> 5.8 聚合函数</h3>
<ol>
<li>
<p>sum()  	   求和</p>
</li>
<li>
<p>avg()          求平均值</p>
</li>
<li>
<p>max()        求最大值</p>
</li>
<li>
<p>min()          求最小值</p>
</li>
<li>
<p>count()      求记录数</p>
</li>
</ol>
<div><pre><code>#求语文总分、语文平均分、语文最高分、语文最低分、总人数

mysql&gt; select sum(ch) &#39;语文总分&#39;,avg(ch) &#39;语文平均分&#39;, max(ch) &#39;语文最高分&#39;,min(ch) &#39;语文最低分&#39;,count(*) &#39;总人数&#39; from stu;
+----------+------------+------------+------------+--------+
| 语文总分        | 语文平均分          | 语文最高分          | 语文最低分          | 总人数       |

+----------+------------+------------+------------+--------+
|      597 |    74.6250 |         88 |         55 |      9 |
+----------+------------+------------+------------+--------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="_5-9-通配符"> 5.9 通配符</h3>
<ol>
<li>
<p>_  [下划线]   表示任意一个字符</p>
</li>
<li>
<p>%  表示任意字符</p>
</li>
</ol>
<p>练习</p>
<p>1、满足“T_m”的有（A、C）</p>
<p>A：Tom         B：Toom       C：Tam         D：Tm     E：Tmo</p>
<p>2、满足“T_m_”的有（B、C  ）</p>
<p>A:Tmom   B:Tmmm  C:T1m2    D:Tmm     E:Tm</p>
<p>3、满足“张%”的是（A、B、C、D）</p>
<p>A:张三     B：张三丰     C：张牙舞爪      D：张      E：小张</p>
<p>4、满足“%诺基亚%”的是（A、B、C、D）</p>
<p>A：诺基亚2100   B：2100诺基亚   C：把我的诺基亚拿过来   D：诺基亚</p>
<h3 id="_5-10-模糊查询-like"> 5.10 模糊查询（like）</h3>
<div><pre><code># 查找姓张的同学
mysql&gt; select * from stu where stuname like &#39;张%&#39;;
+--------+---------+--------+--------+---------+------------+------+------+
| stuNo  | stuName | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+---------+--------+--------+---------+------------+------+------+
| s25301 | 张秋丽        | 男       |     18 |       1 | 北京           |   80 | NULL |
+--------+---------+--------+--------+---------+------------+------+------+
1 row in set (0.00 sec)
#例题
mysql&gt; select * from stu where stuname like &#39;T_m&#39;;
+--------+---------+--------+--------+---------+------------+------+------+
| stuNo  | stuName | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+---------+--------+--------+---------+------------+------+------+
| s25320 | Tom     | 男       |     24 |       8 | 北京           |   65 |   67 |
+--------+---------+--------+--------+---------+------------+------+------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_5-11-order-by排序"> 5.11 order by排序</h3>
<p>asc：升序【默认】</p>
<p>desc：降序</p>
<div><pre><code>mysql&gt; select * from stu order by ch desc;		# 语文成绩降序排列

mysql&gt; select * from stu order by math asc;     # 数学成绩升序排列

mysql&gt; select * from stu order by math;       # 默认升序排列
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>多列排序</p>
<div><pre><code>#年龄升序,成绩降序
mysql&gt; select *,(ch+math) as &#39;总分&#39; from stu order by stuage asc,(ch+math) desc;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>思考如下代码表示什么含义</p>
<div><pre><code>select * from stu order by stuage desc,ch desc;     #年龄降序，语文降序
select * from stu order by stuage desc,ch asc;		#年龄降序，语文升序
select * from stu order by stuage,ch desc;          #年龄升序、语文降序
select * from stu order by stuage,ch; 				#年龄升序、语文升序
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_5-12-group-by-【分组查询】"> 5.12 group by 【分组查询】</h3>
<p>将查询的结果分组，分组查询目的在于统计数据。</p>
<div><pre><code># 按性别分组，显示每组的平均年龄
mysql&gt; select avg(stuage) as &#39;年龄&#39;,stusex from stu group by stusex;
+---------+--------+
| 年龄        | stusex |
+---------+--------+
| 22.7500 | 女      |
| 25.4000 | 男       |
+---------+--------+
2 rows in set (0.00 sec)
# 按地区分组，每个地区的平均年龄
mysql&gt; select avg(stuage) as &#39;年龄&#39;,stuaddress from stu group by stuaddress;
+---------+------------+
| 年龄        | stuaddress |
+---------+------------+
| 31.0000 | 上海          |
| 21.3333 | 北京           |
| 27.0000 | 天津           |
| 23.0000 | 河北          |
| 23.0000 | 河南           |
+---------+------------+
5 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code>脚下留心：
1、如果是分组查询，查询字段必须是分组字段和聚合函数。
2、查询字段是普通字段，只取第一个值
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./images/1536999666442.png" alt="1536999666442" /></p>
<p>通过group_concat()函数将同一组的值连接起来显示</p>
<div><pre><code>mysql&gt; select group_concat(stuname),stusex from stu group by stusex;
+-------------------------------------+--------+
| group_concat(stuname)               | stusex |
+-------------------------------------+--------+
| 李斯文,诸葛丽丽,梅超风,Tabm                           | 女      |
| 张秋丽,李文才,欧阳俊雄,争青小子,Tom                          | 男       |
+-------------------------------------+--------+
2 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code>多学一招：【了解】
1、分组后的结果默认会按升序排列显示
2、也是可以使用desc实现分组后的降序
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./images/1536999889281.png" alt="1536999889281" /></p>
<p><img src="./images/1536999987356.png" alt="1536999987356" /></p>
<p>多列分组</p>
<div><pre><code>mysql&gt; select stuaddress,stusex,avg(stuage) from stu group by stuaddress,stusex;
+------------+--------+-------------+
| stuaddress | stusex | avg(stuage) |
+------------+--------+-------------+
| 上海          | 男       |     31.0000 |
| 北京           | 女      |     22.0000 |
| 北京           | 男       |     21.0000 |
| 天津           | 男       |     27.0000 |
| 河北          | 女      |     23.0000 |
| 河南           | 女      |     23.0000 |
+------------+--------+-------------+
6 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_5-13-having条件"> 5.13 having条件</h3>
<div><pre><code>思考：数据库中的表是一个二维表，返回的结果是一张二维表，既然能在数据库的二维表中进行查询，能否在结果集的二维表上继续进行查询？

答：可以，having条件就是在结果集上继续进行筛选。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例题</p>
<div><pre><code>mysql&gt; select * from stu where stusex=&#39;男&#39;;   # 从数据库中查找
+--------+----------+--------+--------+---------+------------+------+------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+----------+--------+--------+---------+------------+------+------+
| s25301 | 张秋丽         | 男       |     18 |       1 | 北京           |   80 | NULL |
| s25302 | 李文才        | 男       |     31 |       3 | 上海          |   77 |   76 |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           | NULL |   74 |
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           |   86 |   92 |
| s25320 | Tom      | 男       |     24 |       8 | 北京           |   65 |   67 |
+--------+----------+--------+--------+---------+------------+------+------+
5 rows in set (0.00 sec)

mysql&gt; select * from stu having stusex=&#39;男&#39;;   # 从结果集中查找
+--------+----------+--------+--------+---------+------------+------+------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+----------+--------+--------+---------+------------+------+------+
| s25301 | 张秋丽         | 男       |     18 |       1 | 北京           |   80 | NULL |
| s25302 | 李文才        | 男       |     31 |       3 | 上海          |   77 |   76 |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           | NULL |   74 |
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           |   86 |   92 |
| s25320 | Tom      | 男       |     24 |       8 | 北京           |   65 |   67 |
+--------+----------+--------+--------+---------+------------+------+------+
5 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>思考如下语句是否正确 <img src="./images/1537001246956.png" alt="1537001246956" /></p>
<p><img src="./images/1537001432304.png" alt="1537001432304" /></p>
<p>having和where的区别：</p>
<p>where是对原始数据进行筛选，having是对记录集进行筛选。</p>
<h3 id="_5-14-limit"> 5.14 limit</h3>
<p>语法：limit 起始位置，显示长度</p>
<div><pre><code>mysql&gt; select * from stu limit 0,2;    # 从0的位置开始，取两条数据
+--------+---------+--------+--------+---------+------------+------+------+
| stuNo  | stuName | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+---------+--------+--------+---------+------------+------+------+
| s25301 | 张秋丽        | 男       |     18 |       1 | 北京           |   80 | NULL |
| s25302 | 李文才       | 男       |     31 |       3 | 上海          |   77 |   76 |
+--------+---------+--------+--------+---------+------------+------+------+
2 rows in set (0.00 sec)
 
mysql&gt; select * from stu limit 2,2;    # 从2的位置开始，取两条数据
+--------+----------+--------+--------+---------+------------+------+------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+----------+--------+--------+---------+------------+------+------+
| s25303 | 李斯文        | 女      |     22 |       2 | 北京           |   55 |   82 |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           | NULL |   74 |
+--------+----------+--------+--------+---------+------------+------+------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>起始位置可以省略，默认是从0开始</p>
<div><pre><code>mysql&gt; select * from stu limit 2;
+--------+---------+--------+--------+---------+------------+------+------+
| stuNo  | stuName | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+---------+--------+--------+---------+------------+------+------+
| s25301 | 张秋丽        | 男       |     18 |       1 | 北京           |   80 | NULL |
| s25302 | 李文才       | 男       |     31 |       3 | 上海          |   77 |   76 |
+--------+---------+--------+--------+---------+------------+------+------+
2 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>例题：找出班级总分前三名</p>
<div><pre><code>mysql&gt; select *,(ch+math) total from stu order by total desc limit 0,3;
+--------+----------+--------+--------+---------+------------+------+------+-------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress | ch   | math | total |
+--------+----------+--------+--------+---------+------------+------+------+-------+
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           |   86 |   92 |   178 |
| s25321 | Tabm     | 女      |     23 |       9 | 河北          |   88 |   77 |   165 |
| s25302 | 李文才        | 男       |     31 |       3 | 上海          |   77 |   76 |   153 |
+--------+----------+--------+--------+---------+------------+------+------+-------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>多学一招：limit在update和delete语句中也是可以使用的。</p>
<h3 id="_5-15-查询语句中的选项"> 5.15 查询语句中的选项</h3>
<p>查询语句中的选项有两个：</p>
<p>1、     all：显示所有数据 【默认】</p>
<p>2、     distinct：去除结果集中重复的数据</p>
<div><pre><code>mysql&gt; select distinct stuaddress from stu;
+------------+
| stuaddress |
+------------+
| 上海          |
| 天津           |
| 河南           |
| 河北          |
| 北京           |
+------------+
5 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="_6-union-联合"> 6 union（联合）</h2>
<p>插入测试数据</p>
<div><pre><code>mysql&gt; create table GO1(
    -&gt; id int primary key,
    -&gt; name varchar(20));
Query OK, 0 rows affected (0.06 sec)

mysql&gt; insert into Go1 values (1,&#39;李白&#39;),(2,&#39;张秋丽&#39;);
Query OK, 2 rows affected (0.02 sec)
Records: 2  Duplicates: 0  Warnings: 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="_6-1-union的使用"> 6.1 union的使用</h3>
<p>作用：将多个select语句结果集纵向联合起来</p>
<div><pre><code>select 语句 union [选项] select 语句 union [选项] select 语句;
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>mysql&gt; select stuno,stuname from stu union select id,name from Go1;
+--------+----------+
| stuno  | stuname  |
+--------+----------+
| s25301 | 张秋丽         |
| s25302 | 李文才        |
| s25303 | 李斯文        |
| s25304 | 欧阳俊雄        |
| s25305 | 诸葛丽丽         |
| s25318 | 争青小子        |
| s25319 | 梅超风        |
| s25320 | Tom      |
| s25321 | Tabm     |
| 1      | 李白         |
| 2      | 张秋丽         |
+--------+----------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>例题：查询上海的男生和北京的女生</p>
<div><pre><code>mysql&gt; select stuname,stuaddress,stusex from stu where (stuaddress=&#39;上海&#39; and stusex=&#39;男&#39;) or (stuaddress=&#39;北京&#39; and stusex=&#39;女&#39;);
+---------+------------+--------+
| stuname | stuaddress | stusex |
+---------+------------+--------+
| 张秋丽        | 上海          | 男       |
| 梅超风       | 北京           | 女      |
+---------+------------+--------+
2 rows in set (0.00 sec)

mysql&gt; select stuname,stuaddress,stusex from stu where stuaddress=&#39;上海&#39; and stusex=&#39;男&#39; union select stuname,stuaddress,stusex from stu where stuaddress=&#39;北京&#39; and stusex=&#39;女&#39;;
+---------+------------+--------+
| stuname | stuaddress | stusex |
+---------+------------+--------+
| 张秋丽        | 上海          | 男       |
| 梅超风       | 北京           | 女      |
+---------+------------+--------+
2 rows in set (0.02 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="_6-2-union的选项"> 6.2 union的选项</h3>
<p>union的选项有两个</p>
<p>1、     all：显示所有数据</p>
<p>2、     distinct：去除重复的数据【默认】</p>
<div><pre><code>mysql&gt; select name from go1 union select stuname from stu;
+----------+
| name     |
+----------+
| 李白         |
| 张秋丽         |
| 李文才        |
| 李斯文        |
| 欧阳俊雄        |
| 诸葛丽丽         |
| 争青小子        |
| 梅超风        |
| Tom      |
| Tabm     |
+----------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>默认是去重复的</p>
<div><pre><code>mysql&gt; select name from go1 union all select stuname from stu;  # all不去重复记录
+----------+
| name     |
+----------+
| 李白         |
| 张秋丽         |
| 张秋丽         |
| 李文才        |
| 李斯文        |
| 欧阳俊雄        |
| 诸葛丽丽         |
| 争青小子        |
| 梅超风        |
| Tom      |
| Tabm     |
+----------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_6-3-union的注意事项"> 6.3 union的注意事项</h3>
<p>1、     union两边的select语句的字段个数必须一致</p>
<p>2、     union两边的select语句的字段名可以不一致，最终按第一个select语句的字段名。</p>
<p>3、     union两边的select语句中的数据类型可以不一致。</p>
<h2 id="_7-多表查询分类"> 7 多表查询分类</h2>
<p>将多个表的数据横向的联合起来。
1、	内连接
2、	外连接
a)	左外连接
b)	右外连接
3、	交叉连接
4、	自然连接</p>
<h3 id="_7-1-内连接【inner-join】"> 7.1 内连接【inner join】</h3>
<div><pre><code>语法一：select 列名 from 表1 inner join 表2 on 表1.公共字段=表2.公共字段

语法二：select 列名 from 表1,表2 where 表1.公共字段=表2.公共字段
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例题</p>
<div><pre><code>方法一：
mysql&gt; select stuname,stusex,writtenexam,labexam from stuinfo inner join stumarks on stuinfo.stuno=stumarks.stuno;
+----------+--------+-------------+---------+
| stuname  | stusex | writtenexam | labexam |
+----------+--------+-------------+---------+
| 李斯文        | 女      |          80 |      58 |
| 李文才        | 男       |          50 |      90 |
| 欧阳俊雄        | 男       |          65 |      50 |
| 张秋丽         | 男       |          77 |      82 |
| 争青小子        | 男       |          56 |      48 |
+----------+--------+-------------+---------+

方法二：
mysql&gt; select stuinfo.stuno,stuname,stusex,writtenexam,labexam from stuinfo,stumarks where stuinfo.stuno=stumarks.stuno;
+--------+----------+--------+-------------+---------+
| stuno  | stuname  | stusex | writtenexam | labexam |
+--------+----------+--------+-------------+---------+
| s25303 | 李斯文        | 女      |          80 |      58 |
| s25302 | 李文才        | 男       |          50 |      90 |
| s25304 | 欧阳俊雄        | 男       |          65 |      50 |
| s25301 | 张秋丽         | 男       |          77 |      82 |
| s25318 | 争青小子        | 男       |          56 |      48 |
+--------+----------+--------+-------------+---------+

可以给表取别名
mysql&gt; select i.stuno,stuname,stusex,writtenexam,labexam from stuinfo i,stumarks s where i.stuno=s.stuno;
+--------+----------+--------+-------------+---------+
| stuno  | stuname  | stusex | writtenexam | labexam |
+--------+----------+--------+-------------+---------+
| s25303 | 李斯文        | 女      |          80 |      58 |
| s25302 | 李文才        | 男       |          50 |      90 |
| s25304 | 欧阳俊雄        | 男       |          65 |      50 |
| s25301 | 张秋丽         | 男       |          77 |      82 |
| s25318 | 争青小子        | 男       |          56 |      48 |
+--------+----------+--------+-------------+---------+
5 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>脚下留心：显示公共字段需要指定表名 <img src="./images/1537061664763.png" alt="1537061664763" /></p>
<p><img src="./images/1537061715978.png" alt="1537061715978" /></p>
<div><pre><code>思考：
select * from 表1 inner join 表2 on 表1.公共字段=表2.公共字段  和
select * from 表2 inner join 表1 on 表1.公共字段=表2.公共字段   结果是否一样？
答：一样的，因为内连接获取的是两个表的公共部分
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code>多学一招：三个表的内连接如何实现？
select * from 表1 inner join 表2 on 表1.公共字段=表2.公共字段
inner join 表3 on 表2.公共字段=表3.公共字段
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_7-2-左外连接【left-join】"> 7.2 左外连接【left join】</h3>
<p>以左边的表为标准，如果右边的表没有对应的记录，用NULL填充。</p>
<div><pre><code>语法：select 列名 from 表1 left join 表2 on 表1.公共字段=表2.公共字段
</code></pre>
<div><span>1</span><br></div></div><p>例题</p>
<div><pre><code>mysql&gt; select stuname,writtenexam,labexam from stuinfo left join stumarks on stuinfo.stuno=stumarks.stuno;
+----------+-------------+---------+
| stuname  | writtenexam | labexam |
+----------+-------------+---------+
| 张秋丽         |          77 |      82 |
| 李文才        |          50 |      90 |
| 李斯文        |          80 |      58 |
| 欧阳俊雄        |          65 |      50 |
| 诸葛丽丽         |        NULL |    NULL |
| 争青小子        |          56 |      48 |
| 梅超风        |        NULL |    NULL |
+----------+-------------+---------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code>思考：
select * from 表1 left join 表2 on 表1.公共字段=表2.公共字段
和
select * from 表2 left join 表1 on 表1.公共字段=表2.公共字段   是否一样？
答：不一样，左连接以左边的表为准。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_7-3-右外连接【right-join】"> 7.3 右外连接【right join】</h3>
<p>以右边的表为标准，如果左边的表没有对应的记录，用NULL填充。</p>
<div><pre><code>语法：select 列名 from 表1 right join 表2 on 表1.公共字段=表2.公共字段
</code></pre>
<div><span>1</span><br></div></div><p>例题</p>
<div><pre><code>mysql&gt; select stuname,writtenexam,labexam from stuinfo right join stumarks on stuinfo.stuno=stumarks.stuno;
+----------+-------------+---------+
| stuname  | writtenexam | labexam |
+----------+-------------+---------+
| 李斯文        |          80 |      58 |
| 李文才        |          50 |      90 |
| 欧阳俊雄        |          65 |      50 |
| 张秋丽         |          77 |      82 |
| 争青小子        |          56 |      48 |
| NULL     |          66 |      77 |
+----------+-------------+---------+
6 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code>思考：
select * from 表1 left join 表2 on 表1.公共字段=表2.公共字段
和
select * from 表2 right join 表1 on 表1.公共字段=表2.公共字段  是否一样？

答：一样的
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_7-4-交叉连接【cross-join】"> 7.4 交叉连接【cross join】</h3>
<p>插入测试数据</p>
<div><pre><code>mysql&gt; create table t1(
    -&gt; id int,
    -&gt; name varchar(10)
    -&gt; );
Query OK, 0 rows affected (0.06 sec)

mysql&gt; insert into t1 values (1,&#39;tom&#39;),(2,&#39;berry&#39;);
Query OK, 2 rows affected (0.00 sec)

mysql&gt; create table t2(
    -&gt; id int,
    -&gt; score int);
Query OK, 0 rows affected (0.02 sec)

mysql&gt; insert into t2 values (1,88),(2,99);
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>1、如果没有连接表达式返回的是笛卡尔积</p>
<div><pre><code>mysql&gt; select * from t1 cross join t2;   # 返回笛卡尔积
+------+-------+------+-------+
| id   | name  | id   | score |
+------+-------+------+-------+
|    1 | tom   |    1 |    88 |
|    2 | berry |    1 |    88 |
|    1 | tom   |    2 |    99 |
|    2 | berry |    2 |    99 |
+------+-------+------+-------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>2、如果有连接表达式等价于内连接</p>
<div><pre><code>mysql&gt; select * from t1 cross join t2 where t1.id=t2.id;
+------+-------+------+-------+
| id   | name  | id   | score |
+------+-------+------+-------+
|    1 | tom   |    1 |    88 |
|    2 | berry |    2 |    99 |
+------+-------+------+-------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_7-5-自然连接【natural】"> 7.5 自然连接【natural】</h3>
<div><pre><code>自动的判断连接条件，它是过同名字段来判断的
</code></pre>
<div><span>1</span><br></div></div><p>自然连接又分为：</p>
<ol>
<li>自然内连接		natural join
. 自然左外连接		natural left join
. 自然右外连接		natural right join</li>
</ol>
<p>例题：</p>
<div><pre><code># 自然内连接
mysql&gt; select * from stuinfo natural join stumarks;
+--------+----------+--------+--------+---------+------------+---------+-------------+---------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress | examNo  | writtenExam | labExam |
+--------+----------+--------+--------+---------+------------+---------+-------------+---------+
| s25303 | 李斯文        | 女      |     22 |       2 | 北京           | s271811 |          80 |
  58 |
| s25302 | 李文才        | 男       |     31 |       3 | 上海          | s271813 |          50 |
  90 |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           | s271815 |          65 |
     50 |
| s25301 | 张秋丽         | 男       |     18 |       1 | 北京           | s271816 |          77 |
    82 |
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           | s271819 |          56 |
     48 |
+--------+----------+--------+--------+---------+------------+---------+-------------+---------+
5 rows in set (0.00 sec)

# 自然左外连接

mysql&gt; select * from stuinfo natural left join stumarks;
+--------+----------+--------+--------+---------+------------+---------+-------------+---------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress | examNo  | writtenExam | labExam |
+--------+----------+--------+--------+---------+------------+---------+-------------+---------+
| s25301 | 张秋丽         | 男       |     18 |       1 | 北京           | s271816 |          77
    82 |
| s25302 | 李文才        | 男       |     31 |       3 | 上海          | s271813 |          50 |
  90 |
| s25303 | 李斯文        | 女      |     22 |       2 | 北京           | s271811 |          80 |
  58 |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           | s271815 |          65
     50 |
| s25305 | 诸葛丽丽         | 女      |     23 |       7 | 河南           | NULL    |        NULL
   NULL |
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           | s271819 |          56
     48 |
| s25319 | 梅超风        | 女      |     23 |       5 | 河北          | NULL    |        NULL |
ULL |
+--------+----------+--------+--------+---------+------------+---------+-------------+---------+
7 rows in set (0.00 sec)

# 自然右外连接
mysql&gt; select * from stuinfo natural right join stumarks;
+--------+---------+-------------+---------+----------+--------+--------+---------+------------+
| stuNo  | examNo  | writtenExam | labExam | stuName  | stuSex | stuAge | stuSeat | stuAddress |
+--------+---------+-------------+---------+----------+--------+--------+---------+------------+
| s25303 | s271811 |          80 |      58 | 李斯文        | 女      |     22 |       2 | 北京
     |
| s25302 | s271813 |          50 |      90 | 李文才        | 男       |     31 |       3 | 上海
     |
| s25304 | s271815 |          65 |      50 | 欧阳俊雄        | 男       |     28 |       4 | 天津
        |
| s25301 | s271816 |          77 |      82 | 张秋丽         | 男       |     18 |       1 | 北京
       |
| s25318 | s271819 |          56 |      48 | 争青小子        | 男       |     26 |       6 | 天津
        |
| s25320 | s271820 |          66 |      77 | NULL     | NULL   |   NULL |    NULL | NULL       |
+--------+---------+-------------+---------+----------+--------+--------+---------+------------+
6 rows in set (0.00 sec)

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><p>自然连接结论：</p>
<ol>
<li>
<p>表连接通过同名的字段来连接的</p>
</li>
<li>
<p>如果没有同名的字段返回笛卡尔积</p>
</li>
<li>
<p>会对结果进行整理，整理的规则如下</p>
<p>a)	连接字段保留一个</p>
<p>b)	连接字段放在最前面</p>
<p>c)     左外连接左边在前，右外连接右表在前</p>
</li>
</ol>
<h3 id="_7-6-using"> 7.6 using()</h3>
<ol>
<li>用来指定连接字段。</li>
<li>using()也会对连接字段进行整理，整理方式和自然连接是一样的。</li>
</ol>
<div><pre><code>mysql&gt; select * from stuinfo inner join stumarks using(stuno);   # using指定字段
+--------+----------+--------+--------+---------+------------+---------+-------------+---------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress | examNo  | writtenExam | labExam |
+--------+----------+--------+--------+---------+------------+---------+-------------+---------+
| s25303 | 李斯文        | 女      |     22 |       2 | 北京           | s271811 |          80 |
  58 |
| s25302 | 李文才        | 男       |     31 |       3 | 上海          | s271813 |          50 |
  90 |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           | s271815 |          65 |
     50 |
| s25301 | 张秋丽         | 男       |     18 |       1 | 北京           | s271816 |          77 |
    82 |
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           | s271819 |          56 |
     48 |
+--------+----------+--------+--------+---------+------------+---------+-------------+---------+
5 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="_8-子查询"> 8 子查询</h2>
<p>语法</p>
<div><pre><code>语法：select 语句 where 条件 (select … from 表)
</code></pre>
<div><span>1</span><br></div></div><ol>
<li>外面的查询称为父查询，括号中的查询称为子查询</li>
<li>子查询为父查询提供查询条件</li>
</ol>
<h3 id="_8-1-例题"> 8.1 例题</h3>
<p>1、查找笔试80分的学生</p>
<div><pre><code>mysql&gt; select * from stuinfo where stuno=(select stuno from stumarks where writtenexam=80);
+--------+---------+--------+--------+---------+------------+
| stuNo  | stuName | stuSex | stuAge | stuSeat | stuAddress |
+--------+---------+--------+--------+---------+------------+
| s25303 | 李斯文       | 女      |     22 |       2 | 北京           |
+--------+---------+--------+--------+---------+------------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>2、查找笔试最高分的学生</p>
<div><pre><code># 方法一：
mysql&gt; select * from stuinfo where stuno=(select stuno from stumarks order by writtenexam desc limit
 1);
+--------+---------+--------+--------+---------+------------+
| stuNo  | stuName | stuSex | stuAge | stuSeat | stuAddress |
+--------+---------+--------+--------+---------+------------+
| s25303 | 李斯文       | 女      |     22 |       2 | 北京           |
+--------+---------+--------+--------+---------+------------+
1 row in set (0.00 sec)

# 方法二：
mysql&gt; select * from stuinfo where stuno=(select stuno from stumarks where writtenexam=(select max(writtenexam) from stumarks));
+--------+---------+--------+--------+---------+------------+
| stuNo  | stuName | stuSex | stuAge | stuSeat | stuAddress |
+--------+---------+--------+--------+---------+------------+
| s25303 | 李斯文       | 女      |     22 |       2 | 北京           |
+--------+---------+--------+--------+---------+------------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code>脚下留心：上面的例题，子查询只能返回一个值。如果子查询返回多个值就不能用“=”了,需要用 in
</code></pre>
<div><span>1</span><br></div></div><h3 id="_8-2-in-not-in子查询"> 8.2 in|not in子查询</h3>
<p>用于子查询的返回结果多个值。</p>
<p>1、查找笔试成绩及格的同学</p>
<div><pre><code>mysql&gt; select * from stuinfo where stuno in (select stuno from stumarks where writtenexam&gt;=60);
+--------+----------+--------+--------+---------+------------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress |
+--------+----------+--------+--------+---------+------------+
| s25301 | 张秋丽         | 男       |     18 |       1 | 北京           |
| s25303 | 李斯文        | 女      |     22 |       2 | 北京           |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           |
+--------+----------+--------+--------+---------+------------+
3 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>2、查询不及格的同学</p>
<div><pre><code>mysql&gt; select * from stuinfo where stuno  in (select stuno from stumarks where writtenexam&lt;=60);
+--------+----------+--------+--------+---------+------------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress |
+--------+----------+--------+--------+---------+------------+
| s25302 | 李文才        | 男       |     31 |       3 | 上海          |
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           |
+--------+----------+--------+--------+---------+------------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>3、查询没有通过的同学（不及格，缺考）</p>
<div><pre><code>mysql&gt; select * from stuinfo where stuno  not in (select stuno from stumarks where writtenexam&gt;=60);
+--------+----------+--------+--------+---------+------------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress |
+--------+----------+--------+--------+---------+------------+
| s25302 | 李文才        | 男       |     31 |       3 | 上海          |
| s25305 | 诸葛丽丽         | 女      |     23 |       7 | 河南           |
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           |
| s25319 | 梅超风        | 女      |     23 |       5 | 河北          |
+--------+----------+--------+--------+---------+------------+
4 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="_8-3-exists和not-exists"> 8.3 exists和not exists</h3>
<p>1、	如果有人笔试超过80分就显示所有的学生</p>
<div><pre><code>mysql&gt; select * from stuinfo where exists (select * from stumarks where writtenexam&gt;=80);
+--------+----------+--------+--------+---------+------------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress |
+--------+----------+--------+--------+---------+------------+
| s25301 | 张秋丽         | 男       |     18 |       1 | 北京           |
| s25302 | 李文才        | 男       |     31 |       3 | 上海          |
| s25303 | 李斯文        | 女      |     22 |       2 | 北京           |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           |
| s25305 | 诸葛丽丽         | 女      |     23 |       7 | 河南           |
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           |
| s25319 | 梅超风        | 女      |     23 |       5 | 河北          |
+--------+----------+--------+--------+---------+------------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>2、	如果没有人超过80分就显示所有的学生</p>
<div><pre><code>mysql&gt; select * from stuinfo where not exists (select * from stumarks where writtenexam&gt;=80);
Empty set (0.02 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_8-4-子查询分类"> 8.4 子查询分类</h3>
<p>1、标量子查询：子查询返回的结果就一个</p>
<p>2、列子查询：子查询返回的结果是一个列表</p>
<p>3、行子查询：子查询返回的结果是一行</p>
<p>例题：查询成绩最高的男生和女生</p>
<div><pre><code>mysql&gt; select stuname,stusex,ch from stu where (stusex,ch) in (select stusex,max(ch) from stu group by stusex);
+----------+--------+------+
| stuname  | stusex | ch   |
+----------+--------+------+
| 争青小子        | 男       |   86 |
| Tabm     | 女      |   88 |
+----------+--------+------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>4、表子查询：子查询返回的结果当成一个表</p>
<p>例题：查询成绩最高的男生和女生</p>
<div><pre><code>mysql&gt; select stuname,stusex,ch from (select * from stu order by ch desc) as t group by stusex;
+----------+--------+------+
| stuname  | stusex | ch   |
+----------+--------+------+
| Tabm     | 女      |   88 |
| 争青小子        | 男       |   86 |
+----------+--------+------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code>脚下留心：from后面是一个表，如果子查询的结果当成表来看，必须将子查询的结果取别名。
</code></pre>
<div><span>1</span><br></div></div><h2 id="_9-补充技术"> 9  补充技术</h2>
<h3 id="_9-1-insert-select"> 9.1  insert…select…</h3>
<p>选择一个表的数据插入到另外的表中。</p>
<h3 id="_9-2-on-duplicate-key-update"> 9.2 on duplicate key update</h3>
<p>在插入数据的时候，如果插入的数据不满足主键约束或唯一约束则执行更新操作。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">11 MySQL逻辑架构</title>
    <id>https://clay-wangzhi.com/db/mysql/jiagou/</id>
    <link href="https://clay-wangzhi.com/db/mysql/jiagou/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_11-mysql逻辑架构"> 11 MySQL逻辑架构</h1>
<h2 id="mysql架构"> mysql架构</h2>
<p>mysql架构分为三层：</p>
<ol>
<li>服务层：为客户请求做连接处理、授权认证、安全等</li>
<li>核心层：查询解析，分析，优化，缓存，所有内建函数；存储过程，触发器，视图等</li>
<li>存储引擎层：存储和提取数据以及事务处理</li>
</ol>
<p><img src="./images/1.png" alt="" /></p>
<h3 id="服务层"> 服务层</h3>
<p>​         <img src="./images/1-1581242308187.png" alt="" /></p>
<h3 id="核心层"> 核心层</h3>
<p>​         <img src="./images/1-1581242354457.png" alt="" /></p>
<h3 id="存储引擎层"> 存储引擎层</h3>
<p>​         <img src="./images/1-1581242634333.png" alt="" /></p>
<h2 id="总图"> 总图</h2>
<p>​         <img src="./images/1-1581242670762.png" alt="" /></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">2 列表类型和数据完整性</title>
    <id>https://clay-wangzhi.com/db/mysql/list-com/</id>
    <link href="https://clay-wangzhi.com/db/mysql/list-com/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_2-列表类型和数据完整性"> 2 列表类型和数据完整性</h1>
<h2 id="_1-数据类型"> 1 数据类型</h2>
<h3 id="_1-1-值类型"> 1.1 值类型</h3>
<h4 id="_1-1-1-整型"> 1.1.1   整型</h4>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">字节</th>
<th style="text-align:center">范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">tinyint</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-128~127</td>
</tr>
<tr>
<td style="text-align:center">smallint</td>
<td style="text-align:center">2</td>
<td style="text-align:center">-32768~32767</td>
</tr>
<tr>
<td style="text-align:center">mediumint</td>
<td style="text-align:center">3</td>
<td style="text-align:center">-8388608~8388607</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">-2<sup>31</sup>~2<sup>31</sup>-1</td>
</tr>
<tr>
<td style="text-align:center">bigint</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-2<sup>63</sup>~2<sup>63</sup>-1</td>
</tr>
</tbody>
</table>
<p>1、无符号整数（unsigned）：无符号数没有负数，正数部分是有符号的两倍。</p>
<p>例题</p>
<div><pre><code>mysql&gt; create table stu(
    -&gt; id smallint unsigned auto_increment primary key comment &#39;主键&#39;,
    -&gt; age tinyint unsigned not null comment &#39;年龄&#39;,
    -&gt; money bigint unsigned comment &#39;存款&#39;
    -&gt; );
Query OK, 0 rows affected (0.06 sec)

mysql&gt; desc stu;
+-------+----------------------+------+-----+---------+----------------+
| Field | Type                 | Null | Key | Default | Extra          |
+-------+----------------------+------+-----+---------+----------------+
| id    | smallint(5) unsigned | NO   | PRI | NULL    | auto_increment |
| age   | tinyint(3) unsigned  | NO   |     | NULL    |                |
| money | bigint(20) unsigned  | YES  |     | NULL    |                |
+-------+----------------------+------+-----+---------+----------------+
3 rows in set, 3 warnings (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>2、整型支持显示宽度（最小的显示位数）  比如int(5)，如果数值的位数小于5位，前面加上前导0。比如输入12，显示00012；大于5位就不添加前导0。</p>
<div><pre><code>脚下留心：必须结合zerofill才起作用
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>mysql&gt; create table stu(
    -&gt; id int(5),
    -&gt; age int(5) zerofill   # 填充前导0
    -&gt; );
Query OK, 0 rows affected (0.02 sec)

mysql&gt; desc stu;
+-------+--------------------------+------+-----+---------+-------+
| Field | Type                     | Null | Key | Default | Extra |
+-------+--------------------------+------+-----+---------+-------+
| id    | int(5)                   | YES  |     | NULL    |       |
| age   | int(5) unsigned zerofill | YES  |     | NULL    |       |
+-------+--------------------------+------+-----+---------+-------+
2 rows in set (0.02 sec)

mysql&gt; insert into stu values (1,11);
mysql&gt; insert into stu values (1111111,2222222);
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from stu;
+---------+---------+
| id      | age     |
+---------+---------+
|       1 |   00011 |
| 1111111 | 2222222 |    # 注意：age填充了前导0
+---------+---------+
2 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h4 id="_1-1-2-浮点型-保存近似值小数"> 1.1.2   浮点型（保存近似值小数）</h4>
<table>
<thead>
<tr>
<th style="text-align:center">浮点型</th>
<th style="text-align:center">占用字节</th>
<th style="text-align:center">范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">float（单精度）</td>
<td style="text-align:center">4</td>
<td style="text-align:center">-3.4E+38~3.4E+38</td>
</tr>
<tr>
<td style="text-align:center">double（双精度）</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-1.8E+308~1.8E+308</td>
</tr>
</tbody>
</table>
<p>1、浮点数声明:  float(M,D)   double(M,D)</p>
<p>M：总位数</p>
<p>D：小数位数</p>
<p>例题；</p>
<div><pre><code>mysql&gt; create table t1(
    -&gt; num1 float(5,2),   #总位数是5，小数位数是2，那么整数位数是3，
    -&gt; num2 double(4,1)
    -&gt; );
Query OK, 0 rows affected (0.08 sec)

mysql&gt; insert into t1 values (1.23,1.23); #如果精度超出了允许的范围，会四舍五入
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from t1;
+------+------+
| num1 | num2 |
+------+------+
| 1.23 |  1.2 |   #如果精度超出了允许的范围，会四舍五入
+------+------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>2、浮点的精度可能会丢失【精度指的是小数】</p>
<p><img src="./images/1536718268668.png" alt="1536718268668" /></p>
<h4 id="_1-1-3-定点数"> 1.1.3   定点数</h4>
<p>语法：<code>decimal(M,D)</code></p>
<div><pre><code>mysql&gt; create table t4(
   -&gt; num decimal(20,19)
   -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into t4 values (1.1234567890123456789);
Query OK, 1 row affected (0.01 sec)

mysql&gt; select * from t4;
+-----------------------+
| num                   |
+-----------------------+
| 1.1234567890123456789 |
+-----------------------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code>多学一招：
1、定点数是变长的，大致每9个数字用4个字节来存储。定点数之所以能保存精确的小数，因为整数和小数是分开存储的。占用的资源比浮点数要多。
2、定点数和浮点数都支持显示宽度和无符号数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_1-2-字符型"> 1.2 字符型</h3>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char(长度)</td>
<td style="text-align:center">定长</td>
<td style="text-align:center">最大255</td>
</tr>
<tr>
<td style="text-align:center">varchar(长度)</td>
<td style="text-align:center">变长</td>
<td style="text-align:center">最大65535</td>
</tr>
<tr>
<td style="text-align:center">tinytext</td>
<td style="text-align:center">大段文本</td>
<td style="text-align:center">2<sup>8</sup>-1=255</td>
</tr>
<tr>
<td style="text-align:center">text</td>
<td style="text-align:center">大段文本</td>
<td style="text-align:center">2<sup>16</sup>-1=65535</td>
</tr>
<tr>
<td style="text-align:center">mediumtext</td>
<td style="text-align:center">大段文本</td>
<td style="text-align:center">2<sup>24</sup>-1</td>
</tr>
<tr>
<td style="text-align:center">longtext</td>
<td style="text-align:center">大段文本</td>
<td style="text-align:center">2<sup>32</sup>-1</td>
</tr>
</tbody>
</table>
<p>1、char(10)和varchar(10)的区别？</p>
<p>答：相同点：它们最多只能保存10个字符；</p>
<div><pre><code>    不同点：char不回收多余的字符，varchar会回收多余的字符。

                    char效率高，浪费空间，varchar节省空间，效率比char低。
</code></pre>
</div><p>2、char的最大长度是255。  <img src="./images/1536719919287.png" alt="1536719919287" /></p>
<p>3、varchar理论长度是65535字节,实际根本达不到。具体长度与字符编码有关。 <img src="./images/1536720096028.png" alt="1536720096028" /></p>
<p><img src="./images/1536720113031.png" alt="1536720113031" /></p>
<p>4、一个记录的总长度不能超过65535个字节。</p>
<p>5、大块文本（text）不计算在总长度中,一个大块文本只占用10个字节来保存文本的地址。 <img src="./images/1536720763914.png" alt="1536720763914" /></p>
<h3 id="_1-3-枚举-enum"> 1.3 枚举（enum）</h3>
<p>1、从集合中选择一个数据（单选）</p>
<div><pre><code>mysql&gt; create table t8(
   -&gt; name varchar(20),
   -&gt; sex enum(&#39;男&#39;,&#39;女&#39;,&#39;保密&#39;)   # 枚举
   -&gt; )charset=utf8;
Query OK, 0 rows affected (0.06 sec)

mysql&gt; insert into t8 values (&#39;tom&#39;,&#39;男&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t8 values (&#39;berry&#39;,&#39;女&#39;);
Query OK, 1 row affected (0.05 sec)

mysql&gt; insert into t8 values (&#39;rose&#39;,&#39;未知&#39;);   # 报错，只能插入枚举值
ERROR 1265 (01000): Data truncated for column &#39;sex&#39; at row 1
mysql&gt; select * from t8;
+-------+------+
| name  | sex  |
+-------+------+
| tom   | 男     |
| berry | 女    |
+-------+------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>2、MySQL的枚举类型是通过整数来管理的，第一个值是1，第二个值是2，以此类推。</p>
<p><img src="./images/1536721403493.png" alt="1536721403493" /></p>
<div><pre><code>mysql&gt; select sex+0 from t8;
+-------+
| sex+0 |
+-------+
|     1 |
|     2 |
+-------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>3、既然枚举在数据库内部存储的是整数，那么可以直接插入数字</p>
<div><pre><code>mysql&gt; insert into t8 values (&#39;rose&#39;,3);  # 可以直接插入数字
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from t8;
+-------+------+
| name  | sex  |
+-------+------+
| tom   | 男     |
| berry | 女    |
| rose  | 保密     |
+-------+------+
3 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>枚举的优点：</p>
<p>1、     运行速度快（数字比字符串运算速度快）</p>
<p>2、     限制数据，保证数据完整性</p>
<p>3、     节省空间</p>
<div><pre><code>思考：已知枚举占用2个字节，请问最多有多少个枚举值？

答：2个字节=16位，可以保存数字（0-65535），枚举是从1开始，所以枚举最多可以有65535个枚举值。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_1-4-集合-set"> 1.4 集合（set）</h3>
<p>从集合中选择一些数据（多选）</p>
<div><pre><code>mysql&gt; create table t9(
   -&gt; hobby set(&#39;爬山&#39;,&#39;读书&#39;,&#39;游泳&#39;,&#39;敲代码&#39;)
   -&gt; );
Query OK, 0 rows affected (0.08 sec)

mysql&gt; insert into t9 values (&#39;爬山&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t9 values (&#39;爬山,游泳&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t9 values (&#39;游泳,爬山&#39;);  # 插入顺序不一样，但是显示的顺序是一样的
Query OK, 1 row affected (0.02 sec)

mysql&gt; insert into t9 values (&#39;爬山,游泳,开车&#39;);  # 报错，插入集合中没有的选项会报错
ERROR 1265 (01000): Data truncated for column &#39;hobby&#39; at row 1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>每个集合的元素都分配一个固定的数字，分配的方式从左往右按2的0、1、2、…次方</p>
<p><img src="./images/1536723512843.png" alt="1536723512843" /></p>
<hr>
<div><pre><code>思考：已知集合占用8个字节，最多可以表示几个选项？

答：8个字节=64位，一个位表示1个选项，最多可以表示64个选项。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_1-5-日期类型"> 1.5 日期类型</h3>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">datetime</td>
<td style="text-align:center">日期时间，占用8个字节</td>
</tr>
<tr>
<td style="text-align:center">date</td>
<td style="text-align:center">日期 占用3个字节</td>
</tr>
<tr>
<td style="text-align:center">time</td>
<td style="text-align:center">时间 占用3个字节</td>
</tr>
<tr>
<td style="text-align:center">timestamp</td>
<td style="text-align:center">时间戳，占用4个字节</td>
</tr>
<tr>
<td style="text-align:center">year</td>
<td style="text-align:center">年份   占用1个字节</td>
</tr>
</tbody>
</table>
<h4 id="_1-5-1-datetime"> 1.5.1 datetime</h4>
<p>格式：年-月-日 小时:分钟:秒</p>
<div><pre><code>mysql&gt; create table t10(
   -&gt; field datetime
   -&gt; );
Query OK, 0 rows affected (0.02 sec)

mysql&gt; insert into t10 values (&#39;2025-10-12 10:12:36&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t10 values (&#39;100-10-12 10:12:36&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t10 values (&#39;10000-10-12 10:12:36&#39;);  #datetime保存范围是：1~9999年
ERROR 1292 (22007): Incorrect datetime value: &#39;10000-10-12 10:12:36&#39; for column &#39;field&#39; at row 1

mysql&gt; select * from t10;
+---------------------+
| field               |
+---------------------+
| 2025-10-12 10:12:36 |
| 0100-10-12 10:12:36 |
+---------------------+
2 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h4 id="_1-5-2-date"> 1.5.2 date</h4>
<div><pre><code>mysql&gt; create table t11(
    -&gt; field date
    -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into t11 values (&#39;2025-10-12&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from t11;
+------------+
| field      |
+------------+
| 2025-10-12 |
+------------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="_1-5-3-timestamp"> 1.5.3 timestamp</h4>
<p>时间戳</p>
<p>timestamp类型和 datetime类型在表现上是一样的。他们的区别：
datetime是从1到9999，而timestamp从1970年~2038年，2038年01月19日11:14:07秒以后就超出timestamp范围了。</p>
<div><pre><code>mysql&gt; create table t12(
    -&gt; field timestamp
    -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into t12 values (&#39;1975-5-5 12:12:12&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t12 values (&#39;1969-5-5 12:12:12&#39;);   # 超出范围
ERROR 1292 (22007): Incorrect datetime value: &#39;1969-5-5 12:12:12&#39; for column &#39;field&#39; at row 1
mysql&gt; insert into t12 values (&#39;2038-1-19 11:14:07&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t12 values (&#39;2038-1-19 11:14:08&#39;);  # 超出范围
ERROR 1292 (22007): Incorrect datetime value: &#39;2038-1-19 11:14:08&#39; for column &#39;field&#39; at row 1

mysql&gt; select * from t12;
+---------------------+
| field               |
+---------------------+
| 1975-05-05 12:12:12 |
| 2038-01-19 11:14:07 |
+---------------------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h4 id="_1-5-4-year"> 1.5.4 year</h4>
<p>因为只占用1个字节，最多只能表示255个年份，范围是1901-2155之间的年份</p>
<div><pre><code>mysql&gt; create table t13(
    -&gt; field year
    -&gt; );
Query OK, 0 rows affected (0.06 sec)

mysql&gt; insert into t13 values (2025);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t13 values (1900);   # 超出范围
ERROR 1264 (22003): Out of range value for column &#39;field&#39; at row 1
mysql&gt; insert into t13 values (2155);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t13 values (2156);   # 超出范围
ERROR 1264 (22003): Out of range value for column &#39;field&#39; at row 1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="_1-5-5-time"> 1.5.5 time</h4>
<p>表示时间或时间间隔，范围是-838:59:59~838:59:59</p>
<div><pre><code>mysql&gt; create table t14(
   -&gt; field time
   -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into t14 values (&#39;12:12:12&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t14 values (&#39;212:12:12&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t14 values (&#39;838:59:59&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into t14 values (&#39;839:00:00&#39;);  # 操作范围
ERROR 1292 (22007): Incorrect time value: &#39;839:00:00&#39; for column &#39;field&#39; at row 1
mysql&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>多学一招：time支持以天的方式插入</p>
<div><pre><code>mysql&gt; insert into t14 values (&#39;10 10:10:10&#39;);
Query OK, 1 row affected (0.02 sec)

mysql&gt; select * from t14;
+-----------+
| field     |
+-----------+
| 12:12:12  |
| 212:12:12 |
| 838:59:59 |
| 250:10:10 |
+-----------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_1-6-boolean"> 1.6 boolean</h3>
<p>MySQL不支持boolean类型，true和false在数据库中对应1和0。</p>
<div><pre><code>mysql&gt; create table t15(
   -&gt; field boolean
   -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into t15 values (true),(false);   # true和false在数据库中对应1和0
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; select * from t15;
+-------+
| field |
+-------+
|     1 |
|     0 |
+-------+
2 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="_1-7-关于数据类型的思考题"> 1.7 关于数据类型的思考题</h3>
<ol>
<li>
<p>手机号码一般使用什么数据类型存储?               char</p>
</li>
<li>
<p>电话号码使用什么数据类型                                 varchar</p>
</li>
<li>
<p>性别一般使用什么数据类型存储?                      char      enum</p>
</li>
<li>
<p>学生年龄信息一般使用什么数据类型存储?               tinyint</p>
</li>
<li>
<p>照片信息一般使用什么数据类型存储?                      binary</p>
</li>
<li>
<p>薪水一般使用什么数据类型存储?                             decimal</p>
</li>
</ol>
<p>多学一招：一个字段到底选数字还是字符，取决于有没有计算的可能，如果没有计算的可能即使是数字也要用字符类型，比如手机号、QQ号，…</p>
<h2 id="_2-列属性"> 2 列属性</h2>
<h3 id="_2-1-是否为空-null-not-null"> 2.1 是否为空(null | not null)</h3>
<p>null：可以为空</p>
<p>not null：不可以为空</p>
<p>思考题</p>
<ol>
<li>
<p>学员姓名允许为空吗?                  非空</p>
</li>
<li>
<p>家庭地址允许为空吗?                  非空</p>
</li>
<li>
<p>电子邮件信息允许为空吗?           可以为空</p>
</li>
<li>
<p>考试成绩允许为空吗?                  可以为空</p>
</li>
</ol>
<h3 id="_2-2-默认值-default"> 2.2 默认值（default）</h3>
<p>1、如果一个字段没有插入值，可以默认插入一个指定的值。</p>
<p>2、default关键字用来插入默认值</p>
<div><pre><code>mysql&gt; create table t16(
   -&gt; id int unsigned,
   -&gt; addr varchar(20) not null default &#39;地址不详&#39;
   -&gt; );
Query OK, 0 rows affected (0.06 sec)

mysql&gt; insert into t16 values (1,&#39;北京&#39;),(2,default);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; select * from t16;
+------+----------+
| id   | addr     |
+------+----------+
|    1 | 北京         |
|    2 | 地址不详        |
+------+----------+
2 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="_2-3-自动增长-auto-increment"> 2.3 自动增长（auto_increment）</h3>
<p>1、字段的值从1开始，每次递增1，特点就在字段中的数据不可能重复，适合为记录生成唯一的id</p>
<p>2、自动增长都是无符号整数。</p>
<p>3、在MySQL中，auto_increment必须是主键。但是主键不一定是自动增长的。</p>
<p>4、如果要给自动增长列插入数据，使用null关键字。</p>
<p>5、自动增长列上的数据被删除，默认情况下此记录的编号不再使用。</p>
<p><img src="./images/1536737314504.png" alt="1536737314504" /></p>
<h3 id="_2-4-主键-primary-key"> 2.4 主键（primary key）</h3>
<p>主键：唯一标识表中记录的一个或一组列</p>
<p>主键的特点：不能重复，不能为空</p>
<p>一个表只能有一个主键，主键可以有多个字段组成。</p>
<p>主键的作用：</p>
<p>1、     保证数据完整性</p>
<p>2、     加快查询速度</p>
<h4 id="_2-4-1-添加主键"> 2.4.1 添加主键</h4>
<p>方法一：创建表的时候添加主键</p>
<div><pre><code>mysql&gt; create table t17(
    -&gt; id varchar(5) primary key,   # 创建主键
    -&gt; name varchar(10) not null
    -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into t17 values (&#39;s2531&#39;,&#39;tom&#39;),(&#39;s2532&#39;,&#39;berry&#39;);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; select * from t17;
+-------+-------+
| id    | name  |
+-------+-------+
| s2531 | tom   |
| s2532 | berry |
+-------+-------+
2 rows in set (0.00 sec)

# 如果插入主键相同数据会报错
mysql&gt; insert into t17 values (&#39;s2531&#39;,&#39;tom&#39;);
ERROR 1062 (23000): Duplicate entry &#39;s2531&#39; for key &#39;PRIMARY&#39;

# 主键不能插入null值
mysql&gt; insert into t17 values (null,&#39;tom&#39;);
ERROR 1048 (23000): Column &#39;id&#39; cannot be null
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>方法二：创建表的时候添加主键</p>
<div><pre><code>mysql&gt; create table t18(
    -&gt; id int,
    -&gt; name varchar(10),
    -&gt; primary key(id)
    -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; desc t18;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int(11)     | NO   | PRI | 0       |       |
| name  | varchar(10) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>方法三：更改表的时候添加主键</p>
<div><pre><code>mysql&gt; create table t20(
    -&gt; id int,
    -&gt; name varchar(10)
    -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; alter table t20 add primary key (id);   # 更改表添加主键
Query OK, 0 rows affected (0.08 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; desc t20;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int(11)     | NO   | PRI | 0       |       |
| name  | varchar(10) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id="_2-4-2-创建组合键"> 2.4.2 创建组合键</h4>
<p><img src="./images/1536736467251.png" alt="1536736467251" /></p>
<h4 id="_2-4-3-查看主键"> 2.4.3 查看主键</h4>
<p><img src="./images/1536736627655.png" alt="1536736627655" /></p>
<h4 id="_2-4-4-删除主键"> 2.4.4 删除主键</h4>
<p><img src="./images/1536736700169.png" alt="1536736700169" /></p>
<h4 id="_2-4-5-选择主键的原则"> 2.4.5 选择主键的原则</h4>
<p>1、     最少性：尽量选择一个字段做主键</p>
<p>2、     稳定性：尽量选择更新少的列做主键</p>
<p>3、     尽量选择数字型的列做主键</p>
<h4 id="_2-4-6-主键思考题"> 2.4.6 主键思考题</h4>
<p>1、在主键列输入的数值，允许为空吗?       不可以</p>
<p>2、 一个表可以有多个主键吗?                     不可以</p>
<p>3、 在一个学校数据库中，如果一个学校内允许重名的学员，但是一个班级内不允许学员重名，可以组合班级和姓名两个字段一起来作为主键吗？                  可以</p>
<p>4、 标识列（自动增长列）允许为字符数据类型吗？     不可以</p>
<p>5、 表中没有合适的列作为主键怎么办？      添加自动增加列</p>
<p>6、  如果标识列A的初始值为1，增长量为1，则输入三行数据以后，再删除两行，下次再输入数据行的时候，标识值从多少开始？          从4开始</p>
<h3 id="_2-5-唯一键"> 2.5 唯一键</h3>
<p>特点：</p>
<p>1、不能重复，可以为空</p>
<p>2、一个表可以有多个唯一键</p>
<p>作用：</p>
<p>1、     保证数据不能重复。保证数据完整性</p>
<p>2、     加快数据访问</p>
<h4 id="_2-5-1-添加唯一键"> 2.5.1 添加唯一键</h4>
<p>方法一：创建表的时候添加唯一键</p>
<div><pre><code>mysql&gt; create table t22(
   -&gt; id int primary key,
   -&gt; name varchar(20) unique,    #通过unique添加唯一键
   -&gt; addr varchar(100) unique
   -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into t22 values (1,&#39;tom&#39;,&#39;上海&#39;);
Query OK, 1 row affected (0.05 sec)

mysql&gt; insert into t22 values (2,&#39;tom&#39;,&#39;北京&#39;);    #  name重复了，报错
ERROR 1062 (23000): Duplicate entry &#39;tom&#39; for key &#39;name&#39;
mysql&gt; insert into t22 values (2,&#39;berry&#39;,&#39;上海&#39;);   # addr重复了 
ERROR 1062 (23000): Duplicate entry &#39;上海&#39; for key &#39;addr&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>还有一种方法</p>
<div><pre><code>mysql&gt; create table t26(
    -&gt; id int,
    -&gt; name varchar(20),
    -&gt; addr varchar(20),
    -&gt; primary key(id),
    -&gt; unique (name),     # 添加唯一键
    -&gt; unique (addr)
    -&gt; );
Query OK, 0 rows affected (0.06 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>方法二：修改表的时候添加唯一键</p>
<div><pre><code>mysql&gt; create table t23(
    -&gt; id int primary key,
    -&gt; name varchar(20)
    -&gt; );
Query OK, 0 rows affected (0.02 sec)

mysql&gt; alter table t23 add unique (name);    #  添加一个唯一键
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>一次添加多个唯一键</p>
<div><pre><code>mysql&gt; create table t24(
    -&gt; id int primary key,
    -&gt; name varchar(20),
    -&gt; addr varchar(20)
    -&gt; );
Query OK, 0 rows affected (0.06 sec)

mysql&gt; alter table t24 add unique(name),add unique(addr);  
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>添加组合唯一键</p>
<div><pre><code>mysql&gt; create table t25(
    -&gt; id int primary key,
    -&gt; name varchar(20),
    -&gt; addr varchar(20)
    -&gt; );
Query OK, 0 rows affected (0.09 sec)

mysql&gt; alter table t25 add unique(name,addr);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="_2-5-2-查看唯一键"> 2.5.2 查看唯一键</h4>
<div><pre><code>mysql&gt; show create table t26\G;
*************************** 1. row ***************************
      Table: t26
Create Table: CREATE TABLE `t26` (
 `id` int(11) NOT NULL DEFAULT &#39;0&#39;,
 `name` varchar(20) DEFAULT NULL,
 `addr` varchar(20) DEFAULT NULL,
 PRIMARY KEY (`id`),
 UNIQUE KEY `name` (`name`),      # 唯一键
 UNIQUE KEY `addr` (`addr`)       # 唯一键
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

mysql&gt; show create table t25\G;
*************************** 1. row ***************************
      Table: t25
Create Table: CREATE TABLE `t25` (
 `id` int(11) NOT NULL,
 `name` varchar(20) DEFAULT NULL,
 `addr` varchar(20) DEFAULT NULL,
 PRIMARY KEY (`id`),
 UNIQUE KEY `name` (`name`,`addr`)    # 组合唯一键
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>添加唯一键，给唯一键取名</p>
<div><pre><code>mysql&gt; create table t27(
    -&gt; name varchar(20)
    -&gt; );
Query OK, 0 rows affected (0.03 sec)

mysql&gt; alter table t27 add unique UQ_name(name);
Query OK, 0 rows affected (0.00 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; show create table t27\G
*************************** 1. row ***************************
       Table: t27
Create Table: CREATE TABLE `t27` (
  `name` varchar(20) DEFAULT NULL,
  UNIQUE KEY `UQ_name` (`name`)    # 唯一键的名字是UQ_name
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id="_2-5-3-删除唯一键"> 2.5.3 删除唯一键</h4>
<p>通过唯一键的名字来删除唯一键</p>
<div><pre><code>alter table 表名 drop index 唯一键名称;
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/1536739081697.png" alt="1536739081697" /></p>
<p>问题：主键和唯一键的区别？</p>
<p>1、主键不能重复，不能为空，唯一键不能重复，可以为空</p>
<p>2、主键只有一个，唯一键可以有多个。</p>
<h3 id="_2-6-备注-comment"> 2.6 备注（comment）</h3>
<p>为了程序员之间的相互交流  <img src="./images/1536739540981.png" alt="1536739540981" /></p>
<h2 id="_3-sql注释"> 3 SQL注释</h2>
<p>单行注释：--或#</p>
<p>多行注释：/*    */</p>
<p><img src="./images/1536739661909.png" alt="1536739661909" /></p>
<h2 id="_4-数据完整性介绍"> 4 数据完整性介绍</h2>
<p><img src="./images/1536739894901.png" alt="1536739894901" /></p>
<h3 id="_4-1-保证实体完整性"> 4.1 保证实体完整性</h3>
<p>1、     主键约束</p>
<p>2、     唯一约束</p>
<p>3、     自动增长列</p>
<h3 id="_4-2-保证域完整性"> 4.2 保证域完整性</h3>
<p>1、     数据类型约束</p>
<p>2、     非空约束</p>
<p>3、     默认值约束</p>
<h3 id="_4-3-保证引用完整性"> 4.3 保证引用完整性</h3>
<p>1、外键约束：从表中的公共字段是主表的外键</p>
<h4 id="_4-3-1-主表和从表"> 4.3.1 主表和从表</h4>
<p>两个表建立关系（两个表只要有公共字段就有关系），一个表称为主表，一个表称为从表。</p>
<p>外键约束可以实现：</p>
<p>1、     主表中没有的从表中不允许插入</p>
<p>2、     从表中有的主表中不允许删除</p>
<p>3、     不能更改主表中的值而导致从表中的记录孤立存在。</p>
<p>4、     先删除从表，再删除主表</p>
<h4 id="_4-3-2-外键-foreign-key"> 4.3.2    外键（foreign key）</h4>
<p>1、     外键：从表中的公共字段，公共字段的名字可以不一样，但是数据类型必须一样。</p>
<p>2、     外键约束用来保证引用完整性</p>
<h4 id="_4-3-3-添加外键"> 4.3.3 添加外键</h4>
<p>方法一：创建表的时候添加外键</p>
<div><pre><code>create table stuinfo(
   stuno char(4) primary key,
   name varchar(10) not null
);

create table stumarks(
   stuid char(4) primary key,
   score tinyint unsigned,
   foreign key (stuid) references stuinfo(stuno)
);
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>方法二：修改表的时候添加外键</p>
<div><pre><code>mysql&gt; create table stuinfo(
    -&gt;  stuno char(4) primary key,
    -&gt;  name varchar(10) not null
    -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; create table stumarks(
    -&gt;  stuid char(4) primary key,
    -&gt;  score tinyint unsigned
    -&gt; );
Query OK, 0 rows affected (0.06 sec)

语法：  alter table 从表 add foreign key (从表的公共字段) references 主表(公共字段)

mysql&gt; alter table stumarks add foreign key (stuid) references stuinfo(stuno);
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>脚下留心：要创建外键必须是innodb引擎，myisam不支持外键约束</p>
<h4 id="_4-3-4-查看外键"> 4.3.4 查看外键</h4>
<p><img src="./images/1536742477588.png" alt="1536742477588" /></p>
<h4 id="_4-3-5-删除外键"> 4.3.5 删除外键</h4>
<p>通过外键的名字删除外键</p>
<div><pre><code>alter table 表名 drop foreign key 外键名;
</code></pre>
<div><span>1</span><br></div></div><p>例题</p>
<div><pre><code>mysql&gt; alter table stumarks drop foreign key stumarks_ibfk_1;
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="_5-外键操作"> 5 外键操作</h2>
<p>1、     严格操作（前面讲的是严格操作）</p>
<p>2、     置空操作（set null）：如果主表记录删除或更新，从表置空</p>
<p>3、     级联操作（cascade）：如果主表记录删除或更新，从表级联</p>
<p>一般来说：主表删除的时候，从表置空操作，主表更新的时候，从表级联操作。</p>
<div><pre><code>foreign key(外键) references 主表(关键字段)[主表删除是的动作][主表更新时候的动作]
</code></pre>
<div><span>1</span><br></div></div><p>例题</p>
<div><pre><code>mysql&gt; create table stuinfo(
    -&gt; stuno char(4) primary key,
    -&gt; name varchar(10) not null
    -&gt; );
Query OK, 0 rows affected (0.02 sec)

mysql&gt; create table stumarks(
    -&gt; stuid int auto_increment primary key,
    -&gt; stuno char(4) ,
    -&gt; score tinyint unsigned,
    -&gt;  foreign key (stuno) references stuinfo(stuno) on delete set null on update cascade
    -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into stuinfo values (&#39;s101&#39;,&#39;tom&#39;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into stumarks values (null,&#39;s101&#39;,88);
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from stuinfo;
+-------+------+
| stuno | name |
+-------+------+
| s101  | tom  |
+-------+------+
1 row in set (0.00 sec)

mysql&gt; update stuinfo set stuno=&#39;s102&#39; where stuno=&#39;s101&#39;;   # 更新时级联
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; select * from stumarks;
+-------+-------+-------+
| stuid | stuno | score |
+-------+-------+-------+
|     1 | s102  |    88 |
+-------+-------+-------+
1 row in set (0.00 sec)

mysql&gt; delete from stuinfo where stuno=&#39;s102&#39;;    # 删除时置空
Query OK, 1 row affected (0.02 sec)

mysql&gt; select * from stumarks;
+-------+-------+-------+
| stuid | stuno | score |
+-------+-------+-------+
|     1 | NULL  |    88 |
+-------+-------+-------+
1 row in set (0.00 sec)

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">12 MySQL锁等待</title>
    <id>https://clay-wangzhi.com/db/mysql/lock/</id>
    <link href="https://clay-wangzhi.com/db/mysql/lock/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_12-mysql锁等待"> 12 MySQL锁等待</h1>
<h2 id="_1-锁等待模拟"> 1 锁等待模拟</h2>
<p>创建数据库</p>
<div><pre><code>create database clay_test default charset utf8 collate utf8_general_ci;
use clay_test
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>创建表</p>
<div><pre><code>create table t1(id int, name varchar(20)) engine=innodb default charset=utf8;
</code></pre>
<div><span>1</span><br></div></div><p>插入数据</p>
<div><pre><code>insert into t1 values(1, &#39;clay&#39;);
</code></pre>
<div><span>1</span><br></div></div><p>取消自动提交</p>
<p>则当执行语句commit或者rollback执行提交事务或者回滚</p>
<div><pre><code>set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show variables like &#39;autocommit&#39;;
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | OFF   |
+---------------+-------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>更新第一条插入的数据</p>
<div><pre><code>update t1 set name=&#39;hello&#39; where id=1;
</code></pre>
<div><span>1</span><br></div></div><p>新开一个终端，也更新第一条数据</p>
<div><pre><code>update t1 set name=&#39;world&#39; where id=1;
</code></pre>
<div><span>1</span><br></div></div><h2 id="_2-监控锁状态"> 2 监控锁状态</h2>
<h3 id="_2-1-查看有无锁等待"> 2.1 查看有无锁等待</h3>
<div><pre><code>mysql&gt; show status like &#39;%innodb_row_lock%&#39;;
+-------------------------------+---------+
| Variable_name                 | Value   |
+-------------------------------+---------+
| Innodb_row_lock_current_waits | 1       |
| Innodb_row_lock_time          | 2270662 |
| Innodb_row_lock_time_avg      | 44522   |
| Innodb_row_lock_time_max      | 51599   |
| Innodb_row_lock_waits         | 51      |
+-------------------------------+---------+
5 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>Innodb_row_lock_current_waits 表示当前所等待的数量</li>
<li>Innodb_row_lock_waits 表示历史发生锁等待的数量</li>
</ul>
<p>查看哪个表的打开数量大于0</p>
<div><pre><code>show open tables where in_use&gt;0;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_2-2-查看哪个事务在等待-被阻塞了"> 2.2 查看哪个事务在等待（被阻塞了）</h3>
<div><pre><code>mysql&gt; select * from information_schema.innodb_trx where trx_state=&#39;lock wait&#39; \G;
*************************** 1. row ***************************
                    trx_id: 2502
                 trx_state: LOCK WAIT
               trx_started: 2020-02-15 17:19:37
     trx_requested_lock_id: 2502:9:3:2
          trx_wait_started: 2020-02-15 17:19:37
                trx_weight: 2
       trx_mysql_thread_id: 38
                 trx_query: update t1 set name=&#39;world&#39; where id=1
       trx_operation_state: starting index read
         trx_tables_in_use: 1
         trx_tables_locked: 1
          trx_lock_structs: 2
     trx_lock_memory_bytes: 360
           trx_rows_locked: 1
         trx_rows_modified: 0
   trx_concurrency_tickets: 0
       trx_isolation_level: REPEATABLE READ
         trx_unique_checks: 1
    trx_foreign_key_checks: 1
trx_last_foreign_key_error: NULL
 trx_adaptive_hash_latched: 0
 trx_adaptive_hash_timeout: 10000
          trx_is_read_only: 0
trx_autocommit_non_locking: 0
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="_2-3-查看索源"> 2.3 查看索源</h3>
<div><pre><code>mysql&gt; select * from information_schema.innodb_lock_waits;
+-------------------+-------------------+-----------------+------------------+
| requesting_trx_id | requested_lock_id | blocking_trx_id | blocking_lock_id |
+-------------------+-------------------+-----------------+------------------+
| 2502              | 2500:9:3:2        | 2491            | 2491:9:3:2       |
+-------------------+-------------------+-----------------+------------------+
1 row in set (0.00 sec)

select * from information_schema.innodb_locks;
+------------+-------------+-----------+-----------+------------------+-----------------+------------+-----------+----------+----------------+
| lock_id    | lock_trx_id | lock_mode | lock_type | lock_table       | lock_index      | lock_space | lock_page | lock_rec | lock_data      |
+------------+-------------+-----------+-----------+------------------+-----------------+------------+-----------+----------+----------------+
| 2500:9:3:2 | 2502        | X         | RECORD    | `clay_test`.`t1` | GEN_CLUST_INDEX |          9 |         3 |        2 | 0x000000000212 |
| 2491:9:3:2 | 2491        | X         | RECORD    | `clay_test`.`t1` | GEN_CLUST_INDEX |          9 |         3 |        2 | 0x000000000212 |
+------------+-------------+-----------+-----------+------------------+-----------------+------------+-----------+----------+----------------+
2 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_2-4-找到锁源的sql语句"> 2.4 找到锁源的SQL语句</h3>
<div><pre><code>mysql&gt; select * from information_schema.innodb_trx where trx_id=&#39;2491&#39; \G;
*************************** 1. row ***************************
                    trx_id: 2491
                 trx_state: RUNNING
               trx_started: 2020-02-15 17:01:28
     trx_requested_lock_id: NULL
          trx_wait_started: NULL
                trx_weight: 5
       trx_mysql_thread_id: 37
                 trx_query: update t1 set name=&#39;hello&#39; where id=1;
       trx_operation_state: NULL
         trx_tables_in_use: 0
         trx_tables_locked: 0
          trx_lock_structs: 2
     trx_lock_memory_bytes: 360
           trx_rows_locked: 2
         trx_rows_modified: 3
   trx_concurrency_tickets: 0
       trx_isolation_level: REPEATABLE READ
         trx_unique_checks: 1
    trx_foreign_key_checks: 1
trx_last_foreign_key_error: NULL
 trx_adaptive_hash_latched: 0
 trx_adaptive_hash_timeout: 10000
          trx_is_read_only: 0
trx_autocommit_non_locking: 0
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="_3-杀掉进程"> 3 杀掉进程</h2>
<p>线程ID（trx_mysql_thread_id）</p>
<div><pre><code>mysql&gt; kill 37;
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">9 主主和keepalived</title>
    <id>https://clay-wangzhi.com/db/mysql/owner-kee/</id>
    <link href="https://clay-wangzhi.com/db/mysql/owner-kee/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_9-主主和keepalived"> 9 主主和keepalived</h1>
<h2 id="keepalived简介"> keepalived简介</h2>
<p>keepalived是vrrp协议的实现，原生设计目的是为了高可用ipvs服务，keepalived能够配置文件中的定义生成ipvs规则，并能够对各RS的健康状态进行检测；通过共用的虚拟IP地址对外提供服务；每个热备组内同一时刻只有一台主服务器提供服务，其他服务器处于冗余状态，若当前在线的服务器宕机，其虚拟IP地址将会被其他服务器接替（优先级决定接替顺序），实现高可用为后端主机提供服务。</p>
<p>VRRP全称Virtual Router Redundancy Protocol，即<a href="http://en.wikipedia.org/wiki/VRRP" target="_blank" rel="noopener noreferrer">虚拟路由冗余协议</a>。</p>
<p>虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到vrrp包时就认为master宕掉了，这时就需要根据<a href="http://tools.ietf.org/html/rfc5798#section-5.1" target="_blank" rel="noopener noreferrer">VRRP的优先级</a>来<a href="http://en.wikipedia.org/wiki/Virtual_Router_Redundancy_Protocol#Elections_of_master_routers" target="_blank" rel="noopener noreferrer">选举一个backup当master</a>。这样的话就可以保证路由器的高可用了。</p>
<h2 id="keepalived组件"> keepalived组件</h2>
<p>Keepalived组件介绍</p>
<p><img src="./images/wKiom1gVgVqxP0nVAADi2pjRuog301.png" alt="wKiom1gVgVqxP0nVAADi2pjRuog301.png" /></p>
<ul>
<li>
<p>core：keepalived核心组件，主进程的启动和维护，全局配置等。</p>
</li>
<li>
<p>vrrp stack：keepalived是基于vrrp协议实现高可用vps服务，vrrp则为相关子进程为其提供服务</p>
</li>
<li>
<p>check：检测keepalived的健康状态相关进程</p>
</li>
<li>
<p>system call:系统调用</p>
<p>watch dog:监控check和vrrp进程的看管者，check负责检测器子进程的健康状态，当其检测到master上的服务不可用时则通告vrrp将其转移至backup服务器上。</p>
</li>
</ul>
<h2 id="mysql主主搭建"> mysql主主搭建</h2>
<p>在主从的基础上，互换搭建一下就好了</p>
<p>不详细介绍</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">13 MySQL常见问题</title>
    <id>https://clay-wangzhi.com/db/mysql/qa/</id>
    <link href="https://clay-wangzhi.com/db/mysql/qa/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_13-mysql常见问题"> 13 MySQL常见问题</h1>
<h2 id="主库异常-从库手动切换为主库方案"> 主库异常，从库手动切换为主库方案</h2>
<p>1.登录从服务器，确认从服务器已经完成所有同步操作：</p>
<div><pre><code>mysql&gt; stop slave io_thread  
mysql&gt; show processlist 
直到看到状态都为：xxx has read all relay log 表示更新都执行完毕
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>2.停止从服务器slave服务：</p>
<div><pre><code>mysql&gt; stop slave
</code></pre>
<div><span>1</span><br></div></div><p>3.将从服务器切换为主服务器：</p>
<div><pre><code>mysql&gt; reset master 
</code></pre>
<div><span>1</span><br></div></div><p>完成切换</p>
<p>4.授权内网其他机器有写入等权限(如果没有权限的话)</p>
<div><pre><code>mysql&gt; SELECT Host,User FROM mysql.user;
mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;192.168.1.%&#39; IDENTIFIED BY &#39;123456&#39;  WITH GRANT OPTION;
mysql&gt; FLUSH PRIVILEGES;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>5.修改其他机器hosts或应用内连接</p>
<div><pre><code># vi /etc/hosts
192.168.1.106 db-001
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Mysql常见的几个错误问题及解决方法：</p>

<h2 id="mysql-dns反解-skip-name-resolve"> mysql DNS反解：skip-name-resolve</h2>
<p>错误日志有类似警告：</p>
<ol>
<li>
<p>120119 16:26:04 [Warning] IP address '192.168.1.10' could not be resolved: Name or service not known</p>
</li>
<li>
<p>120119 16:26:04 [Warning] IP address '192.168.1.14' could not be resolved: Name or service not known</p>
</li>
<li>
<p>120119 16:26:04 [Warning] IP address '192.168.1.17' could not be resolved: Name or service not known</p>
</li>
</ol>
<p>通过show processlist发现大量类似如下的连接：</p>
<ol>
<li>
<p>|592|unauthenticated user|192.168.1.10:35320|NULL|Connect| |login|NULL|</p>
</li>
<li>
<p>|593|unauthenticated user|192.168.1.14:35321|NULL|Connect| |login|NULL|</p>
</li>
<li>
<p>|594|unauthenticated user|192.168.1.17:35322|NULL|Connect| |login|NULL|</p>
</li>
</ol>
<p>skip-name-resolve 参数的作用：不再进行反解析（ip不反解成域名），这样可以加快数据库的反应时间。 修改配置文件添加并需要重启：</p>
<div><pre><code>[mysqld] 
skip-name-resolve
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="一键安装mysql脚本"> 一键安装mysql脚本</h2>
<div><pre><code><span>#!/bin/bash</span>


<span># Notes: install mysql5.6 on centos</span>
<span>#</span>
<span>mysql_install_dir</span><span>=</span>/opt/mysql                 <span>#程序目录</span>
<span>mysql_data_dir</span><span>=</span>/opt/mysql/data                           <span>#数据目录</span>
<span>mysql_6_version</span><span>=</span><span>5.6</span>.36                                    <span>#更改文件名</span>
<span>dbrootpwd</span><span>=</span>1qazxsw2                                              <span>#mysql密码</span>

<span>Mem</span><span>=</span><span><span>`</span><span>free</span> -m <span>|</span> <span>awk</span> <span>'/Mem:/{print <span>$2</span>}'</span><span>`</span></span>
<span>Swap</span><span>=</span><span><span>`</span><span>free</span> -m <span>|</span> <span>awk</span> <span>'/Swap:/{print <span>$2</span>}'</span><span>`</span></span>

<span>Install_MySQL</span><span>(</span><span>)</span>
<span>{</span>
yum -y <span>install</span> <span>make</span> gcc-c++ cmake bison-devel  ncurses-devel autoconf
<span>wget</span> http://mirrors.sohu.com/mysql/MySQL-5.6/mysql-<span>${mysql_6_version}</span>.tar.gz

<span>id</span> -u mysql <span>></span>/dev/null <span><span>2</span>></span><span>&amp;1</span>
<span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>useradd</span> -M -s /sbin/nologin mysql

<span>mkdir</span> -p <span>$mysql_data_dir</span><span>;</span><span>chown</span> mysql.mysql -R <span>$mysql_data_dir</span>
<span>tar</span> zxf mysql-<span>${mysql_6_version}</span>.tar.gz
<span>cd</span> mysql-<span>$mysql_6_version</span>
<span>make</span> clean
<span>[</span> <span>!</span> -d <span>"<span>$mysql_install_dir</span>"</span> <span>]</span> <span>&amp;&amp;</span> <span>mkdir</span> -p <span>$mysql_install_dir</span>
cmake <span>.</span> -DCMAKE_INSTALL_PREFIX<span>=</span><span>$mysql_install_dir</span> <span>\</span>
-DMYSQL_DATADIR<span>=</span><span>$mysql_data_dir</span> <span>\</span>
-DSYSCONFDIR<span>=</span>/etc <span>\</span>
-DWITH_INNOBASE_STORAGE_ENGINE<span>=</span><span>1</span> <span>\</span>
-DWITH_PARTITION_STORAGE_ENGINE<span>=</span><span>1</span> <span>\</span>
-DWITH_FEDERATED_STORAGE_ENGINE<span>=</span><span>1</span> <span>\</span>
-DWITH_BLACKHOLE_STORAGE_ENGINE<span>=</span><span>1</span> <span>\</span>
-DWITH_MYISAM_STORAGE_ENGINE<span>=</span><span>1</span> <span>\</span>
-DWITH_INNOBASE_STORAGE_ENGINE<span>=</span><span>1</span> <span>\</span>
-DENABLED_LOCAL_INFILE<span>=</span><span>1</span> <span>\</span>
-DENABLE_DTRACE<span>=</span><span>0</span> <span>\</span>
-DEXTRA_CHARSETS<span>=</span>all <span>\</span>
-DDEFAULT_CHARSET<span>=</span>utf8mb4 <span>\</span>
-DDEFAULT_COLLATION<span>=</span>utf8mb4_general_ci <span>\</span>
-DWITH_EMBEDDED_SERVER<span>=</span><span>1</span> <span>\</span>

<span>make</span> -j <span><span>`</span><span>grep</span> processor /proc/cpuinfo <span>|</span> <span>wc</span> -l<span>`</span></span>
<span>make</span> <span>install</span>

<span>if</span> <span>[</span> -d <span>"<span>$mysql_install_dir</span>/support-files"</span> <span>]</span><span>;</span><span>then</span>
    <span>echo</span> <span>"<span>${CSUCCESS}</span>MySQL install successfully! <span>${CEND}</span>"</span>
    <span>cd</span> <span>..</span>
    <span>rm</span> -rf mysql-<span>$mysql_6_version</span>
<span>else</span>
    <span>rm</span> -rf <span>$mysql_install_dir</span>
    <span>echo</span> <span>"<span>${CFAILURE}</span>MySQL install failed, Please contact the author! <span>${CEND}</span>"</span>
    <span>kill</span> -9 <span>$$</span>
<span>fi</span>

/bin/cp <span>$mysql_install_dir</span>/support-files/mysql.server /etc/init.d/mysqld
<span>chmod</span> +x /etc/init.d/mysqld
<span>chkconfig</span> mysqld on
<span>cd</span> <span>..</span>

<span># my.cf</span>
<span>[</span> -d <span>"/etc/mysql"</span> <span>]</span> <span>&amp;&amp;</span> /bin/mv /etc/mysql<span>{</span>,_bk<span>}</span>
<span>cat</span> <span>></span> /etc/my.cnf <span>&lt;&lt;</span> <span>EOF
[client]
port = 3306
socket = /tmp/mysql.sock
default-character-set = utf8

[mysqld]
port = 3306
socket = /tmp/mysql.sock

basedir = <span>$mysql_install_dir</span>
datadir = <span>$mysql_data_dir</span>
pid-file = <span>$mysql_data_dir</span>/mysql.pid
user = mysql
bind-address = 0.0.0.0
server-id = 1

init-connect = 'SET NAMES utf8mb4'
character-set-server = utf8mb4

skip-name-resolve
skip-external-locking
#skip-networking
back_log = 300

max_connections = 1000
max_connect_errors = 6000
open_files_limit = 65535
table_open_cache = 128
max_allowed_packet = 4M
binlog_cache_size = 1M
max_heap_table_size = 8M
tmp_table_size = 16M

read_buffer_size = 2M
read_rnd_buffer_size = 8M
sort_buffer_size = 8M
join_buffer_size = 8M
key_buffer_size = 4M
thread_cache_size = 8
query_cache_type = 1
query_cache_size = 8M
query_cache_limit = 2M
ft_min_word_len = 4
log_bin = mysql-bin
binlog_format = mixed
expire_logs_days = 10
log_error = <span>$mysql_data_dir</span>/mysql-error.log
slow_query_log = 1
long_query_time = 1
#slow_query_log_file = <span>$mysql_data_dir</span>/mysql-slow.log
performance_schema = 0
explicit_defaults_for_timestamp

#lower_case_table_names = 1
default_storage_engine = InnoDB
#default-storage-engine = MyISAM
innodb_file_per_table = 1
innodb_open_files = 500
innodb_buffer_pool_size = 64M
innodb_write_io_threads = 4
innodb_read_io_threads = 4
innodb_thread_concurrency = 0
innodb_purge_threads = 1
innodb_flush_log_at_trx_commit = 2
innodb_log_buffer_size = 2M
innodb_log_file_size = 32M
innodb_log_files_in_group = 3
innodb_max_dirty_pages_pct = 90
innodb_lock_wait_timeout = 120

bulk_insert_buffer_size = 8M
myisam_sort_buffer_size = 8M
myisam_max_sort_file_size = 10G
myisam_repair_threads = 1

interactive_timeout = 28800
wait_timeout = 28800

[mysqldump]
quick
max_allowed_packet = 16M

[myisamchk]
key_buffer_size = 8M
sort_buffer_size = 8M
read_buffer = 4M
write_buffer = 4M

EOF</span>

<span>if</span> <span>[</span> <span>$Mem</span> -gt <span>1500</span> -a <span>$Mem</span> -le <span>2500</span> <span>]</span><span>;</span><span>then</span>
    <span>sed</span> -i <span>'s@^thread_cache_size.*@thread_cache_size = 16@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^query_cache_size.*@query_cache_size = 16M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^myisam_sort_buffer_size.*@myisam_sort_buffer_size = 16M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^key_buffer_size.*@key_buffer_size = 16M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^innodb_buffer_pool_size.*@innodb_buffer_pool_size = 128M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^tmp_table_size.*@tmp_table_size = 32M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^table_open_cache.*@table_open_cache = 256@'</span> /etc/my.cnf
<span>elif</span> <span>[</span> <span>$Mem</span> -gt <span>2500</span> -a <span>$Mem</span> -le <span>3500</span> <span>]</span><span>;</span><span>then</span>
    <span>sed</span> -i <span>'s@^thread_cache_size.*@thread_cache_size = 32@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^query_cache_size.*@query_cache_size = 32M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^myisam_sort_buffer_size.*@myisam_sort_buffer_size = 32M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^key_buffer_size.*@key_buffer_size = 64M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^innodb_buffer_pool_size.*@innodb_buffer_pool_size = 512M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^tmp_table_size.*@tmp_table_size = 64M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^table_open_cache.*@table_open_cache = 512@'</span> /etc/my.cnf
<span>elif</span> <span>[</span> <span>$Mem</span> -gt <span>3500</span> <span>]</span><span>;</span><span>then</span>
    <span>sed</span> -i <span>'s@^thread_cache_size.*@thread_cache_size = 64@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^query_cache_size.*@query_cache_size = 64M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^myisam_sort_buffer_size.*@myisam_sort_buffer_size = 64M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^key_buffer_size.*@key_buffer_size = 256M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^innodb_buffer_pool_size.*@innodb_buffer_pool_size = 1024M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^tmp_table_size.*@tmp_table_size = 128M@'</span> /etc/my.cnf
    <span>sed</span> -i <span>'s@^table_open_cache.*@table_open_cache = 1024@'</span> /etc/my.cnf
<span>fi</span>

<span>$mysql_install_dir</span>/scripts/mysql_install_db --user<span>=</span>mysql --basedir<span>=</span><span>$mysql_install_dir</span> --datadir<span>=</span><span>$mysql_data_dir</span>

<span>chown</span> mysql.mysql -R <span>$mysql_data_dir</span>
<span>service</span> mysqld start
<span>[</span> -z <span>"<span><span>`</span><span>grep</span> ^<span>'export PATH='</span> /etc/profile<span>`</span></span>"</span> <span>]</span> <span>&amp;&amp;</span> <span>echo</span> <span>"export PATH=<span>$mysql_install_dir</span>/bin:\<span>$PATH</span>"</span> <span>>></span> /etc/profile
<span>[</span> -n <span>"<span><span>`</span><span>grep</span> ^<span>'export PATH='</span> /etc/profile<span>`</span></span>"</span> -a -z <span>"<span><span>`</span><span>grep</span> $mysql_install_dir /etc/profile<span>`</span></span>"</span> <span>]</span> <span>&amp;&amp;</span> <span>sed</span> -i <span>"s@^export PATH=\(.*\)@export PATH=<span>$mysql_install_dir</span>/bin:<span title="\1">\1</span>@"</span> /etc/profile

<span>.</span> /etc/profile

<span>$mysql_install_dir</span>/bin/mysql -e <span>"grant all privileges on *.* to root@'127.0.0.1' identified by <span title="\&quot;">\"</span><span>$dbrootpwd</span><span title="\&quot;">\"</span> with grant option;"</span>
<span>$mysql_install_dir</span>/bin/mysql -e <span>"grant all privileges on *.* to root@'localhost' identified by <span title="\&quot;">\"</span><span>$dbrootpwd</span><span title="\&quot;">\"</span> with grant option;"</span>
<span>$mysql_install_dir</span>/bin/mysql -uroot -p<span>$dbrootpwd</span> -e <span>"delete from mysql.user where Password='';"</span>
<span>$mysql_install_dir</span>/bin/mysql -uroot -p<span>$dbrootpwd</span> -e <span>"delete from mysql.db where User='';"</span>
<span>$mysql_install_dir</span>/bin/mysql -uroot -p<span>$dbrootpwd</span> -e <span>"delete from mysql.proxies_priv where Host!='localhost';"</span>
<span>$mysql_install_dir</span>/bin/mysql -uroot -p<span>$dbrootpwd</span> -e <span>"drop database test;"</span>
<span>$mysql_install_dir</span>/bin/mysql -uroot -p<span>$dbrootpwd</span> -e <span>"reset master;"</span>
<span>rm</span> -rf /etc/ld.so.conf.d/<span>{</span>mysql,mariadb,percona<span>}</span>*.conf
<span>echo</span> <span>"<span>$mysql_install_dir</span>/lib"</span> <span>></span> mysql.conf
/sbin/ldconfig
<span>service</span> mysqld stop
<span>}</span>

Install_MySQL
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">10 读写分离和Amoeba</title>
    <id>https://clay-wangzhi.com/db/mysql/read-write/</id>
    <link href="https://clay-wangzhi.com/db/mysql/read-write/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_10-读写分离和amoeba"> 10 读写分离和Amoeba</h1>
<p>后续补充</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">1 MySQL基本操作</title>
    <id>https://clay-wangzhi.com/db/mysql/</id>
    <link href="https://clay-wangzhi.com/db/mysql/"/>
    <updated>2021-05-11T06:24:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_1-mysql基本操作"> 1 MySQL基本操作</h1>
<h2 id="_1-数据库相关概念"> 1 数据库相关概念</h2>
<h3 id="_1-1-什么是数据"> 1.1 什么是数据？</h3>
<p>​		数据（data）是事实或观察的结果，是对客观事物的逻辑归纳，是用于表示客观事物的未经加工的原始素材。数据是信息的表现形式和载体，可以是符号、文字、数字、语音、图像、视频等。数据和信息是不可分离的，数据是信息的表达，信息是数据的内涵。数据本身没有意义，数据只有对实体行为产生影响才成为信息。数据可以是连续的值，比如声音、图像，称为模拟数据。也可以是离散的，如符号、文字，称为数字数据。在计算机系统中，数据以二进制信息单元0,1的形式表示。</p>
<h3 id="_1-2-什么是数据库"> 1.2 什么是数据库？</h3>
<p>​		数据库（Database）：是按照数据结构来组织、存储和管理数据的仓库。</p>
<h3 id="_1-3-什么是数据库管理系统-dbms"> 1.3 什么是数据库管理系统（DBMS）？</h3>
<p>​		数据库管理系统：是由数据库及其管理软件组成的系统，它支持如下操作：</p>
<p>​			1）提供数据持久性的存储，备份，恢复</p>
<p>​			2）支持事务管理</p>
<p>​			3）支持数据操作的并发</p>
<p>​			4）支持独立的管理语言（sql语句）</p>
<h2 id="_2-数据库的发展史"> 2 数据库的发展史</h2>
<h3 id="_2-1-萌芽阶段-文件系统"> 2.1 萌芽阶段：文件系统</h3>
<p>最初始的数据库是用磁盘来存储数据的。文件就是最早的数据库。</p>
<h3 id="_2-2-第一代数据库-层次模型、网状模型"> 2.2  第一代数据库：层次模型、网状模型</h3>
<h4 id="_2-2-1-层次模型"> 2.2.1 层次模型</h4>
<p><img src="./images/1536628336467.png" alt="1536628336467" /></p>
<p>缺点：</p>
<ol>
<li>
<p>查找不同类的数据效率低了（导航的结构的缺点）</p>
</li>
<li>
<p>数据不完整（不能区分到底是一个李白还是两个李白）</p>
</li>
</ol>
<h4 id="_2-2-2-网状模型"> 2.2.2 网状模型</h4>
<p>网状模型解决了层次数据的数据不完整的问题，但是没有解决层次模型的导航问题。</p>
<p><img src="./images/1536628485678.png" alt="1536628485678" /></p>
<h3 id="_2-3-第二代数据库-关系型数据库"> 2.3 第二代数据库：关系型数据库</h3>
<p>特点：</p>
<ol>
<li>
<p>每个表都是独立的</p>
</li>
<li>
<p>表与表之间通过公共字段来建立关系</p>
</li>
</ol>
<p><img src="./images/1536628687644.png" alt="1536628687644" /></p>
<p>优点：解决了导航问题，并且数据完整性得到解决</p>
<p>缺点：多表查询效率低了</p>
<p>提示：我们现在用的主流的数据库都是关系模型的。</p>
<div><pre><code>多学一招：NoSQL（非关系型数据库）解决关系型数据库多表查询效率的问题，常见的非关系型数据库有：Redis、mongodb。数据库中存储格式是键值对。 
</code></pre>
<div><span>1</span><br></div></div><h2 id="_3-数据库的分类"> 3 数据库的分类</h2>
<h3 id="_3-1-关系型数据库"> 3.1 关系型数据库</h3>
<p>​		关系数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系模型是由埃德加·科德于1970年首先提出的，并配合“科德十二定律”。现如今虽然对模型有一些批评意见，但它还是数据存储的传统标准。标准数据查询语言SQL就是一种基于关系数据库的语言，这种语言执行对关系数据库中数据的检索和操作。关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。</p>
<h4 id="_3-1-2-常见的关系型数据库"> 3.1.2  常见的关系型数据库</h4>
<table>
<thead>
<tr>
<th>关系型数据库</th>
<th>开发公司</th>
<th>使用语言</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQL Server</td>
<td>微软公司</td>
<td>T-SQL</td>
</tr>
<tr>
<td>Oracle</td>
<td>甲骨文公司</td>
<td>PL/SQL</td>
</tr>
<tr>
<td>MySQL</td>
<td>MySQL AB 公司开发——甲骨文公司收购</td>
<td>MySQL</td>
</tr>
</tbody>
</table>
<h3 id="_3-2-非关系型数据库"> 3.2 非关系型数据库</h3>
<h2 id="_4-mysql的安装"> 4 Mysql的安装</h2>
<h2 id="_5-连接服务器"> 5 连接服务器</h2>
<div><pre><code>-h 主机（host）
-u 用户名（username）
-p 密码（password）
-P 端口（port）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="./images/1536633424017.png" alt="1536633424017" /></p>
<hr>
<p><img src="./images/1536633591923.png" alt="1536633591923" /></p>
<div><pre><code>多学一招：如果MySQL服务器在本地，IP地址可以省略；如果MySQL服务器用的是3306端口，-P也是可以省略 
</code></pre>
<div><span>1</span><br></div></div><h2 id="_6-sql介绍"> 6 SQL介绍</h2>
<h3 id="_6-1-sql是什么"> 6.1 SQL是什么</h3>
<p>Structured Query Language（结构化查询语言），是用来操作关系型数据库的一门语言。这是一个关系型数据库的通用操作语言，也成为标准SQL，也叫SQL-92。</p>
<div><pre><code>多学一招：数据库的生产厂商为了占有市场份额，都会在标准SQL的基础上扩展一些自己的东西以吸引用户。
</code></pre>
<div><span>1</span><br></div></div><p>**思考：**已知标准SQL可以在所有的关系型数据库上运行，在Oracle上编写的PL/SQL能否在MySQL上运行？</p>
<p>答：不能，只能运行标准SQL 。</p>
<h3 id="_6-2-sql的分类"> 6.2 SQL的分类</h3>
<ul>
<li>DDL（data definition language）数据库定义语言CREATE、ALTER、DROP、SHOW</li>
<li>DML（data manipulation language）数据操纵语言SELECT、UPDATE、INSERT、DELETE</li>
<li>DCL（data control language）数据库控制语言,是用来设置或更改数据库用户或角色权限的语句GRANT,REVOKE,COMMIT,ROLLBACK</li>
<li>DQL（data query language）：数据查询语言 SELECT</li>
</ul>
<h3 id="_6-3-注意事项"> 6.3 注意事项</h3>
<ul>
<li>
<p>每条SQL语句结束时要以<code>;</code>做为结束符(除了use命令)</p>
</li>
<li>
<p>SQL语句的关键字不区分大小写(除了库名字和表名字)</p>
</li>
<li>
<p>在查询数据库信息或者表信息时,可以以\G做为结束符,表示以文本模式输出</p>
</li>
<li>
<p>当你不需要一条语句输出的结果以\c结束,不可以使用ctrl+c,否则登出mysql.</p>
</li>
<li>
<p>我们可以在命令行执行sql语句,要通过mysql -e参数</p>
<p><code>mysql -e &quot;show databases \G</code>&quot;显示到shell上</p>
</li>
<li>
<p>如果需要获取SQL语句的帮助可以用help命令<code>help create</code>
如果需要进一步获取帮助,可以继续使用help命令<code>help create database</code></p>
</li>
</ul>
<h2 id="_7-数据库操作"> 7 数据库操作</h2>
<h3 id="_7-1-增"> 7.1 增</h3>
<div><pre><code>create database [if not exists] `数据库名` [charset=utf8];
</code></pre>
<div><span>1</span><br></div></div><h3 id="_7-2-删"> 7.2 删</h3>
<div><pre><code>drop database [if exists] 数据库名;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_7-3-改"> 7.3 改</h3>
<div><pre><code>alter database 数据库名 charset=字符编码;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_7-4-查"> 7.4 查</h3>
<div><pre><code>show databases;
</code></pre>
<div><span>1</span><br></div></div><p>安装MySQL后，MySQL自带了4个数据库</p>
<ol>
<li>information_schema：存储了MySQL服务器管理数据库的信息。</li>
<li>performance_schema：MySQL5.5新增的表，用来保存数据库服务器性能的参数</li>
<li>mysql：MySQL系统数据库，保存的登录用户名，密码，以及每个用户的权限等等</li>
<li>test：给用户学习和测试的数据库。</li>
</ol>
<p>显示创建数据库的SQL语句</p>
<div><pre><code>show create database 数据库名;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_7-5-选择数据库"> 7.5 选择数据库</h3>
<div><pre><code>use 数据库名称
</code></pre>
<div><span>1</span><br></div></div><h2 id="_8-表操作"> 8 表操作</h2>
<h3 id="_8-1-增"> 8.1 增</h3>
<div><pre><code>create table [if not exists] 表名（字段名 数据类型 [null|not null] [auto_increment] [primary key] [comment], 字段名 数据类型 [default]...）engine=存储引擎;
</code></pre>
<div><span>1</span><br></div></div><p>单词</p>
<div><pre><code>null | not null   	空|非空
default	          	默认值
auto_increment    	自动增长
primary key       	主键
comment           	备注
engine           	引擎   
innodb  myisam  memory  引擎是决定数据存储的方式
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_8-2-删"> 8.2 删</h3>
<div><pre><code>drop table [if exists] 表1,表2;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_8-3-改"> 8.3 改</h3>
<h4 id="_8-3-1-修改表名"> 8.3.1 修改表名</h4>
<div><pre><code>alter table aa rename to bb;
</code></pre>
<div><span>1</span><br></div></div><h4 id="_8-3-2-添加字段"> 8.3.2 添加字段</h4>
<div><pre><code>alter table aa add age int;
</code></pre>
<div><span>1</span><br></div></div><p>在第一个位置上添加字段</p>
<div><pre><code>alter table aa add email varchar(30) first;
</code></pre>
<div><span>1</span><br></div></div><p>在指定的字段后添加字段</p>
<div><pre><code>alter table aa add age int(10) after name;
</code></pre>
<div><span>1</span><br></div></div><h4 id="_8-3-3-删除字段"> 8.3.3 删除字段</h4>
<div><pre><code>alter table aa drop email;
</code></pre>
<div><span>1</span><br></div></div><h4 id="_8-3-4-修改字段名和类型"> 8.3.4 修改字段名和类型</h4>
<div><pre><code>alter table aa change sex xingbie int;
</code></pre>
<div><span>1</span><br></div></div><h4 id="_8-3-5-修改字段类型"> 8.3.5 修改字段类型</h4>
<div><pre><code>alter table aa modify xingbie varchar(2);
</code></pre>
<div><span>1</span><br></div></div><h4 id="_8-3-6-修改引擎"> 8.3.6 修改引擎</h4>
<div><pre><code>alter table aa engine=myisam;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_8-4-查"> 8.4 查</h3>
<h4 id="_8-4-1-显示所有表"> 8.4.1 显示所有表</h4>
<div><pre><code>show tables;
</code></pre>
<div><span>1</span><br></div></div><h4 id="_8-4-2-显示创建表的语句"> 8.4.2 显示创建表的语句</h4>
<div><pre><code>show create table 表名;
</code></pre>
<div><span>1</span><br></div></div><h4 id="_8-4-3-查看表结构"> 8.4.3 查看表结构</h4>
<div><pre><code>desc 表名;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_8-5-复制表"> 8.5 复制表</h3>
<div><pre><code>create table 新表 select 字段 from 旧表;
</code></pre>
<div><span>1</span><br></div></div><h2 id="_9-数据操作"> 9 数据操作</h2>
<h3 id="_9-1-增"> 9.1 增</h3>
<div><pre><code>insert into 表名 (字段名，字段名，...) values (值1，值2，...);
</code></pre>
<div><span>1</span><br></div></div><h3 id="_9-2-删"> 9.2 删</h3>
<div><pre><code>delete from 表名 [where 条件];
</code></pre>
<div><span>1</span><br></div></div><p>删除表中所有记录</p>
<div><pre><code>delete from aa;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_9-3-改"> 9.3 改</h3>
<div><pre><code>update 表名 set 字段=值 [where 条件];
</code></pre>
<div><span>1</span><br></div></div><h3 id="_9-4-查"> 9.4 查</h3>
<div><pre><code>select 列名 from 表;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_9-5-清空表数据"> 9.5 清空表数据</h3>
<div><pre><code>truncate table 表名;
</code></pre>
<div><span>1</span><br></div></div><h2 id="_10-数据表的文件介绍"> 10 数据表的文件介绍</h2>
<p>一个数据库对应一个文件夹</p>
<p>一个表对应一个或多个文件</p>
<p>引擎是myisam，一个表对应三个文件</p>
<ol>
<li>xx.frm  表结构</li>
<li>xx.MYD  数据</li>
<li>xx.MYI   index信息</li>
</ol>
<p><img src="./images/1536654269605.png" alt="1536654269605" /></p>
<p>引擎是innodb,一个表对应一个表结构文件</p>
<p><img src="./images/1536654519700.png" alt="1536654519700" /></p>
<p>go3.frm 表结构</p>
<p>所有的innodb引擎的数据统一的存放在data\ibdata1文件中。如果数据量很大，MySQL会自动的创建ibdata2，ibdata3，…，目的就是为了便于管理。</p>
<p>引擎是memory，数据存储在内存中，重启服务数据丢失，但是读取速度非常快</p>
<h2 id="_11-字符集"> 11 字符集</h2>
<p>查看当前设置的字符编码集</p>
<div><pre><code>show variables like &#39;character_set_%&#39;;
</code></pre>
<div><span>1</span><br></div></div><p>客户端编码、character_set_client、character_set_results三个编码的值一致即可操作中文。</p>
<h2 id="_12-思维导图"> 12 思维导图</h2>
<p><img src="./images/xmind.png" alt="" /></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">5 MySQL存储引擎</title>
    <id>https://clay-wangzhi.com/db/mysql/stro/</id>
    <link href="https://clay-wangzhi.com/db/mysql/stro/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_5-mysql存储引擎"> 5 MySQL存储引擎</h1>
<h2 id="存储引擎简介"> 存储引擎简介</h2>
<p>​		MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p>
<p>​		例如，如果你在研究大量的临时数据，你也许需要使用内存存储引擎。内存存储引擎能够在内存中存储所有的表格数据。</p>
<h2 id="常用的存储引擎及其特点"> 常用的存储引擎及其特点</h2>
<h3 id="myisam存储引擎"> MyISAM存储引擎</h3>
<p>在5.5版本之前，MyISAM是MySQL的默认存储引擎。</p>
<p>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名 为.MYD （MYData）。索引文件的扩展名是.MYI （MYIndex）。</p>
<p>MyISAM文件的格式是平台无关的，这意味着你可以将数据和索引文件从一个intel服务器上拷贝到一台PowerPC或者Sun SPARC上，而不会出任何问题。</p>
<p>该存储引擎并发性差，不支持事务，所以使用场景比较少，主要特点为：</p>
<ul>
<li>不支持事务</li>
<li>不支持外键，如果强行增加外键，不会提示错误，只是外键不起作用</li>
<li>对数据的查询缓存只会缓存索引，不会像InnoDB一样缓存数据，而且是利用操作系统本身的缓存</li>
<li>默认的锁粒度为表级锁，所以并发度很差，加锁快，锁冲突较少，所以不太容易发生死锁</li>
<li>支持全文索引（MySQL5.6之后，InnoDB存储引擎也对全文索引做了支持），但是MySQL的全文索引基本不会使用，对于全文索引，现在有其他成熟的解决方案，比如：ElasticSearch，Solr，Sphinx等</li>
<li>数据库所在主机如果宕机，MyISAM的数据文件容易损坏，而且难恢复</li>
</ul>
<h3 id="innodb存储引擎"> InnoDB存储引擎</h3>
<p>从MySQL5.5版本之后，MySQL的默认内置存储引擎已经是InnoDB了，它的主要特点有：</p>
<ul>
<li>灾难恢复性比较好</li>
<li>支持事务,默认的事务隔离级别为可重复度，通过MVCC（并发版本控制）来实现的</li>
<li>使用的锁粒度为行级锁，可以支持更高的并发</li>
<li>支持外键</li>
<li>配合一些热备工具可以支持在线热备份</li>
<li>在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度</li>
<li>对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上；</li>
</ul>
<blockquote>
<p>独享表空间：使用 .ibd 文件来存放数据，且每一张 InnoDB 表对应一个 .ibd 文件，文件存放在所属数据库的目录下。</p>
<p>共享表空间：使用 .ibdata 文件，所有表共同使用一个（或多个，自行配置）.ibdata 文件。</p>
<p>配置：innodb_file_per_table 参数</p>
<p>根据版本不同，默认参数不同</p>
</blockquote>
<h3 id="memory存储引擎"> MEMORY存储引擎</h3>
<p>将数据存在内存中，和市场上的Redis，memcached等思想类似，为了提高数据的访问速度，主要特点：</p>
<ul>
<li>支持的数据类型有限制，比如：不支持TEXT和BLOB类型，对于字符串类型的数据，只支持固定长度的行，VARCHAR会被自动存储为CHAR类型</li>
<li>支持的锁粒度为表级锁。所以，在访问量比较大时，表级锁会成为MEMORY存储引擎的瓶颈</li>
<li>由于数据是存放在内存中，所以在服务器重启之后，所有数据都会丢失；</li>
<li>查询的时候，如果有用到临时表，而且临时表中有BLOB，TEXT类型的字段，那么这个临时表就会转化为MyISAM类型的表，性能会急剧降低</li>
</ul>
<h3 id="archive存储引擎"> ARCHIVE存储引擎</h3>
<p>ARCHIVE存储引擎适合的场景有限，由于其支持压缩，故主要是用来做日志，流水等数据的归档，主要特点：</p>
<ul>
<li>支持Zlib压缩，数据在插入表之前，会先被压缩</li>
<li>仅支持SELECT和INSERT操作，存入的数据就只能查询，不能做修改和删除</li>
<li>只支持自增键上的索引，不支持其他索引</li>
</ul>
<h3 id="csv存储引擎"> CSV存储引擎</h3>
<p>数据中转试用，主要特点：</p>
<ul>
<li>其数据格式为.csv格式的文本，可以直接编辑保存</li>
<li>导入导出比较方便，可以将某个表中的数据直接导出为csv，试用Excel办公软件打开；</li>
</ul>
<h2 id="myisam和innodb的主要区别"> MyISAM和InnoDB的主要区别</h2>
<ul>
<li>MyISAM锁的粒度是表级，而InnoDB支持行级锁定
<ul>
<li>由于锁粒度的不同，InnoDB比MyISAM支持更高的并发</li>
<li>InnoDB相对于MyISAM来说，更容易发生死锁，锁冲突的概率更大，而且上锁的开销也更大，因为需要为每一行加锁</li>
</ul>
</li>
<li>在备份容灾上，InnoDB支持在线热备，有很成熟的在线热备解决方案</li>
<li>查询性能上，MyISAM的查询效率高于InnoDB，因为InnoDB在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中定位到要查找的行；而MyISAM可以直接定位到数据所在的内存地址，可以直接找到数据</li>
<li>MyISAM的表结构文件包括：.frm(表结构定义),.MYI(索引),.MYD(数据)；而InnoDB的表数据文件为:.ibd（数据）和.frm(表结构定义)</li>
<li>MyISAM是非事务安全型的，而InnoDB是事务安全型的。</li>
<li>MyISAM支持全文类型索引，而InnoDB不支持全文索引。</li>
<li>MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。</li>
</ul>
<h2 id="如何选择合适的存储引擎"> 如何选择合适的存储引擎</h2>
<p>1、使用场景是否需要事务支持；
2、是否需要支持高并发，InnoDB的并发度远高于MyISAM；
3、是否需要支持外键；
4、是否需要支持在线热备；
5、高效缓冲数据，InnoDB对数据和索引都做了缓冲，而MyISAM只缓冲了索引；
6、索引，不同存储引擎的索引并不太一样；</p>
<blockquote>
<p>参考链接：https://segmentfault.com/a/1190000019400925</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">6 用户权限和访问控制</title>
    <id>https://clay-wangzhi.com/db/mysql/user-contr/</id>
    <link href="https://clay-wangzhi.com/db/mysql/user-contr/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_6-用户权限和访问控制"> 6 用户权限和访问控制</h1>
<h2 id="_1-用户"> 1 用户</h2>
<h3 id="_1-1-创建用户并设置密码"> 1.1 创建用户并设置密码</h3>
<div><pre><code>create user aa@localhost identified by &#39;123&#39;;//本地用户
create user aa@&#39;%&#39; identified by &#39;123&#39;; //其他远程用户
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_1-2-重命名用户"> 1.2 重命名用户</h3>
<div><pre><code>rename user &#39;test3&#39;@&#39;%&#39; to &#39;test1&#39;@&#39;%&#39;;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_1-3-删除用户"> 1.3 删除用户</h3>
<div><pre><code>drop user &#39;testUser&#39;@&#39;%&#39;;
</code></pre>
<div><span>1</span><br></div></div><h2 id="_2-权限"> 2 权限</h2>
<h3 id="_2-1-授予权限"> 2.1 授予权限</h3>
<div><pre><code>grant 权限 on 库.表 to 用户@主机 identified by &#39;密码&#39;；grant 权限 on 库.表 to 用户@主机 identified by &#39;密码&#39;；
grant all on *.* to &#39;testUser&#39;@&#39;%&#39; identified by &#39;123&#39;;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="_2-1-1-查询、插入、更新、删除的权限"> 2.1.1 查询、插入、更新、删除的权限</h4>
<div><pre><code>grant select on testdb.* to &#39;testUser&#39;@&#39;%&#39;;  
grant insert on testdb.* to &#39;testUser&#39;@&#39;%&#39;;  #其中*第通配符，表示所有
grant update on testdb.* to &#39;testUser&#39;@&#39;%&#39;;
grant delete on testdb.* to &#39;testUser&#39;@&#39;%&#39;;

#总结成一条命令
grant select,insert,update,delete on testdb.* to &#39;testUser&#39;@&#39;%&#39;;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="_2-1-2-创建和删除表、索引、视图、存储过程的权限"> 2.1.2 创建和删除表、索引、视图、存储过程的权限</h4>
<div><pre><code>grant create on testdb.* to &#39;testUser&#39;@&#39;%&#39;;  #其中*第通配符，表示所有
grant alter on testdb.* to &#39;testUser&#39;@&#39;%&#39;;
grant drop on testdb.* to &#39;testUser&#39;@&#39;%&#39;;

#总结成一条命令
grant create,alter,drop on testdb.* to &#39;testUser&#39;@&#39;%&#39;;

#外键权限
grant reference on testdb.* to &#39;testUser&#39;@&#39;%&#39;;

#索引权限
grant index on testdb.* to &#39;testUser&#39;@&#39;%&#39;;

#视图权限
grant create view on testdb.* to &#39;testUser&#39;@&#39;%&#39;;
grant show view on testdb.* to &#39;testUser&#39;@&#39;%&#39;;

#存储过程权限
grant create routine on testdb.* to &#39;testUser&#39;@&#39;%&#39;;
grant alter routine on testdb.* to &#39;testUser&#39;@&#39;%&#39;;
grant execute on testdb.* to &#39;testUser&#39;@&#39;%&#39;;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h4 id="_2-1-3-指定用户管理数据库的权限"> 2.1.3 指定用户管理数据库的权限</h4>
<div><pre><code>#仅管理testdb数据库
grant all privileges on testdb.* to &#39;testUser&#39;@&#39;%&#39;;

#管理所有数据库
grant all privileges on *.* to &#39;testUser&#39;@&#39;%&#39;;
#其中privileges关键字可省略
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_2-2-权限的作用层次"> 2.2 权限的作用层次</h3>
<h4 id="_2-2-1-作用在整个mysql服务器上"> 2.2.1 作用在整个MySQL服务器上</h4>
<div><pre><code>grant all privileges on *.* to &#39;testUser&#39;@&#39;%&#39;;
</code></pre>
<div><span>1</span><br></div></div><h4 id="_2-2-2-作用在单个数据库上"> 2.2.2 作用在单个数据库上</h4>
<div><pre><code>grant all privileges on testdb.* to &#39;testUser&#39;@&#39;%&#39;;
</code></pre>
<div><span>1</span><br></div></div><h4 id="_2-2-3-作用在单个数据表上"> 2.2.3 作用在单个数据表上</h4>
<div><pre><code>grant all privileges on testdb.testTable to &#39;testUser&#39;@&#39;%&#39;;
</code></pre>
<div><span>1</span><br></div></div><h4 id="_2-2-4-作用在单个数据表的若干个列上"> 2.2.4 作用在单个数据表的若干个列上</h4>
<div><pre><code>grant select(id, name, home, phone) on testdb.testTable to &#39;testUser&#39;@&#39;%&#39;; #select可以改其他，字段根据实际修改
</code></pre>
<div><span>1</span><br></div></div><h4 id="_2-2-5-作用在存储过程、函数上"> 2.2.5 作用在存储过程、函数上</h4>
<div><pre><code>grant execute on procedure testdb.tsetfunc to &#39;testUser&#39;@&#39;%&#39;;
grant execute on function testdb.tsetfunc to &#39;testUser&#39;@&#39;%&#39;;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_2-3-权限刷新"> 2.3 权限刷新</h3>
<div><pre><code>flush privileges;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_2-4-查看权限"> 2.4 查看权限</h3>
<div><pre><code>#查看当前用户的权限
show grants;

#查看mysql中其他用户的权限
show grants for &#39;testUser&#39;@&#39;%&#39;;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_2-5-移除权限"> 2.5 移除权限</h3>
<div><pre><code>revoke 权限 on 库.表 from 用户@主机;
revoke all on *.* from &#39;testUser&#39;@&#39;%&#39;;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_2-6-mysql授权表"> 2.6 mysql授权表</h3>
<p>mysql授权表共有5个表：user、db、host、tables_priv和columns_priv。</p>
<h4 id="_2-6-1-user表"> 2.6.1 user表</h4>
<p>user表列出可以连接服务器的用户及其口令，并且它指定他们有哪种全局（超级用户）权限。在user表启用的任何权限均是全局权限，并适用于所有数据库。</p>
<h4 id="_2-6-2-db表"> 2.6.2 db表</h4>
<p>db表列出数据库，用户有权限访问它们。在这里指定的权限适用于一个数据库中的所有表。</p>
<h4 id="_2-6-2-host表"> 2.6.2 host表</h4>
<p>host表与db表结合使用在一个较好层次上控制特定主机对数据库的访问权限，这可能比单独使用db好些。这个表不受GRANT和REVOKE语句的影响，所以，你可能发觉你根本不是用它。</p>
<h4 id="_2-6-3-tables-priv表"> 2.6.3 tables_priv表</h4>
<p>tables_priv表指定表级权限，在这里指定的一个权限适用于一个表的所有列。</p>
<h4 id="_2-6-4-columns-priv表"> 2.6.4 columns_priv表</h4>
<p>columns_priv表指定列级权限。这里指定的权限适用于一个表的特定列。</p>
<h3 id="_2-7-注意事项"> 2.7 注意事项</h3>
<p>grant, revoke 用户权限后，该用户只有重新连接 MySQL 数据库，权限才能生效。</p>
<p>如果想让授权的用户，也可以将这些权限 grant 给其他用户，需要选项 <code>grant option</code></p>
<div><pre><code>grant all on testdb.* to &#39;testUser&#39;@&#39;%&#39; with grant option;
</code></pre>
<div><span>1</span><br></div></div><h2 id="_3-密码"> 3 密码</h2>
<h3 id="_3-1-修改密码"> 3.1 修改密码</h3>
<h4 id="_3-1-1-更新mysql-user表"> 3.1.1 更新mysql.user表</h4>
<div><pre><code># mysql5.7之前
update user set password=password(&#39;123456&#39;) where user=&#39;root&#39;;
# mysql5.7之后
update user set authentication_string=password(&#39;123456&#39;) where user=&#39;root&#39;;
flush privileges;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="_3-1-2-用set-password命令"> 3.1.2 用set password命令</h4>
<p>**语法：**set password for ‘用户名'@'登录地址'=password(‘密码')</p>
<div><pre><code>set password for &#39;root&#39;@&#39;localhost&#39;=password(&#39;123456&#39;);
</code></pre>
<div><span>1</span><br></div></div><h4 id="_3-1-3-mysqladmin"> 3.1.3 mysqladmin</h4>
<p>**语法：**mysqladmin -u用户名 -p旧的密码 password 新密码</p>
<div><pre><code>mysqladmin -uroot -p123456 password 1234abcd
</code></pre>
<div><span>1</span><br></div></div><h3 id="_3-2-忘记密码"> 3.2 忘记密码</h3>
<h4 id="_3-2-1-跳过授权"> 3.2.1 跳过授权</h4>
<p><code>vim /etc/my.cnf</code></p>
<div><pre><code>[mysqld]
skip-grant-tables
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="_3-2-2-重启服务"> 3.2.2 重启服务</h4>
<div><pre><code>service mysqld restart
</code></pre>
<div><span>1</span><br></div></div><h4 id="_3-2-3-修改密码"> 3.2.3 修改密码</h4>
<p>此时在终端用mysql命令登录时不需要用户密码，然后按照修改密码的第一种方式将密码修改即可。</p>
<h4 id="_3-2-4-还原登录权限跳过检查配置"> 3.2.4 还原登录权限跳过检查配置</h4>
<p>将my.cnf中mysqld节点的skip-grant-tables配置删除，然后重新启动服务即可。</p>
<blockquote>
<p>参考链接：</p>
<p>https://blog.csdn.net/a791693310/article/details/81083864</p>
<p>https://www.jb51.net/article/87979.htm</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">4 视图、事务、索引、函数</title>
    <id>https://clay-wangzhi.com/db/mysql/view-func/</id>
    <link href="https://clay-wangzhi.com/db/mysql/view-func/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-视图、事务、索引、函数"> 4 视图、事务、索引、函数</h1>
<h2 id="_1-视图【view】"> 1 视图【view】</h2>
<p>1、	视图是一张虚拟表，它表示一张表的部分或多张表的综合的结构。</p>
<p>2、	视图仅仅是表结构，没有表数据。视图的结构和数据建立在表的基础上。</p>
<h3 id="_1-1-创建视图"> 1.1 创建视图</h3>
<p>语法</p>
<div><pre><code>create [or replace] view 视图的名称
as
	select语句;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例题：</p>
<div><pre><code>mysql&gt; create view vw_stu
    -&gt; as
    -&gt; select stuname,stusex,writtenexam,labexam from stuinfo inner join stumarks using(stuno);
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code>多学一招：因为视图是一个表结构，所以创建视图后，会在数据库文件夹中多一个与视图名同名的.frm文件
</code></pre>
<div><span>1</span><br></div></div><h3 id="_1-2-使用视图"> 1.2 使用视图</h3>
<p>视图是一张虚拟表，视图的用法和表的用法一样的</p>
<div><pre><code>mysql&gt; select * from vw_stu;
+----------+--------+-------------+---------+
| stuname  | stusex | writtenexam | labexam |
+----------+--------+-------------+---------+
| 李斯文        | 女      |          80 |      58 |
| 李文才        | 男       |          50 |      90 |
| 欧阳俊雄        | 男       |          65 |      50 |
| 张秋丽         | 男       |          77 |      82 |
| 争青小子        | 男       |          56 |      48 |
+----------+--------+-------------+---------+

mysql&gt; update vw_stu set writtenexam=88 where stuname=&#39;李斯文&#39;;
Query OK, 1 row affected (0.05 sec)
Rows matched: 1  Changed: 1  Warnings: 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="_1-3-查看视图的结构"> 1.3 查看视图的结构</h3>
<p>语法：</p>
<div><pre><code>desc 视图名;
</code></pre>
<div><span>1</span><br></div></div><p>例题</p>
<div><pre><code>mysql&gt; desc vw_stu;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| stuname     | varchar(10) | NO   |     | NULL    |       |
| stusex      | char(2)     | NO   |     | NULL    |       |
| writtenexam | int(11)     | YES  |     | NULL    |       |
| labexam     | int(11)     | YES  |     | NULL    |       |
+-------------+-------------+------+-----+---------+-------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="_1-4-查看创建视图的语法"> 1.4 查看创建视图的语法</h3>
<p>语法：</p>
<div><pre><code>show create view 视图名
</code></pre>
<div><span>1</span><br></div></div><p>例题</p>
<p><img src="./images/1537067071676.png" alt="1537067071676" /></p>
<h3 id="_1-5-显示所有视图"> 1.5 显示所有视图</h3>
<div><pre><code> #方法一：
mysql&gt; show tables;
+------------------+
| Tables_in_itcast |
+------------------+
| stu              |
| stuinfo          |
| stumarks         |
| t1               |
| t2               |
| vw_stu           |

# 方法二
mysql&gt; select table_name from information_schema.views;
+------------+
| table_name |
+------------+
| vw_stu     |
+------------+
1 row in set (0.05 sec)
+------------------+

#方法三
mysql&gt; show table status where comment=&#39;view&#39; \G
*************************** 1. row ***************************
           Name: vw_stu
         Engine: NULL
        Version: NULL
     Row_format: NULL
           Rows: NULL
 Avg_row_length: NULL
    Data_length: NULL
Max_data_length: NULL
   Index_length: NULL
      Data_free: NULL
 Auto_increment: NULL
    Create_time: NULL
    Update_time: NULL
     Check_time: NULL
      Collation: NULL
       Checksum: NULL
 Create_options: NULL
        Comment: VIEW
1 row in set (0.00 sec)

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h3 id="_1-6-更改视图"> 1.6 更改视图</h3>
<p>语法：</p>
<div><pre><code>alter view 视图名
as
	select 语句
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例题：</p>
<div><pre><code>mysql&gt; alter view vw_stu
    -&gt; as
    -&gt; select * from stuinfo;
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_1-7-删除视图"> 1.7 删除视图</h3>
<p>语法：</p>
<div><pre><code>drop view [if exists] 视图1,视图2,…
</code></pre>
<div><span>1</span><br></div></div><p>例题</p>
<div><pre><code>mysql&gt; drop view vw_stu;
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_1-8-视图的作用"> 1.8 视图的作用</h3>
<ol>
<li>
<p>筛选数据，防止未经许可访问敏感数据</p>
</li>
<li>
<p>隐藏表结构</p>
</li>
<li>
<p>降低SQL语句的复杂度</p>
</li>
</ol>
<h3 id="_1-9视图的算法"> 1.9	视图的算法</h3>
<p>场景：找出语文成绩最高的男生和女生</p>
<div><pre><code>mysql&gt; select * from (select * from stu order by ch desc) as t group by stusex;
+--------+----------+--------+--------+---------+------------+------+------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+----------+--------+--------+---------+------------+------+------+
| s25321 | Tabm     | 女      |     23 |       9 | 河北          |   88 |   77 |
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           |   86 |   92 |
+--------+----------+--------+--------+---------+------------+------+------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>我们可以将子查询封装到视图中</p>
<div><pre><code>mysql&gt; create view vw_stu
    -&gt; as
    -&gt; select * from stu order by ch desc;
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可以将上面的子查询更改成视图，但是，结果和上面不一样</p>
<div><pre><code>mysql&gt; select * from vw_stu group by stusex;
+--------+---------+--------+--------+---------+------------+------+------+
| stuNo  | stuName | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+---------+--------+--------+---------+------------+------+------+
| s25301 | 张秋丽        | 男       |     18 |       1 | 北京           |   80 | NULL |
| s25303 | 李斯文       | 女      |     22 |       2 | 北京           |   55 |   82 |
+--------+---------+--------+--------+---------+------------+------+------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>原因：这是因为视图的算法造成的</p>
<div><pre><code>1. merge：合并算法，将视图的语句和外层的语句合并后在执行。
2. temptable：临时表算法，将视图生成一个临时表，再执行外层语句
3. undefined：未定义，MySQL到底用merge还是用temptable由MySQL决定，这是一个默认的算法，一般视图都会选择merge算法，因为merge效率高。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>解决：在创建视图的时候指定视图的算法</p>
<div><pre><code>create algorithm=temptable view 视图名
as
	select 语句
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>指定算法创建视图</p>
<div><pre><code>mysql&gt; create algorithm=temptable view vw_stu
    -&gt; as
    -&gt;  select * from stu order by ch desc;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from vw_stu group by stusex;   # 结果是一致的
+--------+----------+--------+--------+---------+------------+------+------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+----------+--------+--------+---------+------------+------+------+
| s25321 | Tabm     | 女      |     23 |       9 | 河北          |   88 |   77 |
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           |   86 |   92 |
+--------+----------+--------+--------+---------+------------+------+------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="_2-事务【transaction】"> 2 事务【transaction】</h2>
<ol>
<li>事务是一个不可分割的执行单元</li>
<li>事务作为一个整体要么一起执行，要么一起回滚</li>
</ol>
<p>插入测试数据</p>
<div><pre><code>mysql&gt; create table bank(
    -&gt; cardid char(4) primary key,
    -&gt; money int
    -&gt; );
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into bank values (&#39;1001&#39;,1000),(&#39;1002&#39;,100);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="_2-1-事务操作"> 2.1 事务操作</h3>
<div><pre><code>开启事务：start transaction或begin [work]
提交事务：commit
回滚事务：rollback
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例题：</p>
<div><pre><code>mysql&gt; delimiter //            # 更改定界符

mysql&gt; start transaction;			# 开启事务
    -&gt; update bank set money=money-100 where cardid=&#39;1001&#39;;
    -&gt; update bank set money=money+100 where cardid=&#39;1002&#39;  //
Query OK, 0 rows affected (0.00 sec)

mysql&gt; commit //   # 提交事务

mysql&gt; rollback //  # 回滚事务
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>思考：事务什么时候产生？什么时候结束？
答：开启的时候产生，提交事务或回滚事务都结束

脚下留心：只有innodb和BDB才支持事务，myisam不支持事务。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_2-2-设置事务的回滚点"> 2.2 设置事务的回滚点</h3>
<p>语法：</p>
<div><pre><code>设置回滚点： savepoint 回滚点名
回滚到回滚点： rollback to 回滚点
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>例题：</p>
<div><pre><code>mysql&gt;  start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into bank values (&#39;1003&#39;,1000);
Query OK, 1 row affected (0.00 sec)

mysql&gt; savepoint aa;    # 设置回滚点 aa
Query OK, 0 rows affected (0.00 sec)

mysql&gt; insert into bank values (&#39;1004&#39;,500);
Query OK, 1 row affected (0.00 sec)
 
mysql&gt; savepoint bb;   # 设置回滚点bb
Query OK, 0 rows affected (0.00 sec)
 
mysql&gt; rollback to aa;    # 回滚到aa点
Query OK, 0 rows affected (0.00 sec)

mysql&gt; commit;    # 提交事务

mysql&gt; select * from bank ;
+--------+-------+
| cardid | money |
+--------+-------+
| 1001   |   800 |
| 1002   |   200 |
| 1003   |  1000 |
+--------+-------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id="_2-3-事务的特性-acid"> 2.3 事务的特性（ACID）</h3>
<ol>
<li>原子性（Atomicity）：事务是一个整体，不可以再分，要么一起执行，要么一起不执行。</li>
<li>一致性（Consistency）：事务完成时，数据必须处于一致的状态。</li>
<li>隔离性（Isolation）：每个事务都是相互隔离的</li>
<li>永久性（Durability）：事务完成后，对数据的修改是永久性的。</li>
</ol>
<h2 id="_3-索引【index】"> 3 索引【index】</h2>
<p>索引的优点：查询速度快</p>
<p>索引的缺点：</p>
<ol>
<li>增、删、改（数据操作语句）效率低了</li>
<li>索引占用空间</li>
</ol>
<h3 id="_3-1索引的类型"> 3.1	索引的类型</h3>
<ol>
<li>
<p>普通索引</p>
</li>
<li>
<p>唯一索引（唯一键）</p>
</li>
<li>
<p>主键索引：只要主键就自动创建主键索引，不需要手动创建。</p>
</li>
<li>
<p>全文索引，搜索引擎使用，MySQL不支持中文的全文索引，我们通过sphinx去解决中文的全文索引。</p>
</li>
</ol>
<h3 id="_3-2创建普通索引【create-index】"> 3.2	创建普通索引【create index】</h3>
<p>语法：</p>
<div><pre><code>create index [索引名] on 表名 （字段名）
alter table 表名 add index [索引的名称] （列名）
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>例题：</p>
<div><pre><code># 创建索引方法一
mysql&gt; create index ix_stuname on stuinfo(stuname);
Query OK, 0 rows affected (0.08 sec)
Records: 0  Duplicates: 0  Warnings: 0

# 创建索引方法二
mysql&gt; alter table stuinfo add index ix_address (stuaddress);
Query OK, 0 rows affected (0.08 sec)
Records: 0  Duplicates: 0  Warnings: 0

# 创建表的时候就添加索引
mysql&gt; create table emp(
    -&gt; id int,
    -&gt; name varchar(10),
    -&gt; index ix_name (name)   # 创建索引
    -&gt; );
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="_3-3创建唯一索引"> 3.3	创建唯一索引</h3>
<div><pre><code>语法一：create unique index 索引名 on 表名 （字段名）
语法二：alter table 表名 add unqiue [index] [索引的名称] （列名）
语法三：创建表的时候添加唯一索引，和创建唯一键是一样的。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例题</p>
<div><pre><code># 方法一：
mysql&gt; create unique index UQ_stuname on stu(stuname);
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0

# 方法二：
mysql&gt; alter table stu add unique UQ_address (stuaddress);
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

# 方法三
mysql&gt; create table stu2(
    -&gt; id int,
    -&gt; name varchar(20),
    -&gt; unique UQ_name(name)
    -&gt; );
Query OK, 0 rows affected (0.01 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="_3-4删除索引"> 3.4	删除索引</h3>
<p>语法</p>
<div><pre><code>drop index 索引名 on 表名
</code></pre>
<div><span>1</span><br></div></div><p>例题</p>
<div><pre><code>mysql&gt; drop index ix_stuname on stuinfo;
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_3-5创建索引的指导原则"> 3.5	创建索引的指导原则</h3>
<ol>
<li>
<p>该列用于频繁搜索</p>
</li>
<li>
<p>改列用于排序</p>
</li>
<li>
<p>公共字段要创建索引</p>
</li>
<li>
<p>如果表中的数据很少，不需要创建索引。MySQL搜索索引的时间比逐条搜索数据的时间要长。</p>
</li>
<li>
<p>如果一个字段上的数据只有几个不同的值，改字段不适合做索引，比如性别。</p>
</li>
</ol>
<h2 id="_4-函数"> 4  函数</h2>
<h3 id="_4-1-数字类"> 4.1  数字类</h3>
<div><pre><code>mysql&gt; select rand();			# 生成随机数
+---------------------+
| rand()              |
+---------------------+
| 0.18474003969201822 |
+---------------------+
1 row in set (0.00 sec)

mysql&gt; select * from stuinfo order by rand();   # 随机排序

mysql&gt; select * from stuinfo order by rand() limit 2;    # 随机抽两个学生
+--------+----------+--------+--------+---------+------------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress |
+--------+----------+--------+--------+---------+------------+
| s25305 | 诸葛丽丽         | 女      |     23 |       7 | 河南           |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           |
+--------+----------+--------+--------+---------+------------+
2 rows in set (0.00 sec)

mysql&gt; select round(3.5);     #四舍五入
+------------+
| round(3.5) |
+------------+
|          4 |
+------------+
1 row in set (0.00 sec)

mysql&gt; select ceil(3.1);	# 向上取整
+-----------+
| ceil(3.1) |
+-----------+
|         4 |
+-----------+
1 row in set (0.00 sec)

mysql&gt; select floor(3.9);	# 向下取整
+------------+
| floor(3.9) |
+------------+
|          3 |
+------------+
1 row in set (0.00 sec)

mysql&gt; select truncate(3.1415926,3);	# 截取数字
+-----------------------+
| truncate(3.1415926,3) |
+-----------------------+
|                 3.141 |
+-----------------------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h3 id="_4-2-字符串类"> 4.2 字符串类</h3>
<div><pre><code>mysql&gt; select ucase(&#39;i am a boy!&#39;);		# 转成大写
+----------------------+
| ucase(&#39;i am a boy!&#39;) |
+----------------------+
| I AM A BOY!          |
+----------------------+
1 row in set (0.00 sec)

mysql&gt; select lcase(&#39;I Am A Boy!&#39;);		#转成小写
+----------------------+
| lcase(&#39;I Am A Boy!&#39;) |
+----------------------+
| i am a boy!          |
+----------------------+
1 row in set (0.00 sec)

mysql&gt; select left(&#39;abcde&#39;,3);		# 从左边开始截取，截取3个
+-----------------+
| left(&#39;abcde&#39;,3) |
+-----------------+
| abc             |
+-----------------+
1 row in set (0.00 sec)

mysql&gt; select right(&#39;abcde&#39;,3);		# 从右边开始截取，截取3个
+------------------+
| right(&#39;abcde&#39;,3) |
+------------------+
| cde              |
+------------------+
1 row in set (0.00 sec)

mysql&gt; select substring(&#39;abcde&#39;,2,3);	#从第2个位置开始截取，截取3个【位置从1开始】
+------------------------+
| substring(&#39;abcde&#39;,2,3) |
+------------------------+
| bcd                    |
+------------------------+
1 row in set (0.00 sec)

mysql&gt; select concat(&#39;中国&#39;,&#39;上海&#39;);	# 字符串相连
+-----------------------+
| concat(&#39;中国&#39;,&#39;上海&#39;)       |
+-----------------------+
| 中国上海                    |
+-----------------------+
1 row in set (0.00 sec)

mysql&gt; select concat(stuname,&#39;-&#39;,stusex) from stuinfo;  # 将表中的姓名和性别连接起来
+----------------------------+
| concat(stuname,&#39;-&#39;,stusex) |
+----------------------------+
| 张秋丽-男                          |
| 李文才-男                         |
| 李斯文-女                        |
| 欧阳俊雄-男                         |
| 诸葛丽丽-女                         |
| 争青小子-男                         |
| 梅超风-女                        |
+----------------------------+
7 rows in set (0.00 sec)

# coalesce(字段1，字段2)  如果字段1不为空就显示字段1，否则，显示字段2
mysql&gt; select stuname,coalesce(writtenexam,&#39;缺考&#39;),coalesce(labexam,&#39;缺考&#39;) from stuinfo natural left join stumarks;   # 将考试成绩为空的显示为缺考
+----------+------------------------------+--------------------------+
| stuname  | coalesce(writtenexam,&#39;缺考&#39;)    | coalesce(labexam,&#39;缺考&#39;)    |
+----------+------------------------------+--------------------------+
| 张秋丽         | 77                           | 82                       |
| 李文才        | 50                           | 90                       |
| 李斯文        | 88                           | 58                       |
| 欧阳俊雄        | 65                           | 50                       |
| 诸葛丽丽         | 缺考                            | 缺考                        |
| 争青小子        | 56                           | 48                       |
| 梅超风        | 缺考                            | 缺考                        |
+----------+------------------------------+--------------------------+

mysql&gt; select length(&#39;锄禾日当午&#39;);		# 字节长度
+----------------------+
| length(&#39;锄禾日当午&#39;)          |
+----------------------+
|                   10 |
+----------------------+
1 row in set (0.00 sec)

mysql&gt; select char_length(&#39;锄禾日当午&#39;);		# 字符个数
+---------------------------+
| char_length(&#39;锄禾日当午&#39;)          |
+---------------------------+
|                         5 |
+---------------------------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br></div></div><h3 id="_4-3-时间类"> 4.3 时间类</h3>
<div><pre><code>mysql&gt; select unix_timestamp();	#获取时间戳
+------------------+
| unix_timestamp() |
+------------------+
|       1537084508 |
+------------------+
1 row in set (0.00 sec)

mysql&gt; select from_unixtime(unix_timestamp());	# 将时间戳转成年-月-日 小时:分钟:秒的格式
+---------------------------------+
| from_unixtime(unix_timestamp()) |
+---------------------------------+
| 2018-09-16 15:55:56             |
+---------------------------------+
1 row in set (0.00 sec)

mysql&gt; select now();		# 获取当前日期时间
+---------------------+
| now()               |
+---------------------+
| 2018-09-16 15:57:04 |
+---------------------+
1 row in set (0.00 sec)

mysql&gt; select year(now()) 年,month(now()) 月, day(now()) 日,hour(now()) 小,minute(now()) 分钟,second(now()) 秒;
+------+------+------+------+------+------+
| 年     | 月     | 日     | 小时   | 分钟     | 秒     |
+------+------+------+------+------+------+
| 2018 |    9 |   16 |   15 |   59 |   14 |
+------+------+------+------+------+------+
1 row in set (0.00 sec)

mysql&gt; select dayname(now()) 星期,monthname(now()),dayofyear(now()) 本年的第几天;
+--------+------------------+--------------+
| 星期       | monthname(now()) | 本年的第几天           |
+--------+------------------+--------------+
| Sunday | September        |          259 |
+--------+------------------+--------------+
1 row in set (0.00 sec)

mysql&gt; select datediff(now(),&#39;2008-8-8&#39;);	# 日期相减
+----------------------------+
| datediff(now(),&#39;2008-8-8&#39;) |
+----------------------------+
|                       3691 |
+----------------------------+
1 row in set (0.00 sec)

mysql&gt; select convert(now(),date),convert(now(),time);	# 将now()转成日期和时间
+---------------------+---------------------+
| convert(now(),date) | convert(now(),time) |
+---------------------+---------------------+
| 2018-09-16          | 16:07:24            |
+---------------------+---------------------+

mysql&gt; select cast(now() as date),cast(now() as time);   # 将now()转成日期和时间
+---------------------+---------------------+
| cast(now() as date) | cast(now() as time) |
+---------------------+---------------------+
| 2018-09-16          | 16:08:03            |
+---------------------+---------------------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><h3 id="_4-4-加密函数"> 4.4 加密函数</h3>
<div><pre><code>+----------------------------------+------------------------------------------+
| md5(&#39;root&#39;)                      | sha(&#39;root&#39;)                              |
+----------------------------------+------------------------------------------+
| 63a9f0ea7bb98050796b649e85481845 | dc76e9f0c0006e8f919e0c515c66dbba3982f785 |
+----------------------------------+------------------------------------------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_4-5-判断函数"> 4.5 判断函数</h3>
<p>语法</p>
<div><pre><code>if(表达式,值1,值2)
</code></pre>
<div><span>1</span><br></div></div><p>例题：</p>
<div><pre><code>mysql&gt; select if(10%2=0,&#39;偶数&#39;,&#39;奇数&#39;);
+--------------------------+
| if(10%2=0,&#39;偶数&#39;,&#39;奇数&#39;)        |
+--------------------------+
| 偶数                        |
+--------------------------+
1 row in set (0.00 sec)

# 语文和数学都超过60分才通过
mysql&gt; select stuname,ch,math,if(ch&gt;=60 &amp;&amp; math&gt;=60,&#39;通过&#39;,&#39;不通过&#39;) &#39;是否通过&#39; from stu;
+----------+------+------+----------+
| stuname  | ch   | math | 是否通过       |
+----------+------+------+----------+
| 张秋丽         |   80 | NULL | 不通过        |
| 李文才        |   77 |   76 | 通过        |
| 李斯文        |   55 |   82 | 不通过        |
| 欧阳俊雄        | NULL |   74 | 不通过        |
| 诸葛丽丽         |   72 |   56 | 不通过        |
| 争青小子        |   86 |   92 | 通过        |
| 梅超风        |   74 |   67 | 通过        |
| Tom      |   65 |   67 | 通过        |
| Tabm     |   88 |   77 | 通过        |
+----------+------+------+----------+
9 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id="_5-预处理"> 5  预处理</h2>
<p>预编译一次，可以多次执行。用来解决一条SQL语句频繁执行的问题。</p>
<div><pre><code>预处理语句：prepare 预处理名字 from ‘sql语句’
执行预处理：execute 预处理名字 [using 变量]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>例题一：</p>
<div><pre><code>mysql&gt; prepare stmt from &#39;select * from stuinfo&#39;;	# 创建预处理
Query OK, 0 rows affected (0.00 sec)
Statement prepared

mysql&gt; execute stmt;	# 执行预处理
+--------+----------+--------+--------+---------+------------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress |
+--------+----------+--------+--------+---------+------------+
| s25301 | 张秋丽         | 男       |     18 |       1 | 北京           |
| s25302 | 李文才        | 男       |     31 |       3 | 上海          |
| s25303 | 李斯文        | 女      |     22 |       2 | 北京           |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           |
| s25305 | 诸葛丽丽         | 女      |     23 |       7 | 河南           |
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           |
| s25319 | 梅超风        | 女      |     23 |       5 | 河北          |
+--------+----------+--------+--------+---------+------------+
7 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>例题二：传递参数</p>
<div><pre><code>mysql&gt; delimiter // 
mysql&gt; prepare stmt from &#39;select * from stuinfo where stuno=?&#39; // -- ?是位置占位符
Query OK, 0 rows affected (0.00 sec)
Statement prepared

mysql&gt; set @id=&#39;s25301&#39;;       -- 变量以@开头，通过set给变量赋值
    -&gt; execute stmt using @id //  -- 执行预处理，传递参数
Query OK, 0 rows affected (0.00 sec)

+--------+---------+--------+--------+---------+------------+
| stuNo  | stuName | stuSex | stuAge | stuSeat | stuAddress |
+--------+---------+--------+--------+---------+------------+
| s25301 | 张秋丽        | 男       |     18 |       1 | 北京           |
+--------+---------+--------+--------+---------+------------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code>脚下留心：
1、?是位置占位符
2、变量以@开头
3、通过set给变量赋值
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>例题三：传递多个参数</p>
<div><pre><code>mysql&gt; prepare stmt from &#39;select * from stuinfo where stusex=? and stuaddress=?&#39;  //
Query OK, 0 rows affected (0.00 sec)
Statement prepared

mysql&gt; set @sex=&#39;男&#39;;
    -&gt; set @addr=&#39;北京&#39;;
    -&gt; execute stmt using @sex,@addr //
Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

+--------+---------+--------+--------+---------+------------+
| stuNo  | stuName | stuSex | stuAge | stuSeat | stuAddress |
+--------+---------+--------+--------+---------+------------+
| s25301 | 张秋丽        | 男       |     18 |       1 | 北京           |
+--------+---------+--------+--------+---------+------------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="_6-存储过程【procedure】"> 6 存储过程【procedure】</h2>
<h3 id="_6-1-存储过程的优点"> 6.1 存储过程的优点</h3>
<ol>
<li>存储过程可以减少网络流量</li>
<li>允许模块化设计</li>
<li>支持事务</li>
</ol>
<h3 id="_6-2创建存储过程"> 6.2	创建存储过程</h3>
<p>语法：</p>
<div><pre><code>create procedure 存储过程名(参数)
begin
	//sql语句
end;

脚下留心：由于过程中有很多SQL语句，每个语句的结束都要用（；）结束。默认情况下，分号既表示语句结束，又表示向服务器发送SQL语句。我们希望分号仅表示语句的结束，不要将SQL语句发送到服务器执行，通过delimiter来更改结束符。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>例题</p>
<div><pre><code>mysql&gt; delimiter //
mysql&gt; create procedure proc()     -- 创建存储过程
    -&gt; begin
    -&gt; select * from stuinfo;
    -&gt; end //
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_6-3调用存储过程"> 6.3	调用存储过程</h3>
<p>语法：</p>
<div><pre><code>call 存储过程名()
</code></pre>
<div><span>1</span><br></div></div><p>例题：</p>
<div><pre><code>mysql&gt; call proc() //     -- 调用存储过程
+--------+----------+--------+--------+---------+------------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress |
+--------+----------+--------+--------+---------+------------+
| s25301 | 张秋丽         | 男       |     18 |       1 | 北京           |
| s25302 | 李文才        | 男       |     31 |       3 | 上海          |
| s25303 | 李斯文        | 女      |     22 |       2 | 北京           |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           |
| s25305 | 诸葛丽丽         | 女      |     23 |       7 | 河南           |
| s25318 | 争青小子        | 男       |     26 |       6 | 天津           |
| s25319 | 梅超风        | 女      |     23 |       5 | 河北          |
+--------+----------+--------+--------+---------+------------+
7 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="_6-4删除存储过程"> 6.4	删除存储过程</h3>
<p>语法</p>
<div><pre><code>drop procedure [if exists] 存储过程名
</code></pre>
<div><span>1</span><br></div></div><p>例题：</p>
<div><pre><code>mysql&gt; drop procedure proc //    -- 删除存储过程
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_6-5-查看存储过程的信息"> 6.5  查看存储过程的信息</h3>
<div><pre><code>show create procedure 存储过程名\G
</code></pre>
<div><span>1</span><br></div></div><p>例题</p>
<div><pre><code>mysql&gt; show create procedure proc \G
*************************** 1. row ***************************
           Procedure: proc
            sql_mode: STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
    Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `proc`()
begin
select * from stuinfo;
end
character_set_client: gbk
collation_connection: gbk_chinese_ci
  Database Collation: utf8_general_ci
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_6-6-显示所有的存储过程"> 6.6 显示所有的存储过程</h3>
<div><pre><code>mysql&gt; show procedure status \G
</code></pre>
<div><span>1</span><br></div></div><h3 id="_6-7存储过程的参数"> 6.7	存储过程的参数</h3>
<p>存储过程的参数分为：输入参数（in）【默认】，输出参数（out），输入输出参数（inout）</p>
<p>存储过程不能使用return返回值，要返回值只能通过“输出参数”来向外传递值。</p>
<p>例题一：传递学号，获取对应的信息</p>
<div><pre><code>mysql&gt; create procedure proc(in param varchar(10))   -- 输入参数
    -&gt; select * from stuinfo where stuno=param //
Query OK, 0 rows affected (0.00 sec)

mysql&gt; call proc(&#39;s25301&#39;) //
+--------+---------+--------+--------+---------+------------+
| stuNo  | stuName | stuSex | stuAge | stuSeat | stuAddress |
+--------+---------+--------+--------+---------+------------+
| s25301 | 张秋丽        | 男       |     18 |       1 | 北京           |
+--------+---------+--------+--------+---------+------------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>例题二：查找同桌</p>
<div><pre><code>mysql&gt; create procedure proc(name varchar(10))
    -&gt; begin
    -&gt; declare seat tinyint;   -- 声明局部变量
    -&gt; select stuseat into seat from stuinfo where stuname=name;  -- 将座位号保存到变量中
    -&gt; select * from stuinfo where stuseat=seat+1 or stuseat=seat-1;  -- 查找同桌
    -&gt; end //
Query OK, 0 rows affected (0.00 sec)

mysql&gt; call proc(&#39;李文才&#39;) //
+--------+----------+--------+--------+---------+------------+
| stuNo  | stuName  | stuSex | stuAge | stuSeat | stuAddress |
+--------+----------+--------+--------+---------+------------+
| s25303 | 李斯文        | 女      |     22 |       2 | 北京           |
| s25304 | 欧阳俊雄        | 男       |     28 |       4 | 天津           |
+--------+----------+--------+--------+---------+------------+
2 rows in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>强调</p>
<div><pre><code>1、通过declare关键字声明局部变量；全局变量@开头就可以了
2、给变量赋值有两种方法
	方法一：set 变量名=值
	方法二：select 字段 into 变量 from 表 where 条件
3、声明的变量不能与列名同名
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>例题三：输出参数</p>
<div><pre><code>mysql&gt; create procedure proc(num int, out result int)  //out 表示输出参数
    -&gt; begin
    -&gt; set result=num*num;
    -&gt; end //
Query OK, 0 rows affected (0.00 sec)

mysql&gt; call proc(10,@result) //
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select @result //
+---------+
| @result |
+---------+
|     100 |
+---------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>例题四：输入输出参数</p>
<div><pre><code>mysql&gt; create procedure proc(inout num int)  #  inout 表示是输入输出参数
    -&gt; begin
    -&gt; set num=num*num;
    -&gt; end //
Query OK, 0 rows affected (0.00 sec)

mysql&gt; set @num=10;
    -&gt; call proc(@num);
    -&gt; select @num //
Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

+------+
| @num |
+------+
|  100 |
+------+
1 row in set (0.00 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="_7-go连接mysql"> 7 GO连接MySQL</h2>
<ol>
<li>因为Go语言没有提供任何官方数据库驱动，所以需要安装第三方函数库。</li>
<li>由于在github上安装，所以需要安装git软件，安装过程一直点击下一步即可。安装完成后需要配置环境变量</li>
</ol>
<h3 id="_7-1-安装git"> 7.1  安装git</h3>
<p>git软件</p>
<p><img src="./images/1537011074242.png" alt="1537011074242" /></p>
<p>安装完毕后，配置git的环境变量，这样可以使用<code>get</code>的指令</p>
<p><img src="./images/1537094210154.png" alt="1537094210154" /></p>
<h3 id="_7-2-安装数据库驱动"> 7.2  安装数据库驱动</h3>
<p>设置GOPATH的环境变量，这样驱动才会下载到项目根目录中。</p>
<p><img src="./images/1537094342573.png" alt="1537094342573" />****</p>
<p>在cmd命令窗口中输入如下命令安装驱动</p>
<div><pre><code><span>go</span> get github<span>.</span>com<span>/</span><span>go</span><span>-</span>sql<span>-</span>driver<span>/</span>mysql

这一命令会从代码中获取驱动的具体代码，并将这些代码放置到包库中，当需要用到驱动的时候，编译器会把驱动代码与用户编写的代码一同编译。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>安装完毕后，会在GOPATH下看到下载的驱动</p>
<p><img src="./images/1537011722807.png" alt="1537011722807" /></p>
<h3 id="_7-3-连接数据库"> 7.3  连接数据库</h3>
<p>1、在src目录下创建demo.go文件，导入数据库驱动</p>
<div><pre><code><span>import</span> <span>(</span>
	<span>"database/sql"</span>
	<span>_</span> <span>"github.com/go-sql-driver/mysql"</span>
<span>)</span>

注意：程序在操作数据库的时候只需要用到database<span>/</span>sql，而不需要直接使用数据库驱动，所以程序在导入数据库驱动的时候将这个包的名字设置成下划线。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>2、通过sql.open()连接数据库</p>
<div><pre><code>sql.open(驱动名,数据源dsn)(*DB,err)

数据源语法：&quot;用户名:密码@[连接方式](主机名:端口号)/数据库名&quot;

注意：open()在执行时不会真正的与数据库进行连接，只是设置连接数据库需要的参数
ping()方法才是连接数据库
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>3、执行SQL语句</p>
<p>​	创建测试表</p>
<div><pre><code>mysql&gt; create table stu(
    -&gt; id int primary key,
    -&gt; name varchar(10)
    -&gt; );
Query OK, 0 rows affected (0.02 sec)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>操作数据</p>
<div><pre><code>package main

import (
	&quot;database/sql&quot;
	_ &quot;github.com/go-sql-driver/mysql&quot;
	&quot;fmt&quot;
)

func main(){
	//&quot;用户名:密码@[连接方式](主机名:端口号)/数据库名&quot;
	db,_:=sql.Open(&quot;mysql&quot;,&quot;root:root@(127.0.0.1:3306)/itcast&quot;) // 设置连接数据库的参数
	defer db.Close()	//关闭数据库
	err:=db.Ping()		//连接数据库
	if err!=nil{
		fmt.Println(&quot;数据库连接失败&quot;)
		return
	}

	//操作一：执行数据操作语句
	/*
	sql:=&quot;insert into stu values (2,&#39;berry&#39;)&quot;
	result,_:=db.Exec(sql)		//执行SQL语句
	n,_:=result.RowsAffected();	//获取受影响的记录数
	fmt.Println(&quot;受影响的记录数是&quot;,n)
	*/

	//操作二：执行预处理
	/*
	stu:=[2][2] string{{&quot;3&quot;,&quot;ketty&quot;},{&quot;4&quot;,&quot;rose&quot;}}
	stmt,_:=db.Prepare(&quot;insert into stu values (?,?)&quot;)		//获取预处理语句对象
	for _,s:=range stu{
		stmt.Exec(s[0],s[1])			//调用预处理语句
	}
	*/

	//操作三：单行查询
	/*
	var id,name string
	rows:=db.QueryRow(&quot;select * from stu where id=4&quot;)   //获取一行数据
	rows.Scan(&amp;id,&amp;name)		//将rows中的数据存到id,name中
	fmt.Println(id,&quot;--&quot;,name)
	*/

	//操作四：多行查询
	rows,_:=db.Query(&quot;select * from stu&quot;)		//获取所有数据
	var id,name string
	for rows.Next(){		//循环显示所有的数据
		rows.Scan(&amp;id,&amp;name)
		fmt.Println(id,&quot;--&quot;,name)
	}
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h2 id="_8-例题"> 8  例题</h2>
<p>1、	显示地区及每个地区参加考试的人数，并按人数降序排列。</p>
<div><pre><code>select stuaddress,count(writtenexam) c from stuinfo left join stumarks using(stuno) group by stuaddress order by c desc;
</code></pre>
<div><span>1</span><br></div></div><p>2、	显示有学生参加考试的地区</p>
<p>方法一：过滤</p>
<div><pre><code>select stuaddress,count(writtenexam) c from stuinfo left join stumarks using(stuno) group by stuaddress having c&gt;0;
</code></pre>
<div><span>1</span><br></div></div><p>方法二：链接查询</p>
<div><pre><code>select distinct stuaddress c from stuinfo right join stumarks using(stuno) ;
</code></pre>
<div><span>1</span><br></div></div><p>3、	显示男生和女生的人数</p>
<p>方法一：</p>
<div><pre><code>select stusex,count() from stuinfo where stusex=&#39;男&#39; union select stusex,count() from stuinfo where stusex=&#39;女&#39;;
</code></pre>
<div><span>1</span><br></div></div><p>方法二：</p>
<div><pre><code>select sum(stusex=&#39;男&#39;) 男,sum(stusex=&#39;女&#39;) 女 from stuinfo;
</code></pre>
<div><span>1</span><br></div></div><p>4、	显示每个地区的男生和女生和总人数</p>
<div><pre><code>select stuaddress,count(stusex) 总人数, sum(stusex=&#39;男&#39;) 男,sum(stusex=&#39;女&#39;) 女 from stuinfo group by stuaddress
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">hash类型</title>
    <id>https://clay-wangzhi.com/db/redis/operate/hash/</id>
    <link href="https://clay-wangzhi.com/db/redis/operate/hash/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="hash类型"> hash类型</h1>
<p>hash⽤于存储对象
对象的结构为属性、值
值的类型为string</p>
<h2 id="增加、修改"> 增加、修改</h2>
<ul>
<li>设置单个属性</li>
</ul>
<div><pre><code>hset key field value
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>设置多个属性</li>
</ul>
<div><pre><code>hmset key field1 value1 field2 value2 ...
</code></pre>
<div><span>1</span><br></div></div><h2 id="获取"> 获取</h2>
<ul>
<li>获取指定键所有的属性</li>
</ul>
<div><pre><code>hkeys key
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>获取⼀个属性的值</li>
</ul>
<div><pre><code>hget key field
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>获取多个属性的值</li>
</ul>
<div><pre><code>hmget key field1 field2 ...
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>获取所有属性的值</li>
</ul>
<div><pre><code>hvals key
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>获取一个hash有多少个属性</li>
</ul>
<div><pre><code>hlen key
</code></pre>
<div><span>1</span><br></div></div><h2 id="删除"> 删除</h2>
<ul>
<li>删除整个hash键及值，使⽤del命令</li>
<li>删除属性，属性对应的值会被⼀起删除</li>
</ul>
<div><pre><code>hdel key field1 field2 ...
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Redis"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">键命令</title>
    <id>https://clay-wangzhi.com/db/redis/operate/key/</id>
    <link href="https://clay-wangzhi.com/db/redis/operate/key/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="键命令"> 键命令</h1>
<ul>
<li>查找键
参数⽀持正则表达式</li>
</ul>
<div><pre><code>keys pattern
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>判断键是否存在，
如果存在返回1，不存在返回0</li>
</ul>
<div><pre><code>exists key
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>查看键对应的value的类型</li>
</ul>
<div><pre><code>type key
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>删除键</li>
</ul>
<div><pre><code>del key1 key2 ...
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>设置过期时间</li>
</ul>
<p>以秒为单位，如果没有指定过期时间则⼀直存在，直到使⽤DEL移除</p>
<div><pre><code>expire key seconds
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>查看有效时间</li>
</ul>
<p>以秒为单位</p>
<div><pre><code>ttl key
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Redis"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">list类型</title>
    <id>https://clay-wangzhi.com/db/redis/operate/list/</id>
    <link href="https://clay-wangzhi.com/db/redis/operate/list/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="list类型"> list类型</h1>
<ul>
<li>列表的元素类型为string</li>
<li>按照插⼊顺序排序</li>
</ul>
<h2 id="增加"> 增加</h2>
<ul>
<li>在左侧插⼊数据</li>
</ul>
<div><pre><code>lpush key value1 value2 ...
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>在右侧插⼊数据</li>
</ul>
<div><pre><code>rpush key value1 value2 ...
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>在指定元素的前或后插⼊新元素</li>
</ul>
<div><pre><code>linsert key before或after 现有元素 新元素
</code></pre>
<div><span>1</span><br></div></div><h2 id="获取"> 获取</h2>
<ul>
<li>
<p>返回列表⾥指定范围内的元素</p>
</li>
<li>
<p>start、stop为元素的下标索引</p>
</li>
<li>
<p>索引从左侧开始，第⼀个元素为0</p>
</li>
<li>
<p>索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素</p>
</li>
</ul>
<div><pre><code>lrange key start stop
</code></pre>
<div><span>1</span><br></div></div><p>设置指定索引位置的元素值</p>
<p>索引从左侧开始，第⼀个元素为0</p>
<ul>
<li>索引可以是负数，表示尾部开始计数，如-1表示最后⼀个元素</li>
</ul>
<div><pre><code>lset key index value
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>例5：修改键为'a1'的列表中下标为1的元素值为'z'</li>
</ul>
<div><pre><code>lset a1 1 z
</code></pre>
<div><span>1</span><br></div></div><p>删除</p>
<ul>
<li>删除指定元素</li>
<li>将列表中前count次出现的值为value的元素移除</li>
<li>count &gt; 0: 从头往尾移除</li>
<li>count &lt; 0: 从尾往头移除</li>
<li>count = 0: 移除所有</li>
</ul>
<div><pre><code>lrem key count value
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>例6.1：向列表'a2'中加⼊元素'a'、'b'、'a'、'b'、'a'、'b'</li>
</ul>
<div><pre><code>lpush a2 a b a b a b
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>例6.2：从'a2'列表右侧开始删除2个'b'</li>
</ul>
<div><pre><code>lrem a2 -2 b
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>例6.3：查看列表'py12'的所有元素</li>
</ul>
<div><pre><code>lrange a2 0 -1
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Redis"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">set 类型</title>
    <id>https://clay-wangzhi.com/db/redis/operate/set/</id>
    <link href="https://clay-wangzhi.com/db/redis/operate/set/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="set-类型"> set 类型</h1>
<ul>
<li>⽆序集合</li>
<li>元素为string类型</li>
<li>元素具有唯⼀性，不重复</li>
<li>说明：对于集合没有修改操作</li>
</ul>
<p>增加</p>
<ul>
<li>添加元素</li>
</ul>
<div><pre><code>sadd key member1 member2 ...
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>例1：向键'a3'的集合中添加元素'zhangsan'、'lisi'、'wangwu'</li>
</ul>
<div><pre><code>sadd a3 zhangsan sili wangwu
</code></pre>
<div><span>1</span><br></div></div><p>获取</p>
<ul>
<li>返回所有的元素</li>
</ul>
<div><pre><code>smembers key
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>例2：获取键'a3'的集合中所有元素</li>
</ul>
<div><pre><code>smembers a3
</code></pre>
<div><span>1</span><br></div></div><p>删除</p>
<ul>
<li>删除指定元素</li>
</ul>
<div><pre><code>srem key value
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>例3：删除键'a3'的集合中元素'wangwu'</li>
</ul>
<div><pre><code>srem a3 wangwu
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Redis"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">string类型</title>
    <id>https://clay-wangzhi.com/db/redis/operate/string/</id>
    <link href="https://clay-wangzhi.com/db/redis/operate/string/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="string类型"> string类型</h1>
<p>字符串类型是Redis中最为基础的数据存储类型，该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。</p>
<h2 id="保存"> 保存</h2>
<p>如果设置的键不存在则为添加，如果设置的键已经存在则修改</p>
<ul>
<li>设置键值</li>
</ul>
<div><pre><code>set key value
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>设置键值及过期时间，以秒为单位</li>
</ul>
<div><pre><code>setex key seconds value
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>设置多个键值</li>
</ul>
<div><pre><code>mset key1 value1 key2 value2 ...
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>追加值</li>
</ul>
<div><pre><code>append key value
</code></pre>
<div><span>1</span><br></div></div><h2 id="中文乱码问题的解决"> 中文乱码问题的解决</h2>
<p>a) 退出redis客户端</p>
<div><pre><code>Exit
</code></pre>
<div><span>1</span><br></div></div><p>b) 再次进图redis客户端</p>
<div><pre><code>Redis-cli --raw
</code></pre>
<div><span>1</span><br></div></div><h2 id="获取"> 获取</h2>
<ul>
<li>获取：根据键获取值，如果不存在此键则返回nil</li>
</ul>
<div><pre><code>get key
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>根据多个键获取多个值</li>
</ul>
<div><pre><code>mget key1 key2 ...
</code></pre>
<div><span>1</span><br></div></div><h2 id="删除"> 删除</h2>
<p>详⻅下节键的操作，删除键时会将值删除</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Redis"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">zset 类型</title>
    <id>https://clay-wangzhi.com/db/redis/operate/zset/</id>
    <link href="https://clay-wangzhi.com/db/redis/operate/zset/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="zset-类型"> zset 类型</h1>
<ul>
<li>sorted set，有序集合</li>
<li>元素为string类型</li>
<li>元素具有唯⼀性，不重复</li>
<li>每个元素都会关联⼀个double类型的score，表示权重，通过权重将元素从⼩到⼤排序</li>
<li>说明：没有修改操作</li>
</ul>
<p>增加</p>
<ul>
<li>添加</li>
</ul>
<div><pre><code>zadd key score1 member1 score2 member2 ...
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>例1：向键'a4'的集合中添加元素'lisi'、'wangwu'、'zhaoliu'、'zhangsan'，权重分别为4、5、6、3</li>
</ul>
<div><pre><code>zadd a4 4 lisi 5 wangwu 6 zhaoliu 3 zhangsan
</code></pre>
<div><span>1</span><br></div></div><p>获取</p>
<ul>
<li>返回指定范围内的元素</li>
<li>start、stop为元素的下标索引</li>
<li>索引从左侧开始，第⼀个元素为0</li>
<li>索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素</li>
</ul>
<div><pre><code>zrange key start stop
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>例2：获取键'a4'的集合中所有元素</li>
</ul>
<div><pre><code>zrange a4 0 -1
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>返回score值在min和max之间的成员</li>
</ul>
<div><pre><code>zrangebyscore key min max
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>例3：获取键'a4'的集合中权限值在5和6之间的成员</li>
</ul>
<div><pre><code>zrangebyscore a4 5 6
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>返回成员member的score值</li>
</ul>
<div><pre><code>zscore key member
</code></pre>
<div><span>1</span><br></div></div><p>例4：获取键'a4'的集合中元素'zhangsan'的权重</p>
<div><pre><code>zscore a4 zhangsan
</code></pre>
<div><span>1</span><br></div></div><p>删除</p>
<ul>
<li>删除指定元素</li>
</ul>
<div><pre><code>zrem key member1 member2 ...
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>例5：删除集合'a4'中元素'zhangsan'</li>
</ul>
<div><pre><code>zrem a4 zhangsan
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>删除权重在指定范围的元素</li>
</ul>
<div><pre><code>zremrangebyscore key min max
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>例6：删除集合'a4'中权限在5、6之间的元素</li>
</ul>
<div><pre><code>zremrangebyscore a4 5 6
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Redis"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">redis面试题</title>
    <id>https://clay-wangzhi.com/db/redis/qa/</id>
    <link href="https://clay-wangzhi.com/db/redis/qa/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="redis面试题"> redis面试题</h1>
<blockquote>
<p>todo: 添加小林coding的redis相关问题，缓存，穿透，雪崩等</p>
</blockquote>
<h2 id="redis是什么"> Redis是什么</h2>
<p>Redis（Remote Dictionary Server）是C语言开发的一个开源的（遵从BSD协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件。它是一种NoSQL（not-only sql，泛指非关系型数据库）的数据库。</p>
<p>Reidis作为一个内存数据库：</p>
<ul>
<li>性能优秀，数据在内存中，读写速度非常快，支持并发10W QPS</li>
<li>单进程单线程，是线程安全的，采用IO多路复用机制</li>
<li>丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）</li>
<li>支持数据持久化，可以将内存中数据保存在磁盘中，重启时加载</li>
<li>主从复制，哨兵，集群</li>
<li>可以用作分布式锁</li>
<li>可以作为消息中间件使用，支持发布订阅</li>
</ul>
<h2 id="五种类型"> 五种类型</h2>
<ol>
<li>**string是redis最基本的类型，可以理解成与memcache一模一样的类型，一个key对应一个value。**value不仅是string，也可以是数字。string类型是二进制安全的，意思是redis的string类型可以包含任何数据，比如jpg图片或者序列化的对象。string类型的值最大能存储512M。</li>
<li>**Hash是一个键值（key-value）的集合。**redis的hash是一个string的key和value的映射表，Hash特别适合存储对象。常用命令：hget、hset、hgetall等。</li>
<li>**list列表是简单的字符串列表，按照插入顺序排序。**可以添加一个元素到列表的头部（左边）或者尾部（右边）。常用命令：Ipush、rpush、lpop、lrange（获取列表片段）等。</li>
<li>**set是string类型的无序集合。**集合是通过hashtable实现的。set中的元素是没有顺序的，而且是没有重复的。常用命令：sdd、spop、smembers、sunion等。</li>
<li>**zset和set一样是string类型元素的集合，且不允许重复的元素。zset是有序集合。**常用命令：zadd、zrange、zrem、zcard等</li>
</ol>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/redis-640.webp" alt="img" /></p>
<h2 id="为什么单线程的redis这么快"> 为什么单线程的redis这么快</h2>
<ul>
<li>Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的复杂度是O(1)</li>
<li>数据结构简单，对数据操作也简单</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗</li>
<li>使用多路复用IO模型，非阻塞IO</li>
</ul>
<h2 id="redis相比memcached有哪些优势"> Redis相比memcached有哪些优势</h2>
<ul>
<li>存储方式：memecache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。</li>
<li>数据支持类型：memcache对数据类型的支持简单，只支持简单的key-value，而redis支持五种数据类型。</li>
<li>使用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>
<li>value的大小：redis可以达到1GB，而memcache只有1MB。</li>
</ul>
<h2 id="redis的淘汰策略"> Redis的淘汰策略</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1578796973640.webp" alt="img" /></p>
<p>补充一下：Redis4.0加入了LFU(least frequency use)淘汰策略，包括volatile-lfu和allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的KV淘汰。</p>
<h2 id="redis提供了哪几种持久化方式"> Redis提供了哪几种持久化方式</h2>
<ul>
<li>RDB：在指定的时间间隔能对你的数据进行快照存储</li>
<li>AOF：记录每次对服务器写的操作，当服务器重启时，会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</li>
</ul>
<p>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式。</p>
<p>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</p>
<h2 id="如何选择合适的持久化方式"> 如何选择合适的持久化方式</h2>
<p>一般来说，如果想达到足以媲美postgresql的数据安全性，应该同时使用两种持久化功能；</p>
<p>如果非常关心你的数据，但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</p>
<p>AOF将Redis执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能，不知道你是否可以接受。</p>
<p>有很多用户都只使用AOF持久化，但并不推荐这种方式：因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快。</p>
<h2 id="主从复制简介及过程"> 主从复制简介及过程</h2>
<p>主从配置结合哨兵模式能解决单点故障问题，提高redis可用性。从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多个从节点，从而提高响应效率。</p>
<p>主从复制的过程：</p>
<ul>
<li>从节点执行slave of[master IP][master prot]，保存主节点信息</li>
<li>从节点中的定时任务发现从节点信息，建立和主节点的socket连接</li>
<li>从节点发送Ping信号，主节点返回Pong，两遍能互相通信</li>
<li>连接建立后，主节点将所有数据发送给从节点（数据同步）</li>
<li>主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</li>
</ul>
<h2 id="数据同步的过程"> 数据同步的过程</h2>
<p><code>redis2.8</code>之前使用<code>sync [runid] [offset]</code>同步命令；</p>
<p><code>redis2.8</code>之后使用<code>psync [runid] [offset]</code>命令。</p>
<p>两者不同：<code>sync</code>命令仅支持全量复制过程，<code>psync</code>支持全量和部分复制。介绍同步之前，先介绍几个概念：</p>
<ul>
<li><code>runid</code>：每个redis节点启动都会生成唯一uuid，每次redis重启后，<code>runid</code>都会发生变化。</li>
<li><code>offset</code>：主节点和从节点都各自维护自己的主从复制偏移量offset，当主节点有写入命令时，<code>offset=offset+命令的字节长度</code>。从节点在收到主节点发送的命令后，也会增加自己的offset，并把自己的offset发送给主节点。这样，主节点同时保持自己的offset和从节点的offset，通过对比offset来判断主从节点数据是否一致。</li>
<li><code>repl_backlog_size</code>：保存在主节点上的一个固定长度的先进先出队列，默认大小是1MB。
<ul>
<li>主节点发送数据给从节点工程中，主节点还会进行一些写操作，这时候的数据存储在复制缓冲区中。从节点同步主节点数据完成后，主节点将缓冲区的数据继续发送给从节点，用于部分复制。</li>
<li>主节点响应写命令时，不但会把命令发送给从节点，还会写入复制积压缓冲区，用于复制命令丢失的数据补救。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20191222150735579.png" alt="image-20191222150735579" /></p>
<p>上面是psync的执行流程：</p>
<p>从节点发送<code>psync [runid] [offset]</code> 命令，主节点有三种响应：</p>
<ul>
<li>FULLRESYNC：第一次连接，进行全量复制</li>
<li>CONTINUE：进行部分复制</li>
<li>ERR：不支持psync命令，进行全量复制</li>
</ul>
<h2 id="全量复制和部分复制的过程"> 全量复制和部分复制的过程</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1578797079401.webp" alt="img" /></p>
<p>上面是全量复制的流程。主要有以下几步：</p>
<ul>
<li>从节点发送psync ？ -1命令（因为第一次发送，不知道主节点的runid，所以为？，因为是第一次复制，所以offset=-1）。</li>
<li>主节点发现从节点是第一次复制，返回FULLRESYNC {runId} {offset}，runId是主节点的runId，offset是主节点目前的offset。</li>
<li>从节点接收主节点信息后，保存info中。</li>
<li>主节点在发送FULLRESYNC后，启动bgsave命令，生产RDB文件（数据持久化）。</li>
<li>主节点发送RDB文件给从节点。到从节点加载数据完成这段期间主节点的写命令放入缓冲区。</li>
<li>从节点清理自己的数据库数据。</li>
<li>从节点加载RDB文件，将数据保存到自己的数据库中。如果从节点开启了AOF，从节点会异步重写AOF文件。</li>
</ul>
<p>关于部分复制有以下几点说明：</p>
<ul>
<li>部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施，使用<code>psync [runId] [offset]</code>命令实现。当从节点正在复制主节点时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，主节点的复制积压缓冲区将这部分直接发送给从节点，这样就可以保持主从节点复制的一致性。补发的这部分数据一般远远小于全量数据。</li>
<li>主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内的复制积压缓冲区依然可以保存最近一段时间的写命令数据。</li>
<li>当主从连接恢复后，由于从节点之前保存了自己复制的偏移量和主节点的运行ID。因此会把他们当做psync参数发送给主节点，要求进行部分复制。</li>
<li>主节点接收到psync命令后首先核对参数runId是否与自身一致，如果一致，说明之前复制的是当前主节点；之后根据参数offset在复制积压缓冲区中查找，如果offset之后的数据存在，则对从节点发送+continue命令，表示可以进行部分复制。因为缓冲区大小固定，若发生缓冲溢出，则进行全量复制。</li>
<li>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</li>
</ul>
<h2 id="redis有哪几种数据淘汰策略"> Redis有哪几种数据淘汰策略</h2>
<ul>
<li>
<p>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</p>
</li>
<li>
<p>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p>
</li>
<li>
<p>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</p>
</li>
<li>
<p>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</p>
</li>
<li>
<p>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p>
</li>
<li>
<p>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p>
</li>
</ul>
<h2 id="为什么redis需要把所有数据放到内存中"> 为什么Redis需要把所有数据放到内存中</h2>
<p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<h2 id="哨兵有哪些功能"> 哨兵有哪些功能</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1578798554512.webp" alt="img" /></p>
<p>如图，是Redis Sentinel（哨兵）的架构图。Redis Sentinel（哨兵）主要功能包括主节点存活检测、主从运行情况检测、自动故障转移、主从切换。Redis Sentinel最小配置是一主一从。</p>
<p>Redis的Sentinel系统可以用来管理多个Redis服务器，该系统可以执行以下四个任务：</p>
<ul>
<li>监控：不断检查主服务器和从服务器是否正常运行。</li>
<li>通知：当被监控的某个redis服务器出现问题，Sentinel通过API脚本向管理员或者其他应用程序发出通知。</li>
<li>自动故障转移：当主节点不能正常工作时，Sentinel会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样就避免了人工干预。</li>
<li>配置提供者：在Redis Sentinel模式下，客户端应用在初始化时连接的是Sentinel节点集合，从中获取主节点的信息。</li>
</ul>
<h2 id="redis如何设置密码及验证密码"> Redis如何设置密码及验证密码</h2>
<p>设置密码：config set requirepass 123456</p>
<p>授权密码：auth 123456</p>
<h2 id="redis哈希槽的概念"> Redis哈希槽的概念</h2>
<p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<h2 id="redis集群之间是如何复制的"> Redis集群之间是如何复制的</h2>
<p>异步复制</p>
<h2 id="redis集群如何选择数据库"> Redis集群如何选择数据库</h2>
<p>Redis集群目前无法做数据库选择，默认在0数据库。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Redis"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">redis5.0.4集群搭建</title>
    <id>https://clay-wangzhi.com/db/redis/</id>
    <link href="https://clay-wangzhi.com/db/redis/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="redis5-0-4集群搭建"> redis5.0.4集群搭建</h1>
<h3 id="redis5-0新特性"> redis5.0新特性</h3>
<p>Redis 5主要专注于几个重要功能。相比之下Redis 4非常非常专注于操作类型，Redis 5的变化大多是面向用户的。即在现有的基础上增加新的数据类型和操作类型。以下是此版本的主要功能：</p>
<ol>
<li>新的Stream数据类型。[1]</li>
<li>新的Redis模块API：Timers and Cluster API。</li>
<li>RDB现在存储LFU和LRU信息。</li>
<li>集群管理器从Ruby（redis-trib.rb）移植到C代码。可以在redis-cli中。查看redis-cli —cluster help了解更多信息。</li>
<li>新sorted set命令：ZPOPMIN / MAX和阻塞变量。</li>
<li>主动碎片整理V2。</li>
<li>增强HyperLogLog实现。</li>
<li>更好的内存统计报告。</li>
<li>许多带有子命令的命令现在都有一个HELP子命令。</li>
<li>客户经常连接和断开连接时性能更好。</li>
<li>错误修复和改进。</li>
<li>Jemalloc升级到5.1版</li>
</ol>
<p>Redis 4.0大多是5.0的严格子集，应用程序从4.0升级到5.0通常不会碰见问题</p>
<h3 id="集群安装"> 集群安装</h3>
<h4 id="下载"> 下载</h4>
<div><pre><code>mkdir -pv /usr/local/software
cd /usr/local/software
wget http://download.redis.io/releases/redis-5.0.4.tar.gz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="解压编译"> 解压编译</h4>
<div><pre><code>tar -xvf redis-5.0.4.tar.gz -C /usr/local/
cd /usr/local/redis-5.0.4/
make -j 4 &amp;&amp; make install
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="修改相关内核参数"> 修改相关内核参数</h4>
<p>提前做好下面的准备操作，否则redis日志里会有相应报错</p>
<p>打开<code>/etc/sysctl.conf</code>配置文件，追加一下参数</p>
<div><pre><code>net.core.somaxconn = 10240
vm.overcommit_memory = 1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>刷新内参参数，使其生效</p>
<div><pre><code>sysctl -p
</code></pre>
<div><span>1</span><br></div></div><div><pre><code># echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled
# vim /etc/rc.local
echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code># tail -10 /etc/security/limits.conf 
#@faculty        soft    nproc           20
#@faculty        hard    nproc           50
#ftp             hard    nproc           0
#@student        -       maxlogins       4

# End of file
* hard nofile 65535
* soft nofile 65535
* soft nproc 65535
* hard nproc 65535

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h4 id="修改配置文件"> 修改配置文件</h4>
<p>将配置文件修改为</p>
<div><pre><code># egrep -v &quot;^#|^$&quot; /usr/local/redis-5.0.4/redis.conf 
bind 0.0.0.0  #安全起见，尽量用本机ip地址
protected-mode yes
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 0
daemonize yes
supervised no
pidfile /var/run/redis_6379.pid
loglevel notice
logfile &quot;/usr/local/redis-5.0.4/log/redis.log&quot;
databases 16 
always-show-logo yes
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir /usr/local/redis-5.0.4/data
replica-serve-stale-data yes
replica-read-only yes
repl-diskless-sync no
repl-diskless-sync-delay 5
repl-disable-tcp-nodelay no
replica-priority 100
lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
replica-lazy-flush no
appendonly no
appendfilename &quot;appendonly.aof&quot;
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
aof-load-truncated yes
aof-use-rdb-preamble yes
lua-time-limit 5000
cluster-enabled yes
cluster-config-file nodes-6379.conf
slowlog-log-slower-than 10000
slowlog-max-len 128
latency-monitor-threshold 0
notify-keyspace-events Ex
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-size -2
list-compress-depth 0
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
stream-node-max-bytes 4096
stream-node-max-entries 100
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
dynamic-hz yes
aof-rewrite-incremental-fsync yes
rdb-save-incremental-fsync yes
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><blockquote>
<p>线上最好开启密码认证</p>
<p>databases 最好改一下</p>
</blockquote>
<h4 id="开启防火墙"> 开启防火墙</h4>
<div><pre><code># cat /etc/sysconfig/iptables
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 6379 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 16379 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 10050 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT

# systemctl restart iptables
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><hr>
<p>以上步骤均在6台主机上执行</p>
<h4 id="初始化redis集群"> 初始化redis集群</h4>
<div><pre><code>redis-cli --cluster create 192.168.165.23:6379 192.168.165.24:6379 192.168.165.25:6379 192.168.165.26:6379 192.168.165.27:6379 192.168.165.28:6379 --cluster-replicas 1
</code></pre>
<div><span>1</span><br></div></div><p>查看redis集群状态</p>
<div><pre><code># redis-cli 
127.0.0.1:6379&gt; CLUSTER INFO
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_ping_sent:1263
cluster_stats_messages_pong_sent:1190
cluster_stats_messages_sent:2453
cluster_stats_messages_ping_received:1185
cluster_stats_messages_pong_received:1263
cluster_stats_messages_meet_received:5
cluster_stats_messages_received:2453

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="相关操作"> 相关操作</h3>
<h4 id="检查集群"> 检查集群</h4>
<div><pre><code>redis-cli --cluster check 192.168.165.23:6379
</code></pre>
<div><span>1</span><br></div></div><p>查看集群key、slot、slave分布信息</p>
<div><pre><code>redis-cli --cluster info 192.168.165.23:6379
</code></pre>
<div><span>1</span><br></div></div><h4 id="在线迁移槽"> 在线迁移槽</h4>
<ul>
<li>方式1</li>
</ul>
<div><pre><code>redis-cli --cluster reshard 192.168.165.23:6379
</code></pre>
<div><span>1</span><br></div></div><p>选择一个目标节点的id</p>
<p>源选择all</p>
<ul>
<li>方式2</li>
</ul>
<p><strong>将所有master上的slot重新分配到一个master上</strong></p>
<div><pre><code>redis-cli --cluster reshard --cluster-from 3a32aec6092e6a22a45c64fa8281e3893e1175a2 --cluster-to f760e5d366738b28df034512faf1f5ac4466b09e --cluster-slots 5461 --cluster-yes 192.168.165.24:6379
redis-cli --cluster reshard --cluster-from 9fa3ee8869d2d21258e0f2d2b705b787d0342d74 --cluster-to f760e5d366738b28df034512faf1f5ac4466b09e --cluster-slots 5462 --cluster-yes 192.168.165.24:6379
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="平衡各节点槽数量"> 平衡各节点槽数量</h4>
<div><pre><code>redis-cli --cluster rebalance --cluster-threshold 192.168.165.24:6379
</code></pre>
<div><span>1</span><br></div></div><h4 id="删除集群节点"> 删除集群节点</h4>
<div><pre><code>redis-cli --cluster del-node 192.168.165.24:6379 f760e5d366738b28df034512faf1f5ac4466b09e
</code></pre>
<div><span>1</span><br></div></div><p>这里必须是没有槽的节点，所以必须先移除槽，否则报错
被删除的node重启后，依然记得集群中的其它节点，这是需要执行cluster forget nodeid来忘记其它节点</p>
<h4 id="添加集群节点"> 添加集群节点</h4>
<div><pre><code>redis-cli --cluster add-node 192.168.165.30:6379 192.168.165.31:6379
</code></pre>
<div><span>1</span><br></div></div><h4 id="将集群外部redis实例中的数据导入到集群中去"> 将集群外部redis实例中的数据导入到集群中去</h4>
<blockquote>
<p>在redis5中 redis-cli已经集成集群操作的命令， 根本不用把分片迁移到一个节点再操作</p>
</blockquote>
<ol>
<li>把单实例的密码清除</li>
</ol>
<p>把Redis单实例及集群所有节点的密码清理掉，通过如下方式：</p>
<div><pre><code>redis-cli -h [ip] -p [port] -a [pwd]
config set requirepass &quot;&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="2">
<li>执行集群导入命令【redis-cli -- cluster import】</li>
</ol>
<div><pre><code>redis-cli -h 192.168.165.23 -p 6379 --cluster import 192.168.165.23:6379 --cluster-from 192.168.1.46:6379 --cluster-copy --cluster-replace
</code></pre>
<div><span>1</span><br></div></div><p>Cluster-from后面跟外部redis的ip和port
如果只使用cluster-copy，则要导入集群中的key不能在，否则如下：
如果集群中已有同样的key，如果需要替换，可以cluster-copy和cluster-replace联用，这样集群中的key就会被替换为外部的</p>
<ol start="3">
<li>设置回原来的密码</li>
</ol>
<div><pre><code>config set requirepass 原密码
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>注意，如果不清楚密码会报如下错误：
ERR Target instance replied with error: NOAUTH Authentication required.</li>
</ul>
<h4 id="清空集群数据"> 清空集群数据</h4>
<p>redis中数据存储比较多，需要进行清理。我们首先用命令查看集群的主从情况。</p>
<div><pre><code>redis-cli --cluster check 192.168.165.23:6379
</code></pre>
<div><span>1</span><br></div></div><p>连接到每个master 节点上进行数据删除</p>
<p>连接到数据库中，执行如下命令</p>
<div><pre><code>flushall
</code></pre>
<div><span>1</span><br></div></div><p>参考链接：</p>
<blockquote>
<p><a href="https://yangxx.net/?p=3453" target="_blank" rel="noopener noreferrer">https://yangxx.net/?p=3453</a></p>
<p><a href="https://www.jianshu.com/p/7a28d3c92dce" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/7a28d3c92dce</a></p>
<p><a href="https://blog.csdn.net/luoww1/article/details/88425263" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/luoww1/article/details/88425263</a></p>
<p><a href="https://www.cnblogs.com/kevingrace/p/9844310.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/kevingrace/p/9844310.html</a></p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Redis"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">redis-dump方式导入导出数据</title>
    <id>https://clay-wangzhi.com/db/redis/redis-dump/</id>
    <link href="https://clay-wangzhi.com/db/redis/redis-dump/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="redis-dump方式导入导出数据"> redis-dump方式导入导出数据</h1>
<h3 id="安装redis-dump工具"> 安装redis-dump工具</h3>
<p>安装ruby（略）,详见上一章节</p>
<div><pre><code>gem install redis-dump -V
</code></pre>
<div><span>1</span><br></div></div><h3 id="数据导出"> 数据导出</h3>
<p>示例</p>
<div><pre><code>redis-dump -u 127.0.0.1:6379 -a &#39;zykjdr#558996&#39; &gt; test.json
</code></pre>
<div><span>1</span><br></div></div><h3 id="数据导入"> 数据导入</h3>
<p>示例</p>
<div><pre><code>&lt; test.json redis-load -u 127.0.0.1:6379 -a &#39;zykjdr#558996&#39;
</code></pre>
<div><span>1</span><br></div></div><p>导入本机的6379端口，没有密码时，可以写成下面这样</p>
<div><pre><code>&lt; test1.json redis-load
</code></pre>
<div><span>1</span><br></div></div><p><strong>如果报错，请使用-n选项，使用请参考官方，请谨慎使用</strong>！</p>
<p>-n （以二进制形式导入）</p>
<div><pre><code>&lt; test.json redis-load -n 
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Redis"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">centos7安装redis-5.0.0主从</title>
    <id>https://clay-wangzhi.com/db/redis/redis-slave/</id>
    <link href="https://clay-wangzhi.com/db/redis/redis-slave/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="centos7安装redis-5-0-0主从"> centos7安装redis-5.0.0主从</h1>
<h2 id="下载redis-5-0-0安装包"> 下载redis-5.0.0安装包</h2>
<p>从官网下载安装包</p>
<div><pre><code>cd /opt
wget http://download.redis.io/releases/redis-5.0.0.tar.gz
tar -xvf redis-5.0.0.tar.gz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="编译安装"> 编译安装</h2>
<p>安装gcc依赖</p>
<div><pre><code>yum -y install gcc
cd /opt/redis-5.0.0
make -j `grep processor /proc/cpuinfo | wc -l`
make install
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="编辑配置文件"> 编辑配置文件</h2>
<h3 id="主服务器"> 主服务器</h3>
<div><pre><code>cd /opt
mv redis-5.0.0 redis
cd redis
mkdir {conf,log,data}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>vim conf/redis.conf</code>增加以下内容</p>
<p>bind 中的IP地址为服务器IP地址</p>
<div><pre><code>################################## NETWORK #####################################
# 绑定IP地址
bind *.*.*.*

# 5.0新增保护模式
protected-mode yes

# 设置启动端口
port 6379

# tcp最大并发监听数
tcp-backlog 511

#客户端空闲N秒后关闭连接(0禁用)
timeout 0

#向客户机发送TCP ack的沟通，3.2.1以后默认使用300s
tcp-keepalive 300

################################# GENERAL #####################################
# 设置后台启动
daemonize yes

# 没有监督互动
supervised no

# pid文件位置
pidfile /var/run/redis_6379.pid

# 日志等级
loglevel notice

# 日志文件位置
logfile &quot;/opt/redis/log/redis.log&quot;

# 设置数据库的数量
databases 16

# 显示logo
always-show-logo yes

################################ SNAPSHOTTING  ################################
# rdb通过快照方式进行持久化，每个条件之间是“或”的关系
# 15分钟（900秒钟）内至少1个键被更改则进行快照
save 900 1
# 5分钟（300秒）内至少10个键被更改则进行快照
save 300 10
# 1分钟（60秒）内至少10000个键被更改则进行快照
save 60 10000

# 错误停止写入
stop-writes-on-bgsave-error yes

# 数据存储前设置开启压缩
rdbcompression yes

# 对rdb数据进行校验，耗费CPU资源，5.0版本以后可以禁用
rdbchecksum no

# rdb数据转存的文件名称
dbfilename dump.rdb

# 数据存储目录
dir &quot;/opt/redis/data&quot;

################################# REPLICATION #################################
# 设置同步的主节点地址
# replicaof IP 端口 

# 主从同步认证密码
masterauth &quot;&quot;

# 允许从节点正常响应用户的请求
replica-serve-stale-data yes

# 从节点设置为只读
replica-read-only yes

# 同步策略为磁盘方式
repl-diskless-sync no

# socket同步方式的延迟时间
repl-diskless-sync-delay 5

# 是否在slave套接字发送SYNC之后禁用 TCP_NODELAY,如果选择no，数据传输到salve的延迟将会减少但要使用更多的带宽
repl-disable-tcp-nodelay no

# 提升为主节点的优先级，数字越小，优先级越高
replica-priority 100

################################## SECURITY ###################################
# 客户端认证密码设置
requirepass &quot;&quot;

################################### CLIENTS ####################################
# 客户端最大连接数
maxclients 10000

############################## MEMORY MANAGEMENT ################################
# 指定Redis最大内存限制
# maxmemory &lt;bytes&gt;

# 最大内存逐出策略
# maxmemory-policy noeviction

# 用样本量做检测,设置样本量个数
# maxmemory-samples 5

# replica-ignore-maxmemory yes

############################# LAZY FREEING ####################################
lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
replica-lazy-flush no

############################## APPEND ONLY MODE ###############################
# 是否开启AOF备份
appendonly no
appendfilename &quot;appendonly.aof&quot;
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100 
auto-aof-rewrite-min-size 64mb 
aof-load-truncated yes 
aof-use-rdb-preamble yes

################################ LUA SCRIPTING  ###############################
lua-time-limit 5000

################################ REDIS CLUSTER  ###############################
# 略，后续补充

########################## CLUSTER DOCKER/NAT support  ########################
# 略，后续补充

################################## SLOW LOG ###################################
slowlog-log-slower-than 10000
slowlog-max-len 128

################################ REMAINING PART ##############################
latency-monitor-threshold 0
notify-keyspace-events &quot;&quot;
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-size -2
list-compress-depth 0
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
stream-node-max-bytes 4096
stream-node-max-entries 100
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
dynamic-hz yes
aof-rewrite-incremental-fsync yes
rdb-save-incremental-fsync yes
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br></div></div><h3 id="从服务器"> 从服务器</h3>
<p>和主服务器操作相同</p>
<p>改变<code>redis.conf</code>中bind地址</p>
<p>打开<code>replicaof</code>并改为<strong>主服务器地址</strong>即可</p>
<h2 id="启动服务"> 启动服务</h2>
<div><pre><code>cd /opt/redis/src
./redis-server /opt/redis/conf/redis.conf
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Redis"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">centos7安装升级ruby</title>
    <id>https://clay-wangzhi.com/db/redis/ruby-update/</id>
    <link href="https://clay-wangzhi.com/db/redis/ruby-update/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="centos7安装升级ruby"> centos7安装升级ruby</h1>
<p>转载自：<a href="https://blog.csdn.net/qq_26440803/article/details/82717244" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_26440803/article/details/82717244</a></p>
<h3 id="在线安装ruby"> 在线安装ruby</h3>
<div><pre><code>yum -y install ruby
ruby -v
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="添加ruby仓库"> 添加ruby仓库</h3>
<p>添加aliyun镜像</p>
<div><pre><code>gem sources -a http://mirrors.aliyun.com/rubygems/ 
</code></pre>
<div><span>1</span><br></div></div><p>删除原来的镜像</p>
<div><pre><code>gem sources --remove https://rubygems.org/
</code></pre>
<div><span>1</span><br></div></div><p>查看当前镜像源</p>
<div><pre><code>gem sources -l
</code></pre>
<div><span>1</span><br></div></div><h3 id="安装ram"> 安装RAM</h3>
<blockquote>
<p>RAM（<a href="https://rvm.io/" target="_blank" rel="noopener noreferrer">Ruby Version Manager</a> ）是一款RAM的命令行工具，可以使用RAM轻松安装，管理Ruby版本。RVM包含了Ruby的版本管理和Gem库管理(gemset)安装</p>
</blockquote>
<p>安装</p>
<div><pre><code>gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB
curl -sSL https://get.rvm.io | bash -s stable
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>更新配置文件，使其立马生效：</p>
<div><pre><code>source /etc/profile.d/rvm.sh
</code></pre>
<div><span>1</span><br></div></div><p>查看RVM版本信息，如果可以代表安装成功。</p>
<div><pre><code>rvm -v
</code></pre>
<div><span>1</span><br></div></div><p>查看Ruby版本</p>
<div><pre><code>rvm list known
</code></pre>
<div><span>1</span><br></div></div><p>选定版本进行安装</p>
<div><pre><code>rvm install 2.5
</code></pre>
<div><span>1</span><br></div></div><p>验证版本</p>
<div><pre><code>ruby -v
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Redis"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">服务器端和客户端命令</title>
    <id>https://clay-wangzhi.com/db/redis/server-client/</id>
    <link href="https://clay-wangzhi.com/db/redis/server-client/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="服务器端和客户端命令"> 服务器端和客户端命令</h1>
<h2 id="服务器端"> 服务器端</h2>
<p>服务器端的命令为redis-server
可以使⽤help查看帮助⽂档</p>
<div><pre><code>redis-server --help
</code></pre>
<div><span>1</span><br></div></div><p>推荐使⽤服务的⽅式管理redis服务
启动</p>
<div><pre><code>sudo service redis start
</code></pre>
<div><span>1</span><br></div></div><p>停⽌</p>
<div><pre><code>sudo service redis stop
</code></pre>
<div><span>1</span><br></div></div><p>重启</p>
<div><pre><code>sudo service redis restart
</code></pre>
<div><span>1</span><br></div></div><p>个人习惯</p>
<div><pre><code>ps -aux|grep redis //查看redis服务器进程
sudo kill -9 pid //杀死redis服务器
sudo redis-server /etc/redis/redis.conf //指定加载的配置文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="客户端"> 客户端</h2>
<p>客户端的命令为redis-cli
可以使⽤help查看帮助⽂档</p>
<div><pre><code>redis-cli --help
</code></pre>
<div><span>1</span><br></div></div><p>连接redis</p>
<div><pre><code>redis-cli
</code></pre>
<div><span>1</span><br></div></div><p>运⾏测试命令</p>
<div><pre><code>ping //返回PONG
</code></pre>
<div><span>1</span><br></div></div><p>切换数据库
数据库没有名称，默认有16个，通过0-15来标识，连接redis默认选择第一个数据库</p>
<div><pre><code>select n
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Redis"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">git的基本使用</title>
    <id>https://clay-wangzhi.com/git/git-basic/</id>
    <link href="https://clay-wangzhi.com/git/git-basic/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="git的基本使用"> git的基本使用</h1>
<h2 id="由来"> 由来</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/git.png" alt="git" /></p>
<blockquote>
<p>要不说人家是大佬呢，一言不合就自己写一个👍</p>
</blockquote>
<h2 id="安装"> 安装</h2>
<p>下载对应操作系统的 Git 客户端版本 https://git-scm.com/downloads</p>
<h3 id="linux"> Linux</h3>
<p>在<code>centos</code>上安装</p>
<div><pre><code>$ yum <span>install</span> <span>git</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="windows"> windows</h3>
<p>下载对应的32位或者64位版本，点击安装即可</p>
<div><pre><code>$ <span>git</span> --version <span># 查看版本号</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="mac"> Mac</h3>
<p>用<code>homebrew</code>命令安装</p>
<div><pre><code>$ brew <span>install</span> <span>git</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="核心概念"> 核心概念</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/git基本流程.png" alt="git基本流程" /></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Workspace</td>
<td>工作区：<code>.git</code>文件所在的目录就是工作区，一般是项目的根目录</td>
</tr>
<tr>
<td>Index/Stage</td>
<td>暂存区：介于工作区和仓库区之间，暂存修改的</td>
</tr>
<tr>
<td>Repository</td>
<td>仓库区/本地仓库：git初始化后，会在当前目录生成一个<code>.git</code>目录，这就是版本库</td>
</tr>
<tr>
<td>Remote</td>
<td>远程仓库：网络上的另一个版本库，可以和本地库交互</td>
</tr>
</tbody>
</table>
<h3 id="git-的基本工作流程"> git 的基本工作流程</h3>
<ol>
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>
</ol>
<h3 id="git-文件的生命周期"> git 文件的生命周期</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/git文件的生命周期2.png" alt="git文件的生命周期2" /></p>
<ol>
<li>
<p>未追踪的文件（Untracked）在 <code>git add</code> 之后会变成已暂存（staged）状态。</p>
</li>
<li>
<p>未修改的文件（Unmodified）在被修改编辑之后会变成已修改（modified）状态。</p>
</li>
<li>
<p>已修改（modified）的文件在 <code>git add</code>之后会变成已暂存（staged）状态。</p>
</li>
<li>
<p>已暂存的文件（staged）在 <code>git commit</code> 之后会变成未修改（Unmodified）状态。</p>
</li>
<li>
<p>未修改的文件（Unmodified）在 <code>git rm</code> 之后会变成未跟踪（Untracked）状态(注意git rm会删除掉指定的文件)。</p>
</li>
</ol>
<h3 id="git-的三种状态"> git 的三种状态</h3>
<ul>
<li>已修改（modified） 表示修改了文件，但还没保存到数据库中，目前在工作目录（Workspace）</li>
<li>已暂存（staged） 表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中，目前在暂存区域（Index）</li>
<li>已提交（committed） 表示数据已经安全的保存在本地仓库中，目前在本地仓库（Repository）</li>
</ul>
<h3 id="git-的文件分类"> git 的文件分类</h3>
<ul>
<li>追踪的 Tracked，已经加入版本库中的文件</li>
<li>未追踪的 Untracked，未加入到版本库中的，未被管理的文件</li>
<li>忽略的 Ignored， git 不再关注的文件，例如一些临时文件</li>
</ul>
<p><strong><code>.gitignore</code>文件</strong></p>
<p>书写格式规范</p>
<ul>
<li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li>
</ul>
<blockquote>
<p>详解参考 https://github.com/github/gitignore</p>
</blockquote>
<p><strong>glob模式</strong></p>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。</p>
<p>星号（<code>*</code>）匹配零个或多个任意字符；</p>
<p><code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；</p>
<p>问号（<code>?</code>）只匹配一个任意字符；</p>
<p>如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）;</p>
<p>使用两个星号（<code>*</code>) 表示匹配任意中间目录，比如<code>a/**/z</code> 可以匹配 <code>a/z</code>, <code>a/b/z</code> 或 <code>a/b/c/z</code>等。</p>
<h2 id="git基本操作"> git基本操作</h2>
<h3 id="新建代码仓库"> 新建代码仓库</h3>
<div><pre><code><span># 在当前目录新建一个Git代码库</span>
$ <span>git</span> init

<span># 新建一个目录，将其初始化为Git代码库</span>
$ <span>git</span> init <span>[</span>project-name<span>]</span>

<span># 下载一个项目和它的整个代码历史</span>
$ <span>git</span> clone <span>[</span>url<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="设置用户信息"> 设置用户信息</h3>
<p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)</p>
<div><pre><code><span># 设置提交代码时的用户信息</span>
$ <span>git</span> config <span>[</span>--global<span>]</span> user.name <span>"[name]"</span>
$ <span>git</span> config <span>[</span>--global<span>]</span> user.email <span>"[email address]"</span>

<span># 显示当前的Git配置</span>
$ <span>git</span> config --list

<span># 编辑Git配置文件</span>
$ <span>git</span> config -e <span>[</span>--global<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="添加-删除文件"> 添加/删除文件</h3>
<div><pre><code><span># 添加指定文件到暂存区</span>
$ <span>git</span> <span>add</span> <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>.

<span># 添加指定目录到暂存区，包括子目录</span>
$ <span>git</span> <span>add</span> <span>[</span>dir<span>]</span>

<span># 添加当前目录的所有文件到暂存区</span>
$ <span>git</span> <span>add</span> <span>.</span>

<span># 删除工作区文件，并且将这次删除放入暂存区</span>
$ <span>git</span> <span>rm</span> <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>.

<span># 改名文件，并且将这个改名放入暂存区</span>
$ <span>git</span> <span>mv</span> <span>[</span>file-original<span>]</span> <span>[</span>file-renamed<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>
<p>⚠️ 这一步是把文件的当前变化增加到暂存区中，也就是以后这个文件那需要版本库来跟踪管理，注意这不是提交。</p>
</blockquote>
<div><pre><code><span># 将文件从暂存转成未暂存，从版本库中删除，但不删除工作目录的该文件，即文件恢复成不追踪的状态</span>
$ <span>git</span> <span>rm</span> --cached <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="代码提交"> 代码提交</h3>
<p>git的提交分为两个步骤：</p>
<ol>
<li>暂存变更：add作用是把新文件或者文件新的改动添加到一个暂存区stage，也就是加入到index中</li>
<li>提交变更：commit提交的是暂存区中的改动，而不是物理文件目前的改动，提交到当前分支，默认是master</li>
</ol>
<div><pre><code><span># 提交暂存区到仓库区</span>
$ <span>git</span> commit -m <span>[</span>message<span>]</span>

<span># 提交暂存区的指定文件到仓库区</span>
$ <span>git</span> commit <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>. -m <span>[</span>message<span>]</span>

<span># 提交工作区自上次commit之后的变化，直接到仓库区</span>
$ <span>git</span> commit -a

<span># 提交时显示所有diff信息</span>
$ <span>git</span> commit -v

<span># 将add和commit合为一步</span>
$ <span>git</span> commit -am <span>'message'</span>

<span># 使用一次新的commit，替代上一次提交</span>
<span># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span>
$ <span>git</span> commit --amend -m <span>[</span>message<span>]</span>

<span># 重做上一次commit，并包括指定文件的新变化</span>
$ <span>git</span> commit --amend <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="远程同步"> 远程同步</h3>
<div><pre><code><span># 从远程仓库中抓取和拉取， 它并不会自动合并或修改你当前的工作，要手动合并入你的工作</span>
$ <span>git</span> fetch <span>[</span>remote<span>]</span>

<span># 列出所有远程仓库</span>
$ <span>git</span> remote

<span># 详细列出所有远程仓库</span>
$ <span>git</span> remote -v

<span># 显示某个远程仓库的信息</span>
$ <span>git</span> remote show <span>[</span>remote<span>]</span>

<span># 增加一个新的远程仓库，并命名</span>
$ <span>git</span> remote <span>add</span> <span>[</span>shortname<span>]</span> <span>[</span>url<span>]</span>

<span># 取回远程仓库的变化，并与本地分支合并</span>
$ <span>git</span> pull  <span>[</span>remote<span>]</span> <span>[</span>branch<span>]</span>

<span># 上传本地指定分支到远程仓库</span>
<span># -u 第一次远程推送的时候加上，以后就可以不使用 -u 参数，可以 git push origin master,也可以 git push都使用默认</span>
$ <span>git</span> push <span>[</span>-u<span>]</span> <span>[</span>remote<span>]</span> <span>[</span>branch<span>]</span>

<span># 强行推送当前分支到远程仓库，即使有冲突</span>
$ <span>git</span> push <span>[</span>remote<span>]</span> --force

<span># 推送所有分支到远程仓库</span>
$ <span>git</span> push <span>[</span>remote<span>]</span> --all
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><blockquote>
<p>远程版本库名<code>origin</code>，这是个习惯用法，将建立origin和后面url的映射，这些信息保存在<code>.git/config</code>文件的<code>[remote &quot;origin&quot;]</code>端中。</p>
</blockquote>
<p>分支</p>
<h2 id="分支-标签"> 分支/标签</h2>
<h3 id="分支"> 分支</h3>
<div><pre><code><span># 列出所有本地分支</span>
$ <span>git</span> branch

<span># 列出所有远程分支</span>
$ <span>git</span> branch -r

<span># 列出所有本地分支和远程分支</span>
$ <span>git</span> branch -a

<span># 新建一个分支，但依然停留在当前分支</span>
$ <span>git</span> branch <span>[</span>newbranch<span>]</span>

<span># 新建一个本地分支，并切换到该分支</span>
<span># 等价于这两个命令合在一起 git branch newbranch; git checkout newbranch</span>
$ <span>git</span> checkout -b <span>[</span>newbranch<span>]</span>

<span># 新建一个分支，指向指定commit</span>
$ <span>git</span> branch <span>[</span>branch<span>]</span> <span>[</span>commit<span>]</span>

<span># 新建一个分支，与指定的远程分支建立追踪关系</span>
$ <span>git</span> branch --track <span>[</span>branch<span>]</span> <span>[</span>remote-branch<span>]</span>

<span># 切换到指定分支，并更新工作区</span>
$ <span>git</span> checkout <span>[</span>branch-name<span>]</span>

<span># 切换到上一个分支</span>
$ <span>git</span> checkout -

<span># 建立追踪关系，在现有分支与指定的远程分支之间</span>
$ <span>git</span> branch --set-upstream <span>[</span>branch<span>]</span> <span>[</span>remote-branch<span>]</span>

<span># 合并指定分支到当前分支</span>
$ <span>git</span> merge <span>[</span>branch<span>]</span>

<span># 选择一个commit，合并进当前分支</span>
$ <span>git</span> cherry-pick <span>[</span>commit<span>]</span>

<span># 删除本地分支</span>
$ <span>git</span> branch -d <span>[</span>branch-name<span>]</span>

<span># 删除远程分支</span>
$ <span>git</span> push origin --delete <span>[</span>branch-name<span>]</span>
$ <span>git</span> branch -dr <span>[</span>remote/branch<span>]</span>

<span># 检出版本v2.0</span>
$ <span>git</span> checkout v2.0

<span># 从远程分支develop创建新本地分支devel并检出</span>
$ <span>git</span> checkout -b devel origin/develop

<span># 检出head版本的README文件（可用于修改错误回退）</span>
$ <span>git</span> checkout -- README     
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h3 id="标签"> 标签</h3>
<div><pre><code><span># 列出所有tag</span>
$ <span>git</span> tag

<span># 新建一个tag在当前commit</span>
$ <span>git</span> tag <span>[</span>tag<span>]</span>

<span># 新建一个tag在指定commit</span>
$ <span>git</span> tag <span>[</span>tag<span>]</span> <span>[</span>commit<span>]</span>

<span># 删除本地tag</span>
$ <span>git</span> tag -d <span>[</span>tag<span>]</span>

<span># 删除远程tag</span>
$ <span>git</span> push origin :refs/tags/<span>[</span>tagName<span>]</span>

<span># 查看tag信息</span>
$ <span>git</span> show <span>[</span>tag<span>]</span>

<span># 提交指定tag</span>
$ <span>git</span> push <span>[</span>remote<span>]</span> <span>[</span>tag<span>]</span>

<span># 提交所有tag</span>
$ <span>git</span> push <span>[</span>remote<span>]</span> --tags

<span># 新建一个分支，指向某个tag</span>
$ <span>git</span> checkout -b <span>[</span>branch<span>]</span> <span>[</span>tag<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id="查看信息"> 查看信息</h2>
<div><pre><code><span># 显示有变更的文件</span>
$ <span>git</span> status

<span># 显示指定文件是什么人在什么时间修改过</span>
$ <span>git</span> blame <span>[</span>file<span>]</span>

<span># 显示某次提交的元数据和内容变化</span>
$ <span>git</span> show <span>[</span>commit<span>]</span>

<span># 显示某次提交发生变化的文件</span>
$ <span>git</span> show --name-only <span>[</span>commit<span>]</span>

<span># 显示某次提交时，某个文件的内容</span>
$ <span>git</span> show <span>[</span>commit<span>]</span>:<span>[</span>filename<span>]</span>

<span># 显示当前分支的最近几次提交</span>
$ <span>git</span> reflog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="diff-比较"> <code>diff</code> 比较</h3>
<div><pre><code><span># 显示暂存区和工作区的差异</span>
$ <span>git</span> <span>diff</span> <span>[</span>file<span>]</span>

<span># 显示暂存区和上一个commit的差异</span>
$ <span>git</span> <span>diff</span> --cached <span>[</span>file<span>]</span>

<span># 显示工作区与当前分支最新commit之间的差异</span>
$ <span>git</span> <span>diff</span> HEAD <span>[</span>file<span>]</span>

<span># 显示两次提交之间的差异</span>
$ <span>git</span> <span>diff</span> <span>[</span>first-branch<span>]</span><span>..</span>.<span>[</span>second-branch<span>]</span>

<span># 显示今天你写了多少行代码</span>
$ <span>git</span> <span>diff</span> --shortstat <span>"@{0 day ago}"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>HEAD</strong>
HEAD 可以看做是一个游标，一般是指向当前分支最后一次提交。</p>
<p>HEAD 的值存储在<code>.git/HEAD</code>中。</p>
<table>
<thead>
<tr>
<th>表示</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>HEAD</td>
<td>指代最后一次 commit</td>
</tr>
<tr>
<td>HEAD^</td>
<td>指代上一次提交</td>
</tr>
<tr>
<td>HEAD^^</td>
<td>指代上上一次提交</td>
</tr>
<tr>
<td>HEAD~n</td>
<td>表示倒数第n次提交</td>
</tr>
</tbody>
</table>
<p><code>log</code> 提交历史</p>
<div><pre><code><span># 显示当前分支的版本历史</span>
$ <span>git</span> log

<span># 显示commit历史，以及每次commit发生变更的文件</span>
$ <span>git</span> log --stat

<span># 搜索提交历史，根据关键词</span>
$ <span>git</span> log -S <span>[</span>keyword<span>]</span>

<span># 显示某个commit之后的所有变动，每个commit占据一行</span>
$ <span>git</span> log <span>[</span>tag<span>]</span> HEAD --pretty<span>=</span>format:%s

<span># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span>
$ <span>git</span> log <span>[</span>tag<span>]</span> HEAD --grep feature

<span># 显示某个文件的版本历史，包括文件改名</span>
$ <span>git</span> log --follow <span>[</span>file<span>]</span>
$ <span>git</span> whatchanged <span>[</span>file<span>]</span>

<span># 显示指定文件相关的每一次diff</span>
$ <span>git</span> log -p <span>[</span>file<span>]</span>

<span># 显示过去5次提交</span>
$ <span>git</span> log -5 --pretty --oneline

<span># 显示所有提交过的用户，按提交次数排序</span>
$ <span>git</span> shortlog -sn

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id="撤销"> 撤销</h2>
<ul>
<li>
<p>checkout 检出</p>
<p>checkout 用于创建、切换分支，或恢复工作区文件。</p>
<p>注意，checkout 会重写工作区，这个命令还是有危险性的。</p>
</li>
<li>
<p>reset 重置</p>
<p>reset 操作，要慎重，用于版本回滚，再恢复，但也要慎重使用。</p>
</li>
<li>
<p>revert 撤销</p>
<p>revert 主要用在主分支上，保留信息。在工作分支上，可以采用 reset 。</p>
</li>
</ul>
<div><pre><code><span># 列出暂存区可以被检出的文件</span>
$ <span>git</span> checkout

<span># 恢复暂存区的指定文件到工作区</span>
$ <span>git</span> checkout <span>[</span>file<span>]</span>

<span># 恢复某个commit的指定文件到暂存区和工作区</span>
$ <span>git</span> checkout <span>[</span>commit<span>]</span> <span>[</span>file<span>]</span>

<span># 恢复暂存区的所有文件到工作区</span>
$ <span>git</span> checkout <span>.</span>

<span># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span>
$ <span>git</span> reset <span>[</span>file<span>]</span>

<span># 重置暂存区与工作区，与上一次commit保持一致</span>
$ <span>git</span> reset --hard

<span># 显示 commit 的信息，只要HEAD发生变化，就可以在这里看到</span>
$ <span>git</span> reflog

<span># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span>
$ <span>git</span> reset <span>[</span>commit<span>]</span>

<span># 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变</span>
$ <span>git</span> reset --soft commit

<span># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span>
$ <span>git</span> reset --hard <span>[</span>commit<span>]</span>

<span># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span>
$ <span>git</span> reset --keep <span>[</span>commit<span>]</span>

<span># 新建一个commit，用来撤销指定commit</span>
<span># 后者的所有变化都将被前者抵消，并且应用到当前分支</span>
$ <span>git</span> revert <span>[</span>commit<span>]</span>

<span># 暂时将未提交的变化移除，稍后再移入</span>
$ <span>git</span> stash
$ <span>git</span> stash pop
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h2 id="其他"> 其他</h2>
<div><pre><code><span>git</span> config --global color.ui <span>true</span>                         <span># git status等命令自动着色</span>
<span>git</span> config --global color.status auto
<span>git</span> config --global color.diff auto
<span>git</span> config --global color.branch auto
<span>git</span> config --global color.interactive auto
<span>git</span> config --global --unset http.proxy                    <span># remove  proxy configuration on git</span>
<span>git</span> clone git+ssh://git@192.168.53.168/VT.git             <span># clone远程仓库</span>
<span>git</span> clone -b <span>&lt;</span>指定分支名<span>></span> <span>&lt;</span>远程仓库地址<span>></span>                      <span># clone远程指定 分支</span>
<span>git</span> log -p -m
<span>git</span> show dfb02e6e4f2f7b573337763e5c0013802e392818         <span># 显示某个提交的详细内容</span>
<span>git</span> show dfb02                                            <span># 可只用commitid的前几位</span>
<span>git</span> show HEAD                                             <span># 显示HEAD提交日志</span>
<span>git</span> show HEAD^                                            <span># 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span>
<span>git</span> tag -a v2.0 -m <span>'xxx'</span>                                  <span># 增加v2.0的tag</span>
<span>git</span> show v2.0                                             <span># 显示v2.0的日志及详细内容</span>
<span>git</span> log v2.0                                              <span># 显示v2.0的日志</span>
<span>git</span> <span>diff</span> HEAD -- ./lib                                    <span># 比较与HEAD版本lib目录的差异</span>
<span>git</span> <span>diff</span> origin/master<span>..</span>master                            <span># 比较远程分支master上有本地分支master上没有的</span>
<span>git</span> <span>diff</span> origin/master<span>..</span>master --stat                     <span># 只显示差异的文件，不显示具体内容</span>
<span>git</span> remote <span>add</span> origin git+ssh://git@192.168.53.168/VT.git <span># 增加远程定义（用于push/pull/fetch）</span>
<span>git</span> branch --contains <span>50089</span>                               <span># 显示包含提交50089的分支</span>
<span>git</span> branch --merged                                       <span># 显示所有已合并到当前分支的分支</span>
<span>git</span> branch --no-merged                                    <span># 显示所有未合并到当前分支的分支</span>
<span>git</span> branch -m master master_copy                          <span># 本地分支改名</span>
<span>git</span> checkout -b master_copy                               <span># 从当前分支创建新分支master_copy并检出</span>
<span>git</span> checkout -b master master_copy                        <span># 上面的完整版</span>
<span>git</span> checkout features/performance                         <span># 检出已存在的features/performance分支</span>
<span>git</span> checkout --track hotfixes/BJVEP933                    <span># 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span>
<span>git</span> checkout -b devel origin/develop                      <span># 从远程分支develop创建新本地分支devel并检出</span>
<span>git</span> checkout -- README                                    <span># 检出head版本的README文件（可用于修改错误回退）</span>
<span>git</span> merge origin/master                                   <span># 合并远程master分支至当前分支</span>
<span>git</span> cherry-pick ff44785404a8e                             <span># 合并提交ff44785404a8e的修改</span>
<span>git</span> push origin :hotfixes/BJVEP933                        <span># 删除远程仓库的hotfixes/BJVEP933分支</span>
<span>git</span> fetch                                                 <span># 获取所有远程分支（不更新本地分支，另需merge）</span>
<span>git</span> fetch --prune                                         <span># 获取所有原创分支并清除服务器上已删掉的分支</span>
<span>git</span> <span>mv</span> README README2                                     <span># 重命名文件README为README2</span>
<span>git</span> reset --hard HEAD                                     <span># 将当前版本重置为HEAD（通常用于merge失败回退）</span>
<span>git</span> rebase
<span>git</span> branch -d hotfixes/BJVEP933                           <span># 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span>
<span>git</span> branch -D hotfixes/BJVEP933                           <span># 强制删除分支hotfixes/BJVEP933</span>
<span>git</span> ls-files                                              <span># 列出git index包含的文件</span>
<span>git</span> show-branch                                           <span># 图示当前分支历史</span>
<span>git</span> show-branch --all                                     <span># 图示所有分支历史</span>
<span>git</span> whatchanged                                           <span># 显示提交历史对应的文件修改</span>
<span>git</span> revert dfb02e6e4f2f7b573337763e5c0013802e392818       <span># 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span>
<span>git</span> ls-tree HEAD                                          <span># 内部命令：显示某个git对象</span>
<span>git</span> rev-parse v2.0                                        <span># 内部命令：显示某个ref对于的SHA1 HASH</span>
<span>git</span> reflog                                                <span># 显示所有提交，包括孤立节点</span>
<span>git</span> show HEAD@<span>{</span><span>5</span><span>}</span>
<span>git</span> show master@<span>{</span>yesterday<span>}</span>                               <span># 显示master分支昨天的状态</span>
<span>git</span> log --pretty<span>=</span>format:<span>'%h %s'</span> --graph                   <span># 图示提交日志</span>
<span>git</span> show HEAD~3
<span>git</span> show -s --pretty<span>=</span>raw 2be7fcb476
<span>git</span> stash                                                 <span># 暂存当前修改，将所有至为HEAD状态</span>
<span>git</span> stash list                                            <span># 查看所有暂存</span>
<span>git</span> stash show -p stash@<span>{</span><span>0</span><span>}</span>                               <span># 参考第一次暂存</span>
<span>git</span> stash apply stash@<span>{</span><span>0</span><span>}</span>                                 <span># 应用第一次暂存</span>
<span>git</span> <span>grep</span> <span>"delete from"</span>                                    <span># 文件中搜索文本“delete from”</span>
<span>git</span> <span>grep</span> -e <span>'#define'</span> --and -e SORT_DIRENT
<span>git</span> gc
<span>git</span> <span>fsck</span>
<span># 生成一个可供发布的压缩包</span>
$ <span>git</span> archive
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li>杰哥的IT之旅：常用的 Git 命令清单</li>
<li>马哥教育：Git基本操作</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Commit message 和 Change log 编写指南</title>
    <id>https://clay-wangzhi.com/git/git-commit-message/</id>
    <link href="https://clay-wangzhi.com/git/git-commit-message/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="commit-message-和-change-log-编写指南"> Commit message 和 Change log 编写指南</h1>
<p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。</p>
<blockquote>
<div><pre><code>$ <span>git</span> commit -m <span>"hello world"</span>
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<p>上面代码的<code>-m</code>参数，就是用来指定 commit mesage 的。</p>
<p>如果一行不够，可以只执行<code>git commit</code>，就会跳出文本编辑器，让你写多行。</p>
<blockquote>
<div><pre><code>$ <span>git</span> commit
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<p>但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。</p>
<p>目前，社区有多种 Commit message 的<a href="https://github.com/ajoslin/conventional-changelog/blob/master/conventions" target="_blank" rel="noopener noreferrer">写法规范</a>。本文介绍<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0" target="_blank" rel="noopener noreferrer">Angular 规范</a>（见上图），这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。</p>
<h2 id="一、commit-message-的作用"> 一、Commit message 的作用</h2>
<p>格式化的Commit message，有几个好处。</p>
<p><strong>（1）提供更多的历史信息，方便快速浏览。</strong></p>
<p>比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的。</p>
<blockquote>
<div><pre><code>$ <span>git</span> log <span>&lt;</span>last tag<span>></span> HEAD --pretty<span>=</span>format:%s
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016010604.png" alt="img" /></p>
<p><strong>（2）可以过滤某些commit（比如文档改动），便于快速查找信息。</strong></p>
<p>比如，下面的命令仅仅显示本次发布新增加的功能。</p>
<blockquote>
<div><pre><code>$ <span>git</span> log <span>&lt;</span>last release<span>></span> HEAD --grep feature
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<p><strong>（3）可以直接从commit生成Change log。</strong></p>
<p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档，详见后文。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016010603.png" alt="img" /></p>
<h2 id="二、commit-message-的格式"> 二、Commit message 的格式</h2>
<p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p>
<blockquote>
<div><pre><code><span>&lt;</span>type<span>></span><span>(</span><span>&lt;</span>scope<span>></span><span>)</span>: <span>&lt;</span>subject<span>></span>
// 空一行
<span>&lt;</span>body<span>></span>
// 空一行
<span>&lt;</span>footer<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></blockquote>
<p>其中，Header 是必需的，Body 和 Footer 可以省略。</p>
<p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p>
<h3 id="_2-1-header"> 2.1 Header</h3>
<p>Header部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p>
<p><strong>（1）type</strong></p>
<p><code>type</code>用于说明 commit 的类别，只允许使用下面7个标识。</p>
<blockquote>
<ul>
<li>feat：新功能（feature）</li>
<li>fix：修补bug</li>
<li>docs：文档（documentation）</li>
<li>style： 格式（不影响代码运行的变动）</li>
<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li>test：增加测试</li>
<li>chore：构建过程或辅助工具的变动</li>
</ul>
</blockquote>
<p>如果<code>type</code>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p>
<p><strong>（2）scope</strong></p>
<p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<p><strong>（3）subject</strong></p>
<p><code>subject</code>是 commit 目的的简短描述，不超过50个字符。</p>
<blockquote>
<ul>
<li>以动词开头，使用第一人称现在时，比如<code>change</code>，而不是<code>changed</code>或<code>changes</code></li>
<li>第一个字母小写</li>
<li>结尾不加句号（<code>.</code>）</li>
</ul>
</blockquote>
<h3 id="_2-2-body"> 2.2 Body</h3>
<p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p>
<blockquote>
<div><pre><code>More detailed explanatory text, <span>if</span> necessary.  Wrap it to 
about <span>72</span> characters or so. 

Further paragraphs come after blank lines.

- Bullet points are okay, too
- Use a hanging indent
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></blockquote>
<p>有两个注意点。</p>
<p>（1）使用第一人称现在时，比如使用<code>change</code>而不是<code>changed</code>或<code>changes</code>。</p>
<p>（2）应该说明代码变动的动机，以及与以前行为的对比。</p>
<h3 id="_2-3-footer"> 2.3 Footer</h3>
<p>Footer 部分只用于两种情况。</p>
<p><strong>（1）不兼容变动</strong></p>
<p>如果当前代码与上一个版本不兼容，则 Footer 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<blockquote>
<div><pre><code>BREAKING CHANGE: isolate scope bindings definition has changed.

    To migrate the code follow the example below:

    Before:

    scope: <span>{</span>
      myAttr: <span>'attribute'</span>,
    <span>}</span>

    After:

    scope: <span>{</span>
      myAttr: <span>'@'</span>,
    <span>}</span>

    The removed <span><span>`</span>inject<span>`</span></span> wasn't generaly useful <span>for</span> directives so there should be no code using it.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></blockquote>
<p><strong>（2）关闭 Issue</strong></p>
<p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p>
<blockquote>
<div><pre><code>Closes <span>#234</span>
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<p>也可以一次关闭多个 issue 。</p>
<blockquote>
<div><pre><code>Closes <span>#123, #245, #992</span>
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<h3 id="_2-4-revert"> 2.4 Revert</h3>
<p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以<code>revert:</code>开头，后面跟着被撤销 Commit 的 Header。</p>
<blockquote>
<div><pre><code>revert: feat<span>(</span>pencil<span>)</span>: <span>add</span> <span>'graphiteWidth'</span> option

This reverts commit 667ecc1654a317a13331b17617d973392f415f02.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></blockquote>
<p>Body部分的格式是固定的，必须写成<code>This reverts commit &lt;hash&gt;.</code>，其中的<code>hash</code>是被撤销 commit 的 SHA 标识符。</p>
<p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的<code>Reverts</code>小标题下面。</p>
<h2 id="三、commitizen"> 三、Commitizen</h2>
<p><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener noreferrer">Commitizen</a>是一个撰写合格 Commit message 的工具。</p>
<p>安装命令如下。</p>
<blockquote>
<div><pre><code>$ <span>npm</span> <span>install</span> -g commitizen
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<p>然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</p>
<blockquote>
<div><pre><code>$ commitizen init cz-conventional-changelog --save --save-exact
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<p>以后，凡是用到<code>git commit</code>命令，一律改为使用<code>git cz</code>。这时，就会出现选项，用来生成符合格式的 Commit message。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016010605.png" alt="img" /></p>
<h2 id="四、validate-commit-msg"> 四、validate-commit-msg</h2>
<p><a href="https://github.com/kentcdodds/validate-commit-msg" target="_blank" rel="noopener noreferrer">validate-commit-msg</a> 用于检查 Node 项目的 Commit message 是否符合格式。</p>
<p>它的安装是手动的。首先，拷贝下面这个<a href="https://github.com/kentcdodds/validate-commit-msg/blob/master/index.js" target="_blank" rel="noopener noreferrer">JS文件</a>，放入你的代码库。文件名可以取为<code>validate-commit-msg.js</code>。</p>
<p>接着，把这个脚本加入 Git 的 hook。下面是在<code>package.json</code>里面使用 <a href="http://npm.im/ghooks" target="_blank" rel="noopener noreferrer">ghooks</a>，把这个脚本加为<code>commit-msg</code>时运行。</p>
<blockquote>
<div><pre><code>  <span>"config"</span><span>:</span> <span>{</span>
    <span>"ghooks"</span><span>:</span> <span>{</span>
      <span>"commit-msg"</span><span>:</span> <span>"./validate-commit-msg.js"</span>
    <span>}</span>
  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></blockquote>
<p>然后，每次<code>git commit</code>的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。</p>
<blockquote>
<div><pre><code>$ <span>git</span> <span>add</span> -A 
$ <span>git</span> commit -m <span>"edit markdown"</span> 
INVALID COMMIT MSG: does not match <span>"&lt;type>(&lt;scope>): &lt;subject>"</span> <span>!</span> was: edit markdown
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></blockquote>
<h2 id="五、生成-change-log"> 五、生成 Change log</h2>
<p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成（<a href="https://github.com/ajoslin/conventional-changelog/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer">例1</a>，<a href="https://github.com/karma-runner/karma/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer">例2</a>，<a href="https://github.com/btford/grunt-conventional-changelog/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer">例3</a>）。</p>
<p>生成的文档包括以下三个部分。</p>
<blockquote>
<ul>
<li>New features</li>
<li>Bug fixes</li>
<li>Breaking changes.</li>
</ul>
</blockquote>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p>
<p><a href="https://github.com/ajoslin/conventional-changelog" target="_blank" rel="noopener noreferrer">conventional-changelog</a> 就是生成 Change log 的工具，运行下面的命令即可。</p>
<blockquote>
<div><pre><code>$ <span>npm</span> <span>install</span> -g conventional-changelog
$ <span>cd</span> my-project
$ conventional-changelog -p angular -i CHANGELOG.md -w
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></blockquote>
<p>上面命令不会覆盖以前的 Change log，只会在<code>CHANGELOG.md</code>的头部加上自从上次发布以来的变动。</p>
<p>如果你想生成所有发布的 Change log，要改为运行下面的命令。</p>
<blockquote>
<div><pre><code>$ conventional-changelog -p angular -i CHANGELOG.md -w -r <span>0</span>
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<p>为了方便使用，可以将其写入<code>package.json</code>的<code>scripts</code>字段。</p>
<blockquote>
<div><pre><code><span>{</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"changelog"</span><span>:</span> <span>"conventional-changelog -p angular -i CHANGELOG.md -w -r 0"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></blockquote>
<p>以后，直接运行下面的命令即可。</p>
<blockquote>
<div><pre><code>$ <span>npm</span> run changelog
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<blockquote>
<p>转载自：阮一峰 Commit message 和 Change log 编写指南</p>
<p>https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">常用知识</title>
    <id>https://clay-wangzhi.com/linux/basic/common-kno/</id>
    <link href="https://clay-wangzhi.com/linux/basic/common-kno/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="常用知识"> 常用知识</h1>
<p><strong>如何查看当前服务器内核的版本</strong></p>
<div><pre><code>uname -r
cat /proc/version
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>查看当前服务器 cpu 的 core(核心)数</strong></p>
<div><pre><code># 总核数 = 物理CPU个数 X 每颗物理CPU的核数 
# 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数
# 查看物理CPU个数
cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l
# 查看每个物理CPU中core的个数(即核数)
cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq
# 查看逻辑CPU的个数
cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l
查看CPU信息（型号）
cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">计划任务</title>
    <id>https://clay-wangzhi.com/linux/basic/crontab/</id>
    <link href="https://clay-wangzhi.com/linux/basic/crontab/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="计划任务"> 计划任务</h1>
<p><strong>crontab命令</strong>被用来提交和管理用户的需要周期性执行的任务，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p>
<h2 id="语法"> 语法</h2>
<div><pre><code>crontab(选项)(参数)
</code></pre>
<div><span>1</span><br></div></div><h2 id="选项"> 选项</h2>
<p>复制</p>
<div><pre><code>-e：编辑该用户的计时器设置;-l：列出该用户的计时器设置;-r：删除该用户的计时器设置;-u&lt;用户名称&gt;：指定要设定计时器的用户名称;-i：在删除用户的crontab文件时给确认提示。
</code></pre>
<div><span>1</span><br></div></div><h2 id="参数"> 参数</h2>
<p>crontab文件：指定包含待执行任务的crontab文件。</p>
<h2 id="知识扩展"> 知识扩展</h2>
<p>Linux下的任务调度分为两类：系统任务调度和用户任务调度</p>
<p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在<code>/etc</code>目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p>
<p><code>/etc/crontab</code>文件包括下面几行：</p>
<p>复制</p>
<div><pre><code>SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=&quot;&quot;HOME=/# run-parts51 * * * * root run-parts /etc/cron.hourly24 7 * * * root run-parts /etc/cron.daily22 4 * * 0 root run-parts /etc/cron.weekly42 4 1 * * root run-parts /etc/cron.monthly
</code></pre>
<div><span>1</span><br></div></div><p>前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。</p>
<p>**用户任务调度：**用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab文件都被保存在<code>/var/spool/cron</code>目录中。其文件名与用户名一致，使用者权限文件如下：</p>
<p>复制</p>
<div><pre><code>/etc/cron.deny     该文件中所列用户不允许使用crontab命令/etc/cron.allow    该文件中所列用户允许使用crontab命令/var/spool/cron/   所有用户crontab文件存放的目录,以用户名命名
</code></pre>
<div><span>1</span><br></div></div><p>crontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p>
<p>复制</p>
<div><pre><code>minute   hour   day   month   week   command     顺序：分 时 日 月 周
</code></pre>
<div><span>1</span><br></div></div><p>minute： 表示分钟，可以是从0到59之间的任何整数。</p>
<p>hour：表示小时，可以是从0到23之间的任何整数。</p>
<p>day：表示日期，可以是从1到31之间的任何整数。</p>
<p>month：表示月份，可以是从1到12之间的任何整数。</p>
<p>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</p>
<p>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/crontab1.png" alt="img" /></p>
<p>在以上各个字段中，还可以使用以下特殊字符：</p>
<p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p>
<p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p>
<p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p>
<p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p>
<p>查看crontab服务状态：</p>
<p>复制</p>
<div><pre><code>service crond status
</code></pre>
<div><span>1</span><br></div></div><p>手动启动crontab服务：</p>
<p>复制</p>
<div><pre><code>service crond start
</code></pre>
<div><span>1</span><br></div></div><p>查看crontab服务是否已设置为开机启动，执行命令：</p>
<p>复制</p>
<div><pre><code>ntsysv
</code></pre>
<div><span>1</span><br></div></div><p>加入开机自动启动：</p>
<p>复制</p>
<div><pre><code>chkconfig –level 35 crond on
</code></pre>
<div><span>1</span><br></div></div><h2 id="常用方法"> 常用方法</h2>
<p>1). 创建一个新的crontab文件</p>
<p>在考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$ HOME目录下的. profile文件，在其中加入这样一行：</p>
<p>EDITOR=vi; export EDITOR</p>
<p>然后保存并退出。不妨创建一个名为\ cron的文件，其中\是用户名，例如， davecron。在该文件中加入如下的内容。</p>
<p># (put your own initials here)echo the date to the console every</p>
<p># 15minutes between 6pm and 6am</p>
<p>0,15,30,45 18-06 * /bin/echo ‘date’ &gt; /dev/console</p>
<p>保存并退出。确信前面5个域用空格分隔。</p>
<p>在上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数：</p>
<p>$ crontab davecron</p>
<p>现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。</p>
<p>同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。</p>
<p>2). 列出crontab文件</p>
<p>为了列出crontab文件，可以用：</p>
<p>$ crontab -l</p>
<p>0,15,30,45,18-06 * /bin/echo <code>date</code> &gt; dev/tty1</p>
<p>你将会看到和上面类似的内容。可以使用这种方法在$ H O M E目录中对crontab文件做一备份：</p>
<p>$ crontab -l &gt; $HOME/mycron</p>
<p>这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。</p>
<p>3). 编辑crontab文件</p>
<p>如果希望添加、删除或编辑crontab文件中的条目，而E D I TO R环境变量又设置为v i，那么就可以用v i来编辑crontab文件，相应的命令为：</p>
<p>$ crontab -e</p>
<p>可以像使用v i编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， c r o n会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。</p>
<p>我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：</p>
<div><pre><code># DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month
</code></pre>
<div><span>1</span><br></div></div><p>30 3 1,7,14,21,26 /bin/find -name “core’ -exec rm {} ;</p>
<p>现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。</p>
<p>现在让我们使用前面讲过的crontab -l命令列出它的全部信息：</p>
<div><pre><code> $ crontab -l 

 # (crondave installed on Tue May 4 13:07:43 1999)

 # DT:ech the date to the console every 30 minites

0,15,30,45 18-06 * * * /bin/echo `date` &gt; /dev/tty1

 # DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month

 30 3 1,7,14,21,26 * * /bin/find -name &quot;core&#39; -exec rm {} \;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>4). 删除crontab文件</p>
<p>要删除crontab文件，可以用：</p>
<div><pre><code>$ crontab -r
</code></pre>
<div><span>1</span><br></div></div><p>5). 恢复丢失的crontab文件</p>
<p>如果不小心误删了crontab文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/\，其中\是用户名。如果由于权限问题无法完成拷贝，可以用：</p>
<p>$ crontab \</p>
<p>其中，\是你在$ H O M E目录中副本的文件名。</p>
<p>我建议你在自己的$ H O M E目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。</p>
<p>有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按，否则你将丢失crontab文件。</p>
<h2 id="常用实例"> 常用实例</h2>
<p>1）每1分钟执行一次command</p>
<p>复制</p>
<div><pre><code>* * * * * command
</code></pre>
<div><span>1</span><br></div></div><p>2）每小时的第3和第15分钟执行</p>
<p>复制</p>
<div><pre><code>3,15 * * * * command
</code></pre>
<div><span>1</span><br></div></div><p>3）在上午8点到11点的第3和第15分钟执行</p>
<p>复制</p>
<div><pre><code>3,15 8-11 * * * command
</code></pre>
<div><span>1</span><br></div></div><p>4）每隔两天的上午8点到11点的第3和第15分钟执行</p>
<p>复制</p>
<div><pre><code>3,15 8-11 */2 * * command
</code></pre>
<div><span>1</span><br></div></div><p>5）每个星期一的上午8点到11点的第3和第15分钟执行</p>
<p>复制</p>
<div><pre><code>3,15 8-11 * * 1 command
</code></pre>
<div><span>1</span><br></div></div><p>6）每晚的21:30重启smb</p>
<p>复制</p>
<div><pre><code>30 21 * * * /etc/init.d/smb restart
</code></pre>
<div><span>1</span><br></div></div><p>7）每月1、10、22日的4 : 45重启smb</p>
<p>复制</p>
<div><pre><code>45 4 1,10,22 * * /etc/init.d/smb restart
</code></pre>
<div><span>1</span><br></div></div><p>8）每周六、周日的1 : 10重启smb</p>
<p>复制</p>
<div><pre><code>10 1 * * 6,0 /etc/init.d/smb restart
</code></pre>
<div><span>1</span><br></div></div><p>9）每天18 : 00至23 : 00之间每隔30分钟重启smb</p>
<p>复制</p>
<div><pre><code>0,30 18-23 * * * /etc/init.d/smb restart
</code></pre>
<div><span>1</span><br></div></div><p>10）每星期六的晚上11 : 00 pm重启smb</p>
<p>复制</p>
<div><pre><code>0 23 * * 6 /etc/init.d/smb restart
</code></pre>
<div><span>1</span><br></div></div><p>11）每一小时重启smb</p>
<p>复制</p>
<div><pre><code>0 */1 * * * /etc/init.d/smb restart
</code></pre>
<div><span>1</span><br></div></div><p>12）晚上11点到早上7点之间，每隔一小时重启smb</p>
<p>复制</p>
<div><pre><code>0 23-7/1 * * * /etc/init.d/smb restart
</code></pre>
<div><span>1</span><br></div></div><p>13）每月的4号与每周一到周三的11点重启smb</p>
<p>复制</p>
<div><pre><code>0 11 4 * mon-wed /etc/init.d/smb restart
</code></pre>
<div><span>1</span><br></div></div><p>14）一月一号的4点重启smb</p>
<p>复制</p>
<div><pre><code>0 4 1 jan * /etc/init.d/smb restart
</code></pre>
<div><span>1</span><br></div></div><p>15）每小时执行/etc/cron.hourly目录内的脚本</p>
<p>复制</p>
<div><pre><code>01   *   *   *   *     root run-parts /etc/cron.hourly
</code></pre>
<div><span>1</span><br></div></div><p>说明：</p>
<p>run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了</p>
<h2 id="使用注意事项"> 使用注意事项</h2>
<p>有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。</p>
<p>在crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。</p>
<p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：</p>
<p>1）脚本中涉及文件路径时写全局路径；</p>
<p>2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：</p>
<p>cat start_cbp.sh</p>
<p>#!/bin/sh</p>
<p>source /etc/profile</p>
<p>export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf</p>
<p>/usr/local/jboss-4.0.5/bin/run.sh -c mev &amp;</p>
<p>3）当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：</p>
<p>0 . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</p>
<ol>
<li>注意清理系统用户的邮件日志</li>
</ol>
<p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。</p>
<p>例如，可以在crontab文件中设置如下形式，忽略日志输出：</p>
<p>0 <em>/3</em> /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1</p>
<p>“/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p>
<p>. 系统级任务调度与用户级任务调度</p>
<p>系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。</p>
<ol>
<li>其他注意事项</li>
</ol>
<p>新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p>
<p>当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。</p>
<p>千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。</p>
<p>在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+%Y%m%d’。</p>
<p>参考链接：</p>
<p>http://www.cnblogs.com/peida/archive/2013/01/08/2850483.html</p>
<p>http://man.linuxde.net/crontab</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">查看文件内容</title>
    <id>https://clay-wangzhi.com/linux/basic/file/cat/</id>
    <link href="https://clay-wangzhi.com/linux/basic/file/cat/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="查看文件内容"> 查看文件内容</h1>
<h3 id="cat命令"> cat命令</h3>
<p>cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。</p>
<h4 id="语法"> 语法</h4>
<p><code>cat(选项)(参数)</code></p>
<h4 id="选项"> 选项</h4>
<div><pre><code>-A, --show-all           等价于 -vET
-b, --number-nonblank    对非空输出行编号
-e                       等价于 -vE
-E, --show-ends          在每行结束处显示 $
-n, --number     对输出的所有行编号,由1开始对所有输出的行数编号
-s, --squeeze-blank  有连续两行以上的空白行，就代换为一行的空白行 
-t                       与 -vT 等价
-T, --show-tabs          将跳格字符显示为 ^I
-u                       (被忽略)
-v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="功能"> 功能</h4>
<p>1.一次显示整个文件:cat filename</p>
<p>2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.</p>
<p>3.将几个文件合并为一个文件:cat file1 file2 &gt; file</p>
<h4 id="常用范例"> 常用范例</h4>
<p>1）把 log2012.log 的文件内容加上行号后输入 log.log 这个文件里</p>
<div><pre><code># cat log.log 
[root@localhost test]# cat -n log2012.log &gt; log.log
# cat -n log.log 
     1  2012-01
     2  2012-02
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>2）使用here doc来生成文件</p>
<div><pre><code># cat &gt;log.txt &lt;&lt;EOF
&gt; Hello
&gt; World
&gt; Linux
&gt; PWD=$(pwd)
&gt; EOF
# ls -l log.txt 
-rw-r--r-- 1 root root 37 10-28 17:07 log.txt
# cat log.txt 
Hello
World
Linux
PWD=/opt/soft/test
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>说明：</p>
<p>注意粗体部分，here doc可以进行字符串替换。</p>
<p>备注：</p>
<p>tac (反向列示)</p>
<div><pre><code># tac log.txt 
PWD=/opt/soft/test
Linux
World
Hello
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>说明：</p>
<p>tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来！</p>
<h3 id="less命令"> less命令</h3>
<p>less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup][pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。</p>
<h4 id="语法-2"> 语法</h4>
<p><code>less(选项)(参数)</code></p>
<h4 id="选项-2"> 选项</h4>
<div><pre><code>-b  &lt;缓冲区大小&gt; 设置缓冲区的大小
-e  当文件显示结束后，自动离开
-f  强迫打开特殊文件，例如外围设备代号、目录和二进制文件
-g  只标志最后搜索的关键词
-i  忽略搜索时的大小写
-m  显示类似more命令的百分比
-N  显示每行的行号
-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来
-Q  不使用警告音
-s  显示连续空行为一行
-S  行过长时间将超出部分舍弃
-x &lt;数字&gt; 将“tab”键显示为规定的数字空格
/字符串：向下搜索“字符串”的功能
?字符串：向上搜索“字符串”的功能
n：重复前一个搜索（与 / 或 ? 有关）
N：反向重复前一个搜索（与 / 或 ? 有关）
b  向后翻一页
d  向后翻半页
h  显示帮助界面
Q  退出less 命令
u  向前滚动半页
y  向前滚动一行
空格键 滚动一行
回车键 滚动一页
[pagedown]： 向下翻动一页
[pageup]：   向上翻动一页
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h4 id="功能-2"> 功能</h4>
<p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p>
<h4 id="常用实例"> 常用实例</h4>
<p>1）ps查看进程信息并通过less分页显示</p>
<div><pre><code>ps -ef | less
</code></pre>
<div><span>1</span><br></div></div><p>2 ) 查看命令历史使用记录并通过less分页显示</p>
<div><pre><code>history | less
</code></pre>
<div><span>1</span><br></div></div><p>3）浏览多个文件</p>
<div><pre><code>less log2013.log log2014.log
</code></pre>
<div><span>1</span><br></div></div><p>说明：</p>
<p>输入 ：n后，切换到 log2014.log</p>
<p>输入 ：p 后，切换到log2013.log</p>
<h4 id="附加备注"> 附加备注</h4>
<p>1.全屏导航</p>
<p>ctrl + F - 向前移动一屏</p>
<p>ctrl + B - 向后移动一屏</p>
<p>ctrl + D - 向前移动半屏</p>
<p>ctrl + U - 向后移动半屏</p>
<p>2.单行导航</p>
<p>j - 向前移动一行</p>
<p>k - 向后移动一行</p>
<p>3.其它导航</p>
<p>G - 移动到最后一行</p>
<p>g - 移动到第一行</p>
<p>q / ZZ - 退出 less 命令</p>
<p>4.其它有用的命令</p>
<p>v - 使用配置的编辑器编辑当前文件</p>
<p>h - 显示 less 的帮助文档</p>
<p>&amp;pattern - 仅显示匹配模式的行，而不是整个文件</p>
<p>5.标记导航</p>
<p>当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：</p>
<p>ma - 使用 a 标记文本的当前位置</p>
<p>'a - 导航到标记 a 处</p>
<h3 id="more命令"> more命令</h3>
<p>more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。</p>
<h4 id="语法-3"> 语法</h4>
<p><code>more(语法)(参数)</code></p>
<h4 id="选项-3"> 选项</h4>
<div><pre><code>+n      从笫n行开始显示
-n       定义屏幕大小为n行
+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示  
-c       从顶部清屏，然后显示
-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能
-l        忽略Ctrl+l（换页）字符
-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似
-s       把连续的多个空行显示为一行
-u       把文件内容中的下画线去掉
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="功能-3"> 功能</h4>
<p>more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。</p>
<h4 id="常用操作命令"> 常用操作命令</h4>
<div><pre><code>Enter    向下n行，需要定义。默认为1行
Ctrl+F   向下滚动一屏
空格键  向下滚动一屏
Ctrl+B  返回上一屏
=       输出当前行的行号
：f    输出文件名和当前行的行号
V      调用vi编辑器
!命令   调用Shell，并执行命令 
q       退出more
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="常用范例-2"> 常用范例</h4>
<p>1）显示文件中从第3行起的内容</p>
<div><pre><code># cat log2012.log 
2012-01
2012-02
2012-03
2012-04-day1
2012-04-day2
2012-04-day3
# more +3 log2012.log 
2012-03
2012-04-day1
2012-04-day2
2012-04-day3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>2）从文件中查找第一个出现&quot;day3&quot;字符串的行，并从该处前两行开始显示输出</p>
<div><pre><code># more +/day3 log2012.log 
...skipping
2012-04-day1
2012-04-day2
2012-04-day3
2012-05
2012-05-day1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>3）设定每屏显示行数</p>
<div><pre><code># more -5 log2012.log 
2012-01
2012-02
2012-03
2012-04-day1
2012-04-day2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>4）列一个目录下的文件，由于内容太多，我们应该学会用more来分页显示。这得和管道 | 结合起来</p>
<div><pre><code>#  ls -l  | more -5
总计 36
-rw-r--r-- 1 root root  308 11-01 16:49 log2012.log
-rw-r--r-- 1 root root   33 10-28 16:54 log2013.log
-rw-r--r-- 1 root root  127 10-28 16:51 log2014.log
lrwxrwxrwx 1 root root    7 10-28 15:18 log_link.log -&gt; log.log
-rw-r--r-- 1 root root   25 10-28 17:02 log.log
-rw-r--r-- 1 root root   37 10-28 17:07 log.txt
drwxr-xr-x 6 root root 4096 10-27 01:58 scf
drwxrwxrwx 2 root root 4096 10-28 14:47 test3
drwxrwxrwx 2 root root 4096 10-28 14:47 test4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>说明：</p>
<p>每页显示5个文件信息，按 Ctrl+F 或者 空格键 将会显示下5条文件信息。</p>
<h3 id="head命令"> head命令</h3>
<p>head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。</p>
<h4 id="语法-4"> 语法</h4>
<p><code>head(选项)(参数)</code></p>
<h4 id="选项-4"> 选项</h4>
<div><pre><code>-n&lt;数字&gt;：指定显示头部内容的行数；
-c&lt;字符数&gt;：指定显示头部内容的字符数；
-v：总是显示文件名的头信息；
-q：不显示文件名的头信息。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="功能-4"> 功能</h4>
<p>head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。</p>
<h4 id="常用范例-3"> 常用范例</h4>
<p>1）显示文件的前n行</p>
<div><pre><code># cat log2014.log 
2014-01
2014-02
2014-03
2014-04
2014-05
2014-06
2014-07
2014-08
2014-09
2014-10
2014-11
2014-12
# head -n 5 log2014.log 
2014-01
2014-02
2014-03
2014-04
2014-05
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>2）显示文件前n个字节</p>
<div><pre><code># head -c 20 log2014.log
2014-01
2014-02
2014
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>3）文件的除了最后n个字节以外的内容</p>
<div><pre><code># head -c -32 log2014.log
2014-01
2014-02
2014-03
2014-04
2014-05
2014-06
2014-07
2014-08
2014-09
2014-10
2014-11
2014-12
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>4）输出文件除了最后n行的全部内容</p>
<div><pre><code># head -n -6 log2014.log
2014-01
2014-02
2014-03
2014-04
2014-05
2014-06
2014-07
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="tail命令"> tail命令</h3>
<p>tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不断刷新,使你看到最新的文件内容.</p>
<h4 id="语法-5"> 语法</h4>
<p><code>tail(选项)(参数)</code></p>
<h4 id="选项-5"> 选项</h4>
<div><pre><code>-f 循环读取
-q 不显示处理信息
-v 显示详细的处理信息
-c&lt;数目&gt; 显示的字节数
-n&lt;行数&gt; 显示行数
--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. 
-q, --quiet, --silent 从不输出给出文件名的首部 
-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="功能-5"> 功能</h4>
<p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p>
<h4 id="常用范例-4"> 常用范例</h4>
<p>1）显示文件末尾内容</p>
<div><pre><code># tail -n 5 log2014.log 
2014-09
2014-10
2014-11
2014-12
===========================
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>说明：</p>
<p>显示文件最后5行内容</p>
<p>2）循环查看文件内容</p>
<div><pre><code># ping 192.168.120.204 &gt; test.log &amp;
# tail -f test.log 
PING 192.168.120.204 (192.168.120.204) 56(84) bytes of data.
64 bytes from 192.168.120.204: icmp_seq=1 ttl=64 time=0.038 ms
64 bytes from 192.168.120.204: icmp_seq=2 ttl=64 time=0.036 ms
64 bytes from 192.168.120.204: icmp_seq=3 ttl=64 time=0.033 ms
64 bytes from 192.168.120.204: icmp_seq=4 ttl=64 time=0.027 ms
64 bytes from 192.168.120.204: icmp_seq=5 ttl=64 time=0.032 ms
64 bytes from 192.168.120.204: icmp_seq=6 ttl=64 time=0.026 ms
64 bytes from 192.168.120.204: icmp_seq=7 ttl=64 time=0.030 ms
64 bytes from 192.168.120.204: icmp_seq=8 ttl=64 time=0.029 ms
64 bytes from 192.168.120.204: icmp_seq=9 ttl=64 time=0.044 ms
64 bytes from 192.168.120.204: icmp_seq=10 ttl=64 time=0.033 ms
64 bytes from 192.168.120.204: icmp_seq=11 ttl=64 time=0.027 ms
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>3）从第5行开始显示文件</p>
<div><pre><code># cat log2014.log 
2014-01
2014-02
2014-03
2014-04
2014-05
2014-06
2014-07
2014-08
2014-09
2014-10
2014-11
2014-12
# tail -n +5 log2014.log
2014-05
2014-06
2014-07
2014-08
2014-09
2014-10
2014-11
2014-12
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="grep命令"> grep命令</h3>
<p><strong>grep</strong>（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<p>grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p>
<h4 id="选项-6"> 选项</h4>
<div><pre><code>-a 不要忽略二进制数据。
-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。
-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。
-c 计算符合范本样式的列数。
-C&lt;显示列数&gt;或-&lt;显示列数&gt;  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。
-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。
-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。
-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。
-F 将范本样式视为固定字符串的列表。
-G 将范本样式视为普通的表示法来使用。
-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
-H 在显示符合范本样式的那一列之前，标示该列的文件名称。
-i 忽略字符大小写的差别。
-l 列出文件内容符合指定的范本样式的文件名称。
-L 列出文件内容不符合指定的范本样式的文件名称。
-n 在显示符合范本样式的那一列之前，标示出该列的编号。
-q 不显示任何信息。
-R/-r 此参数的效果和指定“-d recurse”参数相同。
-s 不显示错误信息。
-v 反转查找。
-w 只显示全字符合的列。
-x 只显示全列符合的列。
-y 此参数效果跟“-i”相同。
-o 只输出文件中匹配到的部分。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h4 id="规则表达式"> 规则表达式</h4>
<p>grep的规则表达式:</p>
<p>^  #锚定行的开始 如：'^grep'匹配所有以grep开头的行。</p>
<p>$  #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。</p>
<p>.  #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。</p>
<ul>
<li>#匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。</li>
</ul>
<p>.*   #一起用代表任意字符。</p>
<p>[]   #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。</p>
<p>[^]  #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-F和H-Z的一个字母开头，紧跟rep的行。</p>
<p>(..)  #标记匹配字符，如'(love)'，love被标记为1。</p>
<p>\&lt;      #锚定单词的开始，如:'&lt;grep'匹配包含以grep开头的单词的行。</p>
<p>\&gt;      #锚定单词的结束，如'grep&gt;'匹配包含以grep结尾的单词的行。</p>
<p>x{m}  #重复字符x，m次，如：'0{5}'匹配包含5个o的行。</p>
<p>x{m,}  #重复字符x,至少m次，如：'o{5,}'匹配至少有5个o的行。</p>
<p>x{m,n}  #重复字符x，至少m次，不多于n次，如：'o{5,10}'匹配5--10个o的行。</p>
<p>\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。</p>
<p>\W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。</p>
<p>\b    #单词锁定符，如: '\bgrep\b'只匹配grep。</p>
<p>POSIX字符:</p>
<p>为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是[A-Za-z0-9]的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[:alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。</p>
<p>[:alnum:]    #文字数字字符</p>
<p>[:alpha:]    #文字字符</p>
<p>[:digit:]    #数字字符</p>
<p>[:graph:]    #非空字符（非空格、控制字符）</p>
<p>[:lower:]    #小写字符</p>
<p>[:cntrl:]    #控制字符</p>
<p>[:print:]    #非空字符（包括空格）</p>
<p>[:punct:]    #标点符号</p>
<p>[:space:]    #所有空白字符（新行，空格，制表符）</p>
<p>[:upper:]    #大写字符</p>
<p>[:xdigit:]   #十六进制数字（0-9，a-f，A-F）</p>
<h4 id="常用实例-2"> 常用实例</h4>
<p>1）查找指定进程</p>
<div><pre><code> ps -ef|grep svn
root 4943   1      0  Dec05 ?   00:00:00 svnserve -d -r /opt/svndata/grape/
root 16867 16838  0 19:53 pts/0    00:00:00 grep svn
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>2）查找指定进程个数</p>
<div><pre><code># ps -ef|grep -c svn 
2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>3）从文件中读取关键词进行搜索</p>
<div><pre><code># cat test.txt 
hnlinux
peida.cnblogs.com
ubuntu
ubuntu linux
redhat
Redhat
linuxmint
# cat test2.txt 
linux
Redhat
# cat test.txt | grep -f test2.txt
hnlinux
ubuntu linux
Redhat
linuxmint
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>说明：</p>
<p>输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行</p>
<p>4）从文件中读取关键词进行搜索且显示行号</p>
<div><pre><code># cat test.txt 
hnlinux
peida.cnblogs.com
ubuntu
ubuntu linux
redhat
Redhat
linuxmint
# cat test2.txt 
linux
Redhat
# cat test.txt | grep -nf test2.txt
1:hnlinux
4:ubuntu linux
6:Redhat
7:linuxmint

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>说明：</p>
<p>输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行，并显示每一行的行号</p>
<p>5）从文件中查找关键词</p>
<div><pre><code># grep &#39;linux&#39; test.txt 
hnlinux
ubuntu linux
linuxmint
# grep -n &#39;linux&#39; test.txt 
1:hnlinux
4:ubuntu linux
7:linuxmint
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>6）从多个文件中查找关键词</p>
<div><pre><code># grep -n &#39;linux&#39; test.txt test2.txt 
test.txt:1:hnlinux
test.txt:4:ubuntu linux
test.txt:7:linuxmint
test2.txt:1:linux
# grep &#39;linux&#39; test.txt test2.txt 
test.txt:hnlinux
test.txt:ubuntu linux
test.txt:linuxmint
test2.txt:linux
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>说明：</p>
<p>多文件时，输出查询到的信息内容行时，会把文件的命名在行最前面输出并且加上&quot;:&quot;作为标示符</p>
<p>7）grep不显示本身进程</p>
<div><pre><code># ps aux|grep ssh
root   2720  0.0  0.0  62656  1212 ?      Ss   Nov02   0:00 /usr/sbin/sshd
root  16834  0.0  0.0  88088  3288 ?      Ss   19:53   0:00 sshd: root@pts/0 
root  16901  0.0  0.0  61180   764 pts/0  S+   20:31   0:00 grep ssh
# ps aux|grep [s]sh
root   2720  0.0  0.0  62656  1212 ?      Ss   Nov02   0:00 /usr/sbin/sshd
root  16834  0.0  0.0  88088  3288 ?      Ss   19:53   0:00 sshd: root@pts/0 
# ps aux | grep ssh | grep -v &quot;grep&quot;
root   2720  0.0  0.0  62656  1212 ?      Ss   Nov02   0:00 /usr/sbin/sshd
root  16834  0.0  0.0  88088  3288 ?      Ss   19:53   0:00 sshd: root@pts/0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>8）找出已u开头的行内容</p>
<div><pre><code># cat test.txt |grep ^u
ubuntu
ubuntu linux
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>9）输出非u开头的行内容</p>
<div><pre><code># cat test.txt |grep ^[^u]
hnlinux
peida.cnblogs.com
redhat
Redhat
linuxmint
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>10）输出以hat结尾的行内容</p>
<div><pre><code># cat test.txt |grep hat$
redhat
Redhat
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>11）查服务器ip地址所在行</p>
<div><pre><code># ifconfig eth0|grep &quot;[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}&quot;
          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0
# ifconfig eth0|grep -E &quot;([0-9]{1,3}\.){3}[0-9]&quot;
          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>12）显示包含ed或者at字符的内容行</p>
<div><pre><code># cat test.txt |grep -E &quot;peida|com&quot;
peida.cnblogs.com
# cat test.txt |grep -E &quot;ed|at&quot;
redhat
Redhat
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>13）显示当前目录下面以.txt 结尾的文件中的所有包含每个字符串至少有7个连续小写字符的字符串的行</p>
<div><pre><code># grep &#39;[a-z]\{7\}&#39; *.txt
test.txt:hnlinux
test.txt:peida.cnblogs.com
test.txt:linuxmint
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>14）在多级目录中对文本进行递归搜索</p>
<div><pre><code>#grep &quot;text&quot; . -r -n   # .表示当前目录。
</code></pre>
<div><span>1</span><br></div></div><p>15）显示过滤注释( # ; 开头) 和空行后的配置信息</p>
<div><pre><code>#  grep -Ev &quot;^$|^[#;]&quot; server.conf
</code></pre>
<div><span>1</span><br></div></div><p>16）过滤/etc/passwd文件下，包含root的行，并过滤后两行</p>
<div><pre><code>grep -A 2 root /etc/passwd
</code></pre>
<div><span>1</span><br></div></div><p>17）过滤/etc/passwd文件下，包含root的行，并过滤前两行</p>
<div><pre><code>grep -B 2 root /etc/passwd
</code></pre>
<div><span>1</span><br></div></div><p>18）过滤/etc/passwd文件下，包含root的行，并过滤前后两行</p>
<div><pre><code>grep -C 2 root /etc/passwd
</code></pre>
<div><span>1</span><br></div></div><p>18）过滤/etc/passwd文件下，包含root的行数</p>
<div><pre><code>grep -c root /etc/passwd
</code></pre>
<div><span>1</span><br></div></div><p>19)过滤/etc/passwd文件下，包含root的行，并打印行号</p>
<div><pre><code>grep -n root /etc/passwd
</code></pre>
<div><span>1</span><br></div></div><p>20）过滤/etc/下所有文件，包含root的行</p>
<div><pre><code>grep -r root /etc/
</code></pre>
<div><span>1</span><br></div></div><p>21)过滤/etc/下所有文件，包含root的行的文件名</p>
<div><pre><code>grep -rl root /etc/
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">查看文件详细属性</title>
    <id>https://clay-wangzhi.com/linux/basic/file/file-detail/</id>
    <link href="https://clay-wangzhi.com/linux/basic/file/file-detail/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="查看文件详细属性"> 查看文件详细属性</h1>
<h3 id="stat命令"> stat命令</h3>
<div><pre><code># stat a.go 
  File: a.go
  Size: 63        	Blocks: 0          IO Block: 512    regular file
Device: 2h/2d	Inode: 19140298416386648  Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2018-10-09 12:42:07.978765400 +0800
Modify: 2018-10-09 12:42:07.980763600 +0800
Change: 2018-10-09 12:42:07.982774800 +0800
 Birth: -
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>访问时间：atime，查看内容<br>
修改时间：mtime，修改内容
改变时间：ctime，文件属性，比如权限
删除时间：dtime，文件被删除的时间</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">查看文件类型</title>
    <id>https://clay-wangzhi.com/linux/basic/file/file-type/</id>
    <link href="https://clay-wangzhi.com/linux/basic/file/file-type/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="查看文件类型"> 查看文件类型</h1>
<h3 id="ls命令"> ls命令</h3>
<p>ls命令时linux下最常用的命令。ls命令就是list的缩写，缺省下ls用来打印出当前目录的清单，如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。</p>
<p>通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限（包括目录、文件夹、文件权限），查看目录信息等等。</p>
<h4 id="常用选项"> 常用选项</h4>
<div><pre><code>-a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；
-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；
-h:–human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G);
-s：显示文件和目录的大小，以区块为单位；
-t：用文件和目录的更改时间排序；
-r：以文件名反序排列并输出目录内容列表；
-d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；
-R：递归处理，将指定目录下的所有文件及子目录一并处理；
--color[=WHEN]：使用不同的颜色高亮显示不同类型的。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="常用范例"> 常用范例</h4>
<ol>
<li>列出/opt文件夹下的所有文件和目录的详细资料</li>
</ol>
<div><pre><code>ls -lR /opt/
</code></pre>
<div><span>1</span><br></div></div><p>输出结果为：</p>
<div><pre><code>/opt/:
total 124188
-rw-r--r-- 1 root root 127163815 Aug 25 06:10 go1.11.linux-amd64.tar.gz
-rw-r--r-- 1 root root      1003 Sep 11 14:16 setup.sh
drwxr-xr-x 1 root root       512 Jan 28 22:17 test

/opt/test:
total 0
-rw-r--r-- 1 root root 0 Jan 28 22:17 test.txt

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol start="2">
<li>列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：</li>
</ol>
<div><pre><code>ls -l t*
</code></pre>
<div><span>1</span><br></div></div><p>输出结果为：</p>
<div><pre><code>total 0
-rw-r--r-- 1 root root 0 Jan 28 22:17 test.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="3">
<li>列出目前工作目录下所有名称是s 开头的档案，越新的排越后面，可以使用如下命令：</li>
</ol>
<div><pre><code>ls -ltr s*
</code></pre>
<div><span>1</span><br></div></div><p>输出结果为：</p>
<div><pre><code>-rw-r--r-- 1 root root 1003 Sep 11 14:16 setup.sh
-rw-r--r-- 1 root root    0 Jan 28 22:21 s.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="颜色"> 颜色</h4>
<p>蓝色—–目录</p>
<p>绿色—–可执行文件</p>
<p>白色—–一般性文件，如文本文件，配置文件等</p>
<p>红色—–压缩文件或归档文件</p>
<p>浅蓝色—-链接文件</p>
<p>红色闪烁—-链接文件存在问题</p>
<p>黄色—–设备文件</p>
<p>青黄色—-管道文件</p>
<h3 id="file命令"> file命令</h3>
<p>用来探测给定文件的类型。</p>
<h4 id="补充说明"> 补充说明</h4>
<p><strong>file命令</strong> 用来探测给定文件的类型。file命令对文件的检查分为文件系统、魔法幻数检查和语言检查3个过程。</p>
<h4 id="语法"> 语法</h4>
<div><pre><code>file(选项)(参数)
</code></pre>
<div><span>1</span><br></div></div><h4 id="选项"> 选项</h4>
<div><pre><code>-b：列出辨识结果时，不显示文件名称；
-c：详细显示指令执行过程，便于排错或分析程序执行的情形；
-f&lt;名称文件&gt;：指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称；
-L：直接显示符号连接所指向的文件类别；
-m&lt;魔法数字文件&gt;：指定魔法数字文件；
-v：显示版本信息；
-z：尝试去解读压缩文件的内容。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="参数"> 参数</h4>
<p>文件：要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</p>
<h4 id="实例"> 实例</h4>
<p>显示文件类型</p>
<div><pre><code>[root@localhost ~]# file install.log
install.log: UTF-8 Unicode text

[root@localhost ~]# file -b install.log      &lt;== 不显示文件名称
UTF-8 Unicode text

[root@localhost ~]# file -i install.log      &lt;== 显示MIME类别。
install.log: text/plain; charset=utf-8

[root@localhost ~]# file -b -i install.log
text/plain; charset=utf-8

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>显示符号链接的文件类型</p>
<div><pre><code>[root@localhost ~]# ls -l /var/mail
lrwxrwxrwx 1 root root 10 08-13 00:11 /var/mail -&gt; spool/mail

[root@localhost ~]# file /var/mail
/var/mail: symbolic link to `spool/mail&#39;

[root@localhost ~]# file -L /var/mail
/var/mail: directory

[root@localhost ~]# file /var/spool/mail
/var/spool/mail: directory

[root@localhost ~]# file -L /var/spool/mail
/var/spool/mail: directory

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">打包、压缩</title>
    <id>https://clay-wangzhi.com/linux/basic/file/zip/</id>
    <link href="https://clay-wangzhi.com/linux/basic/file/zip/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="打包、压缩"> 打包、压缩</h1>
<h3 id="tar命令"> tar命令</h3>
<p>tar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。</p>
<p>首先要弄清两个概念：打包和压缩。打包时指将一大堆文件或目录变成为一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p>
<p>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（<a href="http://man.linuxde.net/gzip" target="_blank" rel="noopener noreferrer">gzip</a> <a href="http://man.linuxde.net/bzip2" target="_blank" rel="noopener noreferrer">bzip2</a>命令）。</p>
<h4 id="语法"> 语法</h4>
<p><code>tar(选项)(参数)</code></p>
<h4 id="选项"> 选项</h4>
<div><pre><code>-A或--catenate：新增文件到以存在的备份文件；
-B：设置区块大小；
-c或--create：建立新的备份文件；
-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。
-d：记录文件的差别；
-x或--extract或--get：从备份文件中还原文件；
-t或--list：列出备份文件的内容；
-z或--gzip或--ungzip：通过gzip指令处理备份文件；
-Z或--compress或--uncompress：通过compress指令处理备份文件；
-f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；
-v或--verbose：显示指令执行过程；
-r：添加文件到已经压缩的文件；
-u：添加改变了和现有的文件到已经存在的压缩文件；
-j：支持bzip2解压文件；
-v：显示操作过程；
-l：文件系统边界设置；
-k：保留原有文件不覆盖；
-m：保留文件不被覆盖；
-w：确认压缩文件的正确性；
-p或--same-permissions：用原来的文件权限还原文件；
-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；
-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；
--exclude=&lt;范本样式&gt;：排除符合范本样式的文件。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h4 id="参数"> 参数</h4>
<p>文件或目录：指定要打包的文件或目录列表。</p>
<h4 id="常用实例"> 常用实例</h4>
<p>1）<strong>将文件全部打包成tar包</strong>：</p>
<div><pre><code>tar -cvf log.tar log2012.log    仅打包，不压缩！ 
tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 
tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在选项<code>f</code>之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加<code>z</code>选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加<code>j</code>选项，则以.tar.bz2来作为tar包名。</p>
<p>2）<strong>查阅上述tar包内有哪些文件</strong>：</p>
<div><pre><code>tar -ztvf log.tar.gz
</code></pre>
<div><span>1</span><br></div></div><p>由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上<code>z</code>这个选项了。</p>
<p>3）<strong>将tar包解压缩</strong>：</p>
<div><pre><code>tar -zxvf /opt/soft/test/log.tar.gz
</code></pre>
<div><span>1</span><br></div></div><p>在预设的情况下，我们可以将压缩档在任何地方解开的</p>
<p>4）<strong>只将tar内的部分文件解压出来</strong>：</p>
<div><pre><code>tar -zxvf /opt/soft/test/log30.tar.gz log2013.log
</code></pre>
<div><span>1</span><br></div></div><p>5）<strong>文件备份下来，并且保存其权限</strong>：</p>
<div><pre><code>tar -zcvpf log31.tar.gz log2014.log log2015.log log2016.log
</code></pre>
<div><span>1</span><br></div></div><p>这个<code>-p</code>的属性是很重要的，尤其是当您要保留原本文件的属性时。</p>
<p>6）<strong>在文件夹当中，比某个日期新的文件才备份</strong>：</p>
<div><pre><code>tar -N &quot;2012/11/13&quot; -zcvf log17.tar.gz test
</code></pre>
<div><span>1</span><br></div></div><p>7）<strong>备份文件夹内容是排除部分文件：</strong></p>
<div><pre><code>tar --exclude scf/service -zcvf scf.tar.gz scf/*
</code></pre>
<div><span>1</span><br></div></div><p>8）<strong>其实最简单的使用 tar 就只要记忆底下的方式即可：</strong></p>
<div><pre><code>压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称
查　询：tar -jtv -f filename.tar.bz2
解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="gzip命令"> gzip命令</h3>
<p><strong>gzip命令</strong>用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。</p>
<p>gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和<a href="http://man.linuxde.net/tar" target="_blank" rel="noopener noreferrer">tar</a>命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p>
<h4 id="语法-2"> 语法</h4>
<p><code>gzip(选项)(参数)</code></p>
<h4 id="选项-2"> 选项</h4>
<div><pre><code>-a或——ascii：使用ASCII文字模式；
-d或--decompress或----uncompress：解开压缩文件；
-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；
-h或——help：在线帮助；
-l或——list：列出压缩文件的相关信息；
-L或——license：显示版本与版权信息；
-n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；
-N或——name：压缩文件时，保存原来的文件名称及时间戳记；
-q或——quiet：不显示警告信息；
-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；
-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；
-t或——test：测试压缩文件是否正确无误；
-v或——verbose：显示指令执行过程；
-V或——version：显示版本信息；
-&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；
--best：此参数的效果和指定“-9”参数相同；
--fast：此参数的效果和指定“-1”参数相同。

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id="参数-2"> 参数</h4>
<p>文件列表：指定要压缩的文件列表。</p>
<h4 id="常用范例"> 常用范例</h4>
<p>1）把test6目录下的每个文件压缩成.gz文件</p>
<div><pre><code># ll
总计 604
---xr--r-- 1 root mail  302108 11-30 08:39 linklog.log
---xr--r-- 1 mail users 302108 11-30 08:39 log2012.log
-rw-r--r-- 1 mail users     61 11-30 08:39 log2013.log
# gzip *
# ll
总计 28
---xr--r-- 1 root mail  1341 11-30 08:39 linklog.log.gz
---xr--r-- 1 mail users 1341 11-30 08:39 log2012.log.gz
-rw-r--r-- 1 mail users   70 11-30 08:39 log2013.log.gz

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>2）把例1中每个压缩的文件解压，并列出详细的信息</p>
<div><pre><code># ll
总计 28
---xr--r-- 1 root mail  1341 11-30 08:39 linklog.log.gz
---xr--r-- 1 mail users 1341 11-30 08:39 log2012.log.gz
-rw-r--r-- 1 mail users   70 11-30 08:39 log2013.log.gz
# gzip -dv *
linklog.log.gz:  99.6% -- replaced with linklog.log
log2012.log.gz:  99.6% -- replaced with log2012.log
log2013.log.gz:  47.5% -- replaced with log2013.log
# ll
总计 604
---xr--r-- 1 root mail  302108 11-30 08:39 linklog.log
---xr--r-- 1 mail users 302108 11-30 08:39 log2012.log
-rw-r--r-- 1 mail users     61 11-30 08:39 log2013.log

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>3）详细显示例1中每个压缩的文件的信息，并不解压</p>
<div><pre><code># gzip -l *
         compressed        uncompressed  ratio uncompressed_name
               1341              302108  99.6% linklog.log
               1341              302108  99.6% log2012.log
                 70                  61  47.5% log2013.log


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>4）压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gz</p>
<div><pre><code>#ls -al log.tar
-rw-r--r-- 1 root root 307200 11-29 17:54 log.tar
# gzip -r log.tar
# ls -al log.tar.gz 
-rw-r--r-- 1 root root 1421 11-29 17:54 log.tar.gz

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>5）递归的压缩目录</p>
<div><pre><code># ll
总计 604
---xr--r-- 1 root mail  302108 11-30 08:39 linklog.log
---xr--r-- 1 mail users 302108 11-30 08:39 log2012.log
-rw-r--r-- 1 mail users     61 11-30 08:39 log2013.log
# cd ..
# gzip -rv test6
test6/linklog.log:       99.6% -- replaced with test6/linklog.log.gz
test6/log2013.log:       47.5% -- replaced with test6/log2013.log.gz
test6/log2012.log:       99.6% -- replaced with test6/log2012.log.gz
# cd test6
# ll
总计 28
---xr--r-- 1 root mail  1341 11-30 08:39 linklog.log.gz
---xr--r-- 1 mail users 1341 11-30 08:39 log2012.log.gz
-rw-r--r-- 1 mail users   70 11-30 08:39 log2013.log.gz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>说明：</p>
<p>这样，所有test下面的文件都变成了*.gz，目录依然存在只是目录里面的文件相应变成了*.gz.这就是压缩，和打包不同。因为是对目录操作，所以需要加上-r选项，这样也可以对子目录进行递归了。</p>
<p>6）递归地解压目录</p>
<div><pre><code># ll
总计 28
---xr--r-- 1 root mail  1341 11-30 08:39 linklog.log.gz
---xr--r-- 1 mail users 1341 11-30 08:39 log2012.log.gz
-rw-r--r-- 1 mail users   70 11-30 08:39 log2013.log.gz
# cd ..
# gzip -dr test6
# cd test6
# ll
总计 604
---xr--r-- 1 root mail  302108 11-30 08:39 linklog.log
---xr--r-- 1 mail users 302108 11-30 08:39 log2012.log
-rw-r--r-- 1 mail users     61 11-30 08:39 log2013.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">创建、复制、移动、删除</title>
    <id>https://clay-wangzhi.com/linux/basic/file/zsgc/</id>
    <link href="https://clay-wangzhi.com/linux/basic/file/zsgc/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="创建、复制、移动、删除"> 创建、复制、移动、删除</h1>
<h3 id="touch命令-创建文件"> touch命令（创建文件）</h3>
<p>linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。</p>
<h4 id="语法"> 语法</h4>
<p><code>touch(选项)(参数)</code></p>
<p>选项</p>
<div><pre><code>-a：或--time=atime或--time=access或--time=use  只更改存取时间；
-c：或--no-create  不建立任何文件；
-d：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间；
-f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；
-m：或--time=mtime或--time=modify  只更该变动时间；
-r：&lt;参考文件或目录&gt;  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；
-t：&lt;日期时间&gt;  使用指定的日期时间，而非现在的时间；
--help：在线帮助；
--version：显示版本信息。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="功能"> 功能</h4>
<p>touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。</p>
<h4 id="常用范例"> 常用范例</h4>
<p>1）创建不存在的文件</p>
<div><pre><code># touch log2012.log log2013.log
# ll
-rw-r--r-- 1 root root    0 10-28 16:01 log2012.log
-rw-r--r-- 1 root root    0 10-28 16:01 log2013.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果log2014.log不存在，则不创建文件</p>
<div><pre><code># touch -c log2014.log
# ll
-rw-r--r-- 1 root root    0 10-28 16:01 log2012.log
-rw-r--r-- 1 root root    0 10-28 16:01 log2013.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>2）更新log.log的时间和log2012.log时间戳相同</p>
<div><pre><code># ll
-rw-r--r-- 1 root root    0 10-28 16:01 log2012.log
-rw-r--r-- 1 root root    0 10-28 16:01 log2013.log
-rw-r--r-- 1 root root    0 10-28 14:48 log.log
# touch -r log.log log2012.log 
# ll
-rw-r--r-- 1 root root    0 10-28 14:48 log2012.log
-rw-r--r-- 1 root root    0 10-28 16:01 log2013.log
-rw-r--r-- 1 root root    0 10-28 14:48 log.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>3）设定文件的时间戳</p>
<div><pre><code># ll
-rw-r--r-- 1 root root    0 10-28 14:48 log2012.log
-rw-r--r-- 1 root root    0 10-28 16:01 log2013.log
-rw-r--r-- 1 root root    0 10-28 14:48 log.log
# touch -t 201211142234.50 log.log
# ll
-rw-r--r-- 1 root root    0 10-28 14:48 log2012.log
-rw-r--r-- 1 root root    0 10-28 16:01 log2013.log
-rw-r--r-- 1 root root    0 2012-11-14 log.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>说明：</p>
<p>-t  time 使用指定的时间值 time 作为指定文件相应时间戳记的新值．此处的 time规定为如下形式的十进制数:</p>
<p>[[CC]YY]MMDDhhmm[.SS]</p>
<p>这里，CC为年数中的前两位，即”世纪数”；YY为年数的后两位，即某世纪中的年数．如果不给出CC的值，则touch   将把年数CCYY限定在1969--2068之内．MM为月数，DD为天将把年数CCYY限定在1969--2068之内．MM为月数，DD为天数，hh 为小时数(几点)，mm为分钟数，SS为秒数．此处秒的设定范围是0--61，这样可以处理闰秒．这些数字组成的时间是环境变量TZ指定的时区中的一个时 间．由于系统的限制，早于1970年1月1日的时间是错误的。</p>
<p>4）同时创建多个文件</p>
<div><pre><code><span>touch</span> file<span>{</span><span>1</span><span>..</span><span>20</span><span>}</span>
<span>touch</span> /home/<span>{</span>aa,bb<span>}</span>
//<span>{</span><span>}</span>里面为集合
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="mkdir命令-创建目录"> mkdir命令（创建目录）</h3>
<p>mkdir命令用来创建目录。该命令创建由<a href="http://man.linuxde.net/dirname" target="_blank" rel="noopener noreferrer">dirname</a>命名的目录。如果在目录名的前面没有加任何路径名，则在当前目录下创建由dirname指定的目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。</p>
<h4 id="语法-2"> 语法</h4>
<p><code>cd (选项) (参数)</code></p>
<h4 id="选项"> 选项</h4>
<div><pre><code>-Z：设置安全上下文，当使用SELinux时有效；
-m&lt;目标属性&gt;或--mode&lt;目标属性&gt;建立目录的同时设置目录的权限；
-p或--parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；
-v, --verbose  每次创建新目录都显示信息
--version 显示版本信息。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="常用范例-2"> 常用范例</h4>
<p>1）创建一个空目录</p>
<div><pre><code>mkdir test1
</code></pre>
<div><span>1</span><br></div></div><p>2）递归创建多个目录</p>
<div><pre><code>mkdir -p test2/test22
</code></pre>
<div><span>1</span><br></div></div><p>3）创建权限为777的目录</p>
<div><pre><code>mkdir -m 777 test3
</code></pre>
<div><span>1</span><br></div></div><p>4）一个命令创建项目的目录结构</p>
<div><pre><code>#mkdir -vp scf/{lib/,bin/,doc/{info,product},logs/{info,product},service/deploy/{info,product}}
mkdir: 已创建目录 “scf”

mkdir: 已创建目录 “scf/lib”

mkdir: 已创建目录 “scf/bin”

mkdir: 已创建目录 “scf/doc”

mkdir: 已创建目录 “scf/doc/info”

mkdir: 已创建目录 “scf/doc/product”

mkdir: 已创建目录 “scf/logs”

mkdir: 已创建目录 “scf/logs/info”

mkdir: 已创建目录 “scf/logs/product”

mkdir: 已创建目录 “scf/service”

mkdir: 已创建目录 “scf/service/deploy”

mkdir: 已创建目录 “scf/service/deploy/info”

mkdir: 已创建目录 “scf/service/deploy/product”

# tree scf/

scf/

|-- bin

|-- doc

|   |-- info

|   `-- product

|-- lib

|-- logs

|   |-- info

|   `-- product

`-- service

   	 	`-- deploy

  	    	|-- info

        	`-- product


12 directories, 0 files

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><h3 id="cp命令-复制"> cp命令（复制）</h3>
<p>cp命令用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。</p>
<h4 id="语法-3"> 语法</h4>
<p><code>cp(选项)(参数)</code></p>
<h4 id="选项-2"> 选项</h4>
<div><pre><code>-a：此参数的效果和同时指定&quot;-dpR&quot;参数相同；
-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；
-f：强行复制文件或目录，不论目标文件或目录是否已存在；
-i：覆盖既有文件之前先询问用户；
-l：对源文件建立硬连接，而非复制文件；
-p：保留源文件或目录的属性；
-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；
-s：对源文件建立符号连接，而非复制文件；
-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；
-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；
-b：覆盖已存在的文件目标前将目标文件备份；
-v：详细显示命令执行的操作。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h4 id="参数"> 参数</h4>
<ul>
<li>源文件：制定源文件列表。默认情况下，cp命令不能复制目录，如果要复制目录，则必须使用<code>-R</code>选项；</li>
<li>目标文件：指定目标文件。当“源文件”为多个文件时，要求“目标文件”为指定的目录。</li>
</ul>
<h4 id="常用范例-3"> 常用范例</h4>
<p>1）复制单个文件到目标目录，文件在目标文件中不存在</p>
<div><pre><code># cp log.log test5
# ll
-rw-r--r-- 1 root root    0 10-28 14:48 log.log
drwxr-xr-x 6 root root 4096 10-27 01:58 scf
drwxrwxrwx 2 root root 4096 10-28 14:47 test3
drwxr-xr-x 2 root root 4096 10-28 14:53 test5
# cd test5
# ll
-rw-r--r-- 1 root root 0 10-28 14:46 log5-1.log
-rw-r--r-- 1 root root 0 10-28 14:46 log5-2.log
-rw-r--r-- 1 root root 0 10-28 14:46 log5-3.log
-rw-r--r-- 1 root root 0 10-28 14:53 log.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>说明：</p>
<p>在没有带-a参数时，两个文件的时间是不一样的。在带了-a参数时，两个文件的时间是一致的。</p>
<p>2）目标文件存在时，会询问是否覆盖</p>
<div><pre><code># cp log.log test5
cp：是否覆盖“test5/log.log”? n
# cp -a log.log test5
cp：是否覆盖“test5/log.log”? y
# cd test5/
# ll
-rw-r--r-- 1 root root 0 10-28 14:46 log5-1.log
-rw-r--r-- 1 root root 0 10-28 14:46 log5-2.log
-rw-r--r-- 1 root root 0 10-28 14:46 log5-3.log
-rw-r--r-- 1 root root 0 10-28 14:48 log.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>说明：</p>
<p>目标文件存在时，会询问是否覆盖。这是因为cp是cp -i的别名。目标文件存在时，即使加了-f标志，也还会询问是否覆盖。</p>
<p>3）复制整个目录</p>
<p>目标目录存在时：</p>
<div><pre><code>#cp -a test3 test5 
# ll
-rw-r--r-- 1 root root    0 10-28 14:48 log.log
drwxr-xr-x 6 root root 4096 10-27 01:58 scf
drwxrwxrwx 2 root root 4096 10-28 14:47 test3
drwxr-xr-x 3 root root 4096 10-28 15:11 test5
# cd test5/
# ll
-rw-r--r-- 1 root root    0 10-28 14:46 log5-1.log
-rw-r--r-- 1 root root    0 10-28 14:46 log5-2.log
-rw-r--r-- 1 root root    0 10-28 14:46 log5-3.log
-rw-r--r-- 1 root root    0 10-28 14:48 log.log
drwxrwxrwx 2 root root 4096 10-28 14:47 test3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>目标目录不存在时：</p>
<div><pre><code># cp -a test3 test4
# ll
-rw-r--r-- 1 root root    0 10-28 14:48 log.log
drwxr-xr-x 6 root root 4096 10-27 01:58 scf
drwxrwxrwx 2 root root 4096 10-28 14:47 test3
drwxrwxrwx 2 root root 4096 10-28 14:47 test4
drwxr-xr-x 3 root root 4096 10-28 15:11 test5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>说明：</p>
<p>注意目标目录存在与否结果是不一样的。目标目录存在时，整个源目录被复制到目标目录里面。</p>
<p>4）复制的 log.log 建立一个链接到 log_link.log</p>
<div><pre><code># cp -s log.log log_link.log
# ll
lrwxrwxrwx 1 root root    7 10-28 15:18 log_link.log -&gt; log.log
-rw-r--r-- 1 root root    0 10-28 14:48 log.log
drwxr-xr-x 6 root root 4096 10-27 01:58 scf
drwxrwxrwx 2 root root 4096 10-28 14:47 test3
drwxrwxrwx 2 root root 4096 10-28 14:47 test4
drwxr-xr-x 3 root root 4096 10-28 15:11 test5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>说明：</p>
<p>那个 log_link.log 是由 -s 的参数造成的，建立的是一个『快捷方式』，所以您会看到在文件的最右边，会显示这个文件是『连结』到哪里去的！</p>
<p>5）将文件file复制到目录<code>/usr/men/tmp</code>下，并改名为file1</p>
<div><pre><code>cp file /usr/men/tmp/file1
</code></pre>
<div><span>1</span><br></div></div><p>6）将目录<code>/usr/men</code>下的所有文件及其子目录复制到目录<code>/usr/zh</code>中</p>
<div><pre><code>cp -i /usr/men m*.c /usr/zh
</code></pre>
<div><span>1</span><br></div></div><p>我们在Linux下使用cp命令复制文件时候，有时候会需要覆盖一些同名文件，覆盖文件的时候都会有提示：需要不停的按Y来确定执行覆盖。文件数量不多还好，但是要是几百个估计按Y都要吐血了，于是折腾来半天总结了一个方法：</p>
<div><pre><code>cp aaa/* /bbb
复制目录aaa下所有到/bbb目录下，这时如果/bbb目录下有和aaa同名的文件，需要按Y来确认并且会略过aaa目录下的子目录。

cp -r aaa/* /bbb
这次依然需要按Y来确认操作，但是没有忽略子目录。

cp -r -a aaa/* /bbb
依然需要按Y来确认操作，并且把aaa目录以及子目录和文件属性也传递到了/bbb。

\cp -r -a aaa/* /bbb
成功，没有提示按Y、传递了目录属性、没有略过目录。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="mv命令-移动"> mv命令（移动）</h3>
<p><strong>mv命令</strong>用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source表示源文件或目录，target表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。</p>
<p>mv命令可以用来将源文件移至一个目标文件中，或将一组文件移至一个目标目录中。源文件被移至目标文件有两种不同的结果：</p>
<ol>
<li>如果目标文件是到某一目录文件的路径，源文件会被移到此目录下，且文件名不变。</li>
<li>如果目标文件不是目录文件，则源文件名（只能有一个）会变为此目标文件名，并覆盖己存在的同名文件。如果源文件和目标文件在同一个目录下，mv的作用就是改文件名。当目标文件是目录文件时，源文件或目录参数可以有多个，则所有的源文件都会被移至目标文件中。所有移到该目录下的文件都将保留以前的文件名。</li>
</ol>
<p>注意事项：mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p>
<h4 id="语法-4"> 语法</h4>
<p><code>mv(选项)(参数)</code></p>
<h4 id="选项-3"> 选项</h4>
<div><pre><code>--backup=&lt;备份模式&gt;：若需覆盖文件，则覆盖前先行备份；
-b：当文件存在时，覆盖前，为其创建一个备份；
-f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录；
-i：交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。
--strip-trailing-slashes：删除源文件中的斜杠“/”；
-S&lt;后缀&gt;：为备份文件指定后缀，而不使用默认的后缀；
-t:--target-directory=&lt;目录&gt;,指定源文件要移动到目标目录；
-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="参数-2"> 参数</h4>
<ul>
<li>源文件：源文件列表。</li>
<li>目标文件：如果“目标文件”是文件名则在移动文件的同时，将其改名为“目标文件”；如果“目标文件”是目录名则将源文件移动到“目标文件”下。</li>
</ul>
<h4 id="常用范例-4"> 常用范例</h4>
<p>1）文件改名</p>
<div><pre><code># ll
总计 20drwxr-xr-x 6 root root 4096 10-27 01:58 scf
drwxrwxrwx 2 root root 4096 10-25 17:46 test3
drwxr-xr-x 2 root root 4096 10-25 17:56 test4
drwxr-xr-x 3 root root 4096 10-25 17:56 test5
-rw-r--r-- 1 root root   16 10-28 06:04 test.log
# mv test.log test1.txt
# ll
总计 20drwxr-xr-x 6 root root 4096 10-27 01:58 scf
-rw-r--r-- 1 root root   16 10-28 06:04 test1.txt
drwxrwxrwx 2 root root 4096 10-25 17:46 test3
drwxr-xr-x 2 root root 4096 10-25 17:56 test4
drwxr-xr-x 3 root root 4096 10-25 17:56 test5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>2）移动文件</p>
<div><pre><code># ll
总计 20drwxr-xr-x 6 root root 4096 10-27 01:58 scf
-rw-r--r-- 1 root root   29 10-28 06:05 test1.txt
drwxrwxrwx 2 root root 4096 10-25 17:46 test3
drwxr-xr-x 2 root root 4096 10-25 17:56 test4
drwxr-xr-x 3 root root 4096 10-25 17:56 test5
# mv test1.txt test3
# ll
总计 16drwxr-xr-x 6 root root 4096 10-27 01:58 scf
drwxrwxrwx 2 root root 4096 10-28 06:09 test3
drwxr-xr-x 2 root root 4096 10-25 17:56 test4
drwxr-xr-x 3 root root 4096 10-25 17:56 test5
# cd test3
# ll
总计 4
-rw-r--r-- 1 root root 29 10-28 06:05 test1.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>3）将文件log1.txt,log2.txt,log3.txt移动到目录test3中</p>
<div><pre><code># ll
总计 28
-rw-r--r-- 1 root root    8 10-28 06:15 log1.txt
-rw-r--r-- 1 root root   12 10-28 06:15 log2.txt
-rw-r--r-- 1 root root   13 10-28 06:16 log3.txt
drwxrwxrwx 2 root root 4096 10-28 06:09 test3
# mv log1.txt log2.txt log3.txt test3
# ll
总计 16drwxrwxrwx 2 root root 4096 10-28 06:18 test3
# cd test3/
# ll
总计 16
-rw-r--r-- 1 root root  8 10-28 06:15 log1.txt
-rw-r--r-- 1 root root 12 10-28 06:15 log2.txt
-rw-r--r-- 1 root root 13 10-28 06:16 log3.txt
-rw-r--r-- 1 root root 29 10-28 06:05 test1.txt
# ll
总计 20
-rw-r--r-- 1 root root    8 10-28 06:15 log1.txt
-rw-r--r-- 1 root root   12 10-28 06:15 log2.txt
-rw-r--r-- 1 root root   13 10-28 06:16 log3.txt
drwxr-xr-x 2 root root 4096 10-28 06:21 logs
-rw-r--r-- 1 root root   29 10-28 06:05 test1.txt
# mv -t /opt/soft/test/test4/ log1.txt log2.txt 	log3.txt 
]# cd ..
# cd test4/
# ll
总计 12
-rw-r--r-- 1 root root  8 10-28 06:15 log1.txt
-rw-r--r-- 1 root root 12 10-28 06:15 log2.txt
-rw-r--r-- 1 root root 13 10-28 06:16 log3.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>4）将文件file1改名为file2，如果file2已经存在，则询问是否覆盖</p>
<div><pre><code># ll
总计 12
-rw-r--r-- 1 root root  8 10-28 06:15 log1.txt
-rw-r--r-- 1 root root 12 10-28 06:15 log2.txt
-rw-r--r-- 1 root root 13 10-28 06:16 log3.txt
# cat log1.txt 
odfdfs
# cat log2.txt 
ererwerwer
# mv -i log1.txt log2.txt 
mv：是否覆盖“log2.txt”? y
# cat log2.txt 
odfdfs
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>5）将文件file1改名为file2，即使file2存在，也是直接覆盖掉</p>
<div><pre><code># ll
总计 8
-rw-r--r-- 1 root root  8 10-28 06:15 log2.txt
-rw-r--r-- 1 root root 13 10-28 06:16 log3.txt
# cat log2.txt 
odfdfs
# cat log3
cat: log3: 没有那个文件或目录
# ll
总计 8
-rw-r--r-- 1 root root  8 10-28 06:15 log2.txt
-rw-r--r-- 1 root root 13 10-28 06:16 log3.txt
# cat log2.txt 
odfdfs
# cat log3.txt 
dfosdfsdfdss
# mv -f log3.txt log2.txt 
# cat log2.txt 
dfosdfsdfdss
# ll
总计 4
-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>说明：</p>
<p>log3.txt的内容直接覆盖了log2.txt内容，-f 这是个危险的选项，使用的时候一定要保持头脑清晰，一般情况下最好不用加上它。</p>
<p>6）目录的移动</p>
<div><pre><code>ll
-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt
# ll
-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt
# cd ..
# ll
drwxr-xr-x 6 root root 4096 10-27 01:58 scf
drwxrwxrwx 3 root root 4096 10-28 06:24 test3
drwxr-xr-x 2 root root 4096 10-28 06:48 test4
drwxr-xr-x 3 root root 4096 10-25 17:56 test5
# cd test3
# ll
drwxr-xr-x 2 root root 4096 10-28 06:21 logs
-rw-r--r-- 1 root root   29 10-28 06:05 test1.txt
# cd ..
# mv test4 test3
# ll
drwxr-xr-x 6 root root 4096 10-27 01:58 scf
drwxrwxrwx 4 root root 4096 10-28 06:54 test3
drwxr-xr-x 3 root root 4096 10-25 17:56 test5
# cd test3/
# ll
drwxr-xr-x 2 root root 4096 10-28 06:21 log
-rw-r--r-- 1 root root   29 10-28 06:05 test1.txt
drwxr-xr-x 2 root root 4096 10-28 06:48 test4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>说明：</p>
<p>如果目录dir2不存在，将目录dir1改名为dir2；否则，将dir1移动到dir2中。</p>
<p>7）移动当前文件夹下的所有文件到上一级目录</p>
<div><pre><code># ll
-rw-r--r-- 1 root root 25 10-28 07:02 log1.txt
-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt
# mv * ../
# ll
# cd ..
# ll
-rw-r--r-- 1 root root   25 10-28 07:02 log1.txt
-rw-r--r-- 1 root root   13 10-28 06:16 log2.txt
drwxr-xr-x 2 root root 4096 10-28 06:21 logs
-rw-r--r-- 1 root root   29 10-28 06:05 test1.txt
drwxr-xr-x 2 root root 4096 10-28 07:02 test4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>8）把当前目录的一个子目录里的文件移动到另一个子目录里</p>
<div><pre><code># ll
drwxr-xr-x 6 root root 4096 10-27 01:58 scf
drwxrwxrwx 4 root root 4096 10-28 07:02 test3
drwxr-xr-x 3 root root 4096 10-25 17:56 test5
# cd test3
# ll
-rw-r--r-- 1 root root   25 10-28 07:02 log1.txt
-rw-r--r-- 1 root root   13 10-28 06:16 log2.txt
drwxr-xr-x 2 root root 4096 10-28 06:21 logs
-rw-r--r-- 1 root root   29 10-28 06:05 test1.txt
drwxr-xr-x 2 root root 4096 10-28 07:02 test4
# cd ..
# mv test3/*.txt test5
# cd test5
# ll
-rw-r--r-- 1 root root   25 10-28 07:02 log1.txt
-rw-r--r-- 1 root root   13 10-28 06:16 log2.txt
-rw-r--r-- 1 root root   29 10-28 06:05 test1.txt
drwxr-xr-x 2 root root 4096 10-25 17:56 test5-1
# 	cd ..
# cd test3/
# ll
drwxr-xr-x 2 root root 4096 10-28 06:21 logs
drwxr-xr-x 2 root root 4096 10-28 07:02 test4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>9）文件被覆盖前做简单备份，前面加参数-b</p>
<div><pre><code># ll
-rw-r--r-- 1 root root   25 10-28 07:02 log1.txt
-rw-r--r-- 1 root root   13 10-28 06:16 log2.txt
-rw-r--r-- 1 root root   29 10-28 06:05 test1.txt
drwxr-xr-x 2 root root 4096 10-25 17:56 test5-1
# mv log1.txt -b log2.txt
mv：是否覆盖“log2.txt”? y
# ll
-rw-r--r-- 1 root root   25 10-28 07:02 log2.txt
-rw-r--r-- 1 root root   13 10-28 06:16 log2.txt~
-rw-r--r-- 1 root root   29 10-28 06:05 test1.txt
drwxr-xr-x 2 root root 4096 10-25 17:56 test5-1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>说明：</p>
<p>-b 不接受参数，mv会去读取环境变量VERSION_CONTROL来作为备份策略。</p>
<p>--backup该选项指定如果目标文件存在时的动作，共有四种备份策略：</p>
<p>1.CONTROL=none或off : 不备份。</p>
<p>2.CONTROL=numbered或t：数字编号的备份</p>
<p>3.CONTROL=existing或nil：如果存在以数字编号的备份，则继续编号备份m+1...n：</p>
<p>执行mv操作前已存在以数字编号的文件log2.txt.<sub>1</sub>，那么再次执行将产生log2.txt<sub>2</sub>，以次类推。如果之前没有以数字编号的文件，则使用下面讲到的简单备份。</p>
<p>4.CONTROL=simple或never：使用简单备份：在被覆盖前进行了简单备份，简单备份只能有一份，再次被覆盖时，简单备份也会被覆盖。</p>
<h3 id="rm命令-删除"> rm命令（删除）</h3>
<p>rm命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。</p>
<p>rm是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。</p>
<h4 id="语法-5"> 语法</h4>
<p><code>rm (选项)(参数)</code></p>
<h4 id="选项-4"> 选项</h4>
<div><pre><code>-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录；
-f：强制删除文件或目录；
-i：删除已有文件或目录之前先询问用户；
-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；
--preserve-root：不对根目录进行递归操作；
-v：显示指令的详细执行过程。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="参数-3"> 参数</h4>
<p>文件：指定被删除的文件列表，如果参数中含有目录，则必须加上<code>-r</code>或者<code>-R</code>选项。</p>
<h4 id="常用范例-5"> 常用范例</h4>
<p>1）删除文件file，系统会先询问是否删除。</p>
<div><pre><code># rm log.log 
rm：是否删除 一般文件 “log.log”? y
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>输入rm log.log命令后，系统会询问是否删除，输入y后就会删除文件，不想删除则数据n。</p>
<p>2）强行删除file，系统不再提示</p>
<div><pre><code>rm -f log1.log
</code></pre>
<div><span>1</span><br></div></div><p>3）删除任何.log文件；删除前逐一询问确认</p>
<div><pre><code>rm -i *.log
</code></pre>
<div><span>1</span><br></div></div><p>4）将 test1子目录及子目录中所有档案删除</p>
<div><pre><code>rm -r test1
</code></pre>
<div><span>1</span><br></div></div><h3 id="rmdir命令-删除空目录"> rmdir命令（删除空目录）</h3>
<p>rmdir命令。rmdir是常用的命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。（注意，rm - r dir命令可代替rmdir，但是有很大危险性。）删除某目录时也必须具有对父目录的写权限。</p>
<h4 id="语法-6"> 语法</h4>
<p><code>rmdir(选项)(参数)</code></p>
<h4 id="选项-5"> 选项</h4>
<div><pre><code>-p或--parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除；
--ignore-fail-on-non-empty：此选项使rmdir命令忽略由于删除非空目录时导致的错误信息；
-v或-verboes：显示命令的详细执行过程；
--help：显示命令的帮助信息；
--version：显示命令的版本信息。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="参数-4"> 参数</h4>
<p>目录列表：要删除的空目录列表。当删除多个空目录时，目录名之间使用空格隔开。</p>
<h4 id="常用范例-6"> 常用范例</h4>
<p>1）rmdir 不能删除非空目录</p>
<div><pre><code># tree
.
|-- bin
|-- doc
|   |-- info
|   `-- product
|-- lib
|-- logs
|   |-- info
|   `-- product
`-- service
    `-- deploy
        |-- info
        `-- product
12 directories, 0 files
# rmdir doc
rmdir: doc: 目录非空
# rmdir doc/info
# rmdir doc/product
# tree
.
|-- bin
|-- doc
|-- lib
|-- logs
|   |-- info
|   `-- product
`-- service
    `-- deploy
        |-- info
        `-- product
10 directories, 0 files
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>2）rmdir -p 当子目录被删除后使它也成为空目录的话，则顺便一并删除</p>
<div><pre><code># tree
.
|-- bin
|-- doc
|-- lib
|-- logs
|   `-- product
`-- service
    `-- deploy
        |-- info
        `-- product
10 directories, 0 files
# rmdir -p logs
rmdir: logs: 目录非空
# tree
.
|-- bin
|-- doc
|-- lib
|-- logs
|   `-- product
`-- service
    `-- deploy
        |-- info
        `-- product
9 directories, 0 files
# rmdir -p logs/product
# tree
.
|-- bin
|-- doc
|-- lib
`-- service
`-- deploy
        |-- info
        `-- product
7 directories, 0 files
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">管道及I/O重定向</title>
    <id>https://clay-wangzhi.com/linux/basic/i-o/</id>
    <link href="https://clay-wangzhi.com/linux/basic/i-o/"/>
    <updated>2021-05-11T06:11:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="管道及i-o重定向"> 管道及I/O重定向</h1>
<h2 id="标准输入、标准输出、标准错误"> 标准输入、标准输出、标准错误</h2>
<h3 id="输出重定向"> 输出重定向</h3>
<p>输出重定向（覆盖）</p>
<div><pre><code>date &gt; a.txt
</code></pre>
<div><span>1</span><br></div></div><p>输出重定向（追加）</p>
<div><pre><code>date 1&gt;&gt; a.txt
</code></pre>
<div><span>1</span><br></div></div><p>错误输出重定向</p>
<div><pre><code>ls /home/ /aa &gt;&gt; a.txt 2&gt;b.txt
</code></pre>
<div><span>1</span><br></div></div><p>正确和错误都输入到相同位置</p>
<div><pre><code>ls /home/ /aa &amp;&gt; a.txt 
ls /home/ /aa &gt; a.txt 2&gt;&amp;1 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>重定向到空设备/dev/null</p>
<div><pre><code>ls /home/ /aa &amp;&gt; /dev/null
</code></pre>
<div><span>1</span><br></div></div><h3 id="输入重定向"> 输入重定向</h3>
<div><pre><code>grep &#39;root&#39; &lt; /etc/passwd
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>mysql -uroot -p123 &lt; aa.sql
</code></pre>
<div><span>1</span><br></div></div><h3 id="总和应用"> 总和应用</h3>
<div><pre><code>cat &gt; a.txt &lt;&lt;EOF
&gt; 11
&gt; 22
&gt; EOF
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">网络管理</title>
    <id>https://clay-wangzhi.com/linux/basic/inter/</id>
    <link href="https://clay-wangzhi.com/linux/basic/inter/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="网络管理"> 网络管理</h1>
<h1 id="网络基础"> 网络基础</h1>
<h2 id="常见的网络接口"> 常见的网络接口</h2>
<p>eth0			以太网接口
lo				本地环回接口<br>
br0			桥接接口 （虚拟交换机）
vnet0		    KVM虚拟机网卡接口</p>
<h2 id="查看网络信息"> 查看网络信息</h2>
<div><pre><code>ip addr //查看IP、掩码、MAC...
ip addr show eth0 //只显示eth0的信息
ip route //查看本机路由表
cat /etc/resolv.conf //查看DNS
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">/etc/security/limits.conf 详解与配置</title>
    <id>https://clay-wangzhi.com/linux/basic/limit/</id>
    <link href="https://clay-wangzhi.com/linux/basic/limit/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="etc-security-limits-conf-详解与配置"> /etc/security/limits.conf 详解与配置</h1>
<h2 id="一、-etc-security-limits-conf-详解"> 一、 /etc/security/limits.conf 详解</h2>
<p><code>/etc/security/limits.conf</code> 文件实际是 Linux PAM（插入式认证模块，Pluggable Authentication Modules）中 <code>pam_limits.so</code> 的配置文件，而且只针对于单个会话。 该设置不会影响系统服务的资源限制。还要注意 <code>/etc/security/limits.d/</code> 的这个目录，</p>
<h3 id="etc-security-limits-conf-配置解析"> /etc/security/limits.conf 配置解析</h3>
<div><pre><code># /etc/security/limits.conf
#
#This file sets the resource limits for the users logged in via PAM.
该文件为通过PAM登录的用户设置资源限制。
#It does not affect resource limits of the system services.
#它不影响系统服务的资源限制。
#Also note that configuration files in /etc/security/limits.d directory,
#which are read in alphabetical order, override the settings in this
#file in case the domain is the same or more specific.
请注意/etc/security/limits.d下按照字母顺序排列的配置文件会覆盖 /etc/security/limits.conf中的
domain相同的的配置
#That means for example that setting a limit for wildcard domain here
#can be overriden with a wildcard setting in a config file in the
#subdirectory, but a user specific setting here can be overriden only
#with a user specific setting in the subdirectory.
这意味着，例如使用通配符的domain会被子目录中相同的通配符配置所覆盖，但是某一用户的特定配置
只能被字母路中用户的配置所覆盖。其实就是某一用户A如果在/etc/security/limits.conf有配置，当
/etc/security/limits.d子目录下配置文件也有用户A的配置时，那么A中某些配置会被覆盖。最终取的值是 /etc/security/limits.d 下的配置文件的配置。

#
#Each line describes a limit for a user in the form:
#每一行描述一个用户配置
#&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt;

#Where:
#&lt;domain&gt; can be:
# - a user name    一个用户名
# - a group name, with @group syntax    用户组格式为@GROUP_NAME
# - the wildcard *, for default entry    默认配置为*，代表所有用户
# - the wildcard %, can be also used with %group syntax,
# for maxlogin limit 
#
#&lt;type&gt; can have the two values:
# - &quot;soft&quot; for enforcing the soft limits 
# - &quot;hard&quot; for enforcing hard limits
有soft，hard和-，soft指的是当前系统生效的设置值，软限制也可以理解为警告值。
hard表名系统中所能设定的最大值。soft的限制不能比hard限制高，用-表名同时设置了soft和hard的值。
#&lt;item&gt; can be one of the following:    &lt;item&gt;可以使以下选项中的一个
# - core - limits the core file size (KB)    限制内核文件的大小。
# - data - max data size (KB)    最大数据大小
# - fsize - maximum filesize (KB)    最大文件大小
# - memlock - max locked-in-memory address space (KB)    最大锁定内存地址空间
# - nofile - max number of open file descriptors 最大打开的文件数(以文件描叙符，file descripter计数) 
# - rss - max resident set size (KB) 最大持久设置大小
# - stack - max stack size (KB) 最大栈大小
# - cpu - max CPU time (MIN)    最多CPU占用时间，单位为MIN分钟
# - nproc - max number of processes 进程的最大数目
# - as - address space limit (KB) 地址空间限制 
# - maxlogins - max number of logins for this user    此用户允许登录的最大数目
# - maxsyslogins - max number of logins on the system    系统最大同时在线用户数
# - priority - the priority to run user process with    运行用户进程的优先级
# - locks - max number of file locks the user can hold    用户可以持有的文件锁的最大数量
# - sigpending - max number of pending signals
# - msgqueue - max memory used by POSIX message queues (bytes)
# - nice - max nice priority allowed to raise to values: [-20, 19] max nice优先级允许提升到值
# - rtprio - max realtime pr iority
#
#&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt;
#

#* soft core 0
#* hard rss 10000
#@student hard nproc 20
#@faculty soft nproc 20
#@faculty hard nproc 50
#ftp hard nproc 0
#@st
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><h3 id="etc-security-limits-d-目录"> /etc/security/limits.d/目录</h3>
<ul>
<li>
<p><code>/etc/security/limits.d/</code>目录</p>
<p>该目录下默认有<code>*-nproc.conf</code>文件，该文件是用于限制用户的线程限制。我们也可以在该目录创建配置文件</p>
<p>在<code>/etc/security/limits.d/</code>下，以 .conf 结尾。</p>
<ul>
<li>
<p>centos 7</p>
<p>在CentOS 7版本中为<code>/etc/security/limits.d/20-nproc.conf</code>，</p>
<div><pre><code># Default limit for number of user&#39;s processes to prevent
# accidental fork bombs.
# See rhbz #432903 for reasoning.

*          soft    nproc     4096 # 所有的用户默认可以打开最大的进程数为 4096
root       soft    nproc     unlimited # root 用户默认可以打开最大的进程数 无限制的。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>CentOS 6</p>
<p>在CentOS 6版本中为<code>/etc/security/limits.d/90-nproc.conf</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="二、-ulimit-如何配置"> 二、 ulimit 如何配置</h2>
<h3 id="配置注意事项"> 配置注意事项</h3>
<p>注意不能设置 <code>nofile</code>不能设置 <code>unlimited</code>，<code>noproc</code>可以.
当我们设置了 <code>nofile</code>不能设置 <code>unlimited</code> 后，我们进行 ssh 登录，是登录不了的，并且报错下面的内容。</p>
<div><pre><code>Dec  1 14:57:57 localhost sshd[1543]: pam_limits(sshd:session): Could not set limit for &#39;nofile&#39;: Operation not permitted
</code></pre>
<div><span>1</span><br></div></div><p>当我们设置的 <code>nofile</code> 的值可以设置的最大值为 1048576(2**20)，设置的值大于该数，就会进行登录不了。也会显示上面的登录错误。(亲测)</p>
<h3 id="基础配置"> 基础配置</h3>
<p>我们不将所有的配置配置在<code>/etc/security/limits.conf</code> 而是将配置放在 <code>/etc/security/limits.d/</code> 下。
比如我们将 nofile的配置放在 <code>/etc/security/limits.d/20-nofile.conf</code> ，nproc 的配置放在 <code>/etc/security/limits.d/20-nproc.conf</code>.</p>
<p>一般我们需要配置的 <code>/etc/security/limits.d/20-nofile.conf</code> 为。</p>
<div><pre><code>root soft nofile 65535
root hard nofile 65535
* soft nofile 65535
* hard nofile 65535
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>/etc/security/limits.d/20-nproc.conf</code> 设置为</p>
<div><pre><code>*    -     nproc   65535
root soft  nproc  unlimited
root hard  nproc  unlimited
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="注意覆盖点的问题。"> 注意覆盖点的问题。</h3>
<p><strong>示例一：</strong>
当 <code>/etc/security/limits.conf</code> 配置了:</p>
<div><pre><code>root soft nofile 65538
root hard nofile 65538
* soft nofile 65539
* hard nofile 65539
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个root 用户的 默认取值是 65538 ，* 统配符虽然在 root 配置后面，但是 root 的配置只能被 root 进行覆盖。</p>
<p>我们看下这个配置，当这样配置的时候</p>
<div><pre><code>root soft nofile 65538
root hard nofile 65538
* soft nofile 65539
* hard nofile 65539
root soft nofile 65539
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个的 root 用户的取值还是 65538 ，因为虽然 <code>root soft nofile 65539</code> 会覆盖我们之前的配置，但是这个配置是不生效的。因为 <code>root soft nofile 65539</code> 配置的值大于<code>root hard nofile 65538</code> , <code>soft</code> 配置的值不能大于 <code>hard</code>.</p>
<p><strong>示例二：</strong>
当我们在 <code>/etc/security/limits.conf</code> 配置了:</p>
<div><pre><code>root soft nofile 65538
root hard nofile 65538
* soft nofile 65539
* hard nofile 65539
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>然后我们在 <code>/etc/security/limits.d/20-nofile.conf</code> 配置了：</p>
<div><pre><code>root soft nofile 65536
root hard nofile 65536
* soft nofile 65540
* hard nofile 65540
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>最后的取值是会取 <code>/etc/security/limits.d/20-nofile.conf</code> 里面的值。</p>
<blockquote>
<ol>
<li>配置，只能被特定覆盖。</li>
<li><code>/etc/security/limits.d/</code> 下文件的相同配置可以覆盖 <code>/etc/security/limits.conf</code></li>
<li><code>soft</code>和<code>hard</code>需要都进行设置,才能生效。</li>
<li><code>nofile</code>不能设置 <code>unlimited</code></li>
<li><code>nofile</code>可以设置的最大值为 1048576(2**20)，设置的值大于该数，就会进行登录不了。</li>
<li>soft 设置的值 一定要小于或等于 hard 的值。</li>
</ol>
</blockquote>
<p>具体详细配置根据应用情况进行配置。</p>
<h2 id="三、ulimit-配置后生效"> 三、ulimit 配置后生效</h2>
<h3 id="临时配置"> 临时配置</h3>
<p>设置可以打开文件的最大数为 65536</p>
<div><pre><code>ulimit  -SHn  65536
</code></pre>
<div><span>1</span><br></div></div><p>重启后失效。</p>
<h3 id="永久配置"> 永久配置</h3>
<p>配置到配置文件<code>/etc/security/limits.conf</code>或者 <code>/etc/security/limits.d/</code> 中。
然后退出当前会话，重新登录。 即可生效，重启配置也会保留。</p>
<h3 id="配置不生效的问题"> 配置不生效的问题</h3>
<p>按照上面的配置好了之后，我们进行设置登录到服务器，我发现是配置没有生效的，但是我使用 su - root 之后，发现配置是生效的。 很怪异。
设备环境： Centos6.</p>
<h4 id="问题原因"> 问题原因</h4>
<p>主要是 Centos6 的原因，我们排查到 sshd 服务的 PAM 模块是没有开启的，而<code>/etc/security/limits.conf</code> 文件实际是 Linux PAM（插入式认证模块，Pluggable Authentication Modules）中 <code>pam_limits.so</code> 的配置文件，我们没有开启 PAM 模块，最终也就没有读取到 <code>/etc/security/limits.conf</code> 的内容。 而 su 进行切换的时候使用的是 终端tty登陆(默认使用PAM模块),</p>
<h4 id="解决办法"> 解决办法</h4>
<p>在 <code>/etc/ssh/sshd_config</code> 将 <code>UsePAM no</code> 更改为 <code>UsePAM yes</code>, 然后重启 sshd 服务。</p>
<h2 id="四、ulimit-常用命令"> 四、ulimit 常用命令</h2>
<div><pre><code>      -S	use the `soft&#39; resource limit # 设置软限制
      -H	use the `hard&#39; resource limit # 设置硬限制
      -a	all current limits are reported# 显示所有的配置。
      -b	the socket buffer size # 设置socket buffer 的最大值。
      -c	the maximum size of core files created # 设置core文件的最大值.
      -d	the maximum size of a process&#39;s data segment  # 设置线程数据段的最大值
      -e	the maximum scheduling priority (`nice&#39;) # 设置最大调度优先级
      -f	the maximum size of files written by the shell and its children # 创建文件的最大值。
      -i	the maximum number of pending signals # 设置最大的等待信号
      -l	the maximum size a process may lock into memory #设置在内存中锁定进程的最大值
      -m	the maximum resident set size 
      -n	the maximum number of open file descriptors # 设置最大可以的打开文件描述符。
      -p	the pipe buffer size
      -q	the maximum number of bytes in POSIX message queues
      -r	the maximum real-time scheduling priority
      -s	the maximum stack size
      -t	the maximum amount of cpu time in seconds
      -u	the maximum number of user processes  # 设置用户可以创建的最大进程数。
      -v	the size of virtual memory  # 设置虚拟内存的最大值
      -x	the maximum number of file locks
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="查看配置"> 查看配置</h3>
<p>查看所有的配置</p>
<div><pre><code>ulimit  -a
</code></pre>
<div><span>1</span><br></div></div><p>查看配置的最大打开文件数</p>
<div><pre><code>ulimit  -n
</code></pre>
<div><span>1</span><br></div></div><p>更改配置</p>
<div><pre><code>ulimit  -SHn  65536
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>转载链接：https://www.cnblogs.com/operationhome/p/11966041.html</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">日志logrotate</title>
    <id>https://clay-wangzhi.com/linux/basic/logrotate/</id>
    <link href="https://clay-wangzhi.com/linux/basic/logrotate/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="日志logrotate"> 日志logrotate</h1>
<h2 id="logrotate简介"> logrotate简介</h2>
<p>日志是Linux系统中最重要的部分之一，通过日志可以知道系统中正在发生什么或者发生过什么，极大的方便了系统管理，常见的linux发行版中都自带了logrotate程序来管理系统日志，当然logrotate也可以用来管理软件日志。使用logrotate有以下几点好处：</p>
<p>1.大多数系统自带，不用安装
2.配置简单，功能很强大
3.可靠性高</p>
<h2 id="配置文件"> 配置文件</h2>
<p>默认的配置文件为：</p>
<div><pre><code>/etc/logrotate.conf
/etc/logratate.d/
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>logrotate.conf</code>：为主配置文件</p>
<p><code>logrotate.d</code>：为配置相关子系统，用于隔离每个应用配置（Nginx、PHP、Tomcat...）</p>
<p>Logrotate是基于CRON来运行的，其脚本是/etc/cron.daily/logrotate，日志轮转是系统自动完成的。
实际运行时，Logrotate会调用配置文件/etc/logrotate.conf。</p>
<p>Logrotate可以由自动或者手动触发日志轮转：</p>
<div><pre><code>logrotate -f /etc/logrotate.d/nginx
logrotate -f /etc/logrotate.d/php
不过正式执行前最好通过Debug选项来验证一下（-d参数）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>查看各log文件的具体执行情况</p>
<div><pre><code>cat /var/lib/logrotate/logrotate.status
</code></pre>
<div><span>1</span><br></div></div><p>具体logrotate命令格式如下：</p>
<blockquote>
<p>logrotate [OPTION...] <configfile>
-d, --debug ：debug模式，测试配置文件是否有错误。
-f, --force ：强制转储文件。
-m, --mail=command ：压缩日志后，发送日志到指定邮箱。
-s, --state=statefile ：使用指定的状态文件。
-v, --verbose ：显示转储过程。</p>
</blockquote>
<h2 id="切割介绍"> 切割介绍</h2>
<p>比如以系统日志/var/log/message做切割来简单说明下：
第一次执行完rotate(轮转)之后，原本的messages会变成messages.1，而且会制造一个空的messages给系统来储存日志；
第二次执行之后，messages.1会变成messages.2，而messages会变成messages.1，又造成一个空的messages来储存日志！
如果仅设定保留三个日志（即轮转3次）的话，那么执行第三次时，则 messages.3这个档案就会被删除，并由后面的较新的保存日志所取代！也就是会保存最新的几个日志。
日志究竟轮换几次，这个是根据配置文件中的rotate参数来判定的。</p>
<p>看下logrotate.conf配置：</p>
<div><pre><code># cat /etc/logrotate.conf
# 底下的设定是 &quot;logrotate 的默认值&quot; ，如果別的文件设定了其他的值，
# 就会以其它文件的设定为主
weekly          //默认每一周执行一次rotate轮转工作
rotate 4       //保留多少个日志文件(轮转几次).默认保留四个.就是指定日志文件删除之前轮转的次数，0 指没有备份
create         //自动创建新的日志文件，新的日志文件具有和原来的文件相同的权限；因为日志被改名,因此要创建一个新的来继续存储之前的日志
dateext       //这个参数很重要！就是切割后的日志文件以当前日期为格式结尾，如xxx.log-20131216这样,如果注释掉,切割出来是按数字递增,即前面说的 xxx.log-1这种格式
compress      //是否通过gzip压缩转储以后的日志文件，如xxx.log-20131216.gz ；如果不需要压缩，注释掉就行

include /etc/logrotate.d
# 将 /etc/logrotate.d/ 目录中的所有文件都加载进来

/var/log/wtmp {                 //仅针对 /var/log/wtmp 所设定的参数
monthly                    //每月一次切割,取代默认的一周
minsize 1M              //文件大小超过 1M 后才会切割
create 0664 root utmp            //指定新建的日志文件权限以及所属用户和组
rotate 1                    //只保留一个日志.
}
# 这个 wtmp 可记录用户登录系统及系统重启的时间
# 因为有 minsize 的参数，因此不见得每个月一定会执行一次喔.要看文件大小。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="其他重要参数说明"> 其他重要参数说明</h3>
<div><pre><code>compress                                   通过gzip 压缩转储以后的日志
nocompress                                不做gzip压缩处理
copytruncate                              用于还在打开中的日志文件，把当前日志备份并截断；是先拷贝再清空的方式，拷贝和清空之间有一个时间差，可能会丢失部分日志数据。
nocopytruncate                           备份日志文件不过不截断
create mode owner group             轮转时指定创建新文件的属性，如create 0777 nobody nobody
nocreate                                    不建立新的日志文件
delaycompress                           和compress 一起使用时，转储的日志文件到下一次转储时才压缩
nodelaycompress                        覆盖 delaycompress 选项，转储同时压缩。
missingok                                 如果日志丢失，不报错继续滚动下一个日志
errors address                           专储时的错误信息发送到指定的Email 地址
ifempty                                    即使日志文件为空文件也做轮转，这个是logrotate的缺省选项。
notifempty                               当日志文件为空时，不进行轮转
mail address                             把转储的日志文件发送到指定的E-mail 地址
nomail                                     转储时不发送日志文件
olddir directory                         转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统
noolddir                                   转储后的日志文件和当前日志文件放在同一个目录下
sharedscripts                           运行postrotate脚本，作用是在所有日志都轮转后统一执行一次脚本。如果没有配置这个，那么每个日志轮转后都会执行一次脚本
prerotate                                 在logrotate转储之前需要执行的指令，例如修改文件的属性等动作；必须独立成行
postrotate                               在logrotate转储之后需要执行的指令，例如重新启动 (kill -HUP) 某个服务！必须独立成行
daily                                       指定转储周期为每天
weekly                                    指定转储周期为每周
monthly                                  指定转储周期为每月
rotate count                            指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份
dateext                                  使用当期日期作为命名格式
dateformat .%s                       配合dateext使用，紧跟在下一行出现，定义文件切割后的文件名，必须配合dateext使用，只支持 %Y %m %d %s 这四个参数
size(或minsize) log-size            当日志文件到达指定的大小时才转储，log-size能指定bytes(缺省)及KB (sizek)或MB(sizem).
当日志文件 &gt;= log-size 的时候就转储。 以下为合法格式：（其他格式的单位大小写没有试过）
size = 5 或 size 5 （&gt;= 5 个字节就转储）
size = 100k 或 size 100k
size = 100M 或 size 100M
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id="logrotate日志切割轮询"> logrotate日志切割轮询</h2>
<p>由于Logrotate是基于CRON运行的，所以这个日志轮转的时间是由CRON控制的，具体可以查询CRON的配置文件/etc/anacrontab，过往的老版本的文件为（/etc/crontab）</p>
<p>查看轮转文件：<code>/etc/anacrontab</code></p>
<div><pre><code># egrep -v &quot;^$|^#&quot; /etc/anacrontab
SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
RANDOM_DELAY=45
START_HOURS_RANGE=3-22
1	5	cron.daily		nice run-parts /etc/cron.daily
7	25	cron.weekly		nice run-parts /etc/cron.weekly
@monthly 45	cron.monthly		nice run-parts /etc/cron.monthly
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>使用anacrontab轮转的配置文件，日志切割的生效时间是在凌晨3点到22点之间，而且随机延迟时间是45分钟，但是这样配置无法满足我们在现实中的应用</p>
<p>现在的需求是将切割时间调整到每天的晚上12点，即每天切割的日志是前一天的0-24点之间的内容，操作如下：</p>
<p>取消日志自动轮转的设置</p>
<div><pre><code>mv /etc/anacrontab /etc/anacrontab.bak 
</code></pre>
<div><span>1</span><br></div></div><p>使用crontab来作为日志轮转的触发容器来修改Logrotate默认执行时间</p>
<div><pre><code> egrep -v &quot;^$|^#&quot; /etc/crontab 
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
# run-parts
01 * * * * root run-parts /etc/cron.hourly
59 23 * * * root run-parts /etc/cron.daily
22 4 * * 0 root run-parts /etc/cron.weekly
42 4 1 * * root run-parts /etc/cron.monthly
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="nginx日志配置"> nginx日志配置</h2>
<div><pre><code><span># vim /etc/logrotate.d/nginx</span>
/var/log/nginx/*.log <span>{</span>
		daily
		missingok
		rotate <span>90</span>
		compress
		delaycompress
		notifempty
		create <span>640</span> nginx adm
		dateext
		sharedscripts
		postrotate
              <span>[</span> <span>!</span> -f /var/run/nginx.pid <span>]</span> <span>||</span> <span>kill</span> -USR1 <span><span>`</span><span>cat</span> /var/run/nginx.pid<span>`</span></span>
         endscript
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="tomcat日志配置"> tomcat日志配置</h2>
<div><pre><code>/home/tomcat/tomcat/logs/catalina.out {
	su tomcat tomcat
        daily
        rotate 90
        missingok
        notifempty
        dateext
        compress
        delaycompress
        sharedscripts
	copytruncate
        create 644 tomcat tomcat
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="解决logrotate无法自动轮询日志的办法"> 解决logrotate无法自动轮询日志的办法</h2>
<p>现象说明：
使用logrotate轮询nginx日志，配置好之后，发现nginx日志连续两天没被切割，检查后确定配置文件一切正常，这是为什么呢？？</p>
<p>强行启动记录文件维护操作，纵使logrotate指令认为没有需要，应该有可能是logroate认为nginx日志太小，不进行轮询。
故需要强制轮询，即在/etc/cron.daily/logrotate脚本中将 -t 参数替换成 -f 参数</p>
<div><pre><code># vim /etc/cron.daily/logrotate 
#!/bin/sh
/usr/sbin/logrotate /etc/logrotate.conf
EXITVALUE=$?
if [ $EXITVALUE != 0 ]; then
    /usr/bin/logger -f logrotate &quot;ALERT exited abnormally with [$EXITVALUE]&quot;
fi
exit 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>最后最后重启下cron服务：</p>
<div><pre><code>/etc/init.d/crond restart
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">进程管理</title>
    <id>https://clay-wangzhi.com/linux/basic/process/</id>
    <link href="https://clay-wangzhi.com/linux/basic/process/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="进程管理"> 进程管理</h1>
<h2 id="静态查看进程-ps"> 静态查看进程 ps</h2>
<p><strong>ps命令</strong>用于报告当前系统的进程状态。可以搭配<a href="http://man.linuxde.net/kill" target="_blank" rel="noopener noreferrer">kill</a>指令随时中断、删除不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。</p>
<ol>
<li>
<p>运行(正在运行或在运行队列中等待)</p>
</li>
<li>
<p>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</p>
</li>
<li>
<p>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</p>
</li>
<li>
<p>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</p>
</li>
<li>
<p>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</p>
</li>
</ol>
<p>ps工具标识进程的5种状态码:</p>
<p>D 不可中断 uninterruptible sleep （usually IO）</p>
<p>R 运行 runnable （on run queue）</p>
<p>S 中断 sleeping</p>
<p>T 停止 traced or stopped</p>
<p>Z 僵死 a defunct （“zombie”） process</p>
<h3 id="语法"> 语法</h3>
<div><pre><code>ps(选项)
</code></pre>
<div><span>1</span><br></div></div><h3 id="选项"> 选项</h3>
<p>复制</p>
<div><pre><code>-a：显示所有终端机下执行的程序，除了阶段作业领导者之外。
a：显示现行终端机下的所有程序，包括其他用户的程序。
-A：显示所有程序。
-c：显示CLS和PRI栏位。
c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。
-C&lt;指令名称&gt;：指定执行指令的名称，并列出该指令的程序的状况。
-d：显示所有程序，但不包括阶段作业领导者的程序。
-e：此选项的效果和指定&quot;A&quot;选项相同。
e：列出程序时，显示每个程序所使用的环境变量。
-f：显示UID,PPIP,C与STIME栏位。
f：用ASCII字符显示树状结构，表达程序间的相互关系。
-g&lt;群组名称&gt;：此选项的效果和指定&quot;-G&quot;选项相同，当亦能使用阶段作业领导者的名称来指定。
g：显示现行终端机下的所有程序，包括群组领导者的程序。
-G&lt;群组识别码&gt;：列出属于该群组的程序的状况，也可使用群组名称来指定。
h：不显示标题列。
-H：显示树状结构，表示程序间的相互关系。
-j或j：采用工作控制的格式显示程序状况。
-l或l：采用详细的格式来显示程序状况。
L：列出栏位的相关信息。
-m或m：显示所有的执行绪。
n：以数字来表示USER和WCHAN栏位。
-N：显示所有的程序，除了执行ps指令终端机下的程序之外。
-p&lt;程序识别码&gt;：指定程序识别码，并列出该程序的状况。
p&lt;程序识别码&gt;：此选项的效果和指定&quot;-p&quot;选项相同，只在列表格式方面稍有差异。
r：只列出现行终端机正在执行中的程序。
-s&lt;阶段作业&gt;：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。
s：采用程序信号的格式显示程序状况。
S：列出程序时，包括已中断的子程序资料。
-t&lt;终端机编号&gt;：指定终端机编号，并列出属于该终端机的程序的状况。
t&lt;终端机编号&gt;：此选项的效果和指定&quot;-t&quot;选项相同，只在列表格式方面稍有差异。
-T：显示现行终端机下的所有程序。
-u&lt;用户识别码&gt;：此选项的效果和指定&quot;-U&quot;选项相同。
u：以用户为主的格式来显示程序状况。
-U&lt;用户识别码&gt;：列出属于该用户的程序的状况，也可使用用户名称来指定。
U&lt;用户名称&gt;：列出属于该用户的程序的状况。
v：采用虚拟内存的格式显示程序状况。
-V或V：显示版本信息。
-w或w：采用宽阔的格式来显示程序状况。　
x：显示所有程序，不以终端机来区分。
X：采用旧式的Linux i386登陆格式显示程序状况。
-y：配合选项&quot;-l&quot;使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。
-&lt;程序识别码&gt;：此选项的效果和指定&quot;p&quot;选项相同。
--cols&lt;每列字符数&gt;：设置每列的最大字符数。
--columns&lt;每列字符数&gt;：此选项的效果和指定&quot;--cols&quot;选项相同。
--cumulative：此选项的效果和指定&quot;S&quot;选项相同。
--deselect：此选项的效果和指定&quot;-N&quot;选项相同。
--forest：此选项的效果和指定&quot;f&quot;选项相同。
--headers：重复显示标题列。
--help：在线帮助。
--info：显示排错信息。
--lines&lt;显示列数&gt;：设置显示画面的列数。
--no-headers：此选项的效果和指定&quot;h&quot;选项相同，只在列表格式方面稍有差异。
--group&lt;群组名称&gt;：此选项的效果和指定&quot;-G&quot;选项相同。
--Group&lt;群组识别码&gt;：此选项的效果和指定&quot;-G&quot;选项相同。
--pid&lt;程序识别码&gt;：此选项的效果和指定&quot;-p&quot;选项相同。
--rows&lt;显示列数&gt;：此选项的效果和指定&quot;--lines&quot;选项相同。
--sid&lt;阶段作业&gt;：此选项的效果和指定&quot;-s&quot;选项相同。
--tty&lt;终端机编号&gt;：此选项的效果和指定&quot;-t&quot;选项相同。
--user&lt;用户名称&gt;：此选项的效果和指定&quot;-U&quot;选项相同。
--User&lt;用户识别码&gt;：此选项的效果和指定&quot;-U&quot;选项相同。
--version：此选项的效果和指定&quot;-V&quot;选项相同。
--widty&lt;每列字符数&gt;：此选项的效果和指定&quot;-cols&quot;选项相同。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><h3 id="常用范例"> 常用范例</h3>
<p>1）显示所有进程信息</p>
<p>复制</p>
<div><pre><code># ps -A  PID TTY          TIME CMD    1 ?        00:00:00 init    2 ?        00:00:01 migration/0    3 ?        00:00:00 ksoftirqd/0    4 ?        00:00:01 migration/1
</code></pre>
<div><span>1</span><br></div></div><p>2）显示指定用户信息</p>
<p>复制</p>
<div><pre><code># ps -u root  PID TTY          TIME CMD    1 ?        00:00:00 init    2 ?        00:00:01 migration/0    3 ?        00:00:00 ksoftirqd/0    4 ?        00:00:01 migration/1
</code></pre>
<div><span>1</span><br></div></div><p>3）显示所有进程信息，连同命令行</p>
<p>复制</p>
<div><pre><code>ps -efUID        PID  PPID  C STIME TTY          TIME CMDroot         1     0  0 Nov02 ?        00:00:00 init [3]                  root         2     1  0 Nov02 ?        00:00:01 [migration/0]root         3     1  0 Nov02 ?        00:00:00 [ksoftirqd/0]root         4     1  0 Nov02 ?        00:00:01 [migration/1]root         5     1  0 Nov02 ?        00:00:00 [ksoftirqd/1]
</code></pre>
<div><span>1</span><br></div></div><p>4） ps 与grep 常用组合用法，查找特定进程</p>
<p>复制</p>
<div><pre><code># ps -ef|grep sshroot      2720     1  0 Nov02 ?        00:00:00 /usr/sbin/sshdroot     17394  2720  0 14:58 ?        00:00:00 sshd: root@pts/0 root     17465 17398  0 15:57 pts/0    00:00:00 grep ssh
</code></pre>
<div><span>1</span><br></div></div><p>5）将目前属于您自己这次登入的 PID 与相关信息列示出来</p>
<p>复制</p>
<div><pre><code># ps -lF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD4 S     0 17398 17394  0  75   0 - 16543 wait   pts/0    00:00:00 bash4 R     0 17469 17398  0  77   0 - 15877 -      pts/0    00:00:00 ps
</code></pre>
<div><span>1</span><br></div></div><p>说明：</p>
<p>各相关信息的意义：</p>
<p>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</p>
<p>S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</p>
<p>UID 程序被该 UID 所拥有</p>
<p>PID 就是这个程序的 ID ！</p>
<p>PPID 则是其上级父程序的ID</p>
<p>C CPU 使用的资源百分比</p>
<p>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</p>
<p>NI 这个是 Nice 值，在下一小节我们会持续介绍</p>
<p>ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“</p>
<p>SZ 使用掉的内存大小</p>
<p>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</p>
<p>TTY 登入者的终端机位置</p>
<p>TIME 使用掉的 CPU 时间。</p>
<p>CMD 所下达的指令为何</p>
<p>在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，所以， 当我使用 ps -l 的时候，只有三个 PID。</p>
<p>6）列出目前所有的正在内存当中的程序</p>
<p>复制</p>
<div><pre><code># ps auxUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot         1  0.0  0.0  10368   676 ?        Ss   Nov02   0:00 init [3]                  root         2  0.0  0.0      0     0 ?        S&lt;   Nov02   0:01 [migration/0]root         3  0.0  0.0      0     0 ?        SN   Nov02   0:00 [ksoftirqd/0]root         4  0.0  0.0      0     0 ?        S&lt;   Nov02   0:01 [migration/1]root         5  0.0  0.0      0     0 ?        SN   Nov02   0:00 [ksoftirqd/1]
</code></pre>
<div><span>1</span><br></div></div><p>说明：</p>
<p>USER：该 process 属于那个使用者账号的</p>
<p>PID ：该 process 的号码</p>
<p>%CPU：该 process 使用掉的 CPU 资源百分比</p>
<p>%MEM：该 process 所占用的物理内存百分比</p>
<p>VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)</p>
<p>RSS ：该 process 占用的固定的内存量 (Kbytes)</p>
<p>TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。</p>
<p>STAT：该程序目前的状态，主要的状态有</p>
<p>R ：该程序目前正在运作，或者是可被运作</p>
<p>S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。</p>
<p>T ：该程序目前正在侦测或者是停止了</p>
<p>Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</p>
<p>START：该 process 被触发启动的时间</p>
<p>TIME ：该 process 实际使用 CPU 运作的时间</p>
<p>COMMAND：该程序的实际指令</p>
<p>7）列出类似程序树的程序显示</p>
<p>复制</p>
<div><pre><code> ps -axjfWarning: bad syntax, perhaps a bogus &#39;-&#39;? See /usr/share/doc/procps-3.2.7/FAQ PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND    0     1     1     1 ?           -1 Ss       0   0:00 init [3]                      1     2     1     1 ?           -1 S&lt;       0   0:01 [migration/0]    1     3     1     1 ?           -1 SN       0   0:00 [ksoftirqd/0]    1     4     1     1 ?           -1 S&lt;       0   0:01 [migration/1]    1     5     1     1 ?           -1 SN       0   0:00 [ksoftirqd/1]
</code></pre>
<div><span>1</span><br></div></div><p>8）找出与 cron 与 syslog 这两个服务有关的 PID 号码</p>
<p>复制</p>
<div><pre><code># ps aux | egrep &#39;(cron|syslog)&#39;root      2682  0.0  0.0  83384  2000 ?        Sl   Nov02   0:00 /sbin/rsyslogd -i /var/run/syslogd.pid -c 5root      2735  0.0  0.0  74812  1140 ?        Ss   Nov02   0:00 crondroot     17475  0.0  0.0  61180   832 pts/0    S+   16:27   0:00 egrep (cron|syslog)
</code></pre>
<div><span>1</span><br></div></div><p>说明：</p>
<p>其他实例：</p>
<ol>
<li>可以用 | 管道和 more 连接起来分页查看</li>
</ol>
<p>复制</p>
<div><pre><code>ps -aux |more
</code></pre>
<div><span>1</span><br></div></div><ol>
<li>把所有进程显示出来，并输出到ps001.txt文件</li>
</ol>
<p>复制</p>
<div><pre><code>ps -aux &gt; ps001.txt
</code></pre>
<div><span>1</span><br></div></div><ol>
<li>输出指定的字段</li>
</ol>
<p>复制</p>
<div><pre><code># ps -o pid,ppid,pgrp,session,tpgid,comm  PID  PPID  PGRP  SESS TPGID COMMAND17398 17394 17398 17398 17478 bash17478 17398 17478 17398 17478 ps
</code></pre>
<div><span>1</span><br></div></div><h2 id="查看指定进程的pid-pgrep、pidof"> 查看指定进程的PID(pgrep、pidof)</h2>
<div><pre><code>pgrep sshd -l
47 sshd
51 sshd
128 sshd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code>pidof sshd
128 51 47
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="动态查看进程top"> 动态查看进程top</h2>
<p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。下面详细介绍它的使用方法。top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.</p>
<div><pre><code>top(选项)
</code></pre>
<div><span>1</span><br></div></div><h3 id="选项-2"> 选项</h3>
<p>复制</p>
<div><pre><code>-b：以批处理模式操作；-c：显示完整的治命令；-d：屏幕刷新间隔时间；-I：忽略失效过程；-s：保密模式；-S：累积模式；-i&lt;时间&gt;：设置间隔时间；-u&lt;用户名&gt;：指定用户名；-p&lt;进程号&gt;：指定进程；-n&lt;次数&gt;：循环显示的次数。
</code></pre>
<div><span>1</span><br></div></div><h3 id="功能"> 功能</h3>
<p>显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</p>
<h3 id="常用实例"> 常用实例</h3>
<p>1）显示进程信息</p>
<p>复制</p>
<div><pre><code># toptop - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombieCpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%stMem:  32949016k total, 14411180k used, 18537836k free,   169884k buffersSwap: 32764556k total,        0k used, 32764556k free,  3612636k cached  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java                                                                   18249 root      18   0 3201m 1.9g  11m S 35.9  6.0 569:39.41 java                                                                    2808 root      25   0 3333m 1.0g  11m S 24.3  3.1 526:51.85 java                                                        25668 root      23   0 3180m 704m  11m S 14.0  2.2 360:44.53 java
</code></pre>
<div><span>1</span><br></div></div><p>说明：</p>
<p>统计信息区：</p>
<p>前五行是当前系统情况整体的统计信息区。下面我们看每一行信息的具体意义。</p>
<p>第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：</p>
<p>14:06:23 — 当前系统时间</p>
<p>up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p>
<p>2 users — 当前有2个用户登录系统</p>
<p>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p>
<p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p>
<p>第二行，Tasks — 任务（进程），具体信息说明如下：</p>
<p>系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p>
<p>第三行，cpu状态信息，具体属性说明如下：</p>
<p>5.9%us — 用户空间占用CPU的百分比。</p>
<p>3.4% sy — 内核空间占用CPU的百分比。</p>
<p>0.0% ni — 改变过优先级的进程占用CPU的百分比</p>
<p>90.4% id — 空闲CPU百分比</p>
<p>0.0% wa — IO等待占用CPU的百分比</p>
<p>0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</p>
<p>0.2% si — 软中断（Software Interrupts）占用CPU的百分比</p>
<p>第五行，swap交换分区信息，具体信息说明如下：</p>
<p>32764556k total — 交换区总量（32GB）</p>
<p>0k used — 使用的交换区总量（0K）</p>
<p>32764556k free — 空闲交换区总量（32GB）</p>
<p>3612636k cached — 缓冲的交换区总量（3.6GB）</p>
<p>备注：</p>
<p>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。</p>
<p>如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存：18537836k +169884k +3612636k = 22GB左右。</p>
<p>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p>
<p>第六行，空行。</p>
<p>第七行以下：各进程（任务）的状态监控，项目列信息说明如下：</p>
<p>PID — 进程id</p>
<p>USER — 进程所有者</p>
<p>PR — 进程优先级</p>
<p>NI — nice值。负值表示高优先级，正值表示低优先级</p>
<p>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</p>
<p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</p>
<p>SHR — 共享内存大小，单位kb</p>
<p>S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</p>
<p>%CPU — 上次更新到现在的CPU时间占用百分比</p>
<p>%MEM — 进程使用的物理内存百分比</p>
<p>TIME+ — 进程使用的CPU时间总计，单位1/100秒</p>
<p>COMMAND — 进程名称（命令名/命令行）</p>
<p>其他使用技巧：</p>
<p>1.多U多核CPU监控</p>
<p>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况：</p>
<p>观察上图，服务器有16个逻辑CPU，实际上是4个物理CPU。再按数字键1，就会返回到top基本视图界面。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/top1.png" alt="img" /></p>
<p>2.高亮显示当前运行进程</p>
<p>敲击键盘“b”（打开/关闭加亮效果），top的视图变化如下：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/top2.png" alt="img" /></p>
<p>我们发现进程id为2570的“top”进程被加亮了，top进程就是视图第二行显示的唯一的运行态（runing）的那个进程，可以通过敲击“y”键关闭或打开运行态进程的加亮效果。</p>
<p>3.进程字段排序</p>
<p>默认进入top时，各进程是按照CPU的占用量来排序的，在下图中进程ID为28894的java进程排在第一（cpu占用142%），进程ID为574的java进程排在第二（cpu占用16%）。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/top3.png" alt="img" /></p>
<p>敲击键盘“x”（打开/关闭排序列的加亮效果），top的视图变化如下：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/top4.png" alt="img" /></p>
<p>可以看到，top默认的排序列是“%CPU”。</p>
<ol>
<li>
<p>通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列</p>
<div><pre><code>下图是按一次”shift + &gt;”的效果图,视图现在已经按照%MEM来排序。
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/top5.png" alt="img" /></p>
<p>2）显示完整命令</p>
<p>复制</p>
<div><pre><code>top -c
</code></pre>
<div><span>1</span><br></div></div><p>3）以批处理模式显示程序信息</p>
<p>复制</p>
<div><pre><code>top -b
</code></pre>
<div><span>1</span><br></div></div><p>4）以累积模式显示程序信息</p>
<p>复制</p>
<div><pre><code>top -S
</code></pre>
<div><span>1</span><br></div></div><p>5）设置信息更新次数</p>
<p>复制</p>
<div><pre><code>top -n 2
</code></pre>
<div><span>1</span><br></div></div><p>6）设置信息更新时间</p>
<p>复制</p>
<div><pre><code>top -d 3
</code></pre>
<div><span>1</span><br></div></div><p>说明：</p>
<p>表示更新周期为3秒</p>
<p>7）显示指定的进程信息</p>
<p>复制</p>
<div><pre><code>top -p 574
</code></pre>
<div><span>1</span><br></div></div><h3 id="top交互命令"> top交互命令</h3>
<p>在top 命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了s 选项， 其中一些命令可能会被屏蔽。</p>
<p>h 显示帮助画面，给出一些简短的命令总结说明</p>
<p>k 终止一个进程。</p>
<p>i 忽略闲置和僵死进程。这是一个开关式命令。</p>
<p>q 退出程序</p>
<p>r 重新安排一个进程的优先级别</p>
<p>S 切换到累计模式</p>
<p>s 改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s</p>
<p>f或者F 从当前显示中添加或者删除项目</p>
<p>o或者O 改变显示项目的顺序</p>
<p>l 切换显示平均负载和启动时间信息</p>
<p>m 切换显示内存信息</p>
<p>t 切换显示进程和CPU状态信息</p>
<p>c 切换显示命令名称和完整命令行</p>
<p>M 根据驻留内存大小进行排序</p>
<p>P 根据CPU使用百分比大小进行排序</p>
<p>T 根据时间/累计时间进行排序</p>
<p>W 将当前设置写入~/.toprc文件中</p>
<h2 id="信号控制进程kill"> 信号控制进程kill</h2>
<p>Linux中的kill命令用来终止指定的进程（terminate a process）的运行，是Linux下进程管理的常用命令。通常，终止一个前台进程可以使用Ctrl+C键，但是，对于一个后台进程就须用kill命令来终止，我们就需要先使用ps/pidof/pstree/top等工具获取进程PID，然后使用kill命令来杀掉该进程。kill命令是通过向进程发送指定的信号来结束相应进程的。在默认情况下，采用编号为15的TERM信号。TERM信号将终止所有不能捕获该信号的进程。对于那些可以捕获该信号的进程就要用编号为9的kill信号，强行“杀掉”该进程。</p>
<div><pre><code>kill(选项)(参数)
</code></pre>
<div><span>1</span><br></div></div><h3 id="选项-3"> 选项</h3>
<p>复制</p>
<div><pre><code>-a：当处理当前进程时，不限制命令名和进程号的对应关系；-l &lt;信息编号&gt;：若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称；-p：指定kill 命令只打印相关进程的进程号，而不发送任何信号；-s &lt;信息名称或编号&gt;：指定要送出的信息；-u：指定用户。
</code></pre>
<div><span>1</span><br></div></div><h3 id="参数"> 参数</h3>
<p>进程或作业识别号：指定要删除的进程或作业。</p>
<h3 id="功能-2"> 功能</h3>
<p>发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果无法终止该程序可用“-KILL”参数，其发送的信号为SIGKILL（9），将强制结束进程，使用ps命令或者jobs命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。</p>
<h3 id="常用实例-2"> 常用实例</h3>
<p>复制</p>
<div><pre><code># kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR213) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+439) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+1247) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-1451) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-1055) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-659) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX
</code></pre>
<div><span>1</span><br></div></div><p>说明：</p>
<p>只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略。 下面是常用的信号：</p>
<p>HUP 1 终端断线</p>
<p>INT 2 中断（同 Ctrl + C）</p>
<p>QUIT 3 退出（同 Ctrl + \）</p>
<p>TERM 15 终止</p>
<p>KILL 9 强制终止</p>
<p>CONT 18 继续（与STOP相反， fg/bg命令）</p>
<p>STOP 19 暂停（同 Ctrl + Z）</p>
<p>2）得到指定信号的数值</p>
<p>复制</p>
<div><pre><code># kill -l KILL9# kill -l SIGKILL9# kill -l TERM15# kill -l SIGTERM15
</code></pre>
<div><span>1</span><br></div></div><p>3）先用ps查找进程，然后用kill杀掉</p>
<p>复制</p>
<div><pre><code>#ps -ef|grep vim root      3268  2884  0 16:21 pts/1    00:00:00 vim install.logroot      3370  2822  0 16:21 pts/0    00:00:00 grep vim# kill 3268 # kill 3268 -bash: kill: (3268) - 没有那个进程
</code></pre>
<div><span>1</span><br></div></div><p>4）彻底杀死进程</p>
<p>复制</p>
<div><pre><code># ps -ef|grep vim root      3268  2884  0 16:21 pts/1    00:00:00 vim install.logroot      3370  2822  0 16:21 pts/0    00:00:00 grep vim# kill –9 3268 # kill 3268 -bash: kill: (3268) - 没有那个进程
</code></pre>
<div><span>1</span><br></div></div><p>5）杀死指定用户所有进程</p>
<p>复制</p>
<div><pre><code># kill -9 $(ps -ef | grep peidalinux) # kill -u peidalinux
</code></pre>
<div><span>1</span><br></div></div><p>6）init进程是不可杀的</p>
<p>复制</p>
<div><pre><code># ps -ef|grep initroot         1     0  0 Nov02 ?        00:00:00 init [3]                  root     17563 17534  0 17:37 pts/1    00:00:00 grep init# kill -9 1# kill -HUP 1# ps -ef|grep initroot         1     0  0 Nov02 ?        00:00:00 init [3]                  root     17565 17534  0 17:38 pts/1    00:00:00 grep init# kill -KILL 1# ps -ef|grep initroot         1     0  0 Nov02 ?        00:00:00 init [3]                  root     17567 17534  0 17:38 pts/1    00:00:00 grep init
</code></pre>
<div><span>1</span><br></div></div><p>说明：</p>
<p>init是Linux系统操作中不可缺少的程序之一。所谓的init进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。所以,init始终是第一个进程（其进程编号始终为1）。 其它所有进程都是init进程的子孙。init进程是不可杀的！</p>
<p>参考链接：</p>
<p>http://www.cnblogs.com/peida/archive/2012/12/20/2825837.html</p>
<p>http://man.linuxde.net/kill</p>
<p>http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html</p>
<p>http://man.linuxde.net/top</p>
<p>http://www.cnblogs.com/peida/archive/2012/12/19/2824418.html</p>
<p>http://man.linuxde.net/ps</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">linux简介</title>
    <id>https://clay-wangzhi.com/linux/basic/</id>
    <link href="https://clay-wangzhi.com/linux/basic/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux简介"> linux简介</h1>
<p>GNU/Linux 的历史</p>
<p>自由软件之父Richard M. Stallman(理查德.斯托曼) 1984 GNU Copyleft OpenSource Free GPL</p>
<p>Linux之父 1991 Linus Torvalds(林纳斯 托沃兹) www.kernel.org</p>
<p>Linux 主要发行版有：RHEL/Centos/Ubuntu/Suse/Debian/Oracle</p>
<h2 id="linux目录结构"> linux目录结构</h2>
<p>文件系统在Linux下看上去就象树形结构，所以我们可以把文件系统的结构形象的称为 树形结构。</p>
<p>操作系统安装在一个文件系统中，他表现为由/ 起始的树形结构。linux文件系统的最顶端是/，我们称/为Linux的root，也就是 Linux操作系统的文件系统。Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。</p>
<p>由于linux是开放源代码，各大公司和团体根据linux的核心代码做各自的操作，编程。这样就造成在根下的目录的不同。这样就造成个人不能使用他人的linux系统的PC。因为你根本不知道一些基本的配置，文件在哪里。。。这就造成了混乱。这就是FHS（Filesystem Hierarchy Standard ）机构诞生的原因。该机构是linux爱好者自发的组成的一个团体，主要是是对linux做一些基本的要求，不至于是操作者换一台主机就成了linux的<code>文盲</code>。</p>
<p>根据<a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener noreferrer">FHS</a>的官方文件指出， 他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下， 所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的用户，都能够遵循FHS的标准。 也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。 这样做好处非常多，因为Linux操作系统就能够在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。</p>
<p>事实上，FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动， 而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/HFS.png" alt="" /></p>
<p>四中类型:</p>
<ul>
<li>可分享的：</li>
</ul>
<p>可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；</p>
<ul>
<li>不可分享的：</li>
</ul>
<p>自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。</p>
<ul>
<li>不变的：</li>
</ul>
<p>有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；</p>
<ul>
<li>可变动的：</li>
</ul>
<p>经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。</p>
<p>事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：</p>
<p>/ (root, 根目录)：与开机系统有关；</p>
<p>/usr (unix software resource)：与软件安装/执行有关；</p>
<p>/var (variable)：与系统运作过程有关。</p>
<h3 id="根目录-的意义与内容"> 根目录 (/) 的意义与内容：</h3>
<p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。</p>
<p>因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。</p>
<p>根据以上原因，FHS认为根目录(/)下应该包含如下子目录：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置档案内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin</td>
<td>系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</td>
</tr>
<tr>
<td>/boot</td>
<td>主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。</td>
</tr>
<tr>
<td>/dev</td>
<td>在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等</td>
</tr>
<tr>
<td>/etc</td>
<td>系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop/etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。/etc/X11/ ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。</td>
</tr>
<tr>
<td>/home</td>
<td>这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。</td>
</tr>
<tr>
<td>/lib</td>
<td>系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。</td>
</tr>
<tr>
<td>/media</td>
<td>media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。</td>
</tr>
<tr>
<td>/mnt</td>
<td>如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。</td>
</tr>
<tr>
<td>/opt</td>
<td>这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。</td>
</tr>
<tr>
<td>/root</td>
<td>系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。</td>
</tr>
<tr>
<td>/sbin</td>
<td>Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。</td>
</tr>
<tr>
<td>/srv</td>
<td>srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。</td>
</tr>
<tr>
<td>/tmp</td>
<td>这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。</td>
</tr>
</tbody>
</table>
<p>事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/lost+found</td>
<td>这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found</td>
</tr>
<tr>
<td>/proc</td>
<td>这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？</td>
</tr>
<tr>
<td>/sys</td>
<td>这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。</td>
</tr>
</tbody>
</table>
<p>除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些：</p>
<p>/etc：配置文件</p>
<p>/bin：重要执行档</p>
<p>/dev：所需要的装置文件</p>
<p>/lib：执行档所需的函式库与核心所需的模块</p>
<p>/sbin：重要的系统执行文件</p>
<p>这五个目录千万不可与根目录分开在不同的分区。请背下来啊。</p>
<h3 id="usr-的意义与内容"> /usr 的意义与内容：</h3>
<p>依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。</p>
<p>/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。</p>
<p>因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/X11R6/</td>
<td>为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关)</td>
</tr>
<tr>
<td>/usr/include/</td>
<td>c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib...的次目录</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件/usr/share/doc：软件杂项的文件说明/usr/share/zoneinfo：与时区有关的时区文件</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。</td>
</tr>
</tbody>
</table>
<h3 id="var-的意义与内容"> /var 的意义与内容：</h3>
<p>如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/var/cache/</td>
<td>应用程序本身运作过程中会产生的一些暂存档</td>
</tr>
<tr>
<td>/var/lib/</td>
<td>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去</td>
</tr>
<tr>
<td>/var/lock/</td>
<td>某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用</td>
</tr>
<tr>
<td>/var/log/</td>
<td>非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。</td>
</tr>
<tr>
<td>/var/mail/</td>
<td>放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。</td>
</tr>
<tr>
<td>/var/run/</td>
<td>某些程序或者是服务启动后，会将他们的PID放置在这个目录下</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。</td>
</tr>
</tbody>
</table>
<p>由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。</p>
<h3 id="目录树-directory-tree"> 目录树(directory tree) :</h3>
<p>在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：</p>
<p>目录树的启始点为根目录 (/, root)；</p>
<p>每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。</p>
<p>每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。</p>
<p>如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图所示：</p>
<p>​	<img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/linux_dir.png" alt="" /></p>
<h3 id="绝对路径与相对路径"> 绝对路径与相对路径</h3>
<p>除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意。因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：</p>
<ul>
<li>绝对路径：</li>
</ul>
<p>由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；</p>
<ul>
<li>相对路径：</li>
</ul>
<p>相对于目前路径的文件名写法。 例如 ./dmtsai 。反正开头不是 / 就属于相对路径的写法</p>
<p>而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？</p>
<p>cd /var/log   (absolute)</p>
<p>cd ../var/log (relative)</p>
<p>因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：</p>
<p>.  ：代表当前的目录，也可以使用 ./ 来表示；</p>
<p>.. ：代表上一层目录，也可以 ../ 来代表。</p>
<p>这个 . 与 .. 目录概念是很重要的，你常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态。</p>
<p>实例1：如何先进入/var/spool/mail/目录，再进入到/var/spool/cron/目录内？</p>
<p>命令：</p>
<div><pre><code>cd /var/spool/mail

cd ../cron
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>说明：</p>
<p>由于/var/spool/mail与/var/spool/cron是同样在/var/spool/目录中。如此就不需要在由根目录开始写起了。这个相对路径是非常有帮助的，尤其对于某些软件开发商来说。 一般来说，软件开发商会将数据放置到/usr/local/里面的各相对目录。 但如果用户想要安装到不同目录呢？就得要使用相对路径。</p>
<h2 id="命令行快捷键"> 命令行快捷键</h2>
<ul>
<li>Esc键</li>
</ul>
<div><pre><code>Esc+. 上一个命令的后面的参数

Esc+B 移动到当前单词的开头

Esc+F 移动到当前单词的结尾

Esc+T 颠倒光标所在处及其相邻单词的位置
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>Ctrl键</li>
</ul>
<div><pre><code>Ctrl+A 光标移到命令行的最前端

Ctrl+C 终止前台运行的程序

Ctrl+D 退出 等价exit

Ctrl+E 光标移动到命令行的后端

Ctrl+K 删除光标处到行尾的字符

Ctrl+R 搜索历史名利，利用关键字

Ctrl+T 交换光标位置前的两个字符

Ctrl+U 删除整个命令行文本字符

Ctrl+W 移除光标前的一个单词

Ctrl+Y 粘贴Ctrl+u，Ctrl+k，Ctrl+w删除的文本，粘贴或者恢复上次的删
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="linux-相关认证介绍rhce-rhca"> Linux 相关认证介绍RHCE/RHCA</h2>
<p>Red Hat Certified Architect 认证架构师</p>
<p>Red Hat Certified Engineer 认证工程师</p>
<p>Red Hat Certified System Adminstrator 认证系统管理员</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">软件包管理</title>
    <id>https://clay-wangzhi.com/linux/basic/rpm/</id>
    <link href="https://clay-wangzhi.com/linux/basic/rpm/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="软件包管理"> 软件包管理</h1>
<h2 id="yum管理rpm包"> yum管理RPM包</h2>
<p>清空缓存及其它文件</p>
<div><pre><code>yum clean all
</code></pre>
<div><span>1</span><br></div></div><p>建立缓存数据库</p>
<div><pre><code>yum makecache
</code></pre>
<div><span>1</span><br></div></div><p>查询可用的仓库</p>
<div><pre><code>yum repolist
</code></pre>
<div><span>1</span><br></div></div><p>查询</p>
<div><pre><code>yum list mysql-server
</code></pre>
<div><span>1</span><br></div></div><p>升级</p>
<div><pre><code>yum -y update
</code></pre>
<div><span>1</span><br></div></div><p>查询指定的文件属于哪个包</p>
<div><pre><code>yum provides */httpd
</code></pre>
<div><span>1</span><br></div></div><p>卸载</p>
<div><pre><code>yum -y remove mysql-server
</code></pre>
<div><span>1</span><br></div></div><h2 id="使用rpm工具管理rpm包"> 使用RPM工具管理RPM包</h2>
<p>安装</p>
<div><pre><code>rpm -ivh xxx.rpm
</code></pre>
<div><span>1</span><br></div></div><p>升级</p>
<div><pre><code>rpm -Uvh xxx.rpm
</code></pre>
<div><span>1</span><br></div></div><p>查询</p>
<div><pre><code>rpm -q xxx //查询指定包是否安装
rpm -ql xxx //查询xxx安装的文件
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>卸载</p>
<div><pre><code>rpm -e xxx
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">基本权限 UGO</title>
    <id>https://clay-wangzhi.com/linux/basic/ugo/</id>
    <link href="https://clay-wangzhi.com/linux/basic/ugo/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="基本权限-ugo"> 基本权限 UGO</h1>
<p>文件权限设置： 可以赋于某个用户或组  能够以何种方式  访问某个文件</p>
<p>文件权限管理之： UGO设置基本权限(r、w、x)</p>
<div><pre><code>    rw-r--r--  alice hr  install.log
</code></pre>
<div><span>1</span><br></div></div><p>权限对象：</p>
<ul>
<li>属主： u</li>
<li>属组：g</li>
<li>其他人： o</li>
</ul>
<p>权限类型：</p>
<ul>
<li>
<p>读：r  4</p>
</li>
<li>
<p>写：w 2</p>
</li>
<li>
<p>执行： x 1</p>
</li>
</ul>
<h3 id="设置权限"> 设置权限</h3>
<ol>
<li>更改文件的属主、属组</li>
</ol>
<ul>
<li>chown：</li>
</ul>
<div><pre><code>chown ops.sre file1 //改属主、属组
chown ops file1     //只改属主
chown .ser file1	//只改属组
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>chgrp：</li>
</ul>
<div><pre><code>chgrp it file1	    //改文件属组
chgrp -R it dir1	//改变目录dir1的属组及其目录下已有文件的属组
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="2">
<li>更改权限</li>
</ol>
<ul>
<li>使用符号</li>
</ul>
<div><pre><code>chmod u+x file1		 //属主增加执行
chmod a=rwx file1	 //所有人等于读写执行
chmod a=- file1	     //所有人没有权限
chmod ug=rw,o=r file1 //属主属组等于读写，其他人只读
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>使用数字</li>
</ul>
<div><pre><code>chmod 644 file1  //给file1 属主读写，属组和其他读的权限
</code></pre>
<div><span>1</span><br></div></div><h3 id="r、w、x权限对文件和目录的意义"> r、w、x权限对文件和目录的意义</h3>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>r（读取）</td>
<td>可以读取文件的内容</td>
<td>可以列出目录的内容（文件名）</td>
</tr>
<tr>
<td>w（写入）</td>
<td>可以更改文件的内容</td>
<td>可以创建或删除目录中的任一文件</td>
</tr>
<tr>
<td>x（可执行）</td>
<td>可以作为命令执行文件</td>
<td>可以访问目录的内容（取决于目录中文件的权限）</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">用户管理</title>
    <id>https://clay-wangzhi.com/linux/basic/user/</id>
    <link href="https://clay-wangzhi.com/linux/basic/user/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="用户管理"> 用户管理</h1>
<p>查看当前登录的用户信息：</p>
<div><pre><code>id
uid=0(root) gid=0(root) groups=0(root)
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>系统约定： RHEL6
uid: 0     	    特权用户
uid: 1~499 	    系统用户
uid: 500+  	    普通用户</p>
<h2 id="给普通用户提权"> 给普通用户提权</h2>
<p>1.su</p>
<div><pre><code>su -
</code></pre>
<div><span>1</span><br></div></div><p>2.添加用户至sudoers</p>
<div><pre><code>vim /etc/sudoers
%wheel  ALL=(ALL)       NOPASSWD: ALL
useradd aa -G wheel
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code>usermod aa -G wheel
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">编程语言的分类</title>
    <id>https://clay-wangzhi.com/linux/gainian/code-type/</id>
    <link href="https://clay-wangzhi.com/linux/gainian/code-type/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="编程语言的分类"> 编程语言的分类</h1>
<p>编程语言的分类可以从三个角度出发：</p>
<h2 id="编译型和解释型"> 编译型和解释型</h2>
<h3 id="编译型"> 编译型</h3>
<p>即把源程序的每一条语句都编译成机器语言，并保存为二进制文件，这样运行时计算机可以直接以机器语言来运行此程序。</p>
<ul>
<li>优点：执行速度很快</li>
<li>缺点：开发效率低，不能跨平台</li>
</ul>
<p>常见语言有<code>C\C++</code>、<code>Go</code>等</p>
<h3 id="解释型"> 解释型</h3>
<p>只在运行时才一条一条的解释成机器语言给计算机执行。</p>
<ul>
<li>优点：开发效率高，跨平台</li>
<li>缺点：运行速度慢</li>
</ul>
<p>常见语言有<code>Python</code>、<code>PHP</code>、<code>JavaScript</code></p>
<h3 id="混合型"> 混合型</h3>
<p>常见语言有<code>JAVA</code>、<code>C#</code></p>
<h2 id="静态语言和动态语言"> 静态语言和动态语言</h2>
<h3 id="动态语言"> 动态语言</h3>
<p>即数据类型是在运行期间检查的，写程序时不用给变量指定数据类型，当你第一次赋值给变量时，就在内部记录下了数据类型。</p>
<p>常见语言有<code>Python</code>、<code>Ruby</code>、<code>JavaScript</code></p>
<h3 id="静态语言"> 静态语言</h3>
<p>即数据类型是在编译期间检查的，写程序时声明所有变量的数据类型。</p>
<p>常见语言有<code>JAVA</code>、<code>C\C++</code>、<code>Go</code></p>
<h2 id="强类型语言和弱类型语言"> 强类型语言和弱类型语言</h2>
<h3 id="强类型语言-类型安全"> 强类型语言（类型安全）</h3>
<p>强制数据类型定义的语言，即一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。</p>
<p>常见语言有<code>JAVA</code>、<code>C\C++</code>、<code>Python</code>、<code>Go</code>。</p>
<h3 id="弱类型语言"> 弱类型语言</h3>
<p>一个变量可以赋不同数据类型的值。</p>
<p>常见语言有<code>JavaScript</code></p>
<h2 id="结论"> 结论</h2>
<h3 id="python"> Python</h3>
<p>Python是一门动态解释型的强类型定义语言</p>
<h3 id="c"> C</h3>
<p>C语言是一门静态编译型的强类型定义语言</p>
<h3 id="java"> JAVA</h3>
<p>Java是一门静态混合型的强类型定义语言</p>
<h3 id="go"> Go</h3>
<p>Go是一门静态编译型的强类型定义语言</p>
<h3 id="javascript"> JavaScript</h3>
<p>JavaScript是一门动态解释型的弱类型定义语言</p>
<h2 id="参考链接"> 参考链接</h2>
<blockquote>
<p>https://www.cnblogs.com/sunbr/p/11214498.html</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">DEV SIT UAT PET SIM PRD PROD常见环境英文缩写含义</title>
    <id>https://clay-wangzhi.com/linux/gainian/dev-ops-env/</id>
    <link href="https://clay-wangzhi.com/linux/gainian/dev-ops-env/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="dev-sit-uat-pet-sim-prd-prod常见环境英文缩写含义"> DEV SIT UAT PET SIM PRD PROD常见环境英文缩写含义</h1>
<p>英文缩写 英文 中文
DEV development 开发
SIT System Integrate Test 系统整合测试（内测）
UAT User Acceptance Test 用户验收测试
PET Performance Evaluation Test 性能评估测试（压测）
SIM simulation 仿真
PRD/PROD production 产品/正式/生产</p>
<p>今天给大家介绍一下开发过程中，四个环境以及各自的功能特点，四个环境分别是：pro、pre、test、dev环境，中文名字：生产环境、灰度环境、测试环境、开发环境，其实大家看英文应该就差不多可以看出来对应的是什么环境。</p>
<p>环境介绍：</p>
<p>pro环境：生产环境，面向外部用户的环境，连接上互联网即可访问的正式环境。</p>
<p>pre环境：灰度环境，外部用户可以访问，但是服务器配置相对低，其它和生产一样。</p>
<p>test环境：测试环境，外部用户无法访问，专门给测试人员使用的，版本相对稳定。</p>
<p>dev环境：开发环境，外部用户无法访问，开发人员使用，版本变动很大。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">中文技术文档的写作规范</title>
    <id>https://clay-wangzhi.com/linux/gainian/document-style-guide/</id>
    <link href="https://clay-wangzhi.com/linux/gainian/document-style-guide/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="中文技术文档的写作规范"> 中文技术文档的写作规范</h1>
<blockquote>
<p>转载自：https://github.com/ruanyf/document-style-guide</p>
</blockquote>
<h2 id="标题"> 标题</h2>
<h3 id="层级"> 层级</h3>
<p>标题分为四级。</p>
<ul>
<li>一级标题：文章的标题</li>
<li>二级标题：文章主要部分的大标题</li>
<li>三级标题：二级标题下面一级的小标题</li>
<li>四级标题：三级标题下面某一方面的小标题</li>
</ul>
<p>下面是示例。</p>
<div><pre><code># 一级标题

## 二级标题

### 三级标题

#### 四级标题
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="原则"> 原则</h3>
<p>（1）一级标题下，不能直接出现三级标题。</p>
<p>示例：下面的文章结构，缺少二级标题。</p>
<div><pre><code># 一级标题

### 三级标题
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（2）标题要避免孤立编号（即同级标题只有一个）。</p>
<p>示例：下面的文章结构，<code>二级标题 A</code>只包含一个三级标题，完全可以省略<code>三级标题 A</code>。</p>
<div><pre><code>## 二级标题 A

### 三级标题 A

## 二级标题 B
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>（3）下级标题不重复上一级标题的名字。</p>
<p>示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。</p>
<div><pre><code>## 概述

### 概述
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。</p>
<p>如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</p>
<p>示例：下面的结构二要好于结构一。结构一适用的场景，主要是较长篇幅的内容。</p>
<div><pre><code>结构一

### 三级标题

#### 四级标题 A

#### 四级标题 B

#### 四级标题 C

结构二

### 三级标题

**（1）A**

**（2）B**

**（3）C**
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="文本"> 文本</h2>
<h3 id="字间距"> 字间距</h3>
<p>（1）全角中文字符与半角英文字符之间，应有一个半角空格。</p>
<div><pre><code>错误：本文介绍如何快速启动Windows系统。

正确：本文介绍如何快速启动 Windows 系统。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p>
<div><pre><code>正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。

正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p>
<div><pre><code>错误：他的电脑是 MacBook Air 。

正确：他的电脑是 MacBook Air。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="句子"> 句子</h3>
<p>（1）避免使用长句。</p>
<p>不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，任何情况下都不能接受。</p>
<div><pre><code>错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。

正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>逗号分割的长句，总长度不应该超过 100 字或者正文的 3 行。</p>
<h2 id="段落"> 段落</h2>
<h3 id="原则-2"> 原则</h3>
<ul>
<li>一个段落只能有一个主题，或一个中心句子。</li>
<li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li>
<li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li>
<li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li>
<li>段落之间使用一个空行隔开。</li>
<li>段落开头不要留出空白字符。</li>
</ul>
<h3 id="引用"> 引用</h3>
<p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p>
<div><pre><code>本文转载自 WikiQuote
</code></pre>
<div><span>1</span><br></div></div><h2 id="标点符号"> 标点符号</h2>
<h3 id="原则-3"> 原则</h3>
<p>（1）中文语句的标点符号，均应该采取全角符号，这样可以与全角文字保持视觉的一致。</p>
<p>（2）如果整句为英文，则该句使用英文/半角标点。</p>
<h3 id="句号"> 句号</h3>
<p>中文语句的结尾处应该用全角句号（<code>。</code>）。</p>
<h3 id="括号"> 括号</h3>
<p>（1）补充说明时，使用全角圆括号（<code>（）</code>），括号前后不加空格。</p>
<div><pre><code>例句：请确认所有的连接（电缆和接插件）均安装牢固。
</code></pre>
<div><span>1</span><br></div></div><h2 id="文档体系"> 文档体系</h2>
<h3 id="结构"> 结构</h3>
<p>软件手册是一部完整的书，建议采用下面的结构。</p>
<ul>
<li>
<p><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</p>
</li>
<li>
<p><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</p>
</li>
<li>
<p>入门篇</p>
<p>（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程</p>
<ul>
<li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li>
<li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li>
<li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li>
</ul>
</li>
<li>
<p><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</p>
</li>
<li>
<p><strong>API</strong>（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍</p>
</li>
<li>
<p><strong>FAQ</strong>：[可选] [文件] 常见问题解答</p>
</li>
<li>
<p>附录</p>
<p>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容</p>
<ul>
<li><strong>Glossary</strong>：[可选] [文件] 名词解释</li>
<li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li>
<li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li>
<li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li>
<li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li>
</ul>
</li>
</ul>
<p>下面是两个真实范例，可参考。</p>
<ul>
<li><a href="https://redux.js.org/introduction/getting-started" target="_blank" rel="noopener noreferrer">Redux 手册</a></li>
<li><a href="http://flight-manual.atom.io/" target="_blank" rel="noopener noreferrer">Atom 手册</a></li>
</ul>
<h3 id="文件名"> 文件名</h3>
<p>文档的文件名不得含有空格。</p>
<p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p>
<div><pre><code>错误： 名词解释.md

正确： glossary.md
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>文件名建议只使用小写字母，不使用大写字母。</p>
<div><pre><code>错误：TroubleShooting.md

正确：troubleshooting.md 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p>
<p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p>
<div><pre><code>不佳：advanced_usage.md

正确：advanced-usage.md
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">centos7下时区问题</title>
    <id>https://clay-wangzhi.com/linux/qa/centos-time/</id>
    <link href="https://clay-wangzhi.com/linux/qa/centos-time/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="centos7下时区问题"> centos7下时区问题</h2>
<p>centos7时区同样, 在
CentOS 7 中, 引入了一个叫 <strong>timedatectl</strong> 的设置设置程序。</p>
<p>用法很简单：</p>
<div><pre><code># timedatectl # 查看系统时间方面的各种状态
      Local time: 四 2014-12-25 10:52:10 CST
  Universal time: 四 2014-12-25 02:52:10 UTC
        RTC time: 四 2014-12-25 02:52:10
        Timezone: Asia/Shanghai (CST, +0800)
     NTP enabled: yes
NTP synchronized: yes
 RTC in local TZ: no
      DST active: n/a
# timedatectl list-timezones # 列出所有时区
# timedatectl set-local-rtc 1 # 将硬件时钟调整为与本地时钟一致, 0 为设置为 UTC 时间
# timedatectl set-timezone Asia/Shanghai # 设置系统时区为上海
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>其实不考虑各个发行版的差异化, 从更底层出发的话, 修改时间时区比想象中要简单:</p>
<div><pre><code># cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">证书相关问题</title>
    <id>https://clay-wangzhi.com/linux/qa/curl-https/</id>
    <link href="https://clay-wangzhi.com/linux/qa/curl-https/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="证书相关问题"> 证书相关问题</h1>
<h2 id="curl-https报错-curl-35-ssl-connect-error"> curl https报错: curl: (35) SSL connect error</h2>
<p>原因：curl默认支持https是nss，而不是openssl，需要换成openss</p>
<p>源码编译curl</p>
<div><pre><code>cd /usr/local/src/
wget http://curl.haxx.se/download/archeology/curl-7.19.7.tar.gz
tar -zxf curl-7.19.7.tar.gz
cd curl-7.19.7
./configure --without-nss --with-ssl
make
make install
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>转载自：<a href="https://blog.csdn.net/qq_34810257/article/details/80885622" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_34810257/article/details/80885622</a></p>
<h2 id="ca证书过期导致请求错误"> ca证书过期导致请求错误</h2>
<p>1）查看一下时间date</p>
<p>2） 系统 curl 命令不通的时候</p>
<p>更新一下 证书</p>
<div><pre><code>update-ca-trust
</code></pre>
<div><span>1</span><br></div></div><p>![img](https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/QQ截图20210111155232 [1].jpg)</p>
<p>3）更新一下java里面的cacerts</p>
<div><pre><code>cp -a /etc/pki/ca-trust/extracted/java/cacerts /opt/jdk1.8.0_144/jre/lib/security/cacerts
</code></pre>
<div><span>1</span><br></div></div><h2 id="老交叉根过期"> 老交叉根过期</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20210407141053673.png" alt="image-20210407141053673" /></p>
<p>解决办法：联系证书供应商更新证书</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Linux，du、df统计的硬盘使用情况不一致问题</title>
    <id>https://clay-wangzhi.com/linux/qa/du-df-diff/</id>
    <link href="https://clay-wangzhi.com/linux/qa/du-df-diff/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-du、df统计的硬盘使用情况不一致问题"> Linux，du、df统计的硬盘使用情况不一致问题</h1>
<p>在运维Linux服务器时，会碰到需要查看硬盘空间的情况，这时候，通常会使用<code>df -lh</code>命令来检查每个挂载了文件系统的硬盘的总量和已使用量，或者，可以使用<code>du -sh [directory]</code>命令来统计某个目录下所有文件的空间占用。</p>
<p>在使用<code>df、du</code>命令时，常常会遇到统计的硬盘使用情况不一致的问题。比如du统计根目录下文件总共大小为2G，而df判断挂载在根目录的硬盘已用空间达到了3G，20G甚至更多。发生这种情况，有以下三种原因：</p>
<h2 id="预留空间"> 预留空间</h2>
<p>为了预防紧急情况，linux ext文件系统会预留部分硬盘空间，具体预留的数值可以通过tune2fs -l [dev_name] | grep “Reserved block count”查看到（dev_name是设备名），这里预留的空间会被df计算到已用空间中，从而导致df和du统计不一致。如果需要调整预留空间大小，我们可以使用tune2fs -m [size][dev_name]来进行调整。</p>
<h2 id="幻影文件-phantom-file"> 幻影文件（phantom file）</h2>
<p>du是统计被文件系统记录到的每个文件的大小，然后进行累加得到的大小，这是通过文件系统获取到的。而df主要是从超级块（superblock）中读入硬盘使用信息，df获取到的是磁盘块被使用的情况。当一个文件被删除时，如果有别的进程正在使用它（占有句柄）， 这个文件将不会被du统计到，但是这个文件被占用的磁盘空间却依然会被df统计到。这些文件，以及正在使用这些文件的进程可以通过lsof | grep deleted查到。当进程停止或者被kill时，这些空间将被释放。</p>
<h2 id="未统计到的文件"> 未统计到的文件</h2>
<p>如果上面两种情况都排除了，但是数据还是不一致，那是怎么回事？这里隐藏着一种情况：当我们将一个目录挂在到一个新的设备（硬盘）上之前，如果这个目录里面已经有数据，那么这一部分数据不会被du感知，在文件系统中也看不到这些数据，但是这些数据又是确实占用了磁盘空间，是能够被df所统计到的。这时候通过du/df统计原设备的空间使用情况，就会发现df统计到的比du要多。遇到这样的情况时，使用fuser -km [directory]杀死占用该目录的所有进程（小心操作！），然后使用umount [directory]将该目录挂载的设备卸载，这时，目录里面原来已有的数据就会出现，我们将其删除之后，再重新挂载设备（mount -t [type][dev] [directory]）即可。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">mysql最大连接数的改变</title>
    <id>https://clay-wangzhi.com/linux/qa/mysql-max-con/</id>
    <link href="https://clay-wangzhi.com/linux/qa/mysql-max-con/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mysql最大连接数的改变"> mysql最大连接数的改变</h1>
<p>在使用MySQL数据库的时候，经常会遇到这么一个问题，就是“Can not connect to MySQL server. Too many connections”-mysql 1040错误，这是因为访问MySQL且还未释放的连接数目已经达到MySQL的上限。通常，mysql的最大连接数默认是100, 最大可以达到16384。</p>
<p>常用的有两种方式修改最大连接数。</p>
<h3 id="命令行修改"> 命令行修改</h3>
<div><pre><code>#mysql -uuser -ppassword(命令行登录MySQL)
mysql&gt;show variables like &#39;max_connections&#39;;(查可以看当前的最大连接数)
msyql&gt;set global max_connections=1000;(设置最大连接数为1000，可以再次查看是否设置成功)
mysql&gt;exit(退出)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这种方式有个问题，就是设置的最大连接数只在mysql当前服务进程有效，一旦mysql重启，又会恢复到初始状态。因为mysql启动后的初始化工作是从其配置文件中读取数据的，而这种方式没有对其配置文件做更改。</p>
<h3 id="修改配置文件"> 修改配置文件</h3>
<p>这 种方式说来很简单，只要修改MySQL配置文件my.ini 或 my.cnf的参数max_connections，将其改为max_connections=1000，然后重启MySQL即可。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">linux下如何增加swap交换分区</title>
    <id>https://clay-wangzhi.com/linux/qa/swap/</id>
    <link href="https://clay-wangzhi.com/linux/qa/swap/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux下如何增加swap交换分区"> linux下如何增加swap交换分区</h1>
<p>swap即交换分区，类似于<a href="http://www.ttlsa.com/windows/" target="_blank" rel="noopener noreferrer">windows</a>虚拟内存功能，就是在硬盘上分配出一块空间作为虚拟内存来使用.</p>
<p>通常swap都是在装系统硬盘分区时设定，这里只是探讨一下系统已经安装好后，扩展swap分区的方法.下面我们来将下如何在安装好的<a href="http://www.ttlsa.com/linux/" target="_blank" rel="noopener noreferrer">linux</a>下增加swap交换分区.</p>
<p>可以有两种方法来增加swap分区，一种是将新的分区来作为swap，另一种是在磁盘中创建一个大的文件来作swap.</p>
<h2 id="新分区扩展swap"> 新分区扩展swap</h2>
<p>假如有一个新的分区/dev/sda3,我们用它来作swap.</p>
<div><pre><code># swapon -s                --查看当前swap情况
# mkswap /dev/sda3
# swapon /dev/sda3
# swapon -s
# vi /etc/fstab
/dev/sda3   swap   swap  defaults  0  0    --添加开机自动挂载
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="大文件扩展swap"> 大文件扩展swap</h2>
<div><pre><code># cd /var
# dd if=/dev/zero of=file bs=1M count=1000       --生成1G的大文件
# mkswap file
# swapon file
# swapon -s
# vi /etc/fstab
/var/file   swap   swap   defaults  0   0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Elasticsearch基础概念</title>
    <id>https://clay-wangzhi.com/monitor/elk/bak/9.1%20%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/bak/9.1%20%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="elasticsearch基础概念"> Elasticsearch基础概念</h2>
<h3 id="elasticsearch关键概念"> Elasticsearch关键概念</h3>
<ul>
<li>Document（文档）：用户存储在es中的数据文档，它是以JSON格式定义的特定方式的字段集合。每个文档都属于一个类型，并驻留在一个索引中。每个文档都有一个唯一的标识符，称为UID。</li>
<li>Index（索引）：包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的Document。比如说建立一个商品索引，里面可能就存放了所有的商品数据。</li>
<li>Type/Mapping（类型/映射）：它是共享同一索引中一组公共字段的文档集合。例如，索引包含社交网络应用程序的数据，然后可以有特定类型的用户简档数据、另一种类型的消息数据和另一种类型的评论数据。</li>
<li>Node（节点）：它指的是ElasticSearch的单个运行实例，是集群的构成单元。单个物理和虚拟服务器可容纳多个节点，具体取决于其物理资源(如内存、存储和处理能力)的能力。</li>
<li>Cluster（集群）：它是一个或多个节点组成的集合。集群为整个数据提供跨节点的索引和搜索功能。</li>
<li>Shard（分片）：单台机器无法存储大量数据，ElasticSearch可以将一个索引中的数据切分为多个Shard，分布在多台服务器上存储。有了Shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。</li>
<li>Replicas(副本):服务器随时可能故障或宕机，此时Shard可能就会丢失，因此可以为每个Shard创建多个Replica副本。Replica可以在Shard故障时提供备用服务，保证数据不丢失，多个Replica还可以提升搜索操作的吞吐量和性能。</li>
</ul>
<h3 id="document-文档"> Document（文档）</h3>
<p>document其实就是json object 由字段（Field)组成，常见的类型：</p>
<ul>
<li>
<p>字符串：keyword（不分词）,text(分词)</p>
</li>
<li>
<p>数值型：long,integer,short,byte,double,float,half_float,scaled_float</p>
</li>
<li>
<p>布尔：boolean</p>
</li>
<li>
<p>日期：date</p>
</li>
<li>
<p>二进制：binary</p>
</li>
<li>
<p>范围类型：integer_range,float_range,long_range,double_range,date_range</p>
</li>
</ul>
<p>每一个文档有唯一的ID标识</p>
<ul>
<li>自行指定</li>
<li>es 自动生成</li>
</ul>
<p><img src="./images/document01.png" alt="" /></p>
<ul>
<li>元数据，用于标注文档的相关信息
<ul>
<li>_index：文档所在的索引名</li>
<li>_type：文档所在的类型名</li>
<li>_id：文档唯一id</li>
<li>_uid：组合id，由_type和_id组成（6.x _type不再起作用，同id一样）</li>
<li>_source：文档的原始Json数据，可以从这里获取每个字段的内容</li>
<li>_all：整合所有字段内容到该字段，默认禁用</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：元数据不能删除</p>
</blockquote>
<h3 id="index-索引"> Index（索引）</h3>
<ul>
<li>索引中存储具有相同结构的文档（Document）
<ul>
<li>每个索引都有自己的mapping定义，用于定义字段名和类型</li>
</ul>
</li>
<li>一个集群可以有多个索引，比如：
<ul>
<li>nginx日志存储的时候可以按照日期每天生产一个索引来存储
<ul>
<li>nginx_log_2019-08-01</li>
<li>nginx_log_2019-08-02</li>
<li>nginx_log_2019-08-03</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="mapping"> Mapping</h3>
<h4 id="作用"> 作用</h4>
<ul>
<li>类似数据库中的表结构定义，主要作用如下：
<ul>
<li>定义Index下的字段名（Field Name）</li>
<li>定义字段的类型，比如数值型、字符串型、布尔型等</li>
<li>定义倒排索引相关的配置，比如是否索引、记录position等</li>
</ul>
</li>
</ul>
<p><img src="./images/mapping01.png" alt="" /></p>
<p><img src="./images/mapping02.png" alt="" /></p>
<blockquote>
<p>Mapping中的字段类型一旦设定后，禁止直接修改，原因如下：</p>
<p>​	Lucene实现的倒排索引生成后不允许修改</p>
</blockquote>
<h4 id="常用参数"> 常用参数</h4>
<h5 id="dynamic"> Dynamic</h5>
<ul>
<li>允许新增字段，通过dynamic参数来控制字段的新增
<ul>
<li>true（默认）允许自动新增字段</li>
<li>false不允许自动新增字段，但是文档可以正常写入，但无法对字段进行查询等操作</li>
<li>strict文档不能写入，报错</li>
</ul>
</li>
</ul>
<h5 id="copy-to"> copy_to</h5>
<ul>
<li>将该字段的值复制到目标字段，实现类似_all的作用</li>
<li>不会出现在_source中，只用来搜索</li>
</ul>
<h5 id="index"> index</h5>
<ul>
<li>控制当前字段是否索引，默认为true，即记录索引，false不记录，即不可搜索</li>
</ul>
<h5 id="index-options"> index_options</h5>
<ul>
<li>用于控制倒排索引记录的内容，有如下4种配置
<ul>
<li>docs：只记录doc id</li>
<li>freqs：记录doc id和term frequencies</li>
<li>positions：记录doc id、term frequencies和term position</li>
<li>offsets：记录doc id、term frequencies、term position和character offsets</li>
</ul>
</li>
<li>text类型默认配置为positions，其他默认为docs</li>
<li>记录内容越多，占用空间越大</li>
</ul>
<h5 id="null-value"> null_value</h5>
<ul>
<li>当字段遇到null值时的处理策略，默认为null，即控制，此时es会忽略该值。可以通过设定该值设定字段的默认值</li>
</ul>
<h3 id="rest-api"> Rest API</h3>
<ul>
<li>
<p>Elasticsearch集群对外提供Restful API</p>
<ul>
<li>REST：REpresentational State Transfer</li>
<li>URL指定资源，如Index、Document等</li>
<li>Http Method指明资源操作类型，如GET、POST、PUT、DELETE等</li>
</ul>
</li>
</ul>
<p><img src="./images/rest01.png" alt="" /></p>
<h4 id="创建文档"> 创建文档</h4>
<p><img src="./images/create01.png" alt="" /></p>
<p><img src="./images/create02.png" alt="" /></p>
<h4 id="查询文档"> 查询文档</h4>
<p><img src="./images/select01.png" alt="" /></p>
<p><img src="./images/select02.png" alt="" /></p>
<h4 id="批量创建"> 批量创建</h4>
<p><img src="./images/create03.png" alt="" /></p>
<h4 id="批量查询"> 批量查询</h4>
<p><img src="./images/select03.png" alt="" /></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Elasticsearch分词</title>
    <id>https://clay-wangzhi.com/monitor/elk/bak/9.2%20%E5%88%86%E8%AF%8D/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/bak/9.2%20%E5%88%86%E8%AF%8D/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="elasticsearch分词"> Elasticsearch分词</h2>
<h3 id="分词相关概念"> 分词相关概念</h3>
<ul>
<li>分词：是指将文本转换成一系列单词（term or token）,也可以叫做文本分析，在es里面称为Analysis。</li>
<li>分词器：是es中专门处理分词的组件，英文为Analyzer，它的组成如下：
<ul>
<li>Character Filters：针对原始文本进行处理，比如去除html特殊标记符</li>
<li>Tokenizer：将原始文本按照一定规则切分为单词</li>
<li>Token Filters：针对tokenizer处理完成的单词，再加工，比如转小写、删除或新增等处理</li>
</ul>
</li>
</ul>
<h3 id="使用场景"> 使用场景</h3>
<ul>
<li>创建或更新文档时（Index Time），会对相应的文档进行分词处理</li>
<li>查询时（SearchTime），会对查询语句进行分词</li>
</ul>
<h4 id="索引时"> 索引时</h4>
<ul>
<li>索引时分词是通过配置Index Mapping中每个字段的analyzer属性实现的，不指定分词时，默认使用standard，如下</li>
</ul>
<p><img src="./images/index01.png" alt="" /></p>
<h4 id="查询时"> 查询时</h4>
<ul>
<li>查时分词的指定方式有如下几种:
<ul>
<li>查询的时候通过analyzer指定分词器</li>
<li>通多index mapping设置search_analyzer实现</li>
</ul>
</li>
</ul>
<p><img src="./images/chaxun01.png" alt="" /></p>
<h3 id="analyze-api"> Analyze API</h3>
<ul>
<li>es提供了一个测试分词的api接口，方便验证分词效果，endpoint是_analyze
<ul>
<li>可以直接指定analyzer进行测试</li>
<li>可以直接指定索引中的字段进行测试</li>
<li>可以自定义分词器进行测试</li>
</ul>
</li>
</ul>
<p><img src="./images/analyze01.png" alt="" /></p>
<p><img src="./images/analyze02.png" alt="" /></p>
<p><img src="./images/analyze03.png" alt="" /></p>
<h3 id="预定义的分词器"> 预定义的分词器</h3>
<ul>
<li>
<p>es自带如下的分词器</p>
<ul>
<li>Standard</li>
<li>Simple</li>
<li>Whitespace</li>
<li>Stop</li>
<li>Keyword</li>
<li>Pattern</li>
<li>Language</li>
</ul>
</li>
</ul>
<h4 id="standard-analyzer"> Standard Analyzer</h4>
<ul>
<li>默认分词器</li>
<li>其组成如图，特性为：
<ul>
<li>按词切分，支持多语言</li>
<li>小写处理</li>
</ul>
</li>
</ul>
<p><img src="./images/yudingyi01.png" alt="" /></p>
<h4 id="simple-analyzer"> Simple Analyzer</h4>
<ul>
<li>其组成如图，特性为：
<ul>
<li>按照非字母切分</li>
<li>小写处理</li>
</ul>
</li>
</ul>
<p><img src="./images/yudingyi02.png" alt="" /></p>
<h4 id="whitespace-analyzer"> Whitespace Analyzer</h4>
<ul>
<li>其组成如图，特性为：
<ul>
<li>按照空格切分</li>
</ul>
</li>
</ul>
<p><img src="./images/yudingyi03.png" alt="" /></p>
<h4 id="stop-analyzer"> Stop Analyzer</h4>
<ul>
<li>Stop Word 指预期助词等修饰性的词语，比如the、an、的、这等等</li>
<li>其组成如图，特性为：
<ul>
<li>相比Simple Analyzer多了Stop Word处理</li>
</ul>
</li>
</ul>
<p><img src="./images/yudingyi04.png" alt="" /></p>
<h4 id="keyword-analyzer"> KeyWord Analyzer</h4>
<ul>
<li>其组成如图，特性为：
<ul>
<li>不分词，直接将输入作为一个单词输出</li>
</ul>
</li>
</ul>
<p><img src="./images/yudingyi05.png" alt="" /></p>
<h4 id="pattern-analyzer"> Pattern Analyzer</h4>
<ul>
<li>其组成如图，特性为：
<ul>
<li>通过正则表达式自定义分割符</li>
<li>默认是\W+，即非字词的符号作为分隔符</li>
</ul>
</li>
</ul>
<p><img src="./images/yudingyi06.png" alt="" /></p>
<h3 id="自定义分词"> 自定义分词</h3>
<h4 id="tokernizer"> Tokernizer</h4>
<ul>
<li>将原始文本按照一定规则切分为单词（term or token）</li>
<li>自带的如下：
<ul>
<li>standard 按照单词进行分割</li>
<li>letter按照非字符类进行分割</li>
<li>whitespace 按照空格进行分割</li>
<li>UAX URL Email按照standard分割，但不会分割邮箱和url</li>
<li>NGram和Edge NGram连词分割</li>
<li>Path Hierarchy按照文件路径进行切割</li>
</ul>
</li>
</ul>
<p><img src="./images/zidingyi02.png" alt="" /></p>
<h4 id="character-filters"> Character Filters</h4>
<ul>
<li>在Tokenizer之前对原始文本进行处理，比如增加、删除或替换字符等</li>
<li>自带的如下：
<ul>
<li>HTML Strip 去除html标签和转换html实体</li>
<li>Mapping进行字符替换操作</li>
<li>Pattern Replace进行正则匹配替换</li>
</ul>
</li>
<li>会影响后续tokenizer解析的postion和offset信息</li>
</ul>
<p><img src="./images/zidingyi01.png" alt="" /></p>
<h4 id="token-filters"> Token Filters</h4>
<ul>
<li>对于tokenizer输出的单词（term）进行增加、删除、修改等操作</li>
<li>自带的如下：
<ul>
<li>lowercase将所有term转换为小写</li>
<li>stop删除stop words</li>
<li>NGram和Edge NGram连词分割</li>
<li>Synonym添加近义词的term</li>
</ul>
</li>
</ul>
<p><img src="./images/zidingyi03.png" alt="" /></p>
<h4 id="api"> API</h4>
<ul>
<li>自定义分词需要在索引的配置中设定，如下所示：</li>
</ul>
<p><img src="./images/zidingyi04.png" alt="" /></p>
<p><img src="./images/zidingyi05.png" alt="" /></p>
<h3 id="中文分词"> 中文分词</h3>
<ul>
<li>
<p>难点</p>
<ul>
<li>中文分词指的是将一个汉字序列切分成一个一个单独的词。在英文中，单词之间是以空格作为自然分界符，汉语中词没有一个形式上的分解符。</li>
<li>上下文不同，分词结果迥异，比如交叉歧义问题，比如下面两种分词都合理
<ul>
<li>乒乓球拍/卖/完了</li>
<li>乒乓球/拍卖/完了</li>
</ul>
</li>
</ul>
</li>
<li>
<p>常用分词系统</p>
<ul>
<li>IK
<ul>
<li>实现中英文单词的切分，支持ik_smart、ik_maxword等模式</li>
<li>可自定义词库，支持热更新分词词典</li>
</ul>
</li>
<li>jieba
<ul>
<li>python中最流行的分词系统，支持分词和词性标注</li>
<li>支持繁体分词、自定义词典、并行分词等</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基于自然语言处理的分词系统</p>
<ul>
<li>Hanlp
<ul>
<li>由一系列模型与算法组成的Java工具包，目标是普及自然语言处理在生产环境中的应用</li>
</ul>
</li>
<li>THULAC
<ul>
<li>THU Lexical Analyzer for Chinese，由清华大学自然语言处理与社会人文计算实验室研制推出的一套中文词法分析工具包，具有中文分词和词性标注功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分词使用建议"> 分词使用建议</h3>
<ul>
<li>明确字段是否需要分词，不需要分词的字段就将type设置为keyword，可以节省空间和提高写性能</li>
<li>善用_analyze API，查看文档的具体分词结果</li>
<li>动手测试</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Centos7.6下Elasticseatch7.2集群搭建步骤</title>
    <id>https://clay-wangzhi.com/monitor/elk/bak/9.3%20centos7.6%E4%B8%8Belasticsearch7.2%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/bak/9.3%20centos7.6%E4%B8%8Belasticsearch7.2%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="centos7-6下elasticseatch7-2集群搭建步骤"> Centos7.6下Elasticseatch7.2集群搭建步骤</h2>
<h3 id="环境准备"> 环境准备</h3>
<ul>
<li>云主机：3台</li>
<li>linux系统版本：centos7.6.1810</li>
<li>配置：4核 8G</li>
</ul>
<h4 id="主机名解析"> 主机名解析</h4>
<div><pre><code>hostnamectl set-hostname es01.csp
</code></pre>
<div><span>1</span><br></div></div><p>将三台主机的主机名加入到<code>/etc/hosts</code>文件中</p>
<div><pre><code>echo &quot;xxx.xxx.xxx.xxx es01.csp&quot; /etc/hosts
</code></pre>
<div><span>1</span><br></div></div><h4 id="安装依赖环境"> 安装依赖环境</h4>
<h5 id="安装jdk11和shasum"> 安装JDK11和shasum</h5>
<div><pre><code>yum -y install java-11-openjdk.x86_64 1:perl-Digest-SHA-5.85-4.el7.x86_64
</code></pre>
<div><span>1</span><br></div></div><h5 id="安装docker"> 安装docker</h5>
<h6 id="uninstall-old-versions"> Uninstall old versions</h6>
<div><pre><code>yum remove docker \
  docker-client \
  docker-client-latest \
  docker-common \
  docker-latest \
  docker-latest-logrotate \
  docker-logrotate \
  docker-engine
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h6 id="install-using-the-repository"> Install using the repository</h6>
<ol>
<li>Install required packages. <code>yum-utils</code> provides the <code>yum-config-manager</code> utility, and <code>device-mapper-persistent-data</code> and <code>lvm2</code>are required by the <code>devicemapper</code> storage driver.</li>
</ol>
<div><pre><code>yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li>Use the following command to set up the <strong>stable</strong> repository.</li>
</ol>
<div><pre><code>yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h6 id="install-docker-ce"> INSTALL DOCKER CE</h6>
<ol>
<li>Install the <em>latest version</em> of Docker CE and containerd, or go to the next step to install a specific version:</li>
</ol>
<div><pre><code>yum -y install docker-ce docker-ce-cli containerd.io
</code></pre>
<div><span>1</span><br></div></div><p>2.Start Docker.</p>
<div><pre><code>systemctl enable docker
systemctl start docker
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h6 id="configure-the-docker-accelerator"> Configure the docker accelerator</h6>
<ul>
<li>Docker中国区官方镜像</li>
</ul>
<div><pre><code>vim /etc/docker/daemon.json
</code></pre>
<div><span>1</span><br></div></div><p>加入下面的数据：</p>
<p>docker-cn镜像：</p>
<div><pre><code>{
  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>或者</p>
<ul>
<li>阿里云容器  服务（推荐）</li>
</ul>
<div><pre><code>tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;
{
  &quot;registry-mirrors&quot;: [&quot;https://pclhthp0.mirror.aliyuncs.com&quot;]
}
EOF
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>systemctl restart docker
</code></pre>
<div><span>1</span><br></div></div><h4 id="新增防火墙策略"> 新增防火墙策略</h4>
<div><pre><code>iptables -t filter -I INPUT 5 -m state --state NEW -m tcp -p tcp --dport 9200 -j ACCEPT 
iptables -t filter -I INPUT 6 -m state --state NEW -m tcp -p tcp --dport 9300 -j ACCEPT
iptables-save &gt; /etc/sysconfig/iptables
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="安装elasticsearch"> 安装Elasticsearch</h3>
<ul>
<li>自己手动安装Elasticsearch</li>
</ul>
<p>Elasticsearch以以下包格式提供：</p>
<table>
<thead>
<tr>
<th>Linux和MacOS <code>tar.gz</code>档案</th>
<th>这些<code>tar.gz</code>存档可以在任何Linux发行版和MacOS上安装。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/targz.html" target="_blank" rel="noopener noreferrer">在Linux或MacOS上从归档安装Elasticsearch</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows <code>.zip</code>档案</td>
<td>该<code>zip</code>存档适合在Windows上安装。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/zip-windows.html" target="_blank" rel="noopener noreferrer"><code>.zip</code>在Windows上安装Elasticsearch</a></td>
</tr>
<tr>
<td><code>deb</code></td>
<td>该<code>deb</code>软件包适用于Debian，Ubuntu和其他基于Debian的系统。Debian软件包可以从Elasticsearch网站或我们的Debian存储库下载。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/deb.html" target="_blank" rel="noopener noreferrer">使用Debian软件包安装Elasticsearch</a></td>
</tr>
<tr>
<td><code>rpm</code></td>
<td>该<code>rpm</code>软件包适合安装在Red Hat，Centos，SLES，OpenSuSE和其他基于RPM的系统上。RPM可以从Elasticsearch网站或我们的RPM存储库下载。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/rpm.html" target="_blank" rel="noopener noreferrer">使用RPM安装Elasticsearch</a></td>
</tr>
<tr>
<td><code>msi</code></td>
<td>[ beta ] 此功能处于测试版状态，可能会发生变化。设计和代码不如官方GA功能成熟，并且按原样提供，不提供任何保证。测试版功能不受官方GA功能支持SLA的约束。该<code>msi</code>软件包适合安装在至少安装了.NET 4.5框架的Windows 64位系统上，并且是在Windows上开始使用Elasticsearch的最简单选择。MSI可以从Elasticsearch网站下载。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/windows.html" target="_blank" rel="noopener noreferrer">使用Windows MSI安装程序安装Elasticsearch</a></td>
</tr>
<tr>
<td><code>docker</code></td>
<td>图像可用于将Elasticsearch作为Docker容器运行。它们可以从Elastic Docker Registry下载。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/docker.html" target="_blank" rel="noopener noreferrer">使用Docker安装Elasticsearch</a></td>
</tr>
<tr>
<td><code>brew</code></td>
<td>可以从Elastic Homebrew tap获得公式，以便使用Homebrew包管理器在macOS上安装Elasticsearch。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/brew.html" target="_blank" rel="noopener noreferrer">使用Homebrew在macOS上安装Elasticsearch</a></td>
</tr>
</tbody>
</table>
<ul>
<li>配置管理工具</li>
</ul>
<p>我们还提供以下配置管理工具来帮助进行大型部署：</p>
<table>
<thead>
<tr>
<th>Puppet</th>
<th><a href="https://github.com/elastic/puppet-elasticsearch" target="_blank" rel="noopener noreferrer">puppet-elasticsearch</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>Chef</td>
<td><a href="https://github.com/elastic/cookbook-elasticsearch" target="_blank" rel="noopener noreferrer">cookbook-elasticsearch</a></td>
</tr>
<tr>
<td>Ansible</td>
<td><a href="https://github.com/elastic/ansible-elasticsearch" target="_blank" rel="noopener noreferrer">ansible-elasticsearch</a></td>
</tr>
</tbody>
</table>
<h4 id="使用rmp安装elasticsearch"> 使用RMP安装Elasticsearch</h4>
<h5 id="手动下载并安装rpm包"> 手动下载并安装RPM包</h5>
<p>可以从网站下载Elasticsearch v7.2.0的RPM并按如下方式安装：</p>
<div><pre><code>wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.2.0-x86_64.rpm
wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.2.0-x86_64.rpm.sha512
shasum -a 512 -c elasticsearch-7.2.0-x86_64.rpm.sha512 
rpm --install elasticsearch-7.2.0-x86_64.rpm
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h5 id="用systemd运行elasticsearch"> 用systemd运行Elasticsearch</h5>
<p>要将Elasticsearch配置为在系统启动时自动启动，请运行以下命令：</p>
<div><pre><code>systemctl daemon-reload
systemctl enable elasticsearch.service
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Elasticsearch可以按如下方式启动和停止：</p>
<div><pre><code>systemctl start elasticsearch.service
systemctl stop elasticsearch.service
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>！！！请改好配置文件后，再启动</p>
</blockquote>
<p>这些命令不提供有关Elasticsearch是否成功启动的反馈。相反，此信息将写入位于的日志文件中<code>/var/log/elasticsearch/</code>。</p>
<p>默认情况下，Elasticsearch服务不会在<code>systemd</code> 日记中记录信息。要启用<code>journalctl</code>日志记录，<code>--quiet</code>必须从文件中的<code>ExecStart</code>命令行中删除该选项<code>elasticsearch.service</code>。</p>
<h5 id="当systemd启用了日志记录-日志信息使用可用journalctl的命令"> 当<code>systemd</code>启用了日志记录，日志信息使用可用<code>journalctl</code>的命令：</h5>
<p>To tail the journal:</p>
<div><pre><code>journalctl -f
</code></pre>
<div><span>1</span><br></div></div><p>To list journal entries for the elasticsearch service:</p>
<div><pre><code>journalctl --unit elasticsearch
</code></pre>
<div><span>1</span><br></div></div><p>To list journal entries for the elasticsearch service starting from a given time:</p>
<div><pre><code>journalctl --unit elasticsearch --since  &quot;2016-10-30 18:17:16&quot;
</code></pre>
<div><span>1</span><br></div></div><h5 id="检查elasticsearch是否在正常运行"> 检查Elasticsearch是否在正常运行</h5>
<p>您可以测试你的Elasticsearch节点通过发送一个HTTP请求的端口上运行<code>9200</code>上<code>localhost</code>：</p>
<div><pre><code>GET /
</code></pre>
<div><span>1</span><br></div></div><p>正常情况下会收到类似下面这样的回复</p>
<div><pre><code>{
  &quot;name&quot; : &quot;es01.csp&quot;,
  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,
  &quot;cluster_uuid&quot; : &quot;wdgCotLlSOGt_zwv_69CIw&quot;,
  &quot;version&quot; : {
    &quot;number&quot; : &quot;7.2.0&quot;,
    &quot;build_flavor&quot; : &quot;default&quot;,
    &quot;build_type&quot; : &quot;rpm&quot;,
    &quot;build_hash&quot; : &quot;508c38a&quot;,
    &quot;build_date&quot; : &quot;2019-06-20T15:54:18.811730Z&quot;,
    &quot;build_snapshot&quot; : false,
    &quot;lucene_version&quot; : &quot;8.0.0&quot;,
    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,
    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;
  },
  &quot;tagline&quot; : &quot;You Know, for Search&quot;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h5 id="配置elasticsearch"> 配置Elasticsearch</h5>
<p>Elasticsearch默认使用<code>/etc/elasticsearch</code>运行时配置。此目录的所有权和此目录中的所有文件都设置为 <code>root:elasticsearch</code>打包安装，并且目录<code>setgid</code> 设置了标志，以便创建的所有文件和子目录<code>/etc/elasticsearch</code> 也使用此所有权创建（例如，如果使用密钥库创建<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/secure-settings.html" target="_blank" rel="noopener noreferrer">密钥库）工具</a>）。预计会对此进行维护，以便Elasticsearch进程可以通过组权限读取此目录下的文件。</p>
<p><code>/etc/elasticsearch/elasticsearch.yml</code>默认情况下，Elasticsearch从文件加载其配置 。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/settings.html" target="_blank" rel="noopener noreferrer"><em>配置Elasticsearch中</em></a>介绍了此配置文件的格式。</p>
<p>RPM还有一个系统配置文件（<code>/etc/sysconfig/elasticsearch</code>），允许您设置以下参数：</p>
<table>
<thead>
<tr>
<th><code>JAVA_HOME</code></th>
<th>设置要使用的自定义Java路径。</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MAX_OPEN_FILES</code></td>
<td>最大打开文件数，默认为<code>65535</code>。</td>
</tr>
<tr>
<td><code>MAX_LOCKED_MEMORY</code></td>
<td>最大锁定内存大小。<code>unlimited</code>如果您使用<code>bootstrap.memory_lock</code>elasticsearch.yml中的选项，则 设置为。</td>
</tr>
<tr>
<td><code>MAX_MAP_COUNT</code></td>
<td>进程可能具有的最大内存映射区域数。如果您使用<code>mmapfs</code> 索引存储类型，请确保将其设置为较高的值。欲了解更多信息，请查看 <a href="https://github.com/torvalds/linux/blob/master/Documentation/sysctl/vm.txt" target="_blank" rel="noopener noreferrer">Linux内核文件</a> 有关<code>max_map_count</code>。这是<code>sysctl</code>在启动Elasticsearch之前设置的。默认为<code>262144</code>。</td>
</tr>
<tr>
<td><code>ES_PATH_CONF</code></td>
<td>配置文件目录（其中必须包括<code>elasticsearch.yml</code>，<code>jvm.options</code>，和<code>log4j2.properties</code>文件）; 默认为<code>/etc/elasticsearch</code>。</td>
</tr>
<tr>
<td><code>ES_JAVA_OPTS</code></td>
<td>您可能想要应用的任何其他JVM系统属性。</td>
</tr>
<tr>
<td><code>RESTART_ON_UPGRADE</code></td>
<td>在程序包升级时配置重新启动，默认为<code>false</code>。这意味着您必须在手动安装软件包后重新启动Elasticsearch实例。这样做的原因是为了确保群集中的升级不会导致连续的分片重新分配，从而导致高网络流量并缩短群集的响应时间。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>使用的分发<code>systemd</code>要求通过<code>systemd</code>而不是通过<code>/etc/sysconfig/elasticsearch</code> 文件来配置系统资源限制。有关更多信息，请参阅<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#systemd" target="_blank" rel="noopener noreferrer">Systemd配置</a>。</p>
</blockquote>
<h5 id="rpm目录布局"> RPM目录布局</h5>
<p>RPM将配置文件，日志和数据目录放置在基于RPM的系统的适当位置：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>默认位置</th>
<th>设置</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>home</strong></td>
<td>Elasticsearch主目录或 <code>$ES_HOME</code></td>
<td><code>/usr/share/elasticsearch</code></td>
<td></td>
</tr>
<tr>
<td><strong>bin</strong></td>
<td>二进制脚本，包括<code>elasticsearch</code>启动节点和<code>elasticsearch-plugin</code>安装插件</td>
<td><code>/usr/share/elasticsearch/bin</code></td>
<td></td>
</tr>
<tr>
<td><strong>conf</strong></td>
<td>配置文件包括 <code>elasticsearch.yml</code></td>
<td><code>/etc/elasticsearch</code></td>
<td><code>ES_PATH_CONF</code></td>
</tr>
<tr>
<td><strong>conf</strong></td>
<td>环境变量，包括堆大小，文件描述符。</td>
<td><code>/etc/sysconfig/elasticsearch</code></td>
<td></td>
</tr>
<tr>
<td><strong>data</strong></td>
<td>节点上分配的每个索引/分片的数据文件的位置。可以容纳多个位置。</td>
<td><code>/var/lib/elasticsearch</code></td>
<td><code>path.data</code></td>
</tr>
<tr>
<td><strong>logs</strong></td>
<td>日志文件位置。</td>
<td><code>/var/log/elasticsearch</code></td>
<td><code>path.logs</code></td>
</tr>
<tr>
<td><strong>plugins</strong></td>
<td>插件文件位置。每个插件都将包含在一个子目录中。</td>
<td><code>/usr/share/elasticsearch/plugins</code></td>
<td></td>
</tr>
<tr>
<td><strong>repo</strong></td>
<td>共享文件系统存储库位置。可以容纳多个位置。文件系统存储库可以放在此处指定的任何目录的任何子目录中。</td>
<td>未配置</td>
<td><code>path.repo</code></td>
</tr>
</tbody>
</table>
<h3 id="配置elasticsearch-2"> 配置Elasticsearch</h3>
<p>Elasticsearch具有良好的默认值，只需要很少的配置。可以使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/cluster-update-settings.html" target="_blank" rel="noopener noreferrer"><em>Cluster Update Settings</em></a> API 在正在运行的群集上更改大多数设置 。</p>
<p>配置文件应包含特定于节点的设置（例如<code>node.name</code>和路径），或节点为了能够加入群集而需要的设置，例如<code>cluster.name</code>和<code>network.host</code>。</p>
<ul>
<li>配置文件位置</li>
</ul>
<p>Elasticsearch有三个配置文件：</p>
<p>​	*  <code>elasticsearch.yml</code> 用于配置Elasticsearch</p>
<p>​	* <code>jvm.options</code> 用于配置Elasticsearch JVM设置</p>
<p>​	* <code>log4j2.properties</code> 用于配置Elasticsearch日志记录</p>
<p>这些文件位于config目录中，其默认位置取决于安装是来自存档分发（<code>tar.gz</code>或<code>zip</code>）还是包分发（Debian或RPM软件包）。</p>
<p>对于包分发，config目录位置默认为 <code>/etc/elasticsearch</code>。config目录的位置也可以通过<code>ES_PATH_CONF</code>环境变量进行更改，但请注意，在shell中设置它是不够的。相反，此变量来自 <code>/etc/default/elasticsearch</code>（对于Debian软件包）和<code>/etc/sysconfig/elasticsearch</code>（对于RPM软件包）。您需要相应地编辑<code>ES_PATH_CONF=/etc/elasticsearch</code>其中一个文件中的 条目以更改配置目录位置。</p>
<ul>
<li>配置文件格式</li>
</ul>
<p>配置格式为<a href="http://www.yaml.org/" target="_blank" rel="noopener noreferrer">YAML</a>。以下是更改数据路径和日志目录的示例：</p>
<div><pre><code>path:
    data: /var/lib/elasticsearch
    logs: /var/log/elasticsearch
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>设置也可以按如下方式展平：</p>
<div><pre><code>path.data: /var/lib/elasticsearch
path.logs: /var/log/elasticsearch
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>环境变量替换</li>
</ul>
<p>使用<code>${...}</code>配置文件中的符号引用的环境变量将替换为环境变量的值，例如：</p>
<div><pre><code>node.name:    ${HOSTNAME}
network.host: ${ES_NETWORK_HOST}
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="path-data和path-logs"> <code>path.data</code>和<code>path.logs</code></h4>
<p>如果您使用<code>.zip</code>或<code>.tar.gz</code>存档，则<code>data</code>和<code>logs</code> 目录是子文件夹<code>$ES_HOME</code>。如果这些重要文件夹保留在其默认位置，则在将Elasticsearch升级到新版本时，存在删除它们的高风险。</p>
<p>在生产使用中，您几乎肯定会想要更改数据和日志文件夹的位置：</p>
<div><pre><code>path:
  logs: /var/log/elasticsearch
  data: /var/data/elasticsearch
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>该RPM和Debian发行版已经使用自定义路径，<code>data</code>和<code>logs</code>。</p>
<p>该<code>path.data</code>设置可以被设置为多条路径，在这种情况下，所有的路径将被用于存储数据（虽然属于单个碎片文件将全部存储相同的数据路径上）：</p>
<div><pre><code>path:
  data:
    - /mnt/elasticsearch_1
    - /mnt/elasticsearch_2
    - /mnt/elasticsearch_3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="cluster-name"> <code>cluster.name</code></h4>
<p>节点只能<code>cluster.name</code>在与群集中的所有其他节点共享群集时才能加入群集。默认名称是<code>elasticsearch</code>，但您应将其更改为适当的名称，该名称描述了群集的用途。</p>
<div><pre><code>cluster.name: logging-prod
</code></pre>
<div><span>1</span><br></div></div><p>确保不要在不同的环境中重用相同的群集名称，否则最终会导致节点加入错误的群集。</p>
<h4 id="node-name"> <code>node.name</code></h4>
<p>Elasticsearch使用Elasticsearch <code>node.name</code>的特定实例作为人类可读标识符，因此它包含在许多API的响应中。它默认为Elasticsearch启动时机器具有的主机名，但可以<code>elasticsearch.yml</code>按如下方式显式配置 ：</p>
<div><pre><code>node.name: es01.csp
</code></pre>
<div><span>1</span><br></div></div><h4 id="network-host"> <code>network.host</code></h4>
<p>默认情况下，Elasticsearch仅绑定到环回地址 - 例如<code>127.0.0.1</code> 和<code>[::1]</code>。这足以在服务器上运行单个开发节点。</p>
<blockquote>
<p>实际上，可以从<code>$ES_HOME</code> 单个节点上的相同位置启动多个节点。这对于测试Elasticsearch形成集群的能力非常有用，但它不是推荐用于生产的配置。</p>
</blockquote>
<p>为了在其他服务器上形成包含节点的集群，您的节点将需要绑定到非环回地址。虽然有许多 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/modules-network.html" target="_blank" rel="noopener noreferrer">网络设置</a>，但通常您需要配置的是 <code>network.host</code>：</p>
<div><pre><code>network.host: 192.168.1.10
</code></pre>
<div><span>1</span><br></div></div><p>该<code>network.host</code>设置也了解一些特殊的值，比如 <code>_local_</code>，<code>_site_</code>，<code>_global_</code>。</p>
<h4 id="发现和集群形成设置"> 发现和集群形成设置</h4>
<p>在开始生产之前，应该配置两个重要的发现和集群形成设置，以便群集中的节点可以相互发现并选择主节点。</p>
<h5 id="discovery-seed-hosts"> <code>discovery.seed_hosts</code></h5>
<p>开箱即用，没有任何网络配置，Elasticsearch将绑定到可用的环回地址，并将扫描本地端口9300到9305以尝试连接到在同一服务器上运行的其他节点。这提供了自动集群体验，无需进行任何配置。</p>
<p>如果要在其他主机上形成包含节点的群集，则必须使用该 <code>discovery.seed_hosts</code>设置提供群集中其他节点的列表，这些节点符合主要条件且可能是实时且可联系的，以便为<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/modules-discovery-hosts-providers.html" target="_blank" rel="noopener noreferrer">发现过程设定</a>种子。此设置通常应包含群集中所有符合主节点的节点的地址。此设置包含主机数组或逗号分隔的字符串。每个值应采用<code>host:port</code>或的形式<code>host</code>（如果未设置，则<code>port</code> 默认为设置<code>transport.profiles.default.port</code>回落<code>transport.port</code>）。请注意，必须将IPv6主机置于括号内。此设置的默认值为<code>127.0.0.1, [::1]</code>。</p>
<h5 id="cluster-initial-master-nodes"> <code>cluster.initial_master_nodes</code></h5>
<p>当您第一次启动全新的Elasticsearch集群时，会出现一个<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/modules-discovery-bootstrap-cluster.html" target="_blank" rel="noopener noreferrer">集群引导</a>步骤，该步骤确定在第一次选举中计票的主要合格节点集。在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/bootstrap-checks.html#dev-vs-prod-mode" target="_blank" rel="noopener noreferrer">开发模式下</a>，如果未配置发现设置，则此步骤由节点本身自动执行。由于此自动引导<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/modules-discovery-quorums.html" target="_blank" rel="noopener noreferrer">本质上</a>是<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/modules-discovery-quorums.html" target="_blank" rel="noopener noreferrer">不安全的</a>，因此当您在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/bootstrap-checks.html#dev-vs-prod-mode" target="_blank" rel="noopener noreferrer">生产模式下</a>启动全新集群时，必须明确列出符合主要条件的节点，这些节点的投票应在第一次选举中计算。使用该<code>cluster.initial_master_nodes</code>设置设置此列表 。</p>
<div><pre><code>discovery.seed_hosts:
   - 192.168.1.10:9300
   - 192.168.1.11 ###1
   - seeds.mydomain.com  ###2
cluster.initial_master_nodes: ###3
   - master-node-a
   - master-node-b
   - master-node-c
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>###1 如果未指定，端口将默认为<code>transport.profiles.default.port</code>和回退<code>transport.port</code>。</p>
<p>###2 如果主机名解析为多个IP地址，则该节点将尝试发现所有已解析地址的其他节点。</p>
<p>###3 初始主节点应由其标识 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/node.name.html" target="_blank" rel="noopener noreferrer"><code>node.name</code></a>，默认为其主机名。确保值<code>cluster.initial_master_nodes</code>与<code>node.name</code> 确切匹配。如果使用完全限定的域名（例如 <code>master-node-a.example.com</code>节点名称），则必须在此列表中使用完全限定名称; 相反，如果<code>node.name</code>是一个没有任何尾随限定符的裸主机名，那么你还必须省略尾随限定符<code>cluster.initial_master_nodes</code>。</p>
<p>有关更多信息，请参阅<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/modules-discovery-bootstrap-cluster.html" target="_blank" rel="noopener noreferrer">引导群集</a>以及 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/modules-discovery-settings.html" target="_blank" rel="noopener noreferrer">发现和群集形成设置</a>。</p>
<blockquote>
<p>如果在未配置这些设置的情况下启动Elasticsearch节点，则它将以开发模式启动并自动引导至新集群。如果您在不同的主机上启动某些Elasticsearch节点，则默认情况下它们不会相互发现，并且会在每个主机上形成不同的群集。即使您随后尝试将所有节点配置到单个群集中，Elasticsearch也不会在它们形成后将单独的群集合并在一起。这是因为没有办法将这些单独的集群合并在一起而没有数据丢失的风险。您可以通过检查<code>GET /</code>每个节点上报告的群集UUID来判断您是否已形成单独的群集。如果您打算组建一个群集，那么您应该重新开始：</p>
<ul>
<li>如果您不想丢失任何数据，请拍摄每个单主机群集的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/modules-snapshots.html" target="_blank" rel="noopener noreferrer">快照</a>。请注意，每个群集必须使用自己的快照存储库。</li>
<li>关闭所有节点。</li>
<li>通过删除其<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/modules-node.html#data-path" target="_blank" rel="noopener noreferrer">数据文件夹</a>的内容完全擦除每个节点 。</li>
<li><code>cluster.initial_master_nodes</code>如上所述配置。</li>
<li>重新启动所有节点并验证它们是否已形成单个群集。</li>
<li>根据需要<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/modules-snapshots.html" target="_blank" rel="noopener noreferrer">还原</a>所有快照。</li>
</ul>
</blockquote>
<h4 id="设置堆大小"> 设置堆大小</h4>
<p>默认情况下，Elasticsearch告诉JVM使用最小和最大大小为1 GB的堆。迁移到生产环境时，配置堆大小以确保Elasticsearch有足够的可用堆是很重要的。</p>
<p>Elasticsearch将通过（最小堆大小）和（最大堆大小）设置分配<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/jvm-options.html" target="_blank" rel="noopener noreferrer">jvm.options中</a>指定的整个堆 。您应该将这两个设置设置为彼此相等。<code>Xms</code> <code>Xmx</code></p>
<ul>
<li>设置<code>Xmx</code>并且<code>Xms</code>不超过物理RAM的50％。Elasticsearch需要内存用于JVM堆以外的其他目的，为此留出空间很重要。例如，Elasticsearch使用堆外缓冲区进行有效的网络通信，依赖操作系统的文件系统缓存来有效访问文件，而JVM本身也需要一些内存。使用比使用该<code>Xmx</code>设置配置的限制更多的内存来观察Elasticsearch进程是正常的。</li>
<li>设置<code>Xmx</code>并且<code>Xms</code>不超过JVM用于压缩对象指针的阈值（压缩oops）; 确切的阈值变化但接近32 GB。您可以通过在日志中查找如下所示的行来验证您是否低于阈值：</li>
</ul>
<div><pre><code>heap size [1.9gb], compressed ordinary object pointers [true]
</code></pre>
<div><span>1</span><br></div></div><p>以下是如何通过jvm.options文件设置堆大小的示例：</p>
<div><pre><code>-Xms4g ###1
-Xmx4g ###2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>###1 将最小堆大小设置为4g。</p>
<p>###2 将最大堆大小设置为4g。</p>
<p>也可以通过环境变量设置堆大小。这可以通过注释掉来完成<code>Xms</code>，并<code>Xmx</code>设置在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/jvm-options.html" target="_blank" rel="noopener noreferrer"><code>jvm.options</code></a>文件中，并通过设置这些值<code>ES_JAVA_OPTS</code>：</p>
<div><pre><code>ES_JAVA_OPTS=&quot;-Xms2g -Xmx2g&quot; ./bin/elasticsearch ###1
ES_JAVA_OPTS=&quot;-Xms4000m -Xmx4000m&quot; ./bin/elasticsearch ###2 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>###1 将最小和最大堆大小设置为2 GB。</p>
<p>###2 将最小和最大堆大小设置为4000 MB。</p>
<h4 id="jvm堆存储路径"> JVM堆存储路径</h4>
<p>默认情况下，Elasticsearch将JVM配置为将内存异常转储到默认数据目录（这<code>/var/lib/elasticsearch</code>适用于<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/rpm.html" target="_blank" rel="noopener noreferrer">RPM</a>和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/deb.html" target="_blank" rel="noopener noreferrer">Debian</a>软件包发行版，以及<code>data</code>用于<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/targz.html" target="_blank" rel="noopener noreferrer">tar</a>和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/zip-windows.html" target="_blank" rel="noopener noreferrer">zip</a>归档文件分发的Elasticsearch安装根目录下的目录） 。</p>
<p>如果这个路径是不适合接受堆转储，您应该修改的条目<code>-XX:HeapDumpPath=...</code>在 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/jvm-options.html" target="_blank" rel="noopener noreferrer"><code>jvm.options</code></a>。</p>
<p>如果指定目录，JVM将根据正在运行的实例的PID为堆转储生成文件名。</p>
<p>如果指定固定文件名而不是目录，则当JVM需要在内存不足异常上执行堆转储时，该文件不能存在，否则堆转储将失败。</p>
<h4 id="gc日志"> GC日志</h4>
<p>默认情况下，Elasticsearch启用GC日志。</p>
<p>这些配置在 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/jvm-options.html" target="_blank" rel="noopener noreferrer"><code>jvm.options</code></a>默认位置和默认位置与Elasticsearch日志相同。</p>
<p>默认配置每64 MB轮换一次日志，最多可占用2 GB的磁盘空间。</p>
<h4 id="临时目录"> 临时目录</h4>
<p>默认情况下，Elasticsearch使用启动脚本在系统临时目录下创建的专用临时目录。</p>
<p>在某些Linux发行版上，系统实用程序将清除文件和目录（<code>/tmp</code>如果它们最近未被访问过）。如果长时间不使用需要临时目录的功能，则可能导致在Elasticsearch运行时删除专用临时目录。如果随后使用需要临时目录的功能，则会导致问题。</p>
<p>如果使用<code>.deb</code>或<code>.rpm</code>包安装Elasticsearch 并在其下运行，<code>systemd</code>那么Elasticsearch使用的专用临时目录将从定期清理中排除。</p>
<p>但是，如果您打算<code>.tar.gz</code>在Linux 上运行分发一段时间，那么您应该考虑为Elasticsearch创建一个专用的临时目录，该目录不在将从中清除旧文件和目录的路径下。此目录应具有权限集，以便只有运行Elasticsearch的用户才能访问它。然后<code>$ES_TMPDIR</code>在启动Elasticsearch之前将环境变量设置 为指向它。</p>
<h4 id="jvm致命错误日志"> JVM致命错误日志</h4>
<p>默认情况下，Elasticsearch将JVM配置为将致命错误日志写入默认日志记录目录（这<code>/var/log/elasticsearch</code>适用于<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/rpm.html" target="_blank" rel="noopener noreferrer">RPM</a>和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/deb.html" target="_blank" rel="noopener noreferrer">Debian</a>软件包发行版，以及<code>logs</code> 针对<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/targz.html" target="_blank" rel="noopener noreferrer">tar</a>和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/zip-windows.html" target="_blank" rel="noopener noreferrer">zip</a>归档文件分发的Elasticsearch安装根目录下的目录 ）。</p>
<p>这些是JVM在遇到致命错误（例如，分段错误）时生成的日志。如果该路径不适合于接收的日志，则应修改条目<code>-XX:ErrorFile=...</code>中 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/jvm-options.html" target="_blank" rel="noopener noreferrer"><code>jvm.options</code></a>到备用路径。</p>
<h3 id="系统配置调优"> 系统配置调优</h3>
<h4 id="配置系统设置"> 配置系统设置</h4>
<p>配置系统设置的位置取决于您用于安装Elasticsearch的软件包以及您使用的操作系统。</p>
<p>使用<code>.zip</code>或<code>.tar.gz</code>包时，可以配置系统设置：</p>
<ul>
<li>暂时用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#ulimit" target="_blank" rel="noopener noreferrer"><code>ulimit</code></a>，或</li>
<li>永久地<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#limits.conf" target="_blank" rel="noopener noreferrer"><code>/etc/security/limits.conf</code></a>。</li>
</ul>
<p>使用RPM或Debian软件包时，大多数系统设置都在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#sysconfig" target="_blank" rel="noopener noreferrer">系统配置文件</a>中设置 。但是，使用systemd的系统要求在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#systemd" target="_blank" rel="noopener noreferrer">systemd配置文件</a>中指定系统限制 。</p>
<h5 id="ulimit"> <code>ulimit</code></h5>
<p>在Linux系统上，<code>ulimit</code>可以用于临时更改资源限制。通常需要<code>root</code>在切换到将运行Elasticsearch的用户之前设置限制。例如，要将打开文件句柄（<code>ulimit -n</code>）的数量设置为65,536，您可以执行以下操作：</p>
<div><pre><code>ulimit -n 65535 
</code></pre>
<div><span>1</span><br></div></div><p>新限制仅在当前会话期间应用。</p>
<p>您可以查询所有当前应用的限制<code>ulimit -a</code>。</p>
<h5 id="etc-security-limits-conf"> <code>/etc/security/limits.conf</code></h5>
<p>在Linux系统上，可以通过编辑<code>/etc/security/limits.conf</code>文件为特定用户设置持久限制。要将用户的最大打开文件数设置<code>elasticsearch</code>为65,536，请将以下行添加到<code>limits.conf</code>文件中：</p>
<div><pre><code>elasticsearch  -  nofile 65535
</code></pre>
<div><span>1</span><br></div></div><p>此更改仅在<code>elasticsearch</code>用户下次打开新会话时生效。</p>
<blockquote>
<p>通常在开机以优化<code>/etc/security/limits.conf</code>配置文件</p>
<p>在最后加入下面内容</p>
<div><pre><code>* hard nofile 65535
* soft nofile 65535
* soft nproc 65535
* hard nproc 65535
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果已经设置上述参数，则无需调整</p>
<ul>
<li>hard 硬限制</li>
<li>soft 软限制</li>
<li>nofile 最大打开文件数（文件描述符）</li>
<li>nproc 最大线程数</li>
</ul>
</blockquote>
<h5 id="sysconfig文件"> Sysconfig文件</h5>
<p>使用RPM或Debian软件包时，可以在系统配置文件中指定系统设置和环境变量，该文件位于：</p>
<table>
<thead>
<tr>
<th>RPM</th>
<th><code>/etc/sysconfig/elasticsearch</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian的</td>
<td><code>/etc/default/elasticsearch</code></td>
</tr>
</tbody>
</table>
<p>但是，对于使用的<code>systemd</code>系统，需要通过<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#systemd" target="_blank" rel="noopener noreferrer">systemd</a>指定系统限制。</p>
<h5 id="系统配置"> 系统配置</h5>
<p>在使用<a href="https://en.wikipedia.org/wiki/Systemd" target="_blank" rel="noopener noreferrer">systemd的</a>系统上使用RPM或Debian软件包时 ，必须通过systemd指定系统限制。</p>
<p>systemd服务文件（<code>/usr/lib/systemd/system/elasticsearch.service</code>）包含默认应用的限制。</p>
<p>要覆盖它们，请添加一个名为的文件<code>/etc/systemd/system/elasticsearch.service.d/override.conf</code>（或者，您可以运行<code>systemctl edit elasticsearch</code>它在默认编辑器中自动打开文件）。设置此文件中的任何更改，例如</p>
<div><pre><code>[Service]
LimitMEMLOCK=infinity
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>完成后，运行以下命令重新加载：</p>
<div><pre><code>systemctl daemon-reload
</code></pre>
<div><span>1</span><br></div></div><h4 id="禁用交换"> 禁用交换</h4>
<p>大多数操作系统尝试使用尽可能多的内存来存储文件系统缓存，并急切地交换掉未使用的应用程序内存。这可能导致部分JVM堆甚至其可执行页面被换出到磁盘。</p>
<p>交换对性能，节点稳定性非常不利，应该不惜一切代价避免。它可能导致垃圾收集持续<strong>数分钟</strong>而不是毫秒，并且可能导致节点响应缓慢甚至断开与群集的连接。在弹性分布式系统中，让操作系统终止节点更有效。</p>
<p>有三种禁用交换的方法。首选选项是完全禁用交换。如果这不是一个选项，是否更喜欢最小化swappiness与内存锁定取决于您的环境。</p>
<h5 id="禁用所有交换文件"> 禁用所有交换文件</h5>
<p>通常Elasticsearch是在盒子上运行的唯一服务，其内存使用量由JVM选项控制。应该没有必要启用交换。</p>
<p>在Linux系统上，您可以通过运行以下命令暂时禁用交换：</p>
<div><pre><code>swapoff -a
</code></pre>
<div><span>1</span><br></div></div><p>这不需要重新启动Elasticsearch。</p>
<p>要永久禁用它，您需要编辑<code>/etc/fstab</code>文件并注释掉包含该单词的任何行<code>swap</code>。</p>
<h5 id="配置swappiness"> 配置<code>swappiness</code></h5>
<p>Linux系统上可用的另一个选项是确保将sysctl值 <code>vm.swappiness</code>设置为<code>1</code>。这降低了内核交换的倾向，在正常情况下不应导致交换，同时仍允许整个系统在紧急情况下交换。</p>
<h5 id="启用bootstrap-memory-lock"> 启用<code>bootstrap.memory_lock</code></h5>
<p>另一种选择是在Linux / Unix系统上使用<a href="http://opengroup.org/onlinepubs/007908799/xsh/mlockall.html" target="_blank" rel="noopener noreferrer">mlockall</a>，或 在Windows 上 使用 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366895%28v=vs.85%29.aspx" target="_blank" rel="noopener noreferrer">VirtualLock</a>，以尝试将进程地址空间锁定到RAM中，从而防止任何Elasticsearch内存被换出。这可以通过将此行添加到<code>config/elasticsearch.yml</code>文件来完成：</p>
<div><pre><code>bootstrap.memory_lock: true
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p><code>mlockall</code> 如果尝试分配的内存超过可用内存，可能会导致JVM或shell会话退出！</p>
</blockquote>
<p>启动Elasticsearch后，您可以通过检查<code>mlockall</code>此请求的输出中的值来查看是否已成功应用此设置：</p>
<div><pre><code>GET _nodes?filter_path=**.mlockall
</code></pre>
<div><span>1</span><br></div></div><p>如果你看到<code>mlockall</code>的<code>false</code>，那么就意味着该<code>mlockall</code> 请求失败。您还会在日志中看到包含更多信息的行<code>Unable to lock JVM Memory</code>。</p>
<p>在Linux / Unix系统上，最可能的原因是运行Elasticsearch的用户没有锁定内存的权限。这可以授予如下：</p>
<ul>
<li>
<p><strong><code>.zip</code> 和 <code>.tar.gz</code></strong></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#ulimit" target="_blank" rel="noopener noreferrer"><code>ulimit -l unlimited</code></a>在启动Elasticsearch之前设置为root，或设置<code>memlock</code>为<code>unlimited</code>in <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#limits.conf" target="_blank" rel="noopener noreferrer"><code>/etc/security/limits.conf</code></a>。</p>
</li>
<li>
<p><strong>RPM和Debian</strong></p>
<p>设置<code>MAX_LOCKED_MEMORY</code>到<code>unlimited</code>了在 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#sysconfig" target="_blank" rel="noopener noreferrer">系统配置文件</a>（或见下文使用系统<code>systemd</code>）。</p>
</li>
<li>
<p><strong>系统使用 <code>systemd</code></strong></p>
<p>设置<code>LimitMEMLOCK</code>于<code>infinity</code>在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#systemd" target="_blank" rel="noopener noreferrer">systemd配置</a>。</p>
</li>
</ul>
<p>可能<code>mlockall</code>失败的另一个可能原因是 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/executable-jna-tmpdir.html" target="_blank" rel="noopener noreferrer">JNA临时目录（通常是子目录 <code>/tmp</code>）随<code>noexec</code>选项一起安装</a>。这可以通过使用<code>ES_JAVA_OPTS</code>环境变量为JNA指定新的临时目录来解决：</p>
<div><pre><code><span>export</span> ES_JAVA_OPTS <span>=</span>“$ ES_JAVA_OPTS -Djna.tmpdir <span>=</span> <span>&lt;</span>path<span>></span>”
./bin/elasticsearch
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>或者在jvm.options配置文件中设置此JVM标志。</p>
<h4 id="文件描述符"> 文件描述符</h4>
<p>Elasticsearch使用大量文件描述符或文件句柄。用完文件描述符可能是灾难性的，最有可能导致数据丢失。确保将运行Elasticsearch的用户的打开文件描述符数量限制增加到65,536或更高。</p>
<p>对于<code>.zip</code>and <code>.tar.gz</code>packages，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#ulimit" target="_blank" rel="noopener noreferrer"><code>ulimit -n 65535</code></a>在启动Elasticsearch之前设置为root，或设置<code>nofile</code>为<code>65535</code>in <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#limits.conf" target="_blank" rel="noopener noreferrer"><code>/etc/security/limits.conf</code></a>。</p>
<p>RPM和Debian软件包已将文件描述符的最大数量默认为65535，无需进一步配置。</p>
<p>您可以<code>max_file_descriptors</code>使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/cluster-nodes-stats.html" target="_blank" rel="noopener noreferrer"><em>Nodes Stats</em></a> API 检查每个节点的配置，包括：</p>
<div><pre><code>GET _nodes/stats/process?filter_path=**.max_file_descriptors
</code></pre>
<div><span>1</span><br></div></div><h4 id="虚拟内存"> 虚拟内存</h4>
<p>Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/index-modules-store.html#mmapfs" target="_blank" rel="noopener noreferrer"><code>mmapfs</code></a>默认使用目录来存储其索引。mmap计数的默认操作系统限制可能太低，这可能导致内存不足异常。</p>
<p>在Linux上，您可以通过运行以下命令来增加限制 <code>root</code>：</p>
<div><pre><code>sysctl -w vm.max_map_count <span>=</span> <span>262144</span>
</code></pre>
<div><span>1</span><br></div></div><p>要永久设置此值，请更新<code>vm.max_map_count</code>设置 <code>/etc/sysctl.conf</code>。要在重新启动后进行验证，请运行<code>sysctl vm.max_map_count</code>。</p>
<p>RPM和Debian软件包将自动配置此设置。无需进一步配置。</p>
<h4 id="线程数"> 线程数</h4>
<p>Elasticsearch为不同类型的操作使用许多线程池。重要的是它能够在需要时创建新线程。确保Elasticsearch用户可以创建的线程数至少为4096。</p>
<p>这可以通过<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#ulimit" target="_blank" rel="noopener noreferrer"><code>ulimit -u 4096</code></a>在启动Elasticsearch之前设置为root或通过设置<code>nproc</code>为<code>4096</code>in来完成<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/setting-system-settings.html#limits.conf" target="_blank" rel="noopener noreferrer"><code>/etc/security/limits.conf</code></a>。</p>
<p>作为服务运行时的程序包分发<code>systemd</code>将自动配置Elasticsearch进程的线程数。无需其他配置。</p>
<h3 id="检测集群状态"> 检测集群状态</h3>
<p>让我们从基本运行状况检查开始，我们可以使用它来查看集群的运行情况。我们将使用curl来执行此操作，但您可以使用任何允许您进行HTTP / REST调用的工具。假设我们仍然在我们启动Elasticsearch的同一节点上打开另一个命令shell窗口。</p>
<h4 id="健康状态"> 健康状态</h4>
<p>要检查群集运行状况，我们将使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/cat.html" target="_blank" rel="noopener noreferrer"><code>_cat</code>API</a>。您可以 通过单击“查看控制台”或单击下面的“COPY AS CURL”链接并将其粘贴到终端中，在<a href="https://www.elastic.co/guide/en/kibana/7.2/console-kibana.html" target="_blank" rel="noopener noreferrer">Kibana控制台中</a>运行以下命令<code>curl</code>。</p>
<div><pre><code>GET /_cat/health?v
</code></pre>
<div><span>1</span><br></div></div><p>并回应：</p>
<div><pre><code>epoch      timestamp cluster      status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent
1564125184 07:13:04  logging-prod green           3         3      0   0    0    0        0             0                  -                100.0%
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>我们可以看到名为“elasticsearch”的群集处于绿色状态。</p>
<p>每当我们要求群集健康时，我们要么获得绿色，黄色或红色。</p>
<ul>
<li>绿色 - 一切都很好（集群功能齐全）</li>
<li>黄色 - 所有数据都可用，但尚未分配一些副本（群集功能齐全）</li>
<li>红色 - 某些数据由于某种原因不可用（群集部分功能）</li>
</ul>
<p>**注意：**当群集为红色时，它将继续提供来自可用分片的搜索请求，但您可能需要尽快修复它，因为存在未分配的分片。</p>
<p>同样从上面的响应中，我们可以看到总共3个节点，并且我们有0个分片，因为我们还没有数据。请注意，由于我们使用默认群集名称（elasticsearch），并且由于Elasticsearch默认使用单播网络发现来查找同一台计算机上的其他节点，因此您可能会意外启动计算机上的多个节点并拥有它们所有人都加入一个集群。在这种情况下，您可能会在上面的响应中看到多个节点。</p>
<h4 id="节点列表"> 节点列表</h4>
<p>我们还可以获得群集中的节点列表，如下所示：</p>
<div><pre><code>GET /_cat/nodes?v
</code></pre>
<div><span>1</span><br></div></div><p>并回应：</p>
<div><pre><code>ip             heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name
192.168.165.59           10          79   0    0.00    0.03     0.06 mdi       -      es01.csp
192.168.165.60           10          76   0    0.00    0.01     0.05 mdi       -      es02.csp
192.168.165.61           10          76   0    0.00    0.02     0.05 mdi       *      es03.csp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在这里，我们可以看到一个名为“es03.csp”的节点，它是我们集群中当前的主节点。</p>
<h4 id="列出所有指数"> 列出所有指数</h4>
<p>现在让我们来看看我们的指数：</p>
<div><pre><code>GET /_cat/indices?v
</code></pre>
<div><span>1</span><br></div></div><p>并回应：</p>
<div><pre><code>health status index uuid pri rep docs.count docs.deleted store.size pri.store.size
</code></pre>
<div><span>1</span><br></div></div><p>这仅仅意味着我们在集群中还没有索引。</p>
<h3 id="插件安装"> 插件安装</h3>
<h4 id="中文分词"> 中文分词</h4>
<h5 id="install"> Install</h5>
<p>elasticsearch在分词方面，需要添加中文分词的插件。在其安装代码的plugins目录，即<code>/usr/share/elasticsearch/plugins</code>，需要增加中文分词插件。</p>
<p>download pre-build package from here: <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener noreferrer">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p>
<p>create plugin folder <code>cd your-es-root/plugins/ &amp;&amp; mkdir ik</code></p>
<p>unzip plugin to folder <code>your-es-root/plugins/ik</code></p>
<h5 id="quick-example"> Quick Example</h5>
<p>1.create a index</p>
<div><pre><code>curl -XPUT http://localhost:9200/index
</code></pre>
<div><span>1</span><br></div></div><p>2.create a mapping</p>
<div><pre><code>curl -XPOST http://localhost:9200/index/_mapping -H &#39;Content-Type:application/json&#39; -d&#39;
{
        &quot;properties&quot;: {
            &quot;content&quot;: {
                &quot;type&quot;: &quot;text&quot;,
                &quot;analyzer&quot;: &quot;ik_max_word&quot;,
                &quot;search_analyzer&quot;: &quot;ik_smart&quot;
            }
        }

}&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>3.index some docs</p>
<div><pre><code>curl -XPOST http://localhost:9200/index/_create/1 -H &#39;Content-Type:application/json&#39; -d&#39;
{&quot;content&quot;:&quot;美国留给伊拉克的是个烂摊子吗&quot;}
&#39;
curl -XPOST http://localhost:9200/index/_create/2 -H &#39;Content-Type:application/json&#39; -d&#39;
{&quot;content&quot;:&quot;公安部：各地校车将享最高路权&quot;}
&#39;
curl -XPOST http://localhost:9200/index/_create/3 -H &#39;Content-Type:application/json&#39; -d&#39;
{&quot;content&quot;:&quot;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&quot;}
&#39;
curl -XPOST http://localhost:9200/index/_create/4 -H &#39;Content-Type:application/json&#39; -d&#39;
{&quot;content&quot;:&quot;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首&quot;}
&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>4.query with highlighting</p>
<div><pre><code>curl -XPOST http://localhost:9200/index/_search  -H &#39;Content-Type:application/json&#39; -d&#39;
{
    &quot;query&quot; : { &quot;match&quot; : { &quot;content&quot; : &quot;中国&quot; }},
    &quot;highlight&quot; : {
        &quot;pre_tags&quot; : [&quot;&lt;tag1&gt;&quot;, &quot;&lt;tag2&gt;&quot;],
        &quot;post_tags&quot; : [&quot;&lt;/tag1&gt;&quot;, &quot;&lt;/tag2&gt;&quot;],
        &quot;fields&quot; : {
            &quot;content&quot; : {}
        }
    }
}
&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>Result</p>
<div><pre><code>{
    &quot;took&quot;: 14,
    &quot;timed_out&quot;: false,
    &quot;_shards&quot;: {
        &quot;total&quot;: 5,
        &quot;successful&quot;: 5,
        &quot;failed&quot;: 0
    },
    &quot;hits&quot;: {
        &quot;total&quot;: 2,
        &quot;max_score&quot;: 2,
        &quot;hits&quot;: [
            {
                &quot;_index&quot;: &quot;index&quot;,
                &quot;_type&quot;: &quot;fulltext&quot;,
                &quot;_id&quot;: &quot;4&quot;,
                &quot;_score&quot;: 2,
                &quot;_source&quot;: {
                    &quot;content&quot;: &quot;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首&quot;
                },
                &quot;highlight&quot;: {
                    &quot;content&quot;: [
                        &quot;&lt;tag1&gt;中国&lt;/tag1&gt;驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首 &quot;
                    ]
                }
            },
            {
                &quot;_index&quot;: &quot;index&quot;,
                &quot;_type&quot;: &quot;fulltext&quot;,
                &quot;_id&quot;: &quot;3&quot;,
                &quot;_score&quot;: 2,
                &quot;_source&quot;: {
                    &quot;content&quot;: &quot;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&quot;
                },
                &quot;highlight&quot;: {
                    &quot;content&quot;: [
                        &quot;均每天扣1艘&lt;tag1&gt;中国&lt;/tag1&gt;渔船 &quot;
                    ]
                }
            }
        ]
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h4 id="elasticsearch-head"> elasticsearch-head</h4>
<h5 id="running-with-docker"> Running with docker</h5>
<div><pre><code>docker run -d -p 9100:9100 mobz/elasticsearch-head:5
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>由于elasticsearch-head:5镜像对elasticsearch的7版本好像适配性不够，所以部分显示可能会有空白</p>
</blockquote>
<h5 id="connecting-to-elasticsearch"> Connecting to elasticsearch</h5>
<p>By default elasticsearch exposes a http rest API on port 9200 which elasticsearch-head connects to.</p>
<h6 id="enable-cors-in-elasticsearch"> Enable CORS in elasticsearch</h6>
<p>When not running as a plugin of elasticsearch (which is not even possible from version 5) you must enable <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/modules-http.html" target="_blank" rel="noopener noreferrer">CORS</a> in elasticsearch otherwise your browser will rejects requests which appear insecure.</p>
<p>In elasticsearch configuration;</p>
<ul>
<li>add <code>http.cors.enabled: true</code></li>
<li>you must also set <code>http.cors.allow-origin</code> because no origin allowed by default. <code>http.cors.allow-origin: &quot;*&quot;</code> is valid value, however it’s considered as a security risk as your cluster is open to cross origin from <strong>anywhere</strong>.</li>
</ul>
<p>改完配置后，重启Elasticsearch服务</p>
<p><img src="./images/1.png" alt="" /></p>
<h4 id="cerebro"> cerebro</h4>
<h6 id="runnging-with-docker"> Runnging with docker</h6>
<div><pre><code>docker run -d -p 9000:9000  lmenezes/cerebro
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/2.png" alt="" /></p>
<p>参考链接：</p>
<blockquote>
<p>官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/getting-started.html" target="_blank" rel="noopener noreferrer">https://www.elastic.co/guide/en/elasticsearch/reference/7.2/getting-started.html</a></p>
<p>中文分词器elasticsearch-analysis-ik: <a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener noreferrer">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
<p>elasticsearch-head：<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener noreferrer">https://github.com/mobz/elasticsearch-head</a></p>
<p>cerebro: <a href="https://github.com/lmenezes/cerebro" target="_blank" rel="noopener noreferrer">https://github.com/lmenezes/cerebro</a></p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">filebeat的安装注意</title>
    <id>https://clay-wangzhi.com/monitor/elk/bak/filebeat%E7%9A%84%E5%AE%89%E8%A3%85%E6%B3%A8%E6%84%8F/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/bak/filebeat%E7%9A%84%E5%AE%89%E8%A3%85%E6%B3%A8%E6%84%8F/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="filebeat的安装注意"> filebeat的安装注意</h2>
<div><pre><code># filebeat输出到kafka中时，需要指定topic
output.kafka:
  hosts: [&quot;192.168.165.44:9092&quot;,&quot;192.168.165.45:9092&quot;,&quot;192.168.165.48:9092&quot;]
  topic: &#39;credit&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>1.注意yaml文件的格式需要对齐</p>
<p>2.注意注释掉默认的#output.elasticsearch:</p>
</blockquote>
<p>filebeat.yml配置文件</p>
<p>改动地方</p>
<div><pre><code>filebeat.inputs:

# Each - is an input. Most options can be set at the input level, so
# you can use different inputs for various configurations.
# Below are the input specific configurations.

- type: log

  # Change to true to enable this input configuration.
  enabled: true

  # Paths that should be crawled and fetched. Glob based paths.
  paths:
    - /var/log/aa.txt

# setup.kibana:
#output.elasticsearch:
  # Array of hosts to connect to.
  # hosts: [&quot;localhost:9200&quot;]

  # Optional protocol and basic auth credentials.
  #protocol: &quot;https&quot;
  #username: &quot;elastic&quot;

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>enabled 改为true</p>
<p>setup.kibana注释掉</p>
<p>output.elasticsearch:下面所有东西注释掉</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">kafka2.12集群搭建步骤</title>
    <id>https://clay-wangzhi.com/monitor/elk/bak/kafka2.12%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/bak/kafka2.12%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="kafka2-12集群搭建步骤"> kafka2.12集群搭建步骤</h2>
<h3 id="下载解压"> 下载解压</h3>
<p>从官网下载最新的tgz包</p>
<p>下载地址为：</p>
<p>http://mirror.bit.edu.cn/apache/kafka/2.3.0/kafka_2.12-2.3.0.tgz</p>
<p>下载完成后上传到服务器</p>
<div><pre><code>cd /opt/
scp 192.168.165.46:/opt/kafka_2.12-2.3.0.tgz  .
mv kafka_2.12-2.3.0.tgz /usr/local/
cd /usr/local/
tar -xvf kafka_2.12-2.3.0.tgz 
mv kafka_2.12-2.3.0 kafka
rm -f *.tgz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="修改配置文件"> 修改配置文件</h3>
<div><pre><code># egrep -v &quot;^$|^#&quot; /usr/local/kafka/config/server.properties 
broker.id=45
listeners=PLAINTEXT://192.168.165.45:9092
num.network.threads=3
num.io.threads=8
socket.send.buffer.bytes=102400
socket.receive.buffer.bytes=102400
socket.request.max.bytes=104857600
log.dirs=/opt/kafka-logs
num.partitions=3
num.recovery.threads.per.data.dir=1
offsets.topic.replication.factor=3
transaction.state.log.replication.factor=3
transaction.state.log.min.isr=3
log.retention.hours=168
log.segment.bytes=1073741824
log.retention.check.interval.ms=300000
zookeeper.connect=192.168.165.44:2181,192.168.165.45:2181,192.168.165.46:2181
zookeeper.connection.timeout.ms=6000
group.initial.rebalance.delay.ms=0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><blockquote>
<p>服务器标识不能相同 broker.id</p>
<p>不同服务器的ip不同 listeners=PLAINTEXT://192.168.165.45:9092</p>
<p>设置zookeeper的连接地址 zookeeper.connect=192.168.165.44:2181,192.168.165.45:2181,192.168.165.46:2181</p>
</blockquote>
<h3 id="启动服务"> 启动服务</h3>
<div><pre><code>/usr/local/kafka/bin/kafka-server-start.sh -daemon /usr/local/kafka/config/server.properties

创建topic（其中一台执行）
bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 3 --topic test


查看 Topic describe
bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test

在其中一台服务器启动consumer
bin/kafka-console-consumer.sh --bootstrap-server 192.168.165.44:9092,192.168.165.45:9092,192.168.165.46:9092 --topic test --from-beginning

在任意议一台服务器启动producer
bin/kafka-console-producer.sh --broker-list 192.168.165.44:9092,192.168.165.45:9092,192.168.165.46:9092 --topic test
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>如果<code>consumer</code>服务器接收到<code>producer</code>服务器输入的内容，则启动集群成功.</p>
<p>参考链接：</p>
<blockquote>
<p><a href="https://blog.csdn.net/Cocktail_py/article/details/89877741" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/Cocktail_py/article/details/89877741</a></p>
<p><a href="https://www.jianshu.com/p/5297773fcc1b" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/5297773fcc1b</a>、、</p>
</blockquote>
<p>JVM，参数得调整一下</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">logstash安装注意</title>
    <id>https://clay-wangzhi.com/monitor/elk/bak/logstash%E5%AE%89%E8%A3%85%E6%B3%A8%E6%84%8F/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/bak/logstash%E5%AE%89%E8%A3%85%E6%B3%A8%E6%84%8F/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="logstash安装注意"> logstash安装注意</h2>
<p>在 /etc/sysconfig/logstash中添加对JAVA_HOME的配置</p>
<div><pre><code># cat /etc/sysconfig/logstash 
JAVA_HOME=/opt/jdk1.8.0_144
# source /etc/sysconfig/logstash 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>文件权限所属组是不是logstash</p>
<div><pre><code>/usr/share/logstash/bin/logstash -e &quot;input {stdin{}} output{stdout{codec=&gt;rubydebug}}&quot;
等价于：
/usr/share/logstash/bin/logstash -e &quot;&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code> ansible logstash -m shell -a <span>"export JAVA_HOME=/opt/jdk1.8.0_144;rpm -ivh /opt/logstash-7.7.1.rpm"</span>
ansible logstash -m shell -a <span>'echo "JAVA_HOME=/opt/jdk1.8.0_144" > /etc/sysconfig/logstash '</span>
 ansible logstash -m shell -a <span>'sed -i "s#1g#4g#g" /etc/logstash/jvm.options'</span>
ansible logstash -m shell -a <span>"systemctl enable logstash;systemctl start logstash"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">数据类型</title>
    <id>https://clay-wangzhi.com/monitor/elk/bak/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/bak/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="数据类型"> 数据类型</h2>
<h3 id="核心数据类型"> 核心数据类型</h3>
<ul>
<li>字符串： text、keyword</li>
<li>数值：long、integer、short、byte、double、float、half_float、scaled_float</li>
<li>日期：date</li>
<li>布尔：boolean</li>
<li>二进制：binary</li>
<li>范围：integer_range、float_range、long_range、double_range、date_range</li>
</ul>
<h3 id="复杂数据类型"> 复杂数据类型</h3>
<ul>
<li>数组：array</li>
<li>对象：object</li>
<li>嵌套：nested object</li>
</ul>
<h3 id="地理位置数据类型"> 地理位置数据类型</h3>
<ul>
<li>geo_point</li>
<li>geo_shape</li>
</ul>
<h3 id="专用类型"> 专用类型</h3>
<ul>
<li>记录ip地址：ip</li>
<li>实现自动补全：completion</li>
<li>记录分词数：token_count</li>
<li>记录字符串hash值：murmur3</li>
<li>percolator</li>
<li>join</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">elk借助安装ansible</title>
    <id>https://clay-wangzhi.com/monitor/elk/install/ansible-elk/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/install/ansible-elk/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="elk借助安装ansible"> elk借助安装ansible</h1>
<h2 id="ansible配置"> ansible配置</h2>
<div><pre><code><span># 修改主机名</span>
hostnamectl set-hostname elk_ans
<span># 生产密钥对，生成后将公钥导入到私有云主机中，创建新主机时使用</span>
ssh-keygen -t rsa -f ~/.ssh/id_rsa -N <span>''</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span># yum 安装</span>
yum -y <span>install</span> ansible
<span># 修改主机列表为yaml格式</span>
<span>mv</span> /etc/ansible/hosts<span>{</span>,.yml<span>}</span>
<span># 优化配置</span>
<span>cp</span> /etc/ansible/ansible.cfg<span>{</span>,.bak<span>}</span>
<span>cat</span> <span>></span> /etc/ansible/ansible.cfg <span>&lt;&lt;</span><span>EOF
[defaults]
inventory      = /etc/ansible/hosts.yml
roles_path    = /etc/ansible/roles
host_key_checking = False
deprecation_warnings = False
retry_files_enabled = False
[inventory]
[privilege_escalation]
[paramiko_connection]
[ssh_connection]
ssh_args = -C -o ControlMaster=auto -o ControlPersist=5d
[persistent_connection]
[accelerate]
[selinux]
[colors]
[diff]
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><div><pre><code><span># 编写ansible主机清单</span>
<span>export</span> <span>es_master1</span><span>=</span><span>192.168</span>.135.125 <span>es_master2</span><span>=</span><span>192.168</span>.135.214 <span>es_master3</span><span>=</span><span>192.168</span>.135.62 <span>es_data1</span><span>=</span><span>192.168</span>.135.160 <span>es_data2</span><span>=</span><span>192.168</span>.135.73 <span>es_data3</span><span>=</span><span>192.168</span>.135.105 <span>es_ingest1</span><span>=</span><span>192.168</span>.135.8 <span>es_ingest2</span><span>=</span><span>192.168</span>.135.187 <span>es_ingest3</span><span>=</span><span>192.168</span>.135.189 <span>kibana1</span><span>=</span><span>192.168</span>.135.178 <span>kibana2</span><span>=</span><span>192.168</span>.135.196 <span>kibana3</span><span>=</span><span>192.168</span>.135.198 <span>logstash1</span><span>=</span><span>192.168</span>.135.89 <span>logstash2</span><span>=</span><span>192.168</span>.135.30 <span>logstash3</span><span>=</span><span>192.168</span>.135.96 <span>kafka1</span><span>=</span><span>192.168</span>.135.32 <span>kafka2</span><span>=</span><span>192.168</span>.135.22 <span>kafka3</span><span>=</span><span>192.168</span>.135.51
<span>cat</span> <span>></span> /etc/ansible/hosts.yml <span>&lt;&lt;</span><span>EOF
all:
  children:
    elasticsearch:
      children:
        es_master:
        es_data:
        es_ingest:
    es_master:
      hosts:
        es_master1:
          ansible_host: <span>${es_master1}</span>
        es_master2:
          ansible_host: <span>${es_master2}</span>
        es_master3:
          ansible_host: <span>${es_master3}</span>
    es_data:
      hosts:
        es_data1:
          ansible_host: <span>${es_data1}</span>
        es_data2:
          ansible_host: <span>${es_data2}</span>
        es_data3:
          ansible_host: <span>${es_data3}</span>
    es_ingest:
      hosts:
        es_ingest1:
          ansible_host: <span>${es_ingest1}</span>
        es_ingest2:
          ansible_host: <span>${es_ingest2}</span>
        es_ingest3:
          ansible_host: <span>${es_ingest3}</span>
    kibana:
      hosts:
        kibana1:
          ansible_host: <span>${kibana1}</span>
        kibana2:
          ansible_host: <span>${kibana2}</span>
        kibana3:
          ansible_host: <span>${kibana3}</span>
    logstash:
      hosts:
        logstash1:
          ansible_host: <span>${logstash1}</span>
        logstash2:
          ansible_host: <span>${logstash2}</span>
        logstash3:
          ansible_host: <span>${logstash3}</span>
    kafka:
      hosts:
        kafka1:
          ansible_host: <span>${kafka1}</span>
          zookeeper_id: 1
        kafka2:
          ansible_host: <span>${kafka2}</span>
          zookeeper_id: 2
        kafka3:
          ansible_host: <span>${kafka3}</span>
          zookeeper_id: 3
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><div><pre><code><span># 镜像yum源有问题得，替换下yum源</span>
ansible-galaxy <span>install</span> clay_wangzhi.sysinit
<span>mkdir</span> -p /etc/ansible/playbooks/vars
<span>cat</span> <span>></span> /etc/ansible/playbooks/sysinit.yml <span>&lt;&lt;</span> <span>EOF
---
- hosts: all
  roles:
    - clay_wangzhi.sysinit
EOF</span>
ansible all -m shell -a <span>"rm -rf /etc/yum.repos.d/bak/"</span>
ansible-playbook /etc/ansible/playbooks/sysinit.yml --tags upgrade_repo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="安装-elasticsearch"> 安装 Elasticsearch</h2>
<div><pre><code><span># 下载roles</span>
ansible-galaxy <span>install</span> elastic.elasticsearch,v7.11.2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span># 编写playbook</span>
<span>cat</span> <span>></span> /etc/ansible/playbooks/elasticsearch.yml <span>&lt;&lt;</span> <span>EOF
---
# 注意修改yum源为清华源
- hosts: es_master
  roles:
    - role: elastic.elasticsearch
  vars:
    node_master: true
    node_data: false
  vars_files:
    - vars/es_vars.yml

- hosts: es_data
  roles:
    - role: elastic.elasticsearch
  vars:
    node_master: false
    node_data: true
  vars_files:
    - vars/es_vars.yml

- hosts: es_ingest
  roles:
    - role: elastic.elasticsearch
  vars:
    node_master: false
    node_data: false
  vars_files:
    - vars/es_vars.yml
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><div><pre><code><span># 新增var_files</span>
<span>cat</span> <span>></span> /etc/ansible/playbooks/vars/es_vars.yml <span>&lt;&lt;</span> <span>EOF
es_heap_size: "4g"
es_api_host: "{{ansible_ssh_host}}"
es_data_dirs:
  - "/opt/elasticsearch/data"
es_log_dir: "/opt/elasticsearch/logs"
es_config:
  cluster.name: "suncar-es"
  node.name: "{{inventory_hostname}}"
  network.host: "{{ansible_ssh_host}}"
  cluster.initial_master_nodes: '["{{hostvars[groups["es_master"][0]].ansible_host}}"{% for host in groups["es_master"][1:] %}, "{{hostvars[host].ansible_host}}"{% endfor %}]'
  discovery.seed_hosts: '["{{hostvars[groups["es_master"][0]].ansible_host}}:9300"{% for host in groups["es_master"][1:] %}, "{{hostvars[host].ansible_host}}:9300"{% endfor %}]'
  http.port: 9200
  node.master: "{{node_master}}"
  node.data: "{{node_data}}"
  bootstrap.memory_lock: true
  gateway.recover_after_nodes: 2
  xpack.monitoring.collection.enabled: true
  http.cors.enabled: true
  http.cors.allow-origin: "*"
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><div><pre><code><span># 修改roles文件，修改yum源为清华源</span>
<span>cat</span> <span>></span> /etc/ansible/roles/elastic.elasticsearch/templates/elasticsearch.repo <span>&lt;&lt;</span> <span>EOF
[elasticsearch-7.x]
name=Elasticsearch repository for 7.x packages
baseurl=https://mirrors.tuna.tsinghua.edu.cn/elasticstack/yum/elastic-7.x/
gpgcheck=0
enabled=1
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span># 修改es yml配置文件,将安全功能开启，并自己设置密码</span>
<span>vim</span> /etc/ansible/roles/elastic.elasticsearch/templates/elasticsearch.yml.j2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>{% if es_enable_xpack and es_api_basic_auth_username is defined and es_api_basic_auth_password is defined %}   #将这一行改为下面
{% if not oss_version %}
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>执行playbook前，首先要进行数据磁盘的挂载，挂载到数据目录，es数据节点磁盘占用很大</p>
</blockquote>
<div><pre><code><span># 安装</span>
ansible-playbook /etc/ansible/playbooks/elasticsearch.yml 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span># ansible安装完成后，初始化es通信的密码，在任意es_master1节点执行</span>
<span>export</span> <span>JAVA_HOME</span><span>=</span>/usr/share/elasticsearch/jdk/
<span>cd</span> /usr/share/elasticsearch/
bin/elasticsearch-setup-passwords interactive
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>配置Node间SSL</strong></p>
<p>注意：这里是指配置ES集群节点间transport的SSL认证，对于ES节点的HTTP API接口并没有配置，所以通过API访问ES时不需要提供证书。</p>
<p>参考官网:</p>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/ssl-tls.html</p>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.4/configuring-tls.html</p>
<p>创建SSL/TLS证书：</p>
<div><pre><code><span>cd</span> /usr/share/elasticsearch/bin
<span>export</span> <span>JAVA_HOME</span><span>=</span>/usr/share/elasticsearch/jdk/
./elasticsearch-certutil ca -v   //一路回车
<span>cd</span> <span>..</span>
./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12  //一路回车
<span>mv</span> elastic-* /etc/elasticsearch/
<span>cd</span> /etc/elasticsearch/
<span>chown</span> elasticsearch.elasticsearch *.p12
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>操作完成后，把证书传到剩余节点，修改剩余节点的配置文件，并重启</p>
<div><pre><code><span># 将证书传到 ansible /tmp 目录下</span>
ansible elasticsearch -m copy -a <span>"src=/tmp/elastic-certificates.p12 dest=/etc/elasticsearch/ owner=elasticsearch group=elasticsearch"</span> 
ansible elasticsearch -m copy -a <span>"src=/tmp/elastic-stack-ca.p12 dest=/etc/elasticsearch/ owner=elasticsearch group=elasticsearch"</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span># 修改/etc/elasticsearch/elasticsearch.yml 配置文件</span>
ansible elasticsearch -m lineinfile -a <span>"path=/etc/elasticsearch/elasticsearch.yml line='xpack.security.transport.ssl.enabled: true<span title="\n">\n</span>xpack.security.transport.ssl.verification_mode: certificate<span title="\n">\n</span>xpack.security.transport.ssl.keystore.path: /etc/elasticsearch/elastic-certificates.p12<span title="\n">\n</span>xpack.security.transport.ssl.truststore.path: /etc/elasticsearch/elastic-certificates.p12'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span># 重启es</span>
ansible elasticsearch -m <span>service</span> -a <span>"name=elasticsearch state=restarted"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>在此过程中，所有节点必须全部更新完，否则之前的用户名和密码将会认证失败</p>
<p>更新完成之后，集群的健康检查为yellow，不要着急，等待它自己自动恢复成green，当es中数据较多时会出现</p>
</blockquote>
<blockquote>
<p>Kibana，logstash，kafka的安装可以同时进行，提高效率</p>
</blockquote>
<h2 id="安装-kibana"> 安装 Kibana</h2>
<div><pre><code><span># 下载roles</span>
ansible-galaxy <span>install</span> clay_wangzhi.kibana
<span># 编写playbook，根据实际情况，填写用户名，密码</span>
<span>export</span> <span>k_username</span><span>=</span>elastic <span>k_pass</span><span>=</span>E<span>#2021</span>
<span>cat</span> <span>></span> /etc/ansible/playbooks/kibana.yml <span>&lt;&lt;</span> <span>EOF
- hosts: kibana
  roles:
    - clay_wangzhi.kibana
  vars:
    kibana_version: "7.x"
    kibana_dversion: "7.11.2"
    kibana_server_host: "{{ansible_ssh_host}}"
    kibana_server_name: "{{inventory_hostname}}"
    kibana_elasticsearch_url: '["http://{{hostvars[groups["es_ingest"][0]].ansible_host}}:9200"{% for host in groups["es_ingest"][1:] %}, "http://{{hostvars[host].ansible_host}}:9200"{% endfor %}]'
    kibana_elasticsearch_username: "<span>${k_username}</span>"
    kibana_elasticsearch_password: "<span>${k_pass}</span>"
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span># 安装</span>
ansible-playbook /etc/ansible/playbooks/kibana.yml
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>TODO：Kibana7.11.x 版本具有告警功能，已经GA了，后续可以看一下</p>
</blockquote>
<h2 id="安装-logstash"> 安装 logstash</h2>
<div><pre><code><span># 下载roles</span>
ansible-galaxy <span>install</span> clay_wangzhi.logstash
<span># 编写playbook，根据实际情况，填写用户名，密码</span>
<span>export</span> <span>l_username</span><span>=</span>elastic <span>l_pass</span><span>=</span>E<span>#2021</span>
<span>cat</span> <span>></span> /etc/ansible/playbooks/logstash.yml <span>&lt;&lt;</span> <span>EOF
- hosts: logstash
  roles:
    - clay_wangzhi.logstash
  vars:
    logstash_version: '7.x'
    logstash_dversion: '7.11.2'
    logstash_elasticsearch_hosts: '["http://{{hostvars[groups["es_ingest"][0]].ansible_host}}:9200"{% for host in groups["es_ingest"][1:] %}, "http://{{hostvars[host].ansible_host}}:9200"{% endfor %}]'
    es_user: "<span>${l_username}</span>"
    es_pass: "<span>${l_pass}</span>"
    kafka_topic: "h5-jar"
    kafka_group_id: "suncar-h5"
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span># 安装</span>
ansible-playbook /etc/ansible/playbooks/logstash.yml 
<span># kafka 还未安装，先停止logstash</span>
ansible logstash -m <span>service</span> -a <span>"name=logstash state=stopped"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>TODO: logstash 的playbook后期有空，可以优化一下</p>
</blockquote>
<h2 id="安装-kafka"> 安装 kafka</h2>
<p>kafka集群依赖zookeeper，先安装zookeeper集群</p>
<blockquote>
<p>由于下载源有问题，需要手工注释掉了下载的task，我事先把压缩包下载到了ansible控制节点，先传到各个客户端</p>
<div><pre><code>ansible kafka -m copy -a &quot;src=/tmp/zookeeper-3.4.14.tar.gz dest=/tmp/&quot;
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<p><strong>安装zookeeper</strong></p>
<div><pre><code><span># 下载roles</span>
ansible-galaxy <span>install</span> clay_wangzhi.zookeeper
<span># 编写playbook</span>
<span>cat</span> <span>></span> /etc/ansible/playbooks/zookeeper.yml <span>&lt;&lt;</span> <span>EOF
---
- hosts: kafka
  roles:
  - role: clay_wangzhi.zookeeper
    zookeeper_version: 3.4.14
    zookeeper_mirror: "https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper"
    zookeeper_servers: "{{groups['kafka']}}"
    zookeeper_environment:
      "JAVA_HOME": "/opt/jdk1.8.0_144"
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span># 安装</span>
ansible-playbook /etc/ansible/playbooks/zookeeper.yml
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>安装kafka</strong></p>
<div><pre><code><span># 下载roles</span>
ansible-galaxy <span>install</span> clay_wangzhi.kafka
<span>cat</span> <span>></span> /etc/ansible/playbooks/kafka.yml <span>&lt;&lt;</span> <span>EOF
---
- hosts: kafka
  roles:
    - clay_wangzhi.kafka
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>执行playbook前，首先要进行数据磁盘的挂载，挂载到数据目录，kafka数据节点磁盘占用很大</p>
</blockquote>
<div><pre><code><span># 安装</span>
ansible-playbook /etc/ansible/playbooks/kafka.yml
<span># 启动logstash，上面停止了</span>
ansible logstash -m <span>service</span> -a <span>"name=logstash state=started"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="安装-filebeat"> 安装 filebeat</h2>
<div><pre><code># 添加filebeat主机到主机清单
    filebeat:
      hosts:
        192.168.124.3:
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span># 下载roles</span>
ansible-galaxy <span>install</span> elastic.beats,v7.11.2
<span># 编写playbook，beat_conf 请根据实际情况来填写</span>
<span>cat</span> <span>></span> /etc/ansible/playbooks/filebeat.yml <span>&lt;&lt;</span> <span>EOF
---
- hosts: filebeat
  roles:
    - elastic.beats
  vars:
    beat: filebeat
    beat_conf:
      filebeat:
        inputs:
          - type: log
            enabled: true
            paths:
              - /home/ncar/service/webapps/logs/ShengDaGFHD/ShengDaGFHD.log
            multiline.pattern: '^[0-9]{4}-[0-9]{2}-[0-9]{2}'
            multiline.negate: true
            multiline.match: after
            tags: ["jar"]
            fields:
              type: h5-jar
              ip: "{{inventory_hostname}}"
              service_name: shengdasxgh
      processors:
        - drop_fields:
            fields: ["agent", "ecs.version", "host.name"]
    
    output_conf:
      kafka:
        hosts: '["{{hostvars[groups["kafka"][0]].ansible_host}}:9092"{% for host in groups["kafka"][1:] %}, "{{hostvars[host].ansible_host}}:9092"{% endfor %}]'
        topic: 'h5-jar'
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><pre><code><span># 修改roles文件，修改yum源为清华源</span>
<span>cat</span> <span>></span> /etc/ansible/roles/elastic.beats/templates/beats.repo.j2 <span>&lt;&lt;</span> <span>EOF
[filebeat-7.x]
name=Elasticsearch repository for 7.x packages
baseurl=https://mirrors.tuna.tsinghua.edu.cn/elasticstack/yum/elastic-7.x/
gpgcheck=0
enabled=1
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span># 安装</span>
ansible-playbook /etc/ansible/playbooks/filebeat.yml
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">容器部署ELK7.10</title>
    <id>https://clay-wangzhi.com/monitor/elk/install/docker-com-elk/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/install/docker-com-elk/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="容器部署elk7-10"> 容器部署ELK7.10</h1>
<blockquote>
<p>转载自 YP小站</p>
</blockquote>
<h2 id="一、elk架构简介"> 一、elk架构简介</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640.png" alt="640" /></p>
<ul>
<li>首先 <code>logstash</code> 具有日志采集、过滤、筛选等功能，功能完善但同时体量也会比较大，消耗系统资源自然也多。<code>filebeat</code>作为一个轻量级日志采集工具，虽然没有过滤筛选功能，但是仅仅部署在应用服务器作为我们采集日志的工具可以是说最好的选择。但我们有些时候可能又需要logstash的过滤筛选功能，所以我们在采集日志时用filebeat，然后交给logstash过滤筛选。</li>
<li>其次，logstash的吞吐量是有限的，一旦短时间内filebeat传过来的日志过多会产生堆积和堵塞，对日志的采集也会受到影响，所以在filebeat与logstash中间又加了一层<code>kafka</code>消息队列来缓存或者说解耦，当然redis也是可以的。这样当众多filebeat节点采集大量日志直接放到kafka中，logstash慢慢的进行消费，两边互不干扰。</li>
<li>至于<code>zookeeper</code>，分布式服务管理神器，监控管理kafka的节点注册，<code>topic</code>管理等，同时弥补了kafka集群节点对外界无法感知的问题，kafka实际已经自带了zookeeper，这里将会使用独立的zookeeper进行管理，方便后期zookeeper集群的扩展。</li>
</ul>
<h2 id="二、环境"> 二、环境</h2>
<ul>
<li>SUNCAR私有云：5台部署ES节点，3台分别部署logstash、kafka、zookeeper和kibana等服务。</li>
<li>SUNCAR私有云配置：5台 4核16G SSD磁盘。3台 4核16G SSD磁盘。都是 Centos7.6系统</li>
<li>安装 docker 和 docker-compose</li>
<li>ELK版本7.10.1；zookeeper版本3.6.2；kafka版本2.13-2.6.0；</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">IP地址</th>
<th style="text-align:left">主机名称</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">192.168.134.6</td>
<td style="text-align:left">es-master1</td>
<td style="text-align:left">es master 和 es 数据节点</td>
</tr>
<tr>
<td style="text-align:left">192.168.134.103</td>
<td style="text-align:left">es-master2</td>
<td style="text-align:left">es master 和 es 数据节点</td>
</tr>
<tr>
<td style="text-align:left">192.168.134.168</td>
<td style="text-align:left">es-master3</td>
<td style="text-align:left">es master 和 es 数据节点</td>
</tr>
<tr>
<td style="text-align:left">192.168.134.240</td>
<td style="text-align:left">es-data1</td>
<td style="text-align:left">es数据节点</td>
</tr>
<tr>
<td style="text-align:left">192.168.134.185</td>
<td style="text-align:left">es-data2</td>
<td style="text-align:left">es数据节点</td>
</tr>
<tr>
<td style="text-align:left">192.168.134.162</td>
<td style="text-align:left">logstash1</td>
<td style="text-align:left">logstash、kafka、zookeeper</td>
</tr>
<tr>
<td style="text-align:left">192.168.134.186</td>
<td style="text-align:left">logstash2</td>
<td style="text-align:left">logstash、kafka、zookeeper</td>
</tr>
<tr>
<td style="text-align:left">192.168.134.40</td>
<td style="text-align:left">logstash3</td>
<td style="text-align:left">logstash、kafka、kafa-manager、zookeeper、kibana、curator</td>
</tr>
</tbody>
</table>
<h2 id="三、系统参数优化"> 三、系统参数优化</h2>
<div><pre><code># 最大用户打开进程数
$ vim /etc/security/limits.d/20-nproc.conf

*           soft   nproc       65535
*           hard   nproc       65535

# 优化内核，用于 docker 支持
$ modprobe br_netfilter
$ cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
EOF
$ sysctl -p /etc/sysctl.d/k8s.conf

# 优化内核，对 es 支持
$ echo &#39;vm.max_map_count=262144&#39; &gt;&gt; /etc/sysctl.conf

# 生效配置
$ sysctl -p
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="四、部署-docker-和-docker-compose"> 四、部署 docker 和 docker-compose</h2>
<h3 id="部署-docker"> 部署 docker</h3>
<div><pre><code># 安装必要的一些系统工具
$ yum install -y yum-utils device-mapper-persistent-data lvm2

# 添加软件源信息
$ yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

# 更新并安装 Docker-CE
$ yum makecache fast
$ yum -y install docker-ce

# 配置docker
$ systemctl enable docker
$ systemctl start docker
$ vim /etc/docker/daemon.json
{&quot;data-root&quot;: &quot;/var/lib/docker&quot;, &quot;bip&quot;: &quot;10.50.0.1/16&quot;, &quot;default-address-pools&quot;: [{&quot;base&quot;: &quot;10.51.0.1/16&quot;, &quot;size&quot;: 24}], &quot;registry-mirrors&quot;: [&quot;https://4xr1qpsp.mirror.aliyuncs.com&quot;], &quot;log-opts&quot;: {&quot;max-size&quot;:&quot;500m&quot;, &quot;max-file&quot;:&quot;3&quot;}}
$ sed  -i &#39;/ExecStart=/i ExecStartPost=\/sbin\/iptables -P FORWARD ACCEPT&#39; /usr/lib/systemd/system/docker.service
$ systemctl enable docker.service
$ systemctl daemon-reload
$ systemctl restart docker
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="部署-docker-compose"> 部署 docker-compose</h3>
<div><pre><code># 安装 docker-compose
$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
$ chmod +x /usr/local/bin/docker-compose
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="五、部署-es"> 五、部署 ES</h2>
<h3 id="es-master1-操作"> es-master1 操作</h3>
<div><pre><code># 创建 es 目录
$ mkdir -p /data/ELKStack
$ cd /data/ELKStack
$ mkdir elasticsearch elasticsearch-data elasticsearch-plugins

# 容器es用户 uid 和 gid 都是 1000
$ chown 1000.1000 elasticsearch-data elasticsearch-plugins

# 临时启动一个es
$ docker run --name es-test -it --rm elasticsearch:7.10.1 bash

# 生成证书，证书有效期10年，证书输入的密码这里为空
$ bin/elasticsearch-certutil ca --days 3660
$ bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12 --days 3660

# 打开新的窗口，拷贝生成的证书
$ cd /data/ELKStack/elasticsearch
$ mkdir es-p12
$ docker cp es-test:/usr/share/elasticsearch/elastic-certificates.p12 ./es-p12
$ docker cp es-test:/usr/share/elasticsearch/elastic-stack-ca.p12 ./es-p12
$ chown -R 1000.1000 ./es-p12

# 创建 docker-compose.yml
$ vim docker-compose.yml

version: &#39;2.2&#39;
services:
  elasticsearch:
    image: elasticsearch:7.10.1
    container_name: es01
    environment:
      - cluster.name=es-docker-cluster
      - cluster.initial_master_nodes=192.168.134.6,192.168.134.103,192.168.134.168
      - bootstrap.memory_lock=true
      - &quot;ES_JAVA_OPTS=-Xms10000m -Xmx10000m&quot;
    ulimits:
      memlock:
        soft: -1
        hard: -1
      nofile:
        soft: 65536
        hard: 65536
    mem_limit: 13000m
    cap_add:
      - IPC_LOCK
    restart: always
    # 设置 docker host 网络模式
    network_mode: &quot;host&quot;
    volumes:
       - /data/ELKStack/elasticsearch-data:/usr/share/elasticsearch/data
       - /data/ELKStack/elasticsearch-plugins:/usr/share/elasticsearch/plugins
       - /data/ELKStack/elasticsearch/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml
       - /data/ELKStack/elasticsearch/es-p12:/usr/share/elasticsearch/config/es-p12

# 创建 elasticsearch.yml 配置文件
$ vim elasticsearch.yml

cluster.name: &quot;es-docker-cluster&quot;
node.name: &quot;es01&quot;
network.host: 0.0.0.0

node.master: true
node.data: true

discovery.zen.minimum_master_nodes: 2
http.port: 9200
transport.tcp.port: 9300

# 如果是多节点es，通过ping来健康检查
discovery.zen.ping.unicast.hosts: [&quot;192.168.134.6:9300&quot;, &quot;192.168.134.103:9300&quot;, &quot;192.168.134.168:9300&quot;, &quot;192.168.134.240:9300&quot;, &quot;192.168.134.185:9300&quot;]
discovery.zen.fd.ping_timeout: 120s
discovery.zen.fd.ping_retries: 6
discovery.zen.fd.ping_interval: 10s

cluster.info.update.interval: 1m
indices.fielddata.cache.size:  20%
indices.breaker.fielddata.limit: 40%
indices.breaker.request.limit: 40%
indices.breaker.total.limit: 70%
indices.memory.index_buffer_size: 20%
script.painless.regex.enabled: true

# 磁盘分片分配
cluster.routing.allocation.disk.watermark.low: 100gb
cluster.routing.allocation.disk.watermark.high: 50gb
cluster.routing.allocation.disk.watermark.flood_stage: 30gb

# 本地数据分片恢复配置
gateway.recover_after_nodes: 3
gateway.recover_after_time: 5m
gateway.expected_nodes: 3
cluster.routing.allocation.node_initial_primaries_recoveries: 8
cluster.routing.allocation.node_concurrent_recoveries: 2

# 允许跨域请求
http.cors.enabled: true
http.cors.allow-origin: &quot;*&quot;
http.cors.allow-headers: Authorization,X-Requested-With,Content-Length,Content-Type

# 开启xpack
xpack.security.enabled: true
xpack.monitoring.collection.enabled: true

# 开启集群中https传输
xpack.security.transport.ssl.enabled: true
xpack.security.transport.ssl.verification_mode: certificate
xpack.security.transport.ssl.keystore.path: es-p12/elastic-certificates.p12
xpack.security.transport.ssl.truststore.path: es-p12/elastic-certificates.p12

# 把 es 配置使用 rsync 同步到其它 es 节点
$ rsync -avp -e ssh /data/ELKStack 192.168.134.103:/data/
$ rsync -avp -e ssh /data/ELKStack 192.168.134.168:/data/
$ rsync -avp -e ssh /data/ELKStack 192.168.134.240:/data/
$ rsync -avp -e ssh /data/ELKStack 192.168.134.185:/data/

# 启动 es
$ docker-compose up -d

# 查看 es
$ docker-compose ps
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br></div></div><blockquote>
<p>注意：磁盘分片分配参数，确定数据目录的磁盘空间大于<code>cluster.routing.allocation.disk.watermark.low</code>的值</p>
</blockquote>
<h3 id="es-master2-操作"> es-master2 操作</h3>
<div><pre><code>$ cd /data/ELKStack/elasticsearch

# 修改 docker-compose.yml elasticsearch.yml 两个配置
$ sed -i &#39;s/es01/es02/g&#39; docker-compose.yml elasticsearch.yml

# 启动 es
$ docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="es-master3-操作"> es-master3 操作</h3>
<div><pre><code>$ cd /data/ELKStack/elasticsearch

# 修改 docker-compose.yml elasticsearch.yml 两个配置
$ sed -i &#39;s/es01/es03/g&#39; docker-compose.yml elasticsearch.yml

# 启动 es
$ docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="es-data1-操作"> es-data1 操作</h3>
<div><pre><code>$ cd /data/ELKStack/elasticsearch

# 修改 docker-compose.yml elasticsearch.yml 两个配置
$ sed -i &#39;s/es01/es04/g&#39; docker-compose.yml elasticsearch.yml

# 不做为 es master 节点，只做数据节点
$ sed -i &#39;s/node.master: true/node.master: false/g&#39; elasticsearch.yml

# 启动 es
$ docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="es-data2-操作"> es-data2 操作</h3>
<div><pre><code>$ cd /data/ELKStack/elasticsearch

# 修改 docker-compose.yml elasticsearch.yml 两个配置
$ sed -i &#39;s/es01/es05/g&#39; docker-compose.yml elasticsearch.yml

# 不做为 es master 节点，只做数据节点
$ sed -i &#39;s/node.master: true/node.master: false/g&#39; elasticsearch.yml

# 启动 es
$ docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="设置-es-访问账号"> 设置 es 访问账号</h3>
<div><pre><code># es-master1 操作
$ docker exec -it es01 bash

# 设置 elastic，apm_system，kibana，kibana_system，logstash_system，beats_system，remote_monitoring_user 等密码
# 密码都设置为 elastic123，这里只是举例，具体根据需求设置
$ ./bin/elasticsearch-setup-passwords interactive
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="六、部署-kibana"> 六、部署 Kibana</h2>
<h3 id="logstash3-操作"> logstash3 操作</h3>
<div><pre><code>$ mkdir -p /data/ELKStack/kibana
$ cd /data/ELKStack/kibana

# 创建 kibana 相关目录，用于容器挂载
$ mkdir config data plugins
$ chown 1000.1000 config data plugins

# 创建 docker-compose.yml
$ vim docker-compose.yml

version: &#39;2&#39;
services:
  kibana:
    image: docker.elastic.co/kibana/kibana:7.10.1
    container_name: kibana
    restart: always
    network_mode: &quot;bridge&quot;
    mem_limit: 2000m
    environment:
      SERVER_NAME: kibana.example.com
    ports:
      - &quot;5601:5601&quot;
    volumes:
       - /data/ELKStack/kibana/config:/usr/share/kibana/config
       - /data/ELKStack/kibana/data:/usr/share/kibana/data
       - /data/ELKStack/kibana/plugins:/usr/share/kibana/plugins

# 创建 kibana.yml
$ vim config/kibana.yml

server.name: kibana
server.host: &quot;0&quot;
elasticsearch.hosts: [&quot;http://192.168.134.6:9200&quot;,&quot;http://192.168.134.103:9200&quot;,&quot;http://192.168.134.168:9200&quot;]
elasticsearch.username: &quot;kibana&quot;
elasticsearch.password: &quot;elastic123&quot;
monitoring.ui.container.elasticsearch.enabled: true
xpack.security.enabled: true
xpack.encryptedSavedObjects.encryptionKey: encryptedSavedObjects12345678909876543210
xpack.security.encryptionKey: encryptionKeysecurity12345678909876543210
xpack.reporting.encryptionKey: encryptionKeyreporting12345678909876543210
i18n.locale: &quot;zh-CN&quot;

# 启动 kibana
$ docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="七、部署-zookeeper"> 七、部署 Zookeeper</h2>
<h3 id="logstash1-操作"> logstash1 操作</h3>
<div><pre><code># 创建 zookeeper 目录
$ mkdir -p /data/ELKStack/zookeeper
$ cd /data/ELKStack/zookeeper
$ mkdir data datalog
$ chown 1000.1000 data datalog

# 创建 docker-compose.yml
$ vim docker-compose.yml

version: &#39;2&#39;
services:
  zoo1:
    image: zookeeper:3.6.2
    restart: always
    hostname: zoo1
    container_name: zoo1
    network_mode: &quot;bridge&quot;
    mem_limit: 2000m
    ports:
      - 2181:2181
      - 3888:3888
      - 2888:2888
    volumes:
      - /data/ELKStack/zookeeper/data:/data
      - /data/ELKStack/zookeeper/datalog:/datalog
      - /data/ELKStack/zookeeper/zoo.cfg:/conf/zoo.cfg
    environment:
      ZOO_MY_ID: 1  # 表示 ZK服务的 id, 它是1-255 之间的整数, 必须在集群中唯一
      ZOO_SERVERS: server.1=0.0.0.0:2888:3888;2181 server.2=192.168.134.186:2888:3888;2181 server.3=192.168.134.40:2888:3888;2181
      # ZOOKEEPER_CLIENT_PORT: 2181

# 创建 zoo.cfg 配置
$ vim zoo.cfg

tickTime=2000
initLimit=10
syncLimit=5
dataDir=/data
dataLogDir=/datalog
autopurge.snapRetainCount=3
autopurge.purgeInterval=1
maxClientCnxns=60
server.1= 0.0.0.0:2888:3888;2181
server.2= 192.168.134.186:2888:3888;2181
server.3= 192.168.134.40:2888:3888;2181

# 拷贝配置到 logstash2 logstash3 机器上
$ rsync -avp -e ssh /data/ELKStack 192.168.134.186:/data/
$ rsync -avp -e ssh /data/ELKStack 192.168.134.40:/data/

# 启动 zookeeper
$ docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h3 id="logstash2-操作"> logstash2 操作</h3>
<div><pre><code>$ cd /data/ELKStack/zookeeper

# 修改 docker-compose.yml 文件
$ vim docker-compose.yml

version: &#39;2&#39;
services:
  zoo2:
    image: zookeeper:3.6.2
    restart: always
    hostname: zoo2
    container_name: zoo2
    network_mode: &quot;bridge&quot;
    mem_limit: 2000m
    ports:
      - 2181:2181
      - 3888:3888
      - 2888:2888
    volumes:
      - /data/ELKStack/zookeeper/data:/data
      - /data/ELKStack/zookeeper/datalog:/datalog
      - /data/ELKStack/zookeeper/zoo.cfg:/conf/zoo.cfg
    environment:
      ZOO_MY_ID: 2  # 表示 ZK服务的 id, 它是1-255 之间的整数, 必须在集群中唯一
      ZOO_SERVERS: server.1=192.168.134.162:2888:3888;2181 server.2=0.0.0.0:2888:3888;2181 server.3=192.168.134.40:2888:3888;2181
      # ZOOKEEPER_CLIENT_PORT: 2181

# 修改 zoo.cfg
$ vim zoo.cfg

tickTime=2000
initLimit=10
syncLimit=5
dataDir=/data
dataLogDir=/datalog
autopurge.snapRetainCount=3
autopurge.purgeInterval=1
maxClientCnxns=60
server.1= 192.168.134.162:2888:3888;2181
server.2= 0.0.0.0:2888:3888;2181
server.3= 192.168.134.40:2888:3888;2181

# 启动 zookeeper
$ docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h3 id="logstash3-操作-2"> logstash3 操作</h3>
<div><pre><code>$ cd /data/ELKStack/zookeeper

# 修改 docker-compose.yml 文件
$ vim docker-compose.yml

version: &#39;2&#39;
services:
  zoo3:
    image: zookeeper:3.6.2
    restart: always
    hostname: zoo3
    container_name: zoo3
    network_mode: &quot;bridge&quot;
    mem_limit: 2000m
    ports:
      - 2181:2181
      - 3888:3888
      - 2888:2888
    volumes:
      - /data/ELKStack/zookeeper/data:/data
      - /data/ELKStack/zookeeper/datalog:/datalog
      - /data/ELKStack/zookeeper/zoo.cfg:/conf/zoo.cfg
    environment:
      ZOO_MY_ID: 3  # 表示 ZK服务的 id, 它是1-255 之间的整数, 必须在集群中唯一
      ZOO_SERVERS: server.1=192.168.134.162:2888:3888;2181 server.2=192.168.134.186:2888:3888;2181 server.3=0.0.0.0:2888:3888;2181
      # ZOOKEEPER_CLIENT_PORT: 2181

# 修改 zoo.cfg
$ vim zoo.cfg

tickTime=2000
initLimit=10
syncLimit=5
dataDir=/data
dataLogDir=/datalog
autopurge.snapRetainCount=3
autopurge.purgeInterval=1
maxClientCnxns=60
server.1= 192.168.134.162:2888:3888;2181
server.2= 192.168.134.186:2888:3888;2181
server.3= 0.0.0.0:2888:3888;2181

# 启动 zookeeper
$ docker-compose up -d

# 操作 zookeeper
$ docker exec -it zoo3 bash
$ zkCli.sh -server 192.168.134.162:2181,192.168.134.186:2181,192.168.134.40:2181
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h2 id="八、部署-kafka"> 八、部署 Kafka</h2>
<h3 id="logstash1-操作-2"> logstash1 操作</h3>
<div><pre><code># 创建 kafka 目录
$ mkdir -p /data/ELKStack/kafka
$ cd /data/ELKStack/kafka

# 创建数据目录，用于存储kafka容器数据
$ mkdir data

# 把kafka配置拷贝到宿主机上
$ docker run --name kafka-test -it --rm wurstmeister/kafka:2.13-2.6.0 bash
$ cd /opt/kafka
$ tar zcvf /tmp/config.tar.gz config

# 打开一个新的窗口
$ cd /data/ELKStack/kafka/
$ docker cp kafka-test:/tmp/config.tar.gz ./

# 解压配置文件
$ tar xf config.tar.gz

# 创建 docker-compose.yml
$ vim docker-compose.yml

version: &#39;2&#39;

services:
  kafka1:
    image: wurstmeister/kafka:2.13-2.6.0
    restart: always
    hostname: kafka1
    container_name: kafka1
    network_mode: &quot;bridge&quot;
    mem_limit: 5120m
    ports:
    - 9092:9092
    - 9966:9966
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.134.162:9092       # 宿主机的IP地址而非容器的IP，及暴露出来的端口
      KAFKA_ADVERTISED_HOST_NAME: 192.168.134.162                        # 外网访问地址
      KAFKA_ADVERTISED_PORT: 9092                                      # 端口
      KAFKA_ZOOKEEPER_CONNECT: 192.168.134.162:2181,192.168.134.186:2181,192.168.134.40:2181           # 连接的zookeeper服务及端口
      KAFKA_JMX_OPTS: &quot;-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=192.168.134.162 -Dcom.sun.management.jmxremote.rmi.port=9966&quot;
      JMX_PORT: 9966 # kafka需要监控broker和topic的数据的时候,是需要开启jmx_port的
      KAFKA_HEAP_OPTS: &quot;-Xmx4096M -Xms4096M&quot;
    volumes:
    - /data/ELKStack/kafka/data:/kafka                    # kafka数据文件存储目录
    - /data/ELKStack/kafka/config:/opt/kafka/config

# 优化 kafka server.properties 配置
$ vim config/server.properties

# 调大socket，防止报错
socket.send.buffer.bytes=1024000
socket.receive.buffer.bytes=1024000
socket.request.max.bytes=1048576000

# topic 数据保留多久，默认168小时(7day)
log.retention.hours=72
log.cleanup.policy=delete

# 拷贝配置到 logstash2 logstash3 机器上
$ rsync -avp -e ssh /data/ELKStack/kafka 192.168.134.186:/data/ELKStack/
$ rsync -avp -e ssh /data/ELKStack/kafka 192.168.134.40:/data/ELKStack/

# 启动 kafka
$ docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br></div></div><h3 id="logstash2-操作-2"> logstash2 操作</h3>
<div><pre><code>$ cd /data/ELKStack/kafka

# 修改 docker-compose.yml 文件
$ vim docker-compose.yml

version: &#39;2&#39;

services:
  kafka2:
    image: wurstmeister/kafka:2.13-2.6.0
    restart: always
    hostname: kafka2
    container_name: kafka2
    network_mode: &quot;bridge&quot;
    mem_limit: 5120m
    ports:
    - 9092:9092
    - 9966:9966
    environment:
      KAFKA_BROKER_ID: 2
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.134.186:9092       # 宿主机的IP地址而非容器的IP，及暴露出来的端口
      KAFKA_ADVERTISED_HOST_NAME: 192.168.134.186                        # 外网访问地址
      KAFKA_ADVERTISED_PORT: 9092                                      # 端口
      KAFKA_ZOOKEEPER_CONNECT: 192.168.134.162:2181,192.168.134.186:2181,192.168.134.40:2181           # 连接的zookeeper服务及端口
      KAFKA_JMX_OPTS: &quot;-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=192.168.134.186 -Dcom.sun.management.jmxremote.rmi.port=9966&quot;
      JMX_PORT: 9966  # kafka需要监控broker和topic的数据的时候,是需要开启jmx_port的
      KAFKA_HEAP_OPTS: &quot;-Xmx4096M -Xms4096M&quot;
    volumes:
    - /data/ELKStack/kafka/data:/kafka                    # kafka数据文件存储目录
    - /data/ELKStack/kafka/config:/opt/kafka/config

# 启动 kafka
$ docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id="logstash3-操作-3"> logstash3 操作</h3>
<div><pre><code>$ cd /data/ELKStack/kafka

# 修改 docker-compose.yml 文件
$ vim docker-compose.yml

version: &#39;2&#39;

services:
  kafka3:
    image: wurstmeister/kafka:2.13-2.6.0
    restart: always
    hostname: kafka3
    container_name: kafka3
    network_mode: &quot;bridge&quot;
    mem_limit: 5120m
    ports:
    - 9092:9092
    - 9966:9966
    environment:
      KAFKA_BROKER_ID: 3
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.134.40:9092       # 宿主机的IP地址而非容器的IP，及暴露出来的端口
      KAFKA_ADVERTISED_HOST_NAME: 192.168.134.40                        # 外网访问地址
      KAFKA_ADVERTISED_PORT: 9092                                      # 端口
      KAFKA_ZOOKEEPER_CONNECT: 192.168.134.162:2181,192.168.134.186:2181,192.168.134.40:2181           # 连接的zookeeper服务及端口
      KAFKA_JMX_OPTS: &quot;-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=192.168.134.40 -Dcom.sun.management.jmxremote.rmi.port=9966&quot;
      JMX_PORT: 9966  # kafka需要监控broker和topic的数据的时候,是需要开启jmx_port的
      KAFKA_HEAP_OPTS: &quot;-Xmx4096M -Xms4096M&quot;
    volumes:
    - /data/ELKStack/kafka/data:/kafka                    # kafka数据文件存储目录
    - /data/ELKStack/kafka/config:/opt/kafka/config

# 启动 kafka
$ docker-compose up -d

# 部署 kafka-manager 管理 kafka 平台
$ mkdir /data/ELKStack/kafka-manager
$ cd /data/ELKStack/kafka-manager
$ vim docker-compose.yml

version: &#39;3.6&#39;
services:
  kafka_manager:
    restart: always
    container_name: kafa-manager
    hostname: kafka-manager
    network_mode: &quot;bridge&quot;
    mem_limit: 1024m
    image: hlebalbau/kafka-manager:3.0.0.5-7e7a22e
    ports:
      - &quot;9000:9000&quot;
    environment:
      ZK_HOSTS: &quot;192.168.134.162:2181,192.168.134.186:2181,192.168.134.40:2181&quot;
      APPLICATION_SECRET: &quot;random-secret&quot;
      KAFKA_MANAGER_AUTH_ENABLED: &quot;true&quot;
      KAFKA_MANAGER_USERNAME: admin
      KAFKA_MANAGER_PASSWORD: elastic123
      JMX_PORT: 9966
      TZ: &quot;Asia/Shanghai&quot;

# 启动 kafka-manager
$ docker-compose up -d

# 访问 http://192.168.134.40:9000 ，把上面创建的三台 kafka 加入管理，这里不在阐述，网上很多配置教程
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><h2 id="九、部署-logstash"> 九、部署 logstash</h2>
<h3 id="logstash1-操作-3"> logstash1 操作</h3>
<div><pre><code>$ mkdir /data/ELKStack/logstash
$ cd /data/ELKStack/logstash
$ mkdir config data
$ chown 1000.1000 config data

# 创建 docker-compose.yml
$ vim docker-compose.yml

version: &#39;2&#39;
services:
  logstash1:
    image: logstash:7.10.1
    container_name: logstash1
    hostname: logstash1
    restart: always
    network_mode: &quot;bridge&quot;
    mem_limit: 4096m
    environment:
      TZ: &quot;Asia/Shanghai&quot;
    ports:
      - 5044:5044
    volumes:
      - /data/ELKStack/logstash/config:/config-dir
      - /data/ELKStack/logstash/logstash.yml:/usr/share/logstash/config/logstash.yml
      - /data/ELKStack/logstash/data:/usr/share/logstash/data
      - /etc/localtime:/etc/localtime
    user: logstash
    command: bash -c &quot;logstash -f /config-dir --config.reload.automatic&quot;

# 创建 logstash.yml
$ vim logstash.yml

http.host: &quot;0.0.0.0&quot;
# 指发送到Elasticsearch的批量请求的大小，值越大，处理则通常更高效，但增加了内存开销
pipeline.batch.size: 3000
# 指调整Logstash管道的延迟，过了该时间则logstash开始执行过滤器和输出
pipeline.batch.delay: 200

# 创建 logstash 规则配置
$ vim config/01-input.conf

input {                                        # 输入组件
    kafka {                                    # 从kafka消费数据
        bootstrap_servers =&gt; [&quot;192.168.134.162:9092,192.168.134.186:9092,192.168.134.40:9092&quot;]
        #topics =&gt; &quot;%{[@metadata][topic]}&quot;     # 使用kafka传过来的topic
        topics_pattern =&gt; &quot;elk-.*&quot;             # 使用正则匹配topic
        codec =&gt; &quot;json&quot;                        # 数据格式
        consumer_threads =&gt; 3                  # 消费线程数量
        decorate_events =&gt; true                # 可向事件添加Kafka元数据，比如主题、消息大小的选项，这将向logstash事件中添加一个名为kafka的字段
        auto_offset_reset =&gt; &quot;latest&quot;          # 自动重置偏移量到最新的偏移量
        group_id =&gt; &quot;logstash-node&quot;            # 消费组ID，多个有相同group_id的logstash实例为一个消费组
        client_id =&gt; &quot;logstash1&quot;               # 客户端ID
        fetch_max_wait_ms =&gt; &quot;1000&quot;            # 指当没有足够的数据立即满足fetch_min_bytes时，服务器在回答fetch请求之前将阻塞的最长时间
  }
}

$ vim config/02-output.conf

output {                                       # 输出组件
    elasticsearch {
        # Logstash输出到es
        hosts =&gt; [&quot;192.168.134.6:9200&quot;, &quot;192.168.134.103:9200&quot;, &quot;192.168.134.168:9200&quot;, &quot;192.168.134.240:9200&quot;, &quot;192.168.134.185:9200&quot;]
        index =&gt; &quot;%{[fields][source]}-%{+YYYY-MM-dd}&quot;      # 直接在日志中匹配，索引会去掉elk
        # index =&gt; &quot;%{[@metadata][topic]}-%{+YYYY-MM-dd}&quot;  # 以日期建索引
        user =&gt; &quot;elastic&quot;
        password =&gt; &quot;elastic123&quot;
    }
    #stdout {
    #    codec =&gt; rubydebug
    #}
}

$ vim config/03-filter.conf

filter {
   # 当非业务字段时，无traceId则移除
   if ([message] =~ &quot;traceId=null&quot;) {          # 过滤组件，这里只是展示，无实际意义，根据自己的业务需求进行过滤
      drop {}
   }
}

# 拷贝配置到 logstash2 logstash3 机器上
$ rsync -avp -e ssh /data/ELKStack/logstash 192.168.134.186:/data/ELKStack/
$ rsync -avp -e ssh /data/ELKStack/logstash 192.168.134.40:/data/ELKStack/

# 启动 logstash
$ docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br></div></div><blockquote>
<p><code>pipeline.batch</code> 参数要看一下</p>
</blockquote>
<h3 id="logstash2-操作-3"> logstash2 操作</h3>
<div><pre><code>$ cd /data/ELKStack/logstash
$ sed -i &#39;s/logstash1/logstash2/g&#39; docker-compose.yml
$ sed -i &#39;s/logstash1/logstash2/g&#39; config/01-input.conf

# 启动 logstash
$ docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="logstash3-操作-4"> logstash3 操作</h3>
<div><pre><code>$ cd /data/ELKStack/logstash
$ sed -i &#39;s/logstash1/logstash3/g&#39; docker-compose.yml
$ sed -i &#39;s/logstash1/logstash3/g&#39; config/01-input.conf

# 启动 logstash
$ docker-compose up -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="十、部署-filebeat"> 十、部署 filebeat</h2>
<blockquote>
<p>https://www.elastic.co/guide/en/logstash/current/use-filebeat-modules-kafka.html</p>
<p>以此链接为准</p>
</blockquote>
<div><pre><code># 配置 filebeat yum源，这里以 centos7 为例
$ rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch

$ vim /etc/yum.repos.d/elastic.repo

[elastic-7.x]
name=Elastic repository for 7.x packages
baseurl=https://artifacts.elastic.co/packages/7.x/yum
gpgcheck=1
gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch
enabled=1
autorefresh=1
type=rpm-md

$ yum install -y filebeat-7.10.1
$ systemctl enable filebeat

# 配置
$ cd /etc/filebeat/
$ cp -a filebeat.yml filebeat.yml.old
$ echo &gt; filebeat.yml

# 以收集nginx访问日志为例
$ vim filebeat.yml

filebeat.inputs:                   # inputs为复数，表名type可以有多个
- type: log                        # 输入类型
  access:
  enabled: true                    # 启用这个type配置
  json.keys_under_root: true       # 默认这个值是FALSE的，也就是我们的json日志解析后会被放在json键上。设为TRUE，所有的keys就会被放到根节点
  json.overwrite_keys: true        # 是否要覆盖原有的key，这是关键配置，将keys_under_root设为TRUE后，再将overwrite_keys也设为TRUE，就能把filebeat默认的key值给覆盖
  max_bytes: 20480                 # 单条日志的大小限制,建议限制(默认为10M,queue.mem.events * max_bytes 将是占有内存的一部分)
  paths:
    - /var/log/nginx/access.log    # 监控nginx 的access日志

  fields:                          # 额外的字段
    source: nginx-access-prod      # 自定义source字段，用于es建议索引（字段名小写，我记得大写好像不行）

# 自定义es的索引需要把ilm设置为false
setup.ilm.enabled: false

output.kafka:            # 输出到kafka
  enabled: true          # 该output配置是否启用
  hosts: [&quot;192.168.134.162:9092&quot;, &quot;192.168.134.186:9092&quot;, &quot;192.168.134.40:9092&quot;]  # kafka节点列表
  topic: &quot;elk-%{[fields.source]}&quot;   # kafka会创建该topic，然后logstash(可以过滤修改)会传给es作为索引名称
  partition.hash:
    reachable_only: true # 是否只发往可达分区
  compression: gzip      # 压缩
  max_message_bytes: 1000000  # Event最大字节数。默认1000000。应小于等于kafka broker message.max.bytes值
  required_acks: 1  # kafka ack等级
  worker: 1  # kafka output的最大并发数
  bulk_max_size: 2048    # 单次发往kafka的最大事件数
logging.to_files: true   # 输出所有日志到file，默认true， 达到日志文件大小限制时，日志文件会自动限制替换，详细配置：https://www.cnblogs.com/qinwengang/p/10982424.html
close_older: 30m         # 如果一个文件在某个时间段内没有发生过更新，则关闭监控的文件handle。默认1h
force_close_files: false # 这个选项关闭一个文件,当文件名称的变化。只在window建议为true

# 没有新日志采集后多长时间关闭文件句柄，默认5分钟，设置成1分钟，加快文件句柄关闭
close_inactive: 1m

# 传输了3h后荏没有传输完成的话就强行关闭文件句柄，这个配置项是解决以上案例问题的key point
close_timeout: 3h

# 这个配置项也应该配置上，默认值是0表示不清理，不清理的意思是采集过的文件描述在registry文件里永不清理，在运行一段时间后，registry会变大，可能会带来问题
clean_inactive: 72h

# 设置了clean_inactive后就需要设置ignore_older，且要保证ignore_older &lt; clean_inactive
ignore_older: 70h

# 限制 CPU和内存资源
max_procs: 1 # 限制一个CPU核心,避免过多抢占业务资源
queue.mem.events: 256 # 存储于内存队列的事件数，排队发送 (默认4096)
queue.mem.flush.min_events: 128 # 小于 queue.mem.events ,增加此值可提高吞吐量 (默认值2048)

# 启动 filebeat
$ systemctl start filebeat
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><h2 id="十一、部署-curator-定时清理es索引"> 十一、部署 curator，定时清理es索引</h2>
<h3 id="logstash3-机器操作"> logstash3 机器操作</h3>
<div><pre><code># 参考链接：https://www.elastic.co/guide/en/elasticsearch/client/curator/current/yum-repository.html

# 安装 curator 服务，以 centos7 为例
$ rpm --import https://packages.elastic.co/GPG-KEY-elasticsearch

$ vim /etc/yum.repos.d/elk-curator-5.repo

[curator-5]
name=CentOS/RHEL 7 repository for Elasticsearch Curator 5.x packages
baseurl=https://packages.elastic.co/curator/5/centos/7
gpgcheck=1
gpgkey=https://packages.elastic.co/GPG-KEY-elasticsearch
enabled=1

$ yum install elasticsearch-curator -y

# 创建 curator 配置文件目录与输出日志目录
$ mkdir -p /data/ELKStack/curator/logs
$ cd /data/ELKStack/curator

$ vim config.yml

---
# Remember, leave a key empty if there is no value.  None will be a string,
# # not a Python &quot;NoneType&quot;
client:
  hosts: [&quot;192.168.134.6&quot;, &quot;192.168.134.103&quot;, &quot;192.168.134.168&quot;, &quot;192.168.134.240&quot;, &quot;192.168.134.185&quot;]
  port: 9200
  url_prefix:
  use_ssl: False
  certificate:
  client_cert:
  client_key:
  ssl_no_validate: False
  http_auth: elastic:elastic123
  timeout: 150
  master_only: False

logging:
  loglevel: INFO
  logfile: /data/ELKStack/curator/logs/curator.log
  logformat: default
  blacklist: [&#39;elasticsearch&#39;, &#39;urllib3&#39;]

$ vim action.yml

---
# Remember, leave a key empty if there is no value.  None will be a string,
# not a Python &quot;NoneType&quot;
#
# Also remember that all examples have &#39;disable_action&#39; set to True.  If you
# want to use this action as a template, be sure to set this to False after
# copying it.
actions:
  1:
    action: delete_indices
    description: &gt;-
      Delete indices older than 30 days. Ignore the error if the filter does not result in an actionable list of indices (ignore_empty_list) and exit cleanly.
    options:
      ignore_empty_list: True
      disable_action: False
    filters:
    - filtertype: pattern
      kind: regex
      value: &#39;^((?!(kibana|json|monitoring|metadata|apm|async|transform|siem|security)).)*$&#39;
    - filtertype: age
      source: creation_date
      direction: older
      #timestring: &#39;%Yi-%m-%d&#39;
      unit: days
      unit_count: 30
  2:
    action: delete_indices
    description: &gt;-
      Delete indices older than 15 days. Ignore the error if the filter does not result in an actionable list of indices (ignore_empty_list) and exit cleanly.
    options:
      ignore_empty_list: True
      disable_action: False
    filters:
    - filtertype: pattern
      kind: regex
      value: &#39;^(nginx-).*$&#39;
    - filtertype: age
      source: creation_date
      direction: older
      #timestring: &#39;%Yi-%m-%d&#39;
      unit: days
      unit_count: 15

# 设置定时任务清理es索引
$ crontab -e

0 0 * * * /usr/bin/curator --config /data/ELKStack/curator/config.yml /data/ELKStack/curator/action.yml
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br></div></div><h2 id="十二、参考链接"> 十二、参考链接</h2>
<ul>
<li>es证书配置：https://cloud.tencent.com/developer/article/1549834</li>
<li>es忘记密码找回：https://www.cnblogs.com/woshimrf/p/docker-es7.html</li>
<li>es设置密码：https://blog.csdn.net/extraordinarylife/article/details/107917764?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&amp;spm=1001.2101.3001.4242</li>
<li>elk-kafka部署 1：https://www.codenong.com/cs106056710/</li>
<li>elk-kafka部署 2：https://www.cnblogs.com/lz0925/p/12061293.html</li>
<li>elk优化：https://www.clxz.top/2020/06/19/elk-kafka-optimization/</li>
<li>es7索引分片：https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html</li>
<li>filebeat优化：https://www.jianshu.com/p/389702465461</li>
<li>kafka数据与日志清理：https://blog.csdn.net/VIP099/article/details/106257561</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">在Docker容器中运行Elasticsearch，Kibana和Cerebro</title>
    <id>https://clay-wangzhi.com/monitor/elk/install/docker-elk/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/install/docker-elk/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在docker容器中运行elasticsearch-kibana和cerebro"> 在Docker容器中运行Elasticsearch，Kibana和Cerebro</h1>
<h2 id="elastic-stack-与docker-容器"> Elastic Stack 与Docker 容器</h2>
<ul>
<li>Elastic官方提供Docker Image</li>
<li>如果安装定制的插件，可以写Dockerfile，将官方Image设为Base Image</li>
<li>2018年12月加入CNCF，提供helm</li>
<li>2019年5月，7.1版本发布，同时发布ECK，免费提供Elastic Operator on Kubernetes</li>
</ul>
<h2 id="编写dockerfile"> 编写dockerfile</h2>
<p>vim docker-compose.yaml</p>
<div><pre><code>version<span>:</span> <span>'2.2'</span>
services<span>:</span>
  cerebro<span>:</span>
    image<span>:</span> lmenezes/cerebro<span>:</span>0.8.3
    container_name<span>:</span> cerebro
    ports<span>:</span>
      <span>-</span> <span>"9000:9000"</span>
    command<span>:</span>
      <span>-</span> <span>-</span>Dhosts.0.host=http<span>:</span>//elasticsearch<span>:</span>9200
    networks<span>:</span>
      <span>-</span> es7net
  kibana<span>:</span>
    image<span>:</span> docker.elastic.co/kibana/kibana<span>:</span>7.1.0
    container_name<span>:</span> kibana7
    environment<span>:</span>
      <span>-</span> I18N_LOCALE=zh<span>-</span>CN
      <span>-</span> XPACK_GRAPH_ENABLED=true
      <span>-</span> TIMELION_ENABLED=true
      <span>-</span> XPACK_MONITORING_COLLECTION_ENABLED=<span>"true"</span>
    ports<span>:</span>
      <span>-</span> <span>"5601:5601"</span>
    networks<span>:</span>
      <span>-</span> es7net
  elasticsearch<span>:</span>
    image<span>:</span> docker.elastic.co/elasticsearch/elasticsearch<span>:</span>7.1.0
    container_name<span>:</span> es7_01
    environment<span>:</span>
      <span>-</span> cluster.name=geektime
      <span>-</span> node.name=es7_01
      <span>-</span> bootstrap.memory_lock=true
      <span>-</span> <span>"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span>
      <span>-</span> discovery.seed_hosts=es7_01<span>,</span>es7_02
      <span>-</span> cluster.initial_master_nodes=es7_01<span>,</span>es7_02
    ulimits<span>:</span>
      memlock<span>:</span>
        soft<span>:</span> <span>-</span>1
        hard<span>:</span> <span>-</span>1
    volumes<span>:</span>
      <span>-</span> es7data1<span>:</span>/usr/share/elasticsearch/data
    ports<span>:</span>
      <span>-</span> 9200<span>:</span>9200
    networks<span>:</span>
      <span>-</span> es7net
  elasticsearch2<span>:</span>
    image<span>:</span> docker.elastic.co/elasticsearch/elasticsearch<span>:</span>7.1.0
    container_name<span>:</span> es7_02
    environment<span>:</span>
      <span>-</span> cluster.name=geektime
      <span>-</span> node.name=es7_02
      <span>-</span> bootstrap.memory_lock=true
      <span>-</span> <span>"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span>
      <span>-</span> discovery.seed_hosts=es7_01<span>,</span>es7_02
      <span>-</span> cluster.initial_master_nodes=es7_01<span>,</span>es7_02
    ulimits<span>:</span>
      memlock<span>:</span>
        soft<span>:</span> <span>-</span>1
        hard<span>:</span> <span>-</span>1
    volumes<span>:</span>
      <span>-</span> es7data2<span>:</span>/usr/share/elasticsearch/data
    networks<span>:</span>
      <span>-</span> es7net


volumes<span>:</span>
  es7data1<span>:</span>
    driver<span>:</span> local
  es7data2<span>:</span>
    driver<span>:</span> local

networks<span>:</span>
  es7net<span>:</span>
    driver<span>:</span> bridge
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br></div></div><h2 id="启动-关闭"> 启动/关闭</h2>
<ul>
<li>启动</li>
</ul>
<p><code>cd</code>到<code>docker-compose.yaml</code>所在目录，然后启动</p>
<div><pre><code>docker-compose up 
</code></pre>
<div><span>1</span><br></div></div><p>分别访问服务器的9200,9000,5601端口</p>
<ul>
<li>关闭</li>
</ul>
<div><pre><code>docker-compose down
</code></pre>
<div><span>1</span><br></div></div><p><strong>Cerebro简介</strong></p>
<p>可以用来监控es集群的状态，非常好用，推荐</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Kibana的安装和界面快速浏览</title>
    <id>https://clay-wangzhi.com/monitor/elk/install/quick-browse/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/install/quick-browse/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="kibana的安装和界面快速浏览"> Kibana的安装和界面快速浏览</h1>
<h2 id="安装运行"> 安装运行</h2>
<p>下载地址：</p>
<blockquote>
<p>https://www.elastic.co/cn/downloads/kibana</p>
</blockquote>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567761679082.png" alt="" /></p>
<p>解压并安装运行</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567761719575.png" alt="" /></p>
<h2 id="kibana-console"> Kibana Console</h2>
<ul>
<li>Dev Tool</li>
<li>Search Profiler</li>
<li>Help + 一些快捷键
<ul>
<li>cmd + / (查看API帮助文档)</li>
<li>cmd + option + I</li>
<li>cmd + option + 0</li>
<li>cmd + option + shift + 0</li>
</ul>
</li>
</ul>
<h2 id="kibana-pulgins"> Kibana Pulgins</h2>
<p>常用命令</p>
<div><pre><code>bin/kibana-plugin <span>install</span> /usr/plugin_location
bin/kibana-plugin list
bin/kibana remove
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="用kibana解决日志时间乱序问题"> 用Kibana解决日志时间乱序问题</h2>
<p>可以按照偏移量，和主机名进行排序</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Elasticsearch的安装和简单配置</title>
    <id>https://clay-wangzhi.com/monitor/elk/install/sample-install/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/install/sample-install/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="elasticsearch的安装和简单配置"> Elasticsearch的安装和简单配置</h1>
<h2 id="安装"> 安装</h2>
<h3 id="安装java"> 安装JAVA</h3>
<ul>
<li>运维Elasticsearch，需要安装并配置JDK，设置$JAVA_HOME</li>
<li>各个版本对Java的依赖
<ul>
<li>Elasticsearch 5 需要Java8以上的版本</li>
<li>Elasticsearch 从6.5开始支持Java11</li>
<li>7.0 开始，内置了Java环境</li>
</ul>
</li>
</ul>
<h3 id="安装elasticsearch"> 安装Elasticsearch</h3>
<ul>
<li>下载二进制文件</li>
</ul>
<blockquote>
<p>https://www.elastic.co/cn/downloads/elasticsearch</p>
</blockquote>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567741507169.png" alt="" /></p>
<p>安装并运维Elasticsearch</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567741543204.png" alt="" /></p>
<h2 id="配置"> 配置</h2>
<h3 id="elasticsearch的文件目录结构"> Elasticsearch的文件目录结构</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567741696333.png" alt="" /></p>
<h3 id="jvm配置"> JVM配置</h3>
<ul>
<li>修改JCM - config/jvm.options
<ul>
<li>7.3 下载的默认设置是1GB</li>
</ul>
</li>
<li>配置的建议
<ul>
<li>Xmx和Xms设置成一样</li>
<li>Xmx不要超过机器内存的50%</li>
<li>不要超过30GB</li>
</ul>
</li>
</ul>
<h2 id="运行"> 运行</h2>
<h3 id="运行单个实例"> 运行单个实例</h3>
<div><pre><code>bin/elasticsearch -E node.name<span>=</span>node0 -E node.name<span>=</span>node0 -E cluster.name<span>=</span>geektime -E path.data<span>=</span>node0_data
</code></pre>
<div><span>1</span><br></div></div><h3 id="运行多个实例"> 运行多个实例</h3>
<div><pre><code>bin/elasticsearch -E node.name<span>=</span>node1 -E cluster.name<span>=</span>geektime -E path.data<span>=</span>node1_data -d
bin/elasticsearch -E node.name<span>=</span>node2 -E cluster.name<span>=</span>geektime -E path.data<span>=</span>node2_data -d
bin/elasticsearch -E node.name<span>=</span>node2 -E cluster.name<span>=</span>geektime -E path.data<span>=</span>node2_data -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>访问 http://localhost:9200 check cluster health state</li>
<li>通过 http://localhost:9200_cat/nodes?v 查看节点</li>
</ul>
<h3 id="安装与查看插件"> 安装与查看插件</h3>
<div><pre><code>bin/elasticsearch-plugin <span>install</span> analysis-icu
bin/elasticsearch-plugin list
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>Elasticsearch提供插件的机制对系统进行扩展
<ul>
<li>Discovery Plugin</li>
<li>Analysis Plugin</li>
<li>Security Plugin</li>
<li>Management Plugin</li>
<li>Ingest Plugin</li>
<li>Mapper Plugin</li>
<li>Backup Plugin</li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">基本概念</title>
    <id>https://clay-wangzhi.com/monitor/elk/primer/basic/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/primer/basic/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="基本概念"> 基本概念</h1>
<ul>
<li>Index索引
<ul>
<li>Type类型</li>
<li>Document文档</li>
</ul>
</li>
<li>Node节点
<ul>
<li>shard分片</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567998428921.png" alt="1567998428921" /></p>
<h2 id="文档-document"> 文档（Document）</h2>
<ul>
<li>Elasticsearch是面向文档的，文档时所有可搜索数据的最小单位
<ul>
<li>日志文件中的日志项</li>
<li>一本电影的具体信息/一张唱片的详细信息</li>
<li>MP3播放器里的一首歌/一篇PDF文档中的具体内容</li>
</ul>
</li>
<li>文档会被序列化成JSON格式，保存在Elasticsearch中
<ul>
<li>JSON对象由字段组成</li>
<li>每个字段都有对应的字段类型（字符串/数值/布尔/日期/二进制/范围类型）</li>
</ul>
</li>
<li>每个文档都有一个Unique ID
<ul>
<li>你可以自己制定ID</li>
<li>或者通过Elasticsearch自动生成</li>
</ul>
</li>
</ul>
<h3 id="json文档"> JSON文档</h3>
<ul>
<li>一篇文档包含了一系列的字段，类似数据库表中一条记录</li>
<li>JSON文档，格式灵活，不需要预先定义格式
<ul>
<li>字段的类型可以指定或通过Elasticsearch自动推算</li>
<li>支持数组/支持嵌套</li>
</ul>
</li>
</ul>
<h3 id="文档的元数据"> 文档的元数据</h3>
<ul>
<li>元数据，用于标注文档的相关信息
<ul>
<li>_index : 文档所属的索引名</li>
<li>_type：文档所属的类型名</li>
<li>_id：文档唯一id</li>
<li>_source：文档的原始JSON数据</li>
<li>_all：整合所有字段内容到该字段，已被废除</li>
<li>_version：文档的版本信息</li>
<li>_score：相关性打分</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567998936909.png" alt="" /></p>
<h2 id="索引-index"> 索引（Index）</h2>
<ul>
<li>索引时文档的容器，是一类文档的结合
<ul>
<li>Index体现了逻辑空间的概念：每个索引都有自己的Mapping定义，用于定义包含的文档的字段名和字段类型</li>
<li>shard体现了物理空间的概念：索引中的数据分散在Shard上</li>
</ul>
</li>
<li>索引的Mapping与Settings
<ul>
<li>Mapping定义文档字段的类型</li>
<li>Setting定义不同的数据分布</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567999265615.png" alt="" /></p>
<h3 id="索引的不通语意"> 索引的不通语意</h3>
<ul>
<li>名词：一个Elasticsearch集群中，可以创建很多个不同的索引</li>
<li>动词：保存一个文档到Elasticsearch的过程也叫索引（Indexing）
<ul>
<li>ES中，创建一个倒排索引的过程</li>
</ul>
</li>
<li>在日常中的名词的含义：一个B树索引，一个倒排索引</li>
</ul>
<h3 id="type"> Type</h3>
<ul>
<li>在7.0之前，一个Index可以设置多个Types</li>
<li>6.0开始，Type已经被Deprecated。7.0开始，一个索引只能创建一个Type - &quot;_doc&quot;</li>
</ul>
<h2 id="与关系型数据库的类比"> 与关系型数据库的类比</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567999614563.png" alt="" /></p>
<p>区别：</p>
<ul>
<li>Elasticsearch - Schemaless / 相关性（算分）/ 高性能全文检索</li>
<li>RDMS - 事务性 / Join</li>
</ul>
<h2 id="分布式相关概念"> 分布式相关概念</h2>
<h3 id="可用性和扩展性"> 可用性和扩展性</h3>
<ul>
<li>高可用性
<ul>
<li>服务可用性 - 允许有节点停止服务</li>
<li>数据可用性 - 部分节点丢失，不会丢失数据</li>
</ul>
</li>
<li>可扩展性
<ul>
<li>请求量提升  / 数据的不断增长 （将数据分布到所有节点上）</li>
</ul>
</li>
</ul>
<h3 id="elasticsearch的分布式"> Elasticsearch的分布式</h3>
<ul>
<li>Elasticsearch的分布式架构的好处
<ul>
<li>存储的水平扩容</li>
<li>提高系统的可用性，部分节点停止服务，整个集群的服务不受影响</li>
</ul>
</li>
<li>Elasticsearch的分布式架构
<ul>
<li>不同的集群通过不同的名字来区分，默认名字&quot;Elasticsearch&quot;</li>
<li>通过配置文件修改，或者在命令行中 -E cluster.name=geektime 进行设定</li>
<li>一个集群可以有一个或者多个节点</li>
</ul>
</li>
</ul>
<h2 id="节点-node"> 节点（Node）</h2>
<ul>
<li>节点是一个Elasticsearch的实例
<ul>
<li>本质上就是一个JAVA进程</li>
<li>一台机器上可以运行多个Elasticsearch进程，但是生产环境一般建议一台机器上只运行一个Elasticsearch实例</li>
</ul>
</li>
<li>每一个节点都有名字，通过配置文件配置，或者启动时候指定 -E node.m=name=node1</li>
<li>每一个节点在启动之后，会分配一个UID，保存在data目录下</li>
</ul>
<h3 id="master-eligible-nodes-和-masternode"> Master-eligible nodes 和 Masternode</h3>
<ul>
<li>每个节点启动后，默认就是一个Master eligible节点
<ul>
<li>可以设置node.master：false禁止</li>
</ul>
</li>
<li>Master-eligible节点可以参见选主流程，成为Master节点</li>
<li>当一个节点启动时候，它会将自己选举成Master节点</li>
<li>每个节点上都保存了集群的状态，只有Master节点才能修改集群的状态信息
<ul>
<li>集群状态（Cluster State），维护了一个集群中，必要的信息
<ul>
<li>所有的节点信息</li>
<li>所有的索引和其相关的Mapping与Setting信息</li>
<li>分片的路由信息</li>
</ul>
</li>
<li>任意节点都能修改信息会导致数据的不一致性</li>
</ul>
</li>
</ul>
<h3 id="data-node-coordinating-node"> Data node &amp; Coordinating Node</h3>
<ul>
<li>Data Node
<ul>
<li>可以保存数据的节点，叫做Data Node。负责保存分片数据，在数据扩展上起到了至关重要的作用</li>
</ul>
</li>
<li>Coordinating Node
<ul>
<li>负责接受Client的请求，将请求发到合适的节点，最终把结果汇集到一起</li>
<li>每个节点默认都起到了Coordinating Node的职责</li>
</ul>
</li>
</ul>
<h3 id="其他的节点类型"> 其他的节点类型</h3>
<ul>
<li>Hot &amp; Warm Node
<ul>
<li>不通硬件配置的Data Node，用来实现Hot &amp; Warm架构，降低集群部署的成本</li>
</ul>
</li>
<li>Machine Learning Node
<ul>
<li>负责跑机器学习的Job，用来做异常检测</li>
</ul>
</li>
<li>Tribe Node
<ul>
<li>（5.3 开始使用Cross Cluster Search）Tribe Node连接到不同的Elasticsearch集群，并且支持将这些集群当成一个单独的集群处理</li>
</ul>
</li>
</ul>
<h3 id="配置节点类型"> 配置节点类型</h3>
<ul>
<li>开发环境中一个节点可以承担多种角色</li>
<li>生产环境中，应该设置单一的角色的节点（dedicated node）</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568006607109.png" alt="" /></p>
<h2 id="分片-shard"> 分片（Shard）</h2>
<ul>
<li>主分片，用以解决数据水平扩展的问题。通过主分片，可以将数据分布到集群内的所有节点之上
<ul>
<li>一个分片是一个运行的Lucene的实例</li>
<li>主分片数在索引创建时指定，后续不允许修改，出发Reindex</li>
</ul>
</li>
<li>副本，用以解决数据高可用的问题。分布是主分片的拷贝
<ul>
<li>副本分片数，可以动态调整</li>
<li>增加副本数，还可以在一定程度上提高服务的可用性（读取的吞吐）</li>
</ul>
</li>
</ul>
<p>示例：一个三个节点的集群中，blogs索引的分片分布情况</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568007457411.png" alt="" /></p>
<h3 id="分片的设定"> 分片的设定</h3>
<ul>
<li>
<p>对于生产环境中分片的设定，需要提前做好容量规划</p>
<ul>
<li>分片数设置过小
<ul>
<li>导致后续无法增加节点实现水平扩展</li>
<li>单个分片的数据量太大，导致数据重新分配耗时</li>
</ul>
</li>
<li>分片数设置过大，7.0开始，默认主分片设置成1，解决了over-sharding的问题
<ul>
<li>影响搜索结果的相关性打分，影响统计结果的准确性</li>
<li>单个节点上过多的分片，会导致资源浪费，同时也会影响性能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="查看集群的健康状况"> 查看集群的健康状况</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568009261188.png" alt="" /></p>
<ul>
<li>Green - 主分片与副本都正常分配</li>
<li>Yellow - 主分片全部正常分配，有副本分片未能正常分配</li>
<li>Red - 有主分片未能分配
<ul>
<li>例如，当服务器的磁盘容量超过85%时，去创建了一个新的索引</li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">文档的基本操作CRUP与批量操作</title>
    <id>https://clay-wangzhi.com/monitor/elk/primer/crup/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/primer/crup/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="文档的基本操作crup与批量操作"> 文档的基本操作CRUP与批量操作</h1>
<h2 id="文档的crud"> 文档的CRUD</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568013522348.png" alt="" /></p>
<ul>
<li>Type名，约定都用_doc</li>
<li>Create - 如果ID已经存在，会失败</li>
<li>Index - 如果ID不存在，创建新的文档。否则，先删除现有的文档，再创建现有的文档，再创建新的文档，版本会增加</li>
<li>Update - 文档必须已经存在，更新只会对相应字段做增量修改</li>
</ul>
<h3 id="create一个文档"> Create一个文档</h3>
<ul>
<li>支持自动生产文档id和指定文档id两种方式</li>
<li>通过调用&quot;post /users/_doc&quot;
<ul>
<li>系统会自动生产document id</li>
</ul>
</li>
<li>使用HTTP PUT user/create/1创建时，URI中显示指定_create，此时如果该id的文档已经存在，操作失败</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568015379663.png" alt="" /></p>
<h3 id="get一个文档"> Get一个文档</h3>
<ul>
<li>找到文档，返回HTTP 200
<ul>
<li>文档元信息
<ul>
<li>_index / _type /</li>
<li>版本信息，同一个id的文档，即使被删除，version号也会不断增加</li>
<li>_source中默认包含了文档的所有原始信息</li>
</ul>
</li>
</ul>
</li>
<li>找不到文档，返回HTTP 404</li>
</ul>
<h3 id="index-文档"> Index 文档</h3>
<ul>
<li>Index和Create不一样的地方：如果文档不存在，就索引新的文档。否则现有文档会被删除，新的文档被索引。版本信息+1</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568015891907.png" alt="" /></p>
<h3 id="update文档"> Update文档</h3>
<ul>
<li>Update方法不会删除原来的文档，而是实现真正的数据更新</li>
<li>Post方法 / Payload需要包含在&quot;doc&quot;中</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568016019747.png" alt="" /></p>
<h2 id="api的批量操作"> API的批量操作</h2>
<h3 id="bulk-api"> Bulk API</h3>
<ul>
<li>支持在一次API调用中，对不同的索引进行操作</li>
<li>支持四种类型操作
<ul>
<li>Index</li>
<li>Create</li>
<li>Update</li>
<li>Delete</li>
</ul>
</li>
<li>可以在URI中指定Index，也可以在请求的Payload中进行</li>
<li>操作中单条操作失败，并不会影响其他操作</li>
<li>返回结果包括了每一条操作执行的结果</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568017190479.png" alt="" /></p>
<h3 id="批量读取-mget"> 批量读取 - mget</h3>
<p>批量操作，可以减少网络连接所产生的开销，提高性能</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568018531224.png" alt="" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568018545981.png" alt="" /></p>
<h3 id="批量查询-msearch"> 批量查询 - msearch</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568018796705.png" alt="" /></p>
<h2 id="常见的错误返回"> 常见的错误返回</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568018899854.png" alt="" /></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">倒排索引入门</title>
    <id>https://clay-wangzhi.com/monitor/elk/primer/inverted-index/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/primer/inverted-index/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="倒排索引入门"> 倒排索引入门</h1>
<h2 id="正排与倒排索引"> 正排与倒排索引</h2>
<ul>
<li>在一本书的开始，有一个目录 - 正排</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568083459813.png" alt="" /></p>
<ul>
<li>在一本书的最后，有一个索引页 - 倒排</li>
</ul>
<p>根据关键词查看内容所在页</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568083528241.png" alt="" /></p>
<h3 id="图书和索引引擎的类比"> 图书和索引引擎的类比</h3>
<ul>
<li>图书
<ul>
<li>正排索引 - 目录页</li>
<li>倒排索引 - 索引页</li>
</ul>
</li>
<li>索引引擎
<ul>
<li>正排索引 - 文档id到文档内容和单词的关联</li>
<li>倒排索引 - 单词到文档id的关联</li>
</ul>
</li>
</ul>
<h3 id="举例"> 举例</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568084661010.png" alt="" /></p>
<h2 id="倒排索引"> 倒排索引</h2>
<h3 id="倒排索引的核心组成"> 倒排索引的核心组成</h3>
<ul>
<li>
<p>倒排索引包含两个部分</p>
<ul>
<li>单词词典（Term Dictionary）,记录所有文档的单词，记录单词到倒排列表的关联关系
<ul>
<li>单词词典一般比较大，可以通过B + 树或哈希拉链法实现，以满足高性能的插入与查询</li>
</ul>
</li>
<li>倒排列表（Posting List）,记录了单词对应的文档组合，由倒排索引项组成
<ul>
<li>倒排索引项（Posting）
<ul>
<li>文档ID</li>
<li>词频 TF - 该单词在文档中出现的次数，用户相关性评分</li>
<li>位置（Position）- 单词在文档中分词的位置。用于语句搜索（phrase query）</li>
<li>偏移（Offset）- 记录单词的开始结束位置，实现高亮显示</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="举例-2"> 举例</h3>
<p>Elasticsearch的在文档内容的索引</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568085534232.png" alt="" /></p>
<h3 id="elasticsearch的倒排索引"> Elasticsearch的倒排索引</h3>
<ul>
<li>Elasticsearch的JSON文档中的每个字段，都有自己的倒排索引</li>
<li>可以指定对某些字段不做索引
<ul>
<li>优点：节省存储空间</li>
<li>缺点： 字段无法被搜索</li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">通过分析器进行分词</title>
    <id>https://clay-wangzhi.com/monitor/elk/primer/participle/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/primer/participle/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="通过分析器进行分词"> 通过分析器进行分词</h1>
<h2 id="analysis"> Analysis</h2>
<h3 id="analysis与analyzer"> Analysis与Analyzer</h3>
<ul>
<li>Analysis - 文本分析是把全文本转换一系列单词（term/token）的过程，也叫分词</li>
<li>Analysis是通过Analyzer来实现的
<ul>
<li>可使用Elasticsearch内置的分析器/或者按需定制化分析器</li>
</ul>
</li>
<li>除了在数据写入时转换词条，匹配Query语句时候也需要用相同的分析器对查询语句进行分析</li>
</ul>
<h3 id="analyzer的组成"> Analyzer的组成</h3>
<ul>
<li>分词器是专门处理分词的组件，Analyzer由三部分组成
<ul>
<li>Character Filters（针对原始文本处理，例如去除html）/ Tokenizer（按照规则切分为单词）/ Token Filter（将切分的单词进行加工，小写，删除stopwords，增加同义词）</li>
</ul>
</li>
</ul>
<p>举例</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568094953293.png" alt="" /></p>
<h2 id="elasticsearch的内置分词器"> Elasticsearch的内置分词器</h2>
<ul>
<li>Standard Analyzer - 默认分词器，按词切分，小写处理</li>
<li>Simple Analyzer - 按照非字母切分（符号被过滤），小写处理</li>
<li>Stop Analyzer - 小写处理，停用词过滤（the ，a，is）</li>
<li>Whitespace Analyzer - 按照空格切分，不转小写</li>
<li>Keyword Analyzer - 不分词，直接将输入当做输出</li>
<li>Patter Analyzer - 正则表达式，默认\W+（非字符分隔）</li>
<li>Language - 提供了30多种常见语言的分词器</li>
<li>Customer Analyzer  - 自定义分词器</li>
</ul>
<h3 id="使用-analyzer-api"> 使用_analyzer API</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568095742575.png" alt="" /></p>
<h2 id="中文分词"> 中文分词</h2>
<h3 id="分文分词的难点"> 分文分词的难点</h3>
<ul>
<li>中文句子，切分成一个一个词（不是一个个字）</li>
<li>英文中，单词有自然的空格作为分隔</li>
<li>一句中文，在不同的上下文，有不同的理解
<ul>
<li>这个苹果，不大好吃 / 这个苹果，不大，好吃！</li>
</ul>
</li>
</ul>
<h3 id="icu-analyzer"> ICU Analyzer</h3>
<ul>
<li>需要安装plugin
<ul>
<li>Elasticsearch-plugin install analysis-icu</li>
</ul>
</li>
<li>提供了Unicode的支持，更好的支持亚洲语言</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568096106355.png" alt="" /></p>
<p>举例</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568096123515.png" alt="" /></p>
<h3 id="常用的中文分词器"> 常用的中文分词器</h3>
<ul>
<li>IK
<ul>
<li>支持自定义词库，支持热更新分词字典</li>
<li>https://github.com/medcl/elasticsearch-analysis-ik</li>
</ul>
</li>
<li>THUlAC
<ul>
<li>THU Lexucal Analyzer for Chinese，清华大学自然语言处理和社会人文计算实验室的一套中文分词器</li>
<li>https://github.com/microbun/elasticsearch-thulac-plugin</li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Request Body和Query DSL简介</title>
    <id>https://clay-wangzhi.com/monitor/elk/primer/req-body/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/primer/req-body/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="request-body和query-dsl简介"> Request Body和Query DSL简介</h1>
<h2 id="request-body-search"> Request Body Search</h2>
<ul>
<li>将查询语句通过HTTP Request Body发送给Elasticsearch</li>
<li>Query DSL</li>
</ul>
<p>举例</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568169039971.png" alt="" /></p>
<h3 id="分页"> 分页</h3>
<ul>
<li>From从0开始，默认返回10个结果</li>
<li>获取靠后的翻页成本较高</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568169125069.png" alt="" /></p>
<h3 id="排序"> 排序</h3>
<ul>
<li>最好在&quot;数字型&quot;与&quot;日期型&quot;字段上排序
<ul>
<li>因为对于多值类型或分析过的字段排序，系统会选一个值，无法得知该值</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568170207936.png" alt="" /></p>
<h3 id="source-filtering"> _source filtering</h3>
<ul>
<li>如果_source没有存储，那就只返回匹配的文档的元数据</li>
<li>_source支持使用通配符_source[&quot;name*&quot;,&quot;desc*&quot;]</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568191600446.png" alt="" /></p>
<h3 id="脚本字段"> 脚本字段</h3>
<ul>
<li>用例：订单中有不同的汇率，需要结合汇率对，订单价格进行排序</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568191768549.png" alt="" /></p>
<h3 id="使用查询表达式-match"> 使用查询表达式 - Match</h3>
<ul>
<li>默认使用term类型，或的关系</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568191830422.png" alt="" /></p>
<ul>
<li>可以指定操作类型为AND</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568191867781.png" alt="" /></p>
<h3 id="短语搜索-match-phrase"> 短语搜索 - Match Phrase</h3>
<ul>
<li>slop参数表示，允许各个单词之间插入的单词个数</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568192076860.png" alt="" /></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">URI Search详解</title>
    <id>https://clay-wangzhi.com/monitor/elk/primer/search-api-de/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/primer/search-api-de/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="uri-search详解"> URI Search详解</h1>
<h2 id="通过uri-query实现搜索"> 通过URI query实现搜索</h2>
<ul>
<li>q 指定查询语句，使用Query String Syntax</li>
<li>df 指定默认字段，不指定时会对所有字段进行查询</li>
<li>Sort排序 / from 和size用于分页</li>
<li>Profile 可以查看查询是如何被执行的</li>
</ul>
<h3 id="query-string-syntax"> Query String Syntax</h3>
<ul>
<li>指定字段 v.s 泛查询
<ul>
<li>q=title:2012  /   q=2012</li>
</ul>
</li>
<li>Term v.s Phrase
<ul>
<li>Beautiful Mind 等效于 Beautiful OR Mind</li>
<li>&quot;Beautiful Mind&quot;等效于Beautiful AND Mind。Phrase查询，还要求前后顺序保持一致</li>
</ul>
</li>
<li>分组与引号
<ul>
<li>title:(Beautiful AND Mind)   - term查询要用&quot;()&quot;括起来</li>
<li>title=&quot;Beautiful Mind&quot; - phrase查询要用&quot;&quot;双引号</li>
</ul>
</li>
<li>布尔操作
<ul>
<li>AND 、OR、NOT或者 &amp;&amp; 、||、！
<ul>
<li>必须大写</li>
</ul>
</li>
</ul>
</li>
<li>分组
<ul>
<li>+ 表示must</li>
<li>- 表示must_not</li>
</ul>
</li>
<li>范围查询
<ul>
<li>区间表示：[]闭区间，{}开区间
<ul>
<li>year:{2018 TO 2019}</li>
<li>year:[* TO 2018]</li>
</ul>
</li>
</ul>
</li>
<li>算数符号
<ul>
<li>year:&gt;2010</li>
<li>year:(&gt;2010 &amp;&amp; &lt;=2018)</li>
<li>year:(+&gt;2010 -&lt;2018)</li>
</ul>
</li>
<li>通配符查询（通配符查询效率低，占用内存大，不建议使用。特别是放在最前面）
<ul>
<li>？代表1个字符，* 代表0或多个字符
<ul>
<li>title:mi?d</li>
<li>title:be*</li>
</ul>
</li>
</ul>
</li>
<li>正则表达
<ul>
<li>title:[bt]oy</li>
</ul>
</li>
<li>模糊匹配与近似查询
<ul>
<li>title:befutifl~1</li>
<li>title:&quot;lord rings&quot;~2
<ul>
<li>表示lord 和rings之间可以存在两个单词</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Search API概览</title>
    <id>https://clay-wangzhi.com/monitor/elk/primer/search-api/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/primer/search-api/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="search-api概览"> Search API概览</h1>
<h2 id="search-api"> Search API</h2>
<ul>
<li>URI Search
<ul>
<li>在URL中使用查询参数</li>
</ul>
</li>
<li>Request Body Search
<ul>
<li>使用Elasticsearch提供的，基于JSON格式的更加完备的Query Domain Specific Language （DSL）</li>
</ul>
</li>
</ul>
<h3 id="指定查询的索引"> 指定查询的索引</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568097742808.png" alt="" /></p>
<h3 id="uri查询"> URI查询</h3>
<ul>
<li>使用&quot;q&quot;，指定查询字符串</li>
<li>&quot;query string syntax&quot;，KV键值对</li>
</ul>
<p>举例</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568097928424.png" alt="" /></p>
<h3 id="request-body"> Request Body</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568098031540.png" alt="" /></p>
<h3 id="搜索response字段说明"> 搜索Response字段说明</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568098178099.png" alt="" /></p>
<h2 id="衡量相关性"> 衡量相关性</h2>
<ul>
<li>Information Retrieval（检索）
<ul>
<li>Rrecision（查准率） - 尽可能返回较少的无关文档</li>
<li>Recall （查全率）- 尽量返回较多的相关文档</li>
<li>Ranking - 是否能够按照相关度进行排序</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1568098803331.png" alt="" /></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">ELK</title>
    <id>https://clay-wangzhi.com/monitor/elk/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="elk"> ELK</h1>
<p>hello elk~</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">第十一章 循环与分支</title>
    <id>https://clay-wangzhi.com/code/shell/part3/11_loops_and_branches/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/11_loops_and_branches/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第十一章-循环与分支"> 第十一章 循环与分支</h1>
<blockquote>
<p>奥赛罗夫人，您为什么把这句话说了又说呢？</p>
<p>—— 《奥赛罗》，莎士比亚</p>
</blockquote>
<h3 id="本章目录"> 本章目录</h3>
<ul>
<li><a href="./11_1_loops.html">11.1 循环</a></li>
<li><a href="./11_2_nested_loops.html">11.2 嵌套循环</a></li>
<li><a href="./11_3_loop_control.html">11.3 循环控制</a></li>
<li><a href="./11_4_testing_and_branching.html">11.4 测试与分支</a></li>
</ul>
<p>对代码块的处理是结构化和构建 shell 脚本的关键。循环与分支结构恰好提供了这样一种对代码块处理的工具。</p>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">Elasticsearch 简介及其发展历史</title>
    <id>https://clay-wangzhi.com/monitor/elk/summarize/develop/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/summarize/develop/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="elasticsearch-简介及其发展历史"> Elasticsearch 简介及其发展历史</h1>
<h2 id="从开源到上市"> 从开源到上市</h2>
<ul>
<li>2018年10月纽交所上市，Elastic Inc -开源软件/上市公司</li>
<li>当前市值超过50亿美金，开盘当天涨幅达94%</li>
<li>Elasticsearch软件下载量，超3.5亿次</li>
<li>10万+的社区成员</li>
<li>7200+订阅用户，分布在100+国家</li>
<li>云服务平台的接入- Elastic，Amazon，阿里巴巴，腾讯</li>
</ul>
<h2 id="elasticsearch的诞生"> Elasticsearch的诞生</h2>
<ul>
<li>2004年Shay Banon基于Lucene开发了Compass</li>
<li>2010年Shay Banon重写了Compass，取名Elasticsearch</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567739412739.png" alt="" /></p>
<h3 id="lucene简介"> Lucene简介</h3>
<ul>
<li>基于Java语言开发的搜索引擎库类</li>
<li>创建于1999年，2005年成为Apache顶级开源项目</li>
<li>Lucene具有高性能、易扩张的优点</li>
<li>Lucene的局限性：
<ul>
<li>只能基于Java语言开发</li>
<li>类库的接口学习曲线陡峭</li>
<li>原生并不支持水平扩展</li>
</ul>
</li>
</ul>
<h3 id="elasticsearch的特性"> Elasticsearch的特性</h3>
<ul>
<li>
<p>近实时（Near Real Time）</p>
</li>
<li>
<p>分布式存储/搜索/分析引擎</p>
</li>
<li>
<p>支持多中方式集成接入</p>
<ul>
<li>多种编程语言的类库</li>
<li>RESTful API</li>
<li>JDBC &amp; ODBC</li>
</ul>
</li>
</ul>
<h3 id="elasticsearch的分布式架构"> Elasticsearch的分布式架构</h3>
<ul>
<li>集群规模可以从单个扩展到数百个节点</li>
<li>高可用 &amp; 水平扩展
<ul>
<li>服务和数据的两个纬度</li>
</ul>
</li>
<li>支持不同的节点类型
<ul>
<li>支持 Hot &amp; Warm架构</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567737803003.png" alt="" /></p>
<h3 id="elasticsearch版本与升级"> Elasticsearch版本与升级</h3>
<ul>
<li>0.4：2010年2月第一次发布</li>
<li>1.0：2014年1月</li>
<li>2.0：2015年10月</li>
<li>5.0：2016年10月</li>
<li>6.0：2017年10月</li>
<li>7.0：2019年4月</li>
</ul>
<h4 id="新特性5-x"> 新特性5.X</h4>
<ul>
<li>Lucene6.x，性能提升，默认打分机制从TF-IDF改为BM25</li>
<li>支持Ingest节点/Painless Scripting/Compltion suggested支持/原生的Java REST客户端</li>
<li>Type标记成deprecad，支持了Keyword的类型</li>
<li>性能优化
<ul>
<li>内部引擎移除了避免同一文档并发更新的竞争锁，带来15%~20%的性能提升</li>
<li>Instant aggregation，支持分片上聚合的缓存</li>
<li>新增了Profile API</li>
</ul>
</li>
</ul>
<h4 id="新特性6-x"> 新特性6.X</h4>
<ul>
<li>Lucene 7.X</li>
<li>新功能
<ul>
<li>跨集群复制（CCR）</li>
<li>索引生命周期管理</li>
<li>SQL的支持</li>
</ul>
</li>
<li>更友好的升级及数据迁移
<ul>
<li>在主要版本之间的迁移更为简化，体验升级</li>
<li>全新的基于操作的数据复制框架，可加快数据恢复</li>
</ul>
</li>
<li>性能优化
<ul>
<li>有效存储稀疏字段的新方法，降低了存储成本</li>
<li>在索引时进行排序，可加快排序的查询性能</li>
</ul>
</li>
</ul>
<h4 id="新特性7-x"> 新特性7.X</h4>
<ul>
<li>Lucene 8.0</li>
<li>重大改进 - 正式废除单个索引下多Type的支持</li>
<li>7.1 开始，Security功能免费使用</li>
<li>ECK - Elasticsearch Operator on Kubernetes</li>
<li>新功能
<ul>
<li>New Cluster coordination</li>
<li>Feature - Complete High Level REST Client</li>
<li>Script Score Query</li>
</ul>
</li>
<li>性能优化
<ul>
<li>默认的Primary Shard数从5改为1，避免Over Sharding</li>
<li>性能优化，更快的Top K</li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">聊透监控体系</title>
    <id>https://clay-wangzhi.com/monitor/monitor-system/</id>
    <link href="https://clay-wangzhi.com/monitor/monitor-system/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="聊透监控体系"> 聊透监控体系</h1>
<p>经济高速发展的今天，我们处于信息大爆炸的时代。随着经济发展，信息借助互联网的力量在全球自由地流动，于是就催生了各种各样的服务平台和软件系统。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1579057066348.webp" alt="img" /></p>
<p>由于业务的多样性，这些平台和系统也变得异常的复杂。如何对其进行监控和维护是我们 IT 人需要面对的重要问题。就在这样一个纷繁复杂地环境下，监控系统粉墨登场了。</p>
<p>今天，我们会对 IT 监控系统进行介绍，包括其功能，分类，分层；同时也会介绍几款流行的监控平台。</p>
<h2 id="监控系统的功能"> 监控系统的功能</h2>
<p>在 IT 运维过程中，常遇到这样的情况：</p>
<ul>
<li>某个业务模块出现问题，运维人员并不知道，发现的时候问题已经很严重了。</li>
<li>系统出现瓶颈了，CPU 占用持续升高，内存不足，磁盘被写满；网络请求突增，超出网关承受的压力。</li>
</ul>
<p>以上这些问题一旦发生，会对我们的业务产生巨大的影响。因此，每个公司或者 IT 团队都会针对此类情况建立自己的 IT 监控系统。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1579057079481.webp" alt="img" /></p>
<p>监控系统工作流程图</p>
<p>其功能包括：</p>
<ul>
<li>对服务，系统，平台的运行状态实时监控</li>
<li>收集服务，系统，平台的运行信息</li>
<li>通过收集信息的分析结果，预知存在的故障风险，并采取行动</li>
<li>根据对风险的评估，进行故障预警</li>
<li>一旦发生故障，第一时间发出告警信息</li>
<li>通过监控数据，定位故障，协助生成解决方案</li>
<li>最终保证系统持续、稳定、安全运行</li>
<li>监控数据可视化，便于统计，按照一定周期导出、归档，用于数据分析和问题复盘</li>
</ul>
<h2 id="监控系统的分类"> 监控系统的分类</h2>
<p>既然监控系统我们意义重大，针对不同场景把监控系统分为三类，分别是：</p>
<ul>
<li><strong>日志类</strong></li>
<li><strong>调用链类</strong></li>
<li><strong>度量类</strong></li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/quan.jpg" alt="" /></p>
<h3 id="日志类-logging"> 日志类(Logging)</h3>
<p>通常我们在系统和业务级别上加入一些日志代码，记录一些日志信息，方便我们在发现问题的时候查找。</p>
<p>这些信息会与事件做相关，例如：用户登录，下订单，用户浏览某件商品，一小时以内的网关流量，用户平均响应时间等等。</p>
<p>这类以日志的记录和查询的解决方案比较多。比如 ELK 方案（Elasticsearch+Logstash+Kibana），使用ELK（Elasticsearch、Logstash、Kibana）+Kafka/Redis/RabbitMQ 来搭建一个日志系统。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1579057091787.webp" alt="img" /></p>
<p>ELK 结合 Redis/Kafka/RabbitMQ 实现日志类监控</p>
<p>程序内部通过 Spring AOP 记录日志，Beats 收集日志文件，然后用 Kafka/Redis/RabbitMQ 将其发送给 Logstash，Logstash 再将日志写入 Elasticsearch。</p>
<p>最后，使用 Kibana 将存放在 Elasticsearch 中的日志数据显示出来，形式可以是实时数据图表。</p>
<h3 id="调用链类-tracing"> 调用链类(Tracing)</h3>
<p>对于服务较多的系统，特别是微服务系统。一次服务的调用有可能涉及到多个服务。A 调用 B，B 又要调用 C，好像一个链条一样，形成了服务调用链。</p>
<p>调用链就是记录一个请求经过所有服务的过程。请求从开始进入服务，经过不同的服务节点后，再返回给客户端，通过调用链参数来追踪全链路行为。从而知道请求在哪个环节出了故障，系统的瓶颈在哪儿。</p>
<p>调用链监控的实现原理如下：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1579057103643.webp" alt="img" /></p>
<p>Java 代码运行原理图</p>
<p>在介绍这种方式之前，我们先来复习一下 Java 代码运行的原理。通常我们会把 Java 源代码，通过“Java 编译器”编译成 Class 文件。再把这个 Class 的字节码文件装载到“类装载器”中进行字节码的验证。</p>
<p>最后，把验证过后的字节码发送到“Java 解释器”和“及时编译器”交给“Java 运行系统”运行。</p>
<p>Java 探针，字节码增强的方式就是利用 Java 代理，这个代理是运行方法之前的拦截器。</p>
<p>在 JVM 加载 Class 二进制文件的时候，利用 ASM 动态的修改加载的 Class 文件，在监控的方法前后添加需要监控的内容。</p>
<p>例如：添加计时语句，用于记录方法耗时。将方法耗时存入处理器，利用栈先特性（先进后出）处理方法调用顺序。</p>
<p>每当请求处理结束后，将耗时方法和入参 map 输出到文件中，然后根据 map 中相应参数，区分出耗时业务。</p>
<p>最后将相应耗时文件取下来，转化为 xml 格式并进行解析，通过浏览器将代码分层结构展示出来。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1579057113936.webp" alt="img" /></p>
<p>Java 探针工具原理图</p>
<p>备注：ASM 是一个 Java 字节码操纵框架，它可以动态生成类或者增强既有类的功能。</p>
<p>ASM 可以直接产生二进制 Class 文件，可以在类被载入 Java 虚拟机之前改变类行为。</p>
<p>Java Class 被存储在 .class文件里，文件拥有元数据来解析类中的元素：类名称、方法、属性以及 Java 字节码（指令）。</p>
<p>ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够生成新类。</p>
<p><strong>②拦截请求</strong></p>
<p>获取每次请求服务中的信息来实现跟踪的。这里以 Zipkin+Slueth 为例说明其原理。</p>
<p>Sleuth 提供链路追踪。由于一个请求会涉及到多个服务的互相调用，而这种调用往往成链式结构，经过多次层层调用以后请求才会返回。常常使用 Sleuth 追踪整个调用过程，方便理清服务间的调用关系。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1579057123079.webp" alt="img" /></p>
<p>Sleuth 服务调用追踪图例</p>
<p>每次请求都会生成一个 Trace ID，如上图所示这个 Trace ID 在整个 Request 和 Response 过程中都会保持一致，不论经过了多少个服务。这是为了方便记录一次调用的整个生命周期。</p>
<p>再看每次请求的时候都会有一个 Span ID，这里的 Span 是 Sleuth 服务跟踪的最小单元，每经过一个服务，每次 Request 和 Response 这个值都会有所不同，这是为了区分不同的调用动作。</p>
<p>针对每个调用的动作，Sleuth 都做了标示如下：</p>
<ul>
<li>Server Received 是服务器接受，也就是服务端接受到请求的意思。</li>
<li>Client Sent 是客户端发送，也就是这个服务本身不提供响应，需要调用其他的服务提供该响应，所以这个时候是作为客户端发起请求的。</li>
<li>Server Sent 是服务端发送，看上图SERVICE 3 收到请求后，由于他是最终的服务提供者，所以作为服务端，他需要把请求发送给调用者。</li>
<li>Client Received 是客户端接受，作为发起调用的客户端接受到服务端返回的请求。</li>
</ul>
<p>实际上 Sleuth 就是通过上述方式把每次请求记录一个统一的 Trace ID，每个请求的详细步骤记作 Span ID。</p>
<p>每次发起请求或者接受请求的状态分别记录成 Server Received，Client Sent，Server Sent，Client Received 四种状态来完成这个服务调用链路的跟踪的。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1579057133775.webp" alt="img" /></p>
<p>在调用服务的链路上每个被调用的服务节点都会通过 Parent ID 来记录发起调用服务的 Span ID，由于 Span ID 是唯一确认最小服务单元的，所以知道了 Parent 的 Span ID 也就知道了谁调用自己了。</p>
<h3 id="度量类-metrics"> 度量类(Metrics)</h3>
<p>实现了时序数据库（TimeSeriesData，TSD）的监控方案。实际上就是记录一串以时间为维度的数据，然后再通过聚合运算，查看指标数据和指标趋势。说白了，就是描述某个被测主体在一段时间内的测量值变化（度量）。</p>
<p>由于 IT 基础设施，运维监控和互联网监控的特性，这种方式被广泛应用。一般对时序数据进行建模分为三个部分，分别是：主体，时间点和测量值。</p>
<p>通过这个例子来看一下，时序数据库的数学模型，例如：需要监控服务器的 In/Out 平均流量：</p>
<ul>
<li>整个监控的数据库称为“Metric”，它包含了所有监控的数据。类似关系型数据库中的 Table。</li>
<li>每条监控数据，称为“Point”，类似于关系型数据库中的 Row 的概念。</li>
<li>每个“Point”都会定义一个时间戳“Timestamp”，将其作为索引，表明数据采集的时间。</li>
<li>“Tag”作为维度列，表示监控数据的属性。</li>
<li>“Field”作为指标列，作为测量值，也就是测量的结果。</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1579057144929.webp" alt="img" /></p>
<p>时序数据库数据模型图例</p>
<p>时序数据库的存储原理，关系型数据库存储采用的是 B tree，虽然降低了数据查询的磁盘寻道时间，但是无法解决大量数据写入时的磁盘效率。</p>
<p>由于监控系统的应用场景，经常会遇到大批量的数据写入，所以我们会选择 LSMtree（Log Structured Merge Tree）存储时序数据库。</p>
<p>LSMtree（Log Structured Merge Tree），从字面意义上理解，记录的数据按照日志结构（Log Structured）追加到系统中，然后通过合并树（Merge Tree）的方式将其合并。</p>
<p>来看一个 LevelDB 的例子，方便我们理解，LSM-tree 被分成三种文件：</p>
<ul>
<li>接收写入请求的 memtable 文件（内存中）</li>
<li>不可修改的 immutable memtable 文件（内存中）</li>
<li>磁盘上的 SStable文件（Sorted String Table），有序字符串表，这个有序的字符串就是数据的key。SStable 一共有七层（L0 到 L6）。下一层的总大小限制是上一层的 10 倍。</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1579057158151.webp" alt="img" /></p>
<p>LSMtree LevelDB 存储示意图</p>
<p>LSMtree 写入流程：</p>
<ul>
<li>将数据追加到日志 WAL（Write Ahead Log）中，写入日志的目的是为了防止内存数据丢失，可以及时恢复。</li>
<li>把数据写到 memtable 中。</li>
<li>当 memtable 满了（超过一定阀值），就将这个 memtable 转入 immutable memtable 中，用新的 memtable 接收新的数据请求。</li>
<li>immutablememtable 一旦写满了， 就写入磁盘。并且先存储 L0 层的 SSTable 磁盘文件，此时还不需要做文件的合并。每层的所有文件总大小是有限制的（8MB，10MB，100MB… 1TB）。从 L1 层往后，每下一层容量增大十倍。</li>
<li>某一层的数据文件总量超过阈值，就在这一层中选择一个文件和下一层的文件进行合并。
如此这般上层的数据都是较新的数据，查询可以从上层开始查找，依次往下，并且这些数据都是按照时间序列存放的。</li>
</ul>
<h2 id="监控系统的分层"> 监控系统的分层</h2>
<p>谈完了监控系统的分类，再来聊聊监控系统的分层。用户请求到数据返回，经历系统中的层层关卡。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640-1579057169317.webp" alt="img" /></p>
<p>一般我们将监控系统分为五层来考虑，当然也有人分成三层，大致的意思都差不多，仅供参考：</p>
<ul>
<li><strong>客户端监控</strong>，用户行为信息，业务返回码，客户端性能，运营商，版本，操作系统等。</li>
<li><strong>业务层监控</strong>，核心业务的监控，例如：登录，注册，下单，支付等等。</li>
<li><strong>应用层监控</strong>，相关的技术参数，例如：URL 请求次数，Service 请求数量，SQL 执行的结果，Cache 的利用率，QPS 等等。</li>
<li><strong>系统层监控</strong>，物理主机，虚拟主机以及操作系统的参数。例如：CPU 利用率，内存利用率，磁盘空间情况。</li>
<li><strong>网络层监控</strong>，网络情况参数。例如：网关流量情况，丢包率，错包率，连接数等等。</li>
</ul>
<h2 id="流行的监控系统"> 流行的监控系统</h2>
<p>前面讲了监控系统的功能，分类，分层，相信大家对 IT 监控系统都有一定的了解了。</p>
<p>接下来，我们来看看有哪些优秀实践。这里介绍两个比较流行的监控系统：</p>
<ul>
<li><strong>Zabbix</strong></li>
<li><strong>Prometheus</strong></li>
</ul>
<h3 id="zabbix"> Zabbix</h3>
<p>Zabbix 是一款企业级的分布式开源监控方案。它由 Alexei Vladishev 创建，由 Zabbix SIA 在持续开发和支持。</p>
<p>Zabbix 能够监控网络参数，服务器健康和软件完整性。它提供通知机制，允许用户配置告警，从而快速反馈问题。</p>
<p>基于存储的数据，Zabbix 提供报表和数据可视化，并且支持主动轮询和被动捕获。它的所有报告、统计信息和配置参数都可以通过 Web 页面访问。</p>
<p>Zabbix 的 API 功能，完善度很高，大部分操作都提供了 API 接口，方便和现有系统整合。</p>
<p>例如：通过历史数据查询 API，获取线上服务器使用情况，生成报表；设置条件，对问题服务器和问题业务进行筛选，加入告警。</p>
<p>利用 Zabbix graph 的 API，生成关键指标趋势图，方便运维人员实时了解系统情况。利用告警添加 API，让监控系统和部署系统联动。</p>
<p>比如新部署了一个新实例，那么自动添加所需要的监控策略；反之，下线一个实例，就删除关联的监控策略。</p>
<p>Zabbix 由 Server，Agent，Proxy（可选项）组成：</p>
<ul>
<li>Agent 负责收集数据，并且传输给 Server。</li>
<li>Server 负责接受 Agent 的数据，进行保存或者告警。</li>
<li>Proxy 负责代理 Server 收集 Agent 传输的数据，并且转发给 Server。Proxy 是安装在被监控的服务器上的，用来和 Server 端进行通信，从而传输数据。</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/zabbix.webp" alt="img" /></p>
<p>Zabbix 部署模式</p>
<p>Zabbix 的数据采集，主要有两种模式：Server 主动拉取数据和 Agent 主动上报数据。</p>
<p>以 Server 拉取数据为例，用户在 Web-portal 中，设置需要监控的机器，配置监控项，告警策略。Zabbix-Server 会根据策略主动获取 Agent 的数据，然后存储到 MySQL 中。</p>
<p>同时根据用户配置的策略，判定是否需要告警。用户可以在 Web 端，以图表的形式，查看各种指标的历史趋势。</p>
<p>在 Zabbix 中，将 Server 主动拉取数据的方式称之为 Active Check。这种方式配置起来较为方便，但是会对 Zabbix-Server 的性能存在影响。</p>
<p>所以在生产环境中，一般会选择主动推送数据到 Zabbix-Server 的方式，称之为 Trapper。</p>
<p>即用户可以定时生成数据，再按照 Zabbix 定义的数据格式，批量发送给 Zabbix-Server，这样可以大大提高 Server 的处理能力。</p>
<p>Proxy，作为可选项，起到收集 Agent 数据并且转发到 Server 的作用。</p>
<p>当 Server 和 Agent 不在一个网络内，就需要使用 Proxy 做远程监控，特别是远程网络有防火墙的时候。同时它也可以分担 Server 的压力，降低 Server 处理连接数的开销。</p>
<h3 id="prometheus-普罗米修斯"> Prometheus（普罗米修斯）</h3>
<p>随着这几年云环境的发展，Prometheus 被广泛地认可。它的本质是时间序列数据库，而 Zabbix 采用 MySQL 进行数据存储。</p>
<p>从上面我们对时间序列数据库的分析来看，Prometheus 能够很好地支持大量数据的写入。</p>
<p>它采用拉的模式（Pull）从应用中拉取数据，并通过 Alert 模块实现监控预警。据说单机可以消费百万级时间序列。</p>
<p>一起来看看 Prometheus 的几大组件：</p>
<ul>
<li><strong>Prometheus Server</strong>，用于收集和存储时间序列数据，负责监控数据的获取，存储以及查询。</li>
<li><strong>监控目标配置</strong>，Prometheus Server 可以通过静态配置管理监控目标，也可以配合 Service Discovery（K8s，DNS，Consul）实现动态管理监控目标。</li>
<li><strong>监控目标存储</strong>，Prometheus Server 本身就是一个时序数据库，将采集到的监控数据按照时间序列存储在本地磁盘中。</li>
<li><strong>监控数据查询</strong>，Prometheus Server 对外提供了自定义的 PromQL 语言，实现对数据的查询以及分析。</li>
<li><strong>Client Library</strong>，客户端库。为需要监控的服务生成相应的 Metrics 并暴露给 Prometheus Server。
当 Prometheus Server 来 Pull 时，直接返回实时状态的 Metrics。通常会和 Job 一起合作。</li>
<li><strong>Push Gateway</strong>，主要用于短期的 Jobs。由于这类 Jobs 存在时间较短，可能在 Prometheus 来 Pull 之前就消失了。为此，这些 Jobs 可以直接向 Prometheus Server 端推送它们的 Metrics。</li>
<li><strong>Exporters</strong>，第三方服务接口。将 Metrics（数据集合）发送给 Prometheus。
Exporter 将监控数据采集的端点，通过 HTTP 的形式暴露给 Prometheus Server，使其通过 Endpoint 端点获取监控数据。</li>
<li><strong>Alertmanager</strong>，从 Prometheus Server 端接收到 Alerts 后，会对数据进行处理。例如：去重，分组，然后根据规则，发出报警。</li>
<li><strong>Web UI</strong>，Prometheus Server 内置的 Express Browser UI，通过 PromQL 实现数据的查询以及可视化。</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/prome.webp" alt="img" /></p>
<p>Prometheus 架构图</p>
<p>说完了 Prometheus 的组件，再来看看 Prometheus 的架构：</p>
<ul>
<li>Prometheus Server 定期从 Jobs/Exporters 中拉 Metrics。同时也可以接收来自 Pushgateway 发过来的 Metrics。</li>
<li>Prometheus Server 将接受到的数据存储在本地时序数据库，并运行已定义好的 alert.rules（告警规则），一旦满足告警规则就会向 Alertmanager 推送警报。</li>
<li>Alertmanager 根据配置文件，对接收到的警报进行处理，例如：发出邮件告警，或者借助第三方组件进行告警。</li>
<li>WebUI/Grafana/APIclients，可以借助 PromQL 对监控数据进行查询。</li>
</ul>
<p>最后将两个工具进行比较如下：</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/za-pr-duibi.webp" alt="img" /></p>
<p>Zabbix 和 Prometheus 比较图</p>
<p>从上面的比较可以看出：</p>
<ul>
<li>Zabbix 的成熟度更高，上手更快。高集成度导致灵活性较差，在监控复杂度增加后，定制难度会升高。而且使用的关系型数据库，对于大规模的监控数据插入和查询是个问题。</li>
<li>Prometheus 上手难度大，定制灵活度高，有较多数据聚合的可能，而且有时序数据库的加持。</li>
<li>对于监控物理机或者监控环境相对稳定的情况，Zabbix 有明显优势。如果监控场景多是云环境的话，推荐使用 Prometheus。</li>
</ul>
<h2 id="总结"> 总结</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/640.webp" alt="img" /></p>
<p>监控系统思维导图</p>
<p>监控系统对 IT 系统运维意义重大，从状态监控到收集/分析数据，到故障报警，以及问题解决，最后归档报表，协助运维复盘。</p>
<p>监控系统分为三大类，日志类，调用链类，度量类，他们有各自的特点，且应用场景各不相同。</p>
<p>因为要对整个 IT 系统进行监控，所以将其分为五层，分别是，客户端，业务层，应用层，系统层，网络层。</p>
<p>Zabbix 和 Prometheus 是当下流行的监控系统，可以根据他们的特点选择使用。</p>
<p>作者：崔皓
简介：十六年开发和架构经验，曾担任过惠普武汉交付中心技术专家，需求分析师，项目经理，后在创业公司担任技术/产品经理。善于学习，乐于分享。目前专注于技术架构与研发管理。</p>
<blockquote>
<p>来源：本文转自公众号”51CTO技术栈“，经平台授权转载。</p>
<p>参考其他链接：https://blog.csdn.net/javaforwork/article/details/101093901</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">6 常见问题</title>
    <id>https://clay-wangzhi.com/monitor/zabbix/qa/</id>
    <link href="https://clay-wangzhi.com/monitor/zabbix/qa/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_6-常见问题"> 6 常见问题</h1>
<h1 id="zabbix客户端日志出现-not-all-processes-could-be-identified"> Zabbix客户端日志出现(Not all processes could be identified）</h1>
<p>场景：因为使用了netstat -p参数。</p>
<p>权限问题，zabbix_agentd是zabbix用户启动的，默认不能执行netstat -p等命令，导致从服务器取到的自动发现脚本为空</p>
<p>(Not all processes could be identified, non-owned process info
will not be shown, you would have to be root to see it all.)
解决方法 ：</p>
<div><pre><code><span>chmod</span> +s /bin/netstat
</code></pre>
<div><span>1</span><br></div></div><p>chmod +s 是什么意思</p>
<blockquote>
<p>为了方便普通用户执行一些特权命令，SUID/SGID程序允许普通用户以root身份暂时执行该程序，并在执行结束后再恢复身份。</p>
</blockquote>
<h2 id="zabbix-server-log大量提示cannot-sen-list-of-active-checks-to-ip-host-hostname-not-found"> zabbix_server.log大量提示cannot sen list of active checks to &quot;IP&quot;:host [Hostname] not found</h2>
<p>zabbix server 日志大量提示上图信息 原因是 zabbix_agent.conf配置文件中配置的HostName与zabbix的web界面配置的不同导致的</p>
<p>zabbix_agent.conf里尽量不使用HostnameItem=system.hostname此项去自动获取主机名</p>
<p>尽量使用HostName指定一个主机名，然后web界面配置相同即可</p>
<p>最后重启相应的agent即可</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">1 zabbix4.4新功能</title>
    <id>https://clay-wangzhi.com/monitor/zabbix/</id>
    <link href="https://clay-wangzhi.com/monitor/zabbix/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_1-zabbix4-4新功能"> 1 zabbix4.4新功能</h1>
<p>探索Zabbix4.4新功能</p>
<blockquote>
<p>https://www.zabbix.com/cn/whats_new_4_4</p>
</blockquote>
<ul>
<li>
<p>新一代的Zabbix Agent</p>
<ul>
<li>Go语言编写</li>
<li>用于监控各种服务和应用的插件框架</li>
<li>并发检查时确保状态正常(例如，保持持续的DB连接)</li>
<li>内置时间调度器（scheduler ），支持灵活的时间间隔</li>
<li>使用批量数据传输的高效的网络使用</li>
<li>用即将支持的更多平台嵌入式替换Linux上现有的代理</li>
</ul>
</li>
<li>
<p>活动和告警功能升级：应用Webhooks和可编程逻辑</p>
<ul>
<li>该功能简化了与外部系统的双向集成，允许从Zabbix UI一键访问工单系统中的case，在聊天中创建消息等等。可使用内置的JavaScript引擎定义所有处理逻辑，与外部通知和工单系统集成得到了极大的改进。</li>
</ul>
</li>
<li>
<p>为Zabbix模板设置标准</p>
<ul>
<li>
<p>我们为模板引入了一组标准和定义明确的 <a href="https://www.zabbix.com/documentation/guidelines/templates" target="_blank" rel="noopener noreferrer">准则</a>。 对于所有模板的创建者和维护者以及所有Zabbix用户来说，统一标准非常重要。</p>
<p>对XML/JSON文件的结构进行了极大的简化，仅使用文本编辑器即可手动编辑模板。大多数现有的模板都经过了改进以适应新的标准。</p>
</li>
</ul>
</li>
<li>
<p>官方支持TimescaleDB</p>
<ul>
<li>除了MySQL、PostgreSQL、Oracle和DB2之外，我们现在正式宣布官方支持TimescaleDB。 与传统的关系数据库相比，TimescaleDB有诸多有点：近乎线性的性能水平， 支持自动即时删除旧的历史数据，更容易维护等等。</li>
</ul>
</li>
<li>
<p>监控项和触发器的知识库</p>
<ul>
<li>Zabbix 4.4提供了对监控项和触发器的更直观的描述。这些信息为工程师提供了巨大的帮助， 为他们提供了关于收集监控项的意义和目的、问题细节和触发器的解决指令等所有可能的细节。</li>
</ul>
</li>
<li>
<p>高级可视化功能</p>
<ul>
<li>
<p>仪表板和相关的小工具在许多方面得到了改进，简化了创建和管理的过程， 增加了只需单击鼠标即可修改小工具参数的功能。现在仪表板网格尺寸极佳可支持超宽屏幕和大屏幕墙。</p>
<p>问题视图小工具增强支持聚合视图，并引入了一个新的小工具来显示图形原型。</p>
<p>此外，所有小工具现在都可以在无标题模式下显示。</p>
</li>
</ul>
</li>
<li>
<p>条形图和聚合</p>
<ul>
<li>Zabbix 4.4提供了条形图，graph widget现在支持使用各种聚合函数进行数据聚合。 这两个特性的结合使得长期数据分析和容量规划变得更加容易。</li>
</ul>
</li>
<li>
<p>官方支持更多新平台</p>
<ul>
<li>SUSE Linux Enterprise Server 15</li>
<li>Debian 10</li>
<li>Raspbian 10</li>
<li>Mac OS/X</li>
<li>RHEL 8</li>
<li>用于Windows agent的MSI</li>
</ul>
<p>请参阅<a href="https://www.zabbix.com/cn/download" target="_blank" rel="noopener noreferrer">下载</a> 页面中的所有可用平台</p>
</li>
<li>
<p>云端一键部署</p>
<p>Zabbix容器或镜像已经上线以下国际主流云平台，国内版本即将依次上线：</p>
<ul>
<li>
<p><a href="https://aws.amazon.com/marketplace/pp/B07YLKJTZQ?qid=1570610512988&amp;sr=0-6&amp;ref_=srh_res_product_title" target="_blank" rel="noopener noreferrer">AWS</a></p>
</li>
<li>
<p><a href="https://azuremarketplace.microsoft.com/en-us/marketplace/apps/zabbix.zabbix_vm1?tab=Overview" target="_blank" rel="noopener noreferrer">Azure</a></p>
</li>
<li>
<p>Google Cloud Platform</p>
</li>
<li>
<p><a href="https://marketplace.digitalocean.com/apps/zabbix" target="_blank" rel="noopener noreferrer">Digital Ocean</a></p>
</li>
<li>
<p><a href="https://www.zabbix.com/cn/whats_new_4_4" target="_blank" rel="noopener noreferrer">Docker</a></p>
</li>
</ul>
</li>
<li>
<p>安全的自动注册功能</p>
<ul>
<li>Zabbix的新版本支持可选的PSK加密，用于自动注册，并为添加的主机提供自动加密设置。 现在您可以将Zabbix设置为仅使用PSK，未加密或两者都允许自动注册网络设备。</li>
</ul>
</li>
<li>
<p>预处理功能升级：高级JSONPath</p>
<ul>
<li>Zabbix现在支持JSONPath的高级排列，允许对JSON数据进行复杂的预处理，包括聚合和搜索。 预处理还可以用于低等级发现，这使得它成为一个非常强大的自动化发现工具。</li>
</ul>
</li>
<li>
<p>用户宏的描述</p>
<ul>
<li>用户宏命令是一个非常好的功能，它简化了Zabbix的配置，使大量的配置变得轻而易举。 对用户宏命令的描述支持将有助于记录每个宏命令的用途，使宏命令的管理更加容易。</li>
</ul>
</li>
<li>
<p>更高效高级的数据收集</p>
<ul>
<li>通过新的JSON格式的返回对象数组检查，WMI、JMX和ODBC相关项的数据收集和发现得到了改进。 我们还为VMWare监控增加了VMWare数据存储，为Linux平台增加了系统服务，为CSV到JSON的转换增加了新的预处理类型。</li>
</ul>
</li>
</ul>
<p><strong>Zabbix 4.4的更多新功能一览</strong></p>
<ul>
<li>
<p>来自LLD的XML数据的预处理</p>
</li>
<li>
<p>监控依赖项最大值增加到10K</p>
</li>
<li>
<p>JSONPatch预处理中增加了类型自动转换</p>
</li>
<li>
<p>主机名包含在实时导出文件中</p>
</li>
<li>
<p>Windows agent扩展到支持语言无关的性能计数器</p>
</li>
<li>
<p>在预处理错误时忽略值</p>
</li>
<li>
<p>对最新数据进行了扩展，增加了监控项操作数据</p>
</li>
<li>
<p>去除了编辑触发器描述的功能，访问更加简单</p>
</li>
<li>
<p>取消对内置媒体类型Jabber和Eztexting的支持，转而使用webhook或外部脚本</p>
</li>
<li>
<p>更新了默认仪表板</p>
</li>
<li>
<p>自动注册的主机可以指定“连接到dns”或“连接到IP”选项</p>
</li>
<li>
<p>增加了对{EVENT.ID}宏的支持，用于触发器URL的命令</p>
</li>
<li>
<p>“screen”功能取消</p>
</li>
<li>
<p>最新创建的仪表板小工具类型记忆功能，可用于后续的创建</p>
</li>
<li>
<p>每个小工具都可以配置小工具标题的可见性</p>
</li>
</ul>
<p>还有更多新功能! 有关新功能的完整列表，请参阅<a href="https://www.zabbix.com/rn/rn4.4.0" target="_blank" rel="noopener noreferrer">发布说明</a>.</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">10 Todolist</title>
    <id>https://clay-wangzhi.com/monitor/zabbix/todolist/</id>
    <link href="https://clay-wangzhi.com/monitor/zabbix/todolist/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_10-todolist"> 10 Todolist</h1>
<p>待整理链接有：</p>
<p>tomcat监控自动重启脚本：https://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247483717&amp;idx=1&amp;sn=f3404f8b58d260cf29bb465525a0c391&amp;chksm=fc004a48cb77c35e4a0646d82b015ea76ab5642c3dda935f75845de449fecb7ea64e8c501d0b&amp;scene=21#wechat_redirect</p>
<p>tomcat，jmx监控：https://www.cnblogs.com/ssgeek/p/9299273.html，</p>
<p>zabbix监控的shell脚本，你不得看看啊：https://github.com/RuslanMahotkin/zabbix</p>
<p>nginx监控和nginx自带的监控模板，不得看一下啊：https://www.cnblogs.com/lovelinux199075/p/8990538.html ， https://www.cnblogs.com/anay/p/8994290.html</p>
<p>github优秀模板：https://github.com/qiueer/zabbix/tree/master/All%20In%20One</p>
<p>zabbix 告警分组和添加远端命令</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">8 activemq监控</title>
    <id>https://clay-wangzhi.com/monitor/zabbix/zabbix-activemq/</id>
    <link href="https://clay-wangzhi.com/monitor/zabbix/zabbix-activemq/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_8-activemq监控"> 8 activemq监控</h1>
<blockquote>
<p>zabbix旧版本可以用，新版本建议用官方模板</p>
</blockquote>
<h2 id="关闭被监控端的防火墙"> 关闭被监控端的防火墙</h2>
<p>activemq  防火墙的添加还是有问题，先把防火墙给关了，它好像是后续会再产生一个随机端口，进行数据的传输</p>
<h2 id="zabbix-proxy安装java-gateway"> zabbix_proxy安装java_gateway，</h2>
<p>因为是基于JMX进行监控的</p>
<h2 id="修改配置文件"> 修改配置文件</h2>
<p>配置<code>./apache-activemq-5.11.1/conf/activemq.xml</code></p>
<p>修改broker字段： 增加useJmx=&quot;true&quot;</p>
<div><pre><code>&lt;broker useJmx=&quot;true&quot; xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot;&gt; 
</code></pre>
<div><span>1</span><br></div></div><p>修改broken字段内的managementContext节点：</p>
<div><pre><code>&lt;managementContext&gt;
            &lt;managementContext createConnector=&quot;true&quot; connectorPort=&quot;11099&quot;/&gt;
&lt;/managementContext&gt; 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>配置./apache-activemq-5.11.1/bin/activemq</p>
<p>在脚本最后添加：</p>
<div><pre><code>ACTIVEMQ_SUNJMX_START=&quot;-Dcom.sun.management.jmxremote.port=11099 &quot;
ACTIVEMQ_SUNJMX_START=&quot;$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.password.file=${ACTIVEMQ_CONF}/jmx.password&quot;
ACTIVEMQ_SUNJMX_START=&quot;$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.access.file=${ACTIVEMQ_CONF}/jmx.access&quot;
ACTIVEMQ_SUNJMX_START=&quot;$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.ssl=false&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>然后重启activemq</p>
<blockquote>
<p>增加的方式不对，添加上以后密码还是为空，后续有空查一下原因</p>
</blockquote>
<h2 id="导入模板"> 导入模板</h2>
<p>在zabbix_web中导入zbx_activemq目录下的xml文件</p>
<p>在被监控主机上增加宏设置
加入{<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 13: JMX_PASSWORD}̲，和{'>JMX_PASSWORD}，和{</span>JMX_USERNAME}，user为admin，pass为activemq</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">2 zabbix借助ansible安装</title>
    <id>https://clay-wangzhi.com/monitor/zabbix/zabbix-ans/</id>
    <link href="https://clay-wangzhi.com/monitor/zabbix/zabbix-ans/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_2-zabbix借助ansible安装"> 2 zabbix借助ansible安装</h1>
<h2 id="zabbix-server安装"> zabbix-server安装</h2>
<ol>
<li>下载roles</li>
</ol>
<div><pre><code>ansible-galaxy <span>install</span> dj-wasabi.zabbix-server
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>编写playbook</li>
</ol>
<p><code>vim new-zabbix-server.yml</code></p>
<div><pre><code>---
- hosts: zabbix-server
  become: <span>yes</span>
  vars:
    <span># mysql</span>
    <span># host memory is 16G</span>
    mysql_thread_cache_size: <span>"64"</span>
    mysql_query_cache_size: <span>"128M"</span>
    mysql_innodb_buffer_pool_size: <span>"4096M"</span>
    mysql_tmp_table_size: <span>"128M"</span>
    mysql_table_open_cache: <span>"2048"</span>
    <span># zabbix-server</span>
    zabbix_version: <span>4.4</span>
    zabbix_repo_yum:
      - name: zabbix
        description: Zabbix Official Repository - <span>$basearch</span>
        baseurl: http://mirrors.aliyun.com/zabbix/zabbix/<span>{</span><span>{</span> zabbix_version <span>}</span><span>}</span>/rhel/<span>{</span><span>{</span> ansible_distribution_major_version <span>}</span><span>}</span>/<span>$basearch</span>/
        gpgcheck: <span>0</span>
        gpgkey: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX
        state: present
      - name: zabbix-supported
        description: Zabbix Official Repository non-supported - <span>$basearch</span>
        baseurl: https://mirrors.aliyun.com/zabbix/non-supported/rhel/<span>{</span><span>{</span> ansible_distribution_major_version <span>}</span><span>}</span>/<span>$basearch</span>/
        gpgcheck: <span>0</span>
        gpgkey: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX
        state: present
    zabbix_server_startpollers: <span>12</span>
    zabbix_server_startpollersunreachable: <span>5</span>
    zabbix_server_starttrappers: <span>30</span>
    zabbix_server_startdiscoverers: <span>10</span>
    zabbix_server_housekeepingfrequency: <span>12</span>
    zabbix_server_maxhousekeeperdelete: <span>100000</span>
    zabbix_server_cachesize: 4096M
    zabbix_server_startdbsyncers: <span>20</span>
    zabbix_server_historyindexcachesize: 512M
    zabbix_server_trendcachesize: 256M
    zabbix_server_historytextcachesize: 80M
    zabbix_server_valuecachesize: 4096M
    zabbix_server_timeout: <span>30</span>
    zabbix_server_database: mysql
    zabbix_server_database_long: mysql 
    <span># zabbi-web</span>
    zabbix_url: <span>192.168</span>.165.231
    zabbix_timezone: Asia/Shanghai
  roles:
    - role: geerlingguy.mysql
    - role: geerlingguy.apache
    - role: dj-wasabi.zabbix-server
    - role: dj-wasabi.zabbix-web
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><ol start="3">
<li>安装zabbix-server</li>
</ol>
<div><pre><code>ansible-playbook -i inventory/zabbix.yml new-zabbix-server.yml
</code></pre>
<div><span>1</span><br></div></div><ol start="4">
<li>
<p>优化</p>
<p>优化磁盘，去除atime</p>
</li>
<li>
<p>注意事项</p>
<p>zabbix-web，筛选历史问题时，记得选择时间范围</p>
</li>
</ol>
<h2 id="zabbix-proxy安装"> zabbix-proxy安装</h2>
<ol>
<li>下载roles</li>
</ol>
<div><pre><code>ansible-galaxy <span>install</span> dj-wasabi.zabbix-proxy
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>编写playbook</li>
</ol>
<p><code>vim new-zabbix-proxy.yml</code></p>
<div><pre><code>---
- hosts: zabbix-proxy
  become: <span>yes</span>
  vars:
    <span># mysql</span>
    <span># host memory is 8G</span>
    mysql_thread_cache_size: <span>"64"</span>
    mysql_query_cache_size: <span>"128M"</span>
    mysql_innodb_buffer_pool_size: <span>"2048M"</span>
    mysql_tmp_table_size: <span>"64M"</span>
    mysql_table_open_cache: <span>"1024"</span>

    <span># zabbix-proxy</span>
    zabbix_server_host: <span>192.168</span>.165.231 
    zabbix_version: <span>4.4</span>
    zabbix_repo_yum:
      - name: zabbix
        description: Zabbix Official Repository - <span>$basearch</span>
        baseurl: http://mirrors.aliyun.com/zabbix/zabbix/<span>{</span><span>{</span> zabbix_version <span>}</span><span>}</span>/rhel/<span>{</span><span>{</span> ansible_distribution_major_version <span>}</span><span>}</span>/<span>$basearch</span>/
        gpgcheck: <span>0</span>
        gpgkey: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX
        state: present
      - name: zabbix-supported
        description: Zabbix Official Repository non-supported - <span>$basearch</span>
        baseurl: https://mirrors.aliyun.com/zabbix/non-supported/rhel/<span>{</span><span>{</span> ansible_distribution_major_version <span>}</span><span>}</span>/<span>$basearch</span>/
        gpgcheck: <span>0</span>
        gpgkey: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX
        state: present
    zabbix_proxy_cachesize: <span>2048</span>
    zabbix_proxy_startpollers: <span>12</span>
    zabbix_proxy_housekeepingfrequency: <span>12</span>

  roles:
    - role: geerlingguy.mysql
    - role: dj-wasabi.zabbix-proxy
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><ol start="3">
<li>安装zabbix-proxy</li>
</ol>
<div><pre><code>ansible-playbook -i inventory/zabbix.yml new-zabbix-proxy.yml
</code></pre>
<div><span>1</span><br></div></div><ol start="4">
<li>
<p>将zabbix-proxy添加到zabbix-server中</p>
<ol>
<li>
<p>) 进入zabbix的web页面，点击Administrator--&gt;Proxies--&gt;Create proxy；</p>
</li>
<li>
<p>) 填写Proxy name为主机名称，Proxy mode为Active，然后Add。</p>
<blockquote>
<p>过几十秒，看看proxy是否添加成功，查看proxy和server日志，如无成功，将proxy和server端重启一下；</p>
<p>proxy name一定要和配置文件中<code>/etc/zabbix/zabbix_proxy.conf</code>的<code>Hostname</code>一致。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="zabbix-agent安装"> zabbix-agent安装</h2>
<ol>
<li>下载roles</li>
</ol>
<div><pre><code>ansible-galaxy <span>install</span> dj-wasabi.zabbix-agent
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>编写playbook</li>
</ol>
<p><code>vim new-zabbix-agent.yml</code></p>
<div><pre><code>---
- hosts: zabbix-server
  vars:
    zabbix_version: <span>4.4</span>
    zabbix_repo_yum:
      - name: zabbix
        description: Zabbix Official Repository - <span>$basearch</span>
        baseurl: http://mirrors.aliyun.com/zabbix/zabbix/<span>{</span><span>{</span> zabbix_version <span>}</span><span>}</span>/rhel/<span>{</span><span>{</span> ansible_distribution_major_version <span>}</span><span>}</span>/<span>$basearch</span>/
        gpgcheck: <span>0</span>
        gpgkey: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX
        state: present
      - name: zabbix-supported
        description: Zabbix Official Repository non-supported - <span>$basearch</span>
        baseurl: https://mirrors.aliyun.com/zabbix/non-supported/rhel/<span>{</span><span>{</span> ansible_distribution_major_version <span>}</span><span>}</span>/<span>$basearch</span>/
        gpgcheck: <span>0</span>
        gpgkey: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX
        state: present
    zabbix_agent_server: <span>192.168</span>.165.231
    zabbix_agent_serveractive: <span>192.168</span>.165.231
    zabbix_url: http://192.168.165.231
    zabbix_api_use: <span>true</span>
    zabbix_api_create_hostgroup: <span>true</span>
    zabbix_api_create_hosts: <span>true</span>
    zabbix_api_user: Admin
    zabbix_api_pass: zabbix
    zabbix_create_host: present
    zabbix_host_groups:
      - Zabbix servers
    zabbix_link_templates:
      - Template OS Linux by Zabbix agent active
      - Template App Zabbix Server
  roles:
    - role: dj-wasabi.zabbix-agent

- hosts: hy-bes
  vars:
    zabbix_version: <span>4.4</span>
    zabbix_repo_yum:
      - name: zabbix
        description: Zabbix Official Repository - <span>$basearch</span>
        baseurl: http://mirrors.aliyun.com/zabbix/zabbix/<span>{</span><span>{</span> zabbix_version <span>}</span><span>}</span>/rhel/<span>{</span><span>{</span> ansible_distribution_major_version <span>}</span><span>}</span>/<span>$basearch</span>/
        gpgcheck: <span>0</span>
        gpgkey: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX
        state: present
      - name: zabbix-supported
        description: Zabbix Official Repository non-supported - <span>$basearch</span>
        baseurl: https://mirrors.aliyun.com/zabbix/non-supported/rhel/<span>{</span><span>{</span> ansible_distribution_major_version <span>}</span><span>}</span>/<span>$basearch</span>/
        gpgcheck: <span>0</span>
        gpgkey: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX
        state: present
    zabbix_agent_server: <span>192.168</span>.16.235,192.168.165.232
    zabbix_agent_serveractive: <span>192.168</span>.16.235,192.168.165.232
    zabbix_proxy: bes.zabbixproxy
    zabbix_url: http://192.168.165.231
    zabbix_api_use: <span>true</span>
    zabbix_api_create_hostgroup: <span>true</span>
    zabbix_api_create_hosts: <span>true</span>
    zabbix_api_user: Admin
    zabbix_api_pass: zabbix
    zabbix_create_host: present
    zabbix_host_groups:
      - hy-bes
    zabbix_link_templates:
      - Template OS Linux by Zabbix agent active
  roles:
    - role: dj-wasabi.zabbix-agent
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br></div></div><ol start="3">
<li>
<p>修改roles，添加tags</p>
<p>由于添加监控的主机数以千计，所以必须ansible执行playbook时，必须跳过不必要的判断，这样能大大减少playbook的执行时间，提高执行效率。</p>
</li>
</ol>
<ul>
<li>
<p>修改<code>/dj-wasabi.zabbix-agent/tasks/main.yml</code>，给每个操作系统添加tags，例如</p>
<div><pre><code>- name: &quot;Install the correct repository&quot;
  include: &quot;Debian.yml&quot;
  when:
    - zabbix_agent_os_family == &quot;Debian&quot;
    - not (zabbix_agent_docker | bool)
  tags:
    - zabbix-agent
    - init
    - config
    - service
    - debian
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p>最后的debian是新增的。</p>
</blockquote>
</li>
<li>
<p>修改<code>dj-wasabi.zabbix-agent/tasks/Linux.yml</code>，给DOcker增加tags，如下：</p>
<div><pre><code>- name: &quot;Install the Docker container&quot;
  include: Docker.yml
  when:
    - zabbix_agent_docker | bool
  tags:
    - docker
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p>最后两行是新增的。</p>
</blockquote>
</li>
</ul>
<ol start="4">
<li>安装</li>
</ol>
<div><pre><code> ansible-playbook -i inventory/zabbix.yml new-zabbix-agent.yml -l <span>192.168</span>.163.150 --skip-tags <span>"sangoma,debian,suse,windows,docker"</span>
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>每次新增zabbix-agent，最后安装完成，重启一下zabbix-proxy，这样proxy会尽快发现agent节点</p>
</blockquote>
<ol start="5">
<li>
<p>监控模块</p>
<p>我们采用的是zabbix主动式的监控方式，zabbix-agent主动推送数据给proxy或server，以减少server端压力。</p>
<p>我发现在新的zabbix监控中，还可以检查时间有没有同步。</p>
<p>而且还有磁盘IO的监控，就问你们棒不棒！！！</p>
<p>很棒！</p>
<blockquote>
<p>4.4中新的主动式模板中，需要将监控项system.localtime	变为enabled，否则主机的可用性为unknown</p>
</blockquote>
<p>主动式的缺点，主机宕机，知道的时间不及时，好像是30分钟。</p>
</li>
</ol>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">7 用zabbix api批量添加web监控</title>
    <id>https://clay-wangzhi.com/monitor/zabbix/zabbix-api-web/</id>
    <link href="https://clay-wangzhi.com/monitor/zabbix/zabbix-api-web/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_7-用zabbix-api批量添加web监控"> 7 用zabbix api批量添加web监控</h1>
<p>python脚本如下：</p>
<p><code>vim zabbix_agent.py</code></p>
<div><pre><code><span># ~*~ coding:utf-8 ~*~</span>
<span>from</span> zabbix_api <span>import</span> ZabbixAPI
<span>import</span> sys
<span>import</span> json

ZABBIX_SREVER <span>=</span> <span>"http://192.168.162.122"</span>
USERNAME <span>=</span> <span>"Admin"</span>
PASSWORD <span>=</span> <span>"zabbix"</span>
<span>#HOSTNAME = "sh_ylf_15"</span>
<span>#HOSTNAME = "h5_web_monitor"</span>
HOSTNAME <span>=</span> sys<span>.</span>argv<span>[</span><span>4</span><span>]</span>
urlname <span>=</span> sys<span>.</span>argv<span>[</span><span>1</span><span>]</span>
url <span>=</span> sys<span>.</span>argv<span>[</span><span>2</span><span>]</span>
delay <span>=</span> sys<span>.</span>argv<span>[</span><span>3</span><span>]</span>


<span># 登录</span>
<span>def</span> <span>login</span><span>(</span>ZABBIX_SREVER<span>,</span> USERNAME<span>,</span> PASSWORD<span>)</span><span>:</span>
    zapi <span>=</span> ZabbixAPI<span>(</span>ZABBIX_SREVER<span>)</span>
    zapi<span>.</span>login<span>(</span>USERNAME<span>,</span> PASSWORD<span>)</span>
    <span>return</span> zapi


<span># 获取主机id</span>
<span>def</span> <span>gethostid</span><span>(</span>auth<span>,</span> HOSTNAME<span>)</span><span>:</span>
    json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'host.get'</span><span>,</span> params<span>=</span><span>{</span><span>"filter"</span><span>:</span> <span>{</span><span>"host"</span><span>:</span> HOSTNAME<span>}</span><span>}</span><span>)</span>
    request <span>=</span> ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>

    <span>if</span> request<span>[</span><span>'result'</span><span>]</span><span>:</span>
        <span>return</span> request<span>[</span><span>'result'</span><span>]</span><span>[</span><span>0</span><span>]</span><span>[</span><span>'hostid'</span><span>]</span>
    <span>else</span><span>:</span>
        <span>print</span><span>(</span><span>"找不到该主机"</span><span>)</span>
        sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>


<span># 获取应用级id</span>
<span>def</span> <span>getapplicationid</span><span>(</span>auth<span>,</span> hostid<span>)</span><span>:</span>
    <span># try:</span>
    <span>#     json_obj = ZabbixAPI.json_obj(auth, 'application.create', params={"name": "Web监测","hostid": hostid})</span>
    <span>#     ZabbixAPI.do_request(auth, json_obj)</span>
    <span># except Exception as e:</span>
    <span>#     print(e)</span>
    json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'application.get'</span><span>,</span> params<span>=</span><span>{</span><span>"hostids"</span><span>:</span> hostid<span>}</span><span>)</span>
    request <span>=</span> ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
    <span>for</span> num <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> <span>len</span><span>(</span>request<span>[</span><span>'result'</span><span>]</span><span>)</span><span>)</span><span>:</span>
        <span>if</span> request<span>[</span><span>'result'</span><span>]</span><span>[</span>num<span>]</span><span>[</span><span>'name'</span><span>]</span> <span>==</span> <span>'Web'</span><span>:</span>
            <span>return</span> request<span>[</span><span>'result'</span><span>]</span><span>[</span>num<span>]</span><span>[</span><span>'applicationid'</span><span>]</span>


<span># 增加web监控</span>
<span>def</span> <span>create_web_scenario</span><span>(</span>auth<span>,</span> urlname<span>,</span> url<span>,</span> hostid<span>,</span> applicationid<span>,</span> delay<span>)</span><span>:</span>
    json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'httptest.get'</span><span>,</span> params<span>=</span><span>{</span><span>"filter"</span><span>:</span> <span>{</span><span>"name"</span><span>:</span> urlname<span>}</span><span>}</span><span>)</span>
    request <span>=</span> ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
    <span>if</span> request<span>[</span><span>'result'</span><span>]</span><span>:</span>
        <span>print</span><span>(</span><span>'该web监控已经添加过了'</span><span>)</span>
    <span>else</span><span>:</span>
        <span>try</span><span>:</span>
            json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'httptest.create'</span><span>,</span>
                                          params<span>=</span><span>{</span><span>"name"</span><span>:</span> urlname<span>,</span> <span>"hostid"</span><span>:</span> hostid<span>,</span> <span>"applicationid"</span><span>:</span> applicationid<span>,</span>
                                                  <span>"delay"</span><span>:</span> delay<span>,</span> <span>"retries"</span><span>:</span> <span>'1'</span><span>,</span> <span>"steps"</span><span>:</span> <span>[</span>
                                                  <span>{</span><span>'name'</span><span>:</span> urlname<span>,</span> <span>'url'</span><span>:</span> url<span>,</span> <span>'timeout'</span><span>:</span> <span>'10'</span><span>,</span> <span>'status_codes'</span><span>:</span> <span>'200'</span><span>,</span>
                                                   <span>'no'</span><span>:</span> <span>'1'</span><span>}</span><span>]</span><span>}</span><span>)</span>
            ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
        <span>except</span> Exception <span>as</span> e<span>:</span>
            <span>print</span><span>(</span>e<span>)</span>
            sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>


<span># 增加触发器</span>
<span>def</span> <span>create_trigger</span><span>(</span>auth<span>,</span> HOSTNAME<span>,</span> urlname<span>,</span> url<span>)</span><span>:</span>
    expression <span>=</span> <span>"{"</span> <span>+</span> <span>"{0}:web.test.fail[{1}].avg(#3)"</span><span>.</span><span>format</span><span>(</span>HOSTNAME<span>,</span> urlname<span>)</span> <span>+</span> <span>"}"</span> <span>+</span> <span>">=1"</span>
    <span>try</span><span>:</span>
        json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'trigger.create'</span><span>,</span>
                                      params<span>=</span><span>{</span><span>"description"</span><span>:</span> <span>"{0}访问失败"</span><span>.</span><span>format</span><span>(</span>urlname<span>)</span><span>,</span> <span>"expression"</span><span>:</span> expression<span>,</span>
                                              <span>"priority"</span><span>:</span> <span>5</span><span>,</span> <span>"url"</span><span>:</span> url<span>}</span><span>)</span>
        ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
    <span>except</span> Exception <span>as</span> e<span>:</span>
        <span>print</span><span>(</span>e<span>)</span>
        sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>

    expression <span>=</span> <span>"{"</span> <span>+</span> <span>"{0}:web.test.rspcode[{1},{1}].last(0)"</span><span>.</span><span>format</span><span>(</span>HOSTNAME<span>,</span> urlname<span>)</span> <span>+</span> <span>"}"</span> <span>+</span> <span>"&lt;>200"</span>
    <span>try</span><span>:</span>
        json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'trigger.create'</span><span>,</span>
                                      params<span>=</span><span>{</span><span>"description"</span><span>:</span> <span>"{0}访问异常"</span><span>.</span><span>format</span><span>(</span>urlname<span>)</span><span>,</span> <span>"expression"</span><span>:</span> expression<span>,</span>
                                              <span>"priority"</span><span>:</span> <span>4</span><span>,</span> <span>"url"</span><span>:</span> url<span>}</span><span>)</span>
        ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
    <span>except</span> Exception <span>as</span> e<span>:</span>
        <span>print</span><span>(</span>e<span>)</span>
        sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>


<span># 获取监控项id</span>
<span>def</span> <span>getitem</span><span>(</span>auth<span>,</span> hostid<span>,</span> urlname<span>)</span><span>:</span>
    json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'item.get'</span><span>,</span>
                                  params<span>=</span><span>{</span><span>"hostids"</span><span>:</span> hostid<span>,</span> <span>"webitems"</span><span>:</span> <span>"1"</span><span>,</span>
                                          <span>"filter"</span><span>:</span> <span>{</span><span>"name"</span><span>:</span> <span>"Response code for step \"$2\" of scenario \"$1\"."</span><span>,</span>
                                                     <span>"key_"</span><span>:</span> <span>"web.test.rspcode[{0},{1}]"</span><span>.</span><span>format</span><span>(</span>urlname<span>,</span> urlname<span>)</span><span>}</span><span>}</span><span>)</span>
    request <span>=</span> ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
    <span>return</span> request<span>[</span><span>"result"</span><span>]</span><span>[</span><span>0</span><span>]</span><span>[</span><span>"itemid"</span><span>]</span>


<span># 增加图形</span>
<span>def</span> <span>create_graph</span><span>(</span>auth<span>,</span> urlname<span>,</span> hostid<span>)</span><span>:</span>
    <span>try</span><span>:</span>
        itemid <span>=</span> getitem<span>(</span>auth<span>,</span> hostid<span>,</span> urlname<span>)</span>
        json_obj <span>=</span> ZabbixAPI<span>.</span>json_obj<span>(</span>auth<span>,</span> <span>'graph.create'</span><span>,</span>
                                      params<span>=</span><span>{</span><span>"name"</span><span>:</span> <span>"h5_{0}状态显示"</span><span>.</span><span>format</span><span>(</span>urlname<span>)</span><span>,</span> <span>"width"</span><span>:</span> <span>900</span><span>,</span> <span>"height"</span><span>:</span> <span>200</span><span>,</span>
                                              <span>"gitems"</span><span>:</span> <span>[</span><span>{</span><span>"itemid"</span><span>:</span> itemid<span>,</span> <span>"color"</span><span>:</span> <span>"008800"</span><span>}</span><span>]</span><span>}</span><span>)</span>
        ZabbixAPI<span>.</span>do_request<span>(</span>auth<span>,</span> json_obj<span>)</span>
    <span>except</span> Exception <span>as</span> e<span>:</span>
        <span>print</span><span>(</span>e<span>)</span>
        sys<span>.</span>exit<span>(</span><span>1</span><span>)</span>


<span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    auth <span>=</span> login<span>(</span>ZABBIX_SREVER<span>,</span> USERNAME<span>,</span> PASSWORD<span>)</span>
    hostid <span>=</span> gethostid<span>(</span>auth<span>,</span> HOSTNAME<span>)</span>
    applicationid <span>=</span> getapplicationid<span>(</span>auth<span>,</span> hostid<span>)</span>

    create_web_scenario<span>(</span>auth<span>,</span> urlname<span>,</span> url<span>,</span> hostid<span>,</span> applicationid<span>,</span> delay<span>)</span>
    create_trigger<span>(</span>auth<span>,</span> HOSTNAME<span>,</span> urlname<span>,</span> url<span>)</span>
    create_graph<span>(</span>auth<span>,</span> urlname<span>,</span> hostid<span>)</span>


<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    main<span>(</span><span>)</span>

<span># json_obj = ZabbixAPI.json_obj(auth, 'httptest.get', params={"applicationids": applicationid})</span>
<span># request = ZabbixAPI.do_request(auth, json_obj)</span>
<span># print(json.dumps(request, ensure_ascii=False, indent=4))</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br></div></div><p>编写shell，调用python，打日志</p>
<p><code>vim web_monitor.sh</code></p>
<div><pre><code><span>#!/bin/bash</span>
<span>export</span> <span><span>LANG</span></span><span>=</span><span>"en_US.UTF-8"</span>

<span>arr_hostname</span><span>=</span><span>(</span><span>"192.168.165.115"</span> <span>"192.168.9.13"</span><span>)</span>
<span>len</span><span>=</span><span>${<span>#</span>arr_hostname<span>[</span>@<span>]</span>}</span>
<span>dir</span><span>=</span><span><span>$(</span><span>cd</span> <span>$(</span>dirname $0<span>)</span> <span>&amp;&amp;</span> <span>pwd</span><span>)</span></span>
<span>tdir</span><span>=</span><span>"<span>$dir</span>/tmp"</span>

<span>dt</span><span>=</span><span><span>`</span><span>date</span> <span>"+%F %T"</span><span>`</span></span>

<span>[</span> -f <span>$tdir</span>/code_error.txt <span>]</span> <span>&amp;&amp;</span> <span>true</span> <span>></span><span>$tdir</span>/code_error.txt

<span>## i: 项目信息   j: url   k:时间间隔</span>
<span>while</span> <span>read</span> i j k o<span>;</span><span>do</span>
    <span>if</span> <span>[</span><span>[</span> <span>!</span> x<span>"<span>$o</span>"</span> <span>==</span> x<span>""</span> <span>&amp;&amp;</span> <span>$o</span> -le <span><span>$((</span>$len<span>-</span><span>1</span><span>))</span></span> <span>]</span><span>]</span><span>;</span><span>then</span>
        <span>curl</span> -s -I <span>"<span>$j</span>"</span> <span>></span> <span>$tdir</span>/curl.txt
        <span>code</span><span>=</span><span><span>`</span><span>grep</span> <span>'HTTP/1.1'</span> $tdir/curl.txt<span>|</span><span>awk</span> <span>'{print <span>$2</span>}'</span><span>`</span></span>
        <span>#echo "$i $j $code" </span>

        <span>if</span> <span>[</span> <span>$code</span> -eq <span>200</span> -o <span>$code</span> -eq <span>301</span> -o <span>$code</span> -eq <span>302</span> -o <span>$code</span> -eq <span>405</span> <span>]</span><span>;</span><span>then</span>
            python <span>$dir</span>/zabbix_agent.py <span>$i</span> <span>$j</span> <span>$k</span> <span>${arr_hostname<span>[</span>$o<span>]</span>}</span>
            <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>echo</span> <span>"<span>$dt</span> <span>$i</span> <span>$j</span> <span>$k</span> <span>$o</span> create ok"</span> <span>>></span> <span>$tdir</span>/info <span>||</span> <span>echo</span> <span>"<span>$dt</span> <span>$i</span> <span>$j</span> <span>$k</span> <span>$o</span> create fail"</span> <span>>></span><span>$tdir</span>/info
        <span>else</span>
            <span>echo</span> <span>"<span>$i</span> <span>$j</span> <span>$k</span> <span>$o</span> <span>$code</span>"</span> <span>>></span><span>$tdir</span>/code_error.txt
            <span>echo</span> <span>"<span>$i</span> <span>$code</span>"</span>
        <span>fi</span>
    <span>else</span>
        <span>echo</span> <span>"hostname参数传递错误"</span>
        <span>fi</span>
<span>done</span> <span>&lt;</span><span>$dir</span>/list
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p><code>list</code>文件内容格式如下：</p>
<div><pre><code>csp-web-syndata http://192.168.100.15:8085/csp-web-syndata/shop/synShopInfo/111 3m 0
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>参考链接：https://cloud.tencent.com/developer/article/1157571</p>
<p>https://www.zabbix.com/documentation/current/manual/api</p>
<p>https://segmentfault.com/a/1190000014241994</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">3 zabbix添加报警媒介</title>
    <id>https://clay-wangzhi.com/monitor/zabbix/zabbix-media/</id>
    <link href="https://clay-wangzhi.com/monitor/zabbix/zabbix-media/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_3-zabbix添加报警媒介"> 3 zabbix添加报警媒介</h1>
<h2 id="zabbix添加报警媒介"> zabbix添加报警媒介</h2>
<p>进入zabbix-web，点击Administrator--&gt;Media types--&gt;Create Media type</p>
<h3 id="添加email报警"> 添加Email报警</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200115103058976.png" alt="" /></p>
<h3 id="添加钉钉报警"> 添加钉钉报警</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200115103302741.png" alt="image-20200115103302741" /></p>
<p>图中Script内容如下</p>
<div><pre><code><span>try</span> <span>{</span>
    Zabbix<span>.</span><span>Log</span><span>(</span><span>4</span><span>,</span> <span>'dingding webhook script value='</span><span>+</span>value<span>)</span>
 
    <span>var</span> result <span>=</span> <span>{</span>
        <span>'tags'</span><span>:</span> <span>{</span>
            <span>'endpoint'</span><span>:</span> <span>'ding'</span>
        <span>}</span>
    <span>}</span><span>,</span>
    params <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>value<span>)</span><span>,</span>
    req <span>=</span> <span>new</span> <span>CurlHttpRequest</span><span>(</span><span>)</span><span>,</span>
    fields <span>=</span> <span>{</span><span>}</span><span>,</span>
    resp<span>;</span>
 
    req<span>.</span><span>AddHeader</span><span>(</span><span>'Content-Type: application/json'</span><span>)</span><span>;</span>
 
    fields<span>.</span>msgtype <span>=</span> params<span>.</span>msgtype<span>;</span>
    fields<span>.</span>text <span>=</span> <span>{</span>
      <span>"content"</span><span>:</span>params<span>.</span>content
    <span>}</span><span>;</span>
    resp <span>=</span> req<span>.</span><span>Post</span><span>(</span><span>'https://oapi.dingtalk.com/robot/send?access_token=1163d78d7b8a324d2f5b284414da8e93560008689744495ab4ad3eae14bdd642'</span><span>,</span>
        <span>JSON</span><span>.</span><span>stringify</span><span>(</span>fields<span>)</span>
    <span>)</span><span>;</span>
 
    <span>if</span> <span>(</span>req<span>.</span><span>Status</span><span>(</span><span>)</span> <span>!=</span> <span>201</span><span>)</span> <span>{</span>
        <span>throw</span> <span>'Response code: '</span><span>+</span>req<span>.</span><span>Status</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
 
    resp <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>resp<span>)</span><span>;</span>
    result<span>.</span>tags<span>.</span>issue_id <span>=</span> resp<span>.</span>id<span>;</span>
    result<span>.</span>tags<span>.</span>issue_key <span>=</span> resp<span>.</span>key<span>;</span>
<span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
    Zabbix<span>.</span><span>Log</span><span>(</span><span>4</span><span>,</span> <span>'jira issue creation failed json : '</span><span>+</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>{</span><span>"fields"</span><span>:</span> fields<span>}</span><span>)</span><span>)</span><span>;</span>
    Zabbix<span>.</span><span>Log</span><span>(</span><span>4</span><span>,</span> <span>'jira issue creation failed : '</span><span>+</span>error<span>)</span><span>;</span>
 
    result <span>=</span> <span>{</span><span>}</span><span>;</span>
<span>}</span>
 
<span>return</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>result<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>这个webhook添加钉钉报警，多亏了我的对象，香香大人，谢谢她！</p>
<blockquote>
<p>参考官方文档：https://www.zabbix.com/documentation/current/manual/config/notifications/media/webhook</p>
</blockquote>
<p>添加完告警媒介，就可以给用户Administrator用户，添加这两个报警媒介了。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">4 MySQL监控模块</title>
    <id>https://clay-wangzhi.com/monitor/zabbix/zabbix-mysql/</id>
    <link href="https://clay-wangzhi.com/monitor/zabbix/zabbix-mysql/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-mysql监控模块"> 4 MySQL监控模块</h1>
<blockquote>
<p>zabbix旧版本可以用，新版本建议用官方模板</p>
</blockquote>
<h2 id="template-db-mysql简介"> Template DB MySQL简介</h2>
<h3 id="应用集"> 应用集</h3>
<p>MySQL</p>
<h3 id="监控项"> 监控项</h3>
<ol>
<li>MySQL begin operations per second（MySQL每秒开始操作）</li>
<li>MySQL bytes received per second（从所有客户端接收的字节数）</li>
<li>MySQL bytes sent per second（发送到所有客户端的字节数）</li>
<li>MySQL commit operations per second（MySQL每秒提交操作）</li>
<li>MySQL delete operations per second（MySQL每秒删除操作）</li>
<li>MySQL insert operations per second（MySQL每秒插入操作）</li>
<li>MySQL queries per second（MySQL每秒查询）</li>
<li>MySQL rollback operations per second（MySQL每秒回滚操作）</li>
<li>MySQL select operations per second（MySQL每秒选择操作）</li>
<li>MySQL slow queries（MySQL慢查询）</li>
<li>MySQL status（MySQL的存活状态）</li>
<li>MySQL update operations per second（MySQL每秒更新操作）</li>
<li>MySQL uptime（MySQL正常运行时间）</li>
<li>MySQL version（MySQL的版本信息）</li>
</ol>
<h3 id="触发器"> 触发器</h3>
<p>MySQL is down</p>
<p>表达式：{Template DB MySQL:mysql.ping.last(0)}=0</p>
<h3 id="图形"> 图形</h3>
<ol>
<li>MySQL operations（MySQL业务操作）</li>
</ol>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/mysql图形1.png" alt="" /></p>
<ol start="2">
<li>MySQL bandwidth（MySQL带宽）</li>
</ol>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/mysql图形2.png" alt="" /></p>
<h3 id="聚合图形"> 聚合图形</h3>
<p>MySQL performance（MySQL性能）</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/mysql图形3.png" alt="" /></p>
<h2 id="实现mysql模板监控"> 实现MySQL模板监控</h2>
<h3 id="mysql监控授权"> MySQL监控授权</h3>
<p>配置mysql的客户端，创建一个用户来获取mysql的相关数据，使用mysql账号密码登陆数据库</p>
<div><pre><code>&gt; grant all on *.* to monitor@&#39;localhost&#39; identified by &#39;W***&#39;;
&gt; flush privileges;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="修改zabbix-agent配置文件"> 修改zabbix_agent配置文件</h3>
<ol>
<li>设置完帐户之后在被监控端新建/etc/zabbix/etc/.my.cnf以提供Zabbix Agent访问数据库，内容类似如下</li>
</ol>
<div><pre><code>#vim /etc/zabbix/etc/.my.cnf
[mysql]
host=localhost
user=monitor
password=W***
socket=/var/lib/mysql/mysql.sock
[mysqladmin]
host=localhost
user=monitor
password=W***
socket=/var/lib/mysql/mysql.sock
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>注意：agent安装路径/etc/zabbix/,etc目录若不存在，需要自已创建，创建.my.cnf,为隐藏文件。W***为mysql的密码。</li>
</ul>
<ol start="2">
<li>修改模板中的mysql路径/etc/zabbix/zabbix_agentd.d，将以下三个目录补全</li>
</ol>
<div><pre><code>#vim userparameter_mysql.conf
</code></pre>
<div><span>1</span><br></div></div><p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/mysql配置.png" alt="" /></p>
<h3 id="重启agent服务"> 重启agent服务</h3>
<div><pre><code>service zabbix_agentd restart
</code></pre>
<div><span>1</span><br></div></div><h3 id="zabbix-web设置"> zabbix-web设置</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/mysqlweb.png" alt="" /></p>
<h2 id="修改模板添加主从和连接数监控"> 修改模板添加主从和连接数监控</h2>
<h3 id="主从状态监控"> 主从状态监控</h3>
<ol>
<li>在<code>/opt/monitor</code>目录下添加主从监控脚本</li>
</ol>
<p>vim mysql_slave.sh</p>
<div><pre><code>#!/usr/bin/env bash
user=&#39;monitor&#39;
passwd=
# Seconds_Behind_Master 阈值
tho=1000

# rs为Yes成功数,sbr为同步时间差
rs=$(mysql -u&quot;$user&quot; -p&quot;$passwd&quot; -e &quot;show slave status\G;&quot; 2&gt;/dev/null | grep Running | awk &#39;{print $2}&#39; | grep -c Yes)
sbr=$(mysql -u&quot;$user&quot; -p&quot;$passwd&quot; -e &quot;show slave status\G;&quot; 2&gt;/dev/null | grep Seconds_Behind_Master | awk -F&#39;:&#39; &#39;{print $2}&#39;)

# 判断主从状态是否正常,0代表正常,1代表异常
if [ &quot;$rs&quot; -eq 2 -a &quot;$sbr&quot; -le &quot;$tho&quot; ];then
    echo 0
else
    echo $(date +&quot;%Y-%m-%d %H:%M:%S&quot;) &quot;Yes成功数为$rs&quot; &quot;延时时间为$sbr&quot; &gt;&gt; /var/log/zabbix/mysql_slave.log
    echo 1
fi
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ol start="2">
<li>在zabbix_agentd.conf中添加自定义key</li>
</ol>
<p>在<code>etc/zabbix/zabbix_agentd.conf</code>中新加</p>
<div><pre><code>UserParameter=mysql.replication,/opt/monitor/mysql_slave.sh
</code></pre>
<div><span>1</span><br></div></div><ol start="3">
<li>重启agent服务</li>
</ol>
<div><pre><code>service zabbix_agentd restart
</code></pre>
<div><span>1</span><br></div></div><ol start="4">
<li>在mysql模板中新增监控项，新增触发器，返回值不是0时，报警。</li>
</ol>
<ul>
<li>注意：当监控非主从mysql时，把此项监控禁用掉</li>
</ul>
<h2 id="连接数监控"> 连接数监控</h2>
<ol>
<li>在zabbix_agentd.conf中添加自定义key</li>
</ol>
<p>在<code>etc/zabbix/zabbix_agentd.conf</code>中新加</p>
<div><pre><code>UserParameter=mysql.linknum, ss -an | grep 3306 | grep -c ESTAB
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>重启agent服务</li>
</ol>
<div><pre><code>service zabbix_agentd restart
</code></pre>
<div><span>1</span><br></div></div><ol start="3">
<li>添加监控项和触发器</li>
</ol>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">5 Redis监控模块</title>
    <id>https://clay-wangzhi.com/monitor/zabbix/zabbix-redis/</id>
    <link href="https://clay-wangzhi.com/monitor/zabbix/zabbix-redis/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_5-redis监控模块"> 5 Redis监控模块</h1>
<blockquote>
<p>zabbix旧版本可以用，新版本建议用官方模板</p>
</blockquote>
<h2 id="模板导入"> 模板导入</h2>
<p>打开“配置”--&gt;“模板”--&gt;&quot;导入&quot;</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/redis_daoru.png" alt="" /></p>
<p>导入<code>zax_redis</code>文件夹下的<code>redis_templates_for_zbx_3.4.xml</code>文件</p>
<h2 id="配置文件导入"> 配置文件导入</h2>
<p>将<code>zax_redis</code>文件夹下的<code>userparameter_redis.conf</code>文件上传到redis服务器的<code>/etc/zabbix/zabbix_agentd.d</code>文件夹下，并根据实际情况修改<code>$HostIP</code>和<code>$Pass</code>。</p>
<h2 id="增加ss命令权限"> 增加ss命令权限</h2>
<p>因为zabbix-server端不是通过root用户进行获取数据，所以给ss命令提权</p>
<div><pre><code>chmod +s /usr/sbin/ss
</code></pre>
<div><span>1</span><br></div></div><h2 id="重启zabbix客户端"> 重启zabbix客户端</h2>
<p>修改完成后，重新启动zabbix客户端</p>
<p>centos7下</p>
<div><pre><code>systemctl restart zabbix-agent.service
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">9 zookeeper集群监控</title>
    <id>https://clay-wangzhi.com/monitor/zabbix/zabbix-zookeeper/</id>
    <link href="https://clay-wangzhi.com/monitor/zabbix/zabbix-zookeeper/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_9-zookeeper集群监控"> 9 zookeeper集群监控</h1>
<blockquote>
<p>zabbix旧版本可以用，新版本建议用官方模板</p>
</blockquote>
<h1 id="zabbix-zookeper-template"> Zabbix-Zookeper-Template</h1>
<h2 id="system-requirements"> System requirements</h2>
<ul>
<li><a href="http://www.zabbix.com/downloads/" target="_blank" rel="noopener noreferrer">zabbix</a> &gt;= 3.4 (preprocessing used by this template)</li>
<li><a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener noreferrer">zookeeper</a> &gt;= 3.4 (mntr stats)</li>
<li>netcat</li>
<li>zookeeper监控模板，被监控主机，记得添加nc命令</li>
</ul>
<h2 id="features"> Features</h2>
<ul>
<li>
<p>ruok check</p>
</li>
<li>
<p>mntr stats :</p>
<ul>
<li>zk_num_alive_connections</li>
<li>zk_approximate_data_size</li>
<li>zk_ephemerals_count</li>
<li>zk_min_latency</li>
<li>zk_avg_latency</li>
<li>zk_max_latency</li>
<li>zk_max_file_descriptor_count</li>
<li>zk_open_file_descriptor_count</li>
<li>zk_outstanding_requests</li>
<li>zk_packets_received</li>
<li>zk_packets_sent</li>
<li>zk_server_state</li>
<li>zk_version</li>
<li>zk_znode_count</li>
</ul>
</li>
<li>
<p>graphs</p>
</li>
<li>
<p>screen</p>
</li>
</ul>
<h2 id="zabbix-macros"> Zabbix Macros</h2>
<ul>
<li>{$ZOO_IP} : IP of the Zookeeper Instance (default : 127.0.0.1)</li>
<li>{$ZOO_PORT} : Port of the Zookeeper Instance (default : 2181)</li>
</ul>
<h2 id="zabbix-configuration"> Zabbix Configuration</h2>
<ol>
<li>
<p>Copy <code>UserParameter_Zookeeper.conf</code> to <code>/etc/zabbix/zabbix_agentd.d</code> folder (or whatever is default and/or configured on your system).</p>
</li>
<li>
<p>Restart your Zabbix Agent</p>
</li>
<li>
<p>Import XML template file (<code>zookeeper.xml</code>) into Zabbix via Web GUI (Configuration -&gt; Templates -&gt; Import).</p>
</li>
<li>
<p>Assign the imported template to a host, change MACROS if needed in the host parameters and enjoy!</p>
</li>
</ol>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Centos7 搭建openldap</title>
    <id>https://clay-wangzhi.com/openldap/Centos7%20%E6%90%AD%E5%BB%BAopenldap/</id>
    <link href="https://clay-wangzhi.com/openldap/Centos7%20%E6%90%AD%E5%BB%BAopenldap/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="centos7-搭建openldap"> Centos7 搭建openldap</h1>
<p>环境：</p>
<ul>
<li>
<p>centos7.6</p>
</li>
<li>
<p>openldap 2.4.44</p>
</li>
<li>
<p>phpldapadmin 1.2.3</p>
</li>
</ul>
<h2 id="安装openldap"> 安装openldap</h2>
<p>yum 安装相关包</p>
<div><pre><code>yum <span>install</span> -y openldap openldap-clients openldap-servers
</code></pre>
<div><span>1</span><br></div></div><p>复制一个默认配置到指定目录下,并授权，这一步一定要做，然后再启动服务，不然生产密码时会报错</p>
<div><pre><code><span>cp</span> /usr/share/openldap-servers/DB_CONFIG.example /var/lib/ldap/DB_CONFIG
</code></pre>
<div><span>1</span><br></div></div><p>授权给ldap用户,此用户yum安装时便会自动创建</p>
<div><pre><code>chown -R ldap. /var/lib/ldap/DB_CONFIG
</code></pre>
<div><span>1</span><br></div></div><p>启动&amp;加入开机自启</p>
<div><pre><code>systemctl start slapd
systemctl <span>enable</span> slapd
systemctl status slapd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="修改openldap配置"> 修改openldap配置</h2>
<p>这里就是重点中的重点了，从openldap2.4.23版本开始，所有配置都保存在/etc/openldap/slapd.d目录下的cn=config文件夹内，不再使用slapd.conf作为配置文件。配置文件的后缀为 ldif，且每个配置文件都是通过命令自动生成的，任意打开一个配置文件，在开头都会有一行注释，说明此为自动生成的文件，请勿编辑，使用ldapmodify命令进行修改</p>
<div><pre><code>AUTO-GENERATED FILE - DO NOT EDIT!! Use ldapmodify.
</code></pre>
<div><span>1</span><br></div></div><p>安装openldap后，会有三个命令用于修改配置文件，分别为ldapadd, ldapmodify, ldapdelete，顾名思义就是添加，修改和删除。而需要修改或增加配置时，则需要先写一个ldif后缀的配置文件，然后通过命令将写的配置更新到slapd.d目录下的配置文件中去，完整的配置过程如下，跟着我做就可以了：</p>
<ol>
<li>生成管理员密码,记录下这个密码，后面需要用到</li>
</ol>
<div><pre><code><span># slappasswd -s 123456</span>
<span>{</span>SSHA<span>}</span>LSgYPTUW4zjGtIVtuZ8cRUqqFRv1tWpE
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>密码目前只能是123456，设置其他的还是123456，不清楚原因目前</p>
</blockquote>
<p>新增修改密码文件,ldif为后缀，文件名随意，不要在/etc/openldap/slapd.d/目录下创建类似文件</p>
<p>生成的文件为需要通过命令去动态修改ldap现有配置，如下，我在家目录下，创建文件</p>
<div><pre><code># cd ~
# vim changepwd.ldif
dn: olcDatabase={0}config,cn=config
changetype: modify
add: olcRootPW
olcRootPW: {SSHA}LSgYPTUW4zjGtIVtuZ8cRUqqFRv1tWpE
# ldapadd -Y EXTERNAL -H ldapi:/// -f changepwd.ldif
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这里解释一下这个文件的内容：</p>
<ul>
<li>第一行执行配置文件，这里就表示指定为 cn=config/olcDatabase={0}config 文件。你到/etc/openldap/slapd.d/目录下就能找到此文件</li>
<li>第二行 changetype 指定类型为修改</li>
<li>第三行 add 表示添加 olcRootPW 配置项</li>
<li>第四行指定 olcRootPW 配置项的值</li>
</ul>
<p>在执行下面的命令前，你可以先查看原本的olcDatabase={0}config文件，里面是没有olcRootPW这个项的，执行命令后，你再看就会新增了olcRootPW项，而且内容是我们文件中指定的值加密后的字符串。</p>
<p>执行修改命令后，有如下输出则为正常：</p>
<p><img src="./images/20190426144821449.png" alt="img" /></p>
<p>查看olcDatabase={0}config内容,新增了一个olcRootPW项。</p>
<p><img src="./images/20190426145019794.png" alt="img" /></p>
<p>上面就是一个完整的修改配置的过程，切记不能直接修改/etc/openldap/slapd.d/目录下的配置。</p>
<ol start="2">
<li>我们需要向 LDAP 中导入一些基本的 Schema。</li>
</ol>
<p>这些 Schema 文件位于 /etc/openldap/schema/ 目录中，schema控制着条目拥有哪些对象类和属性，可以自行选择需要的进行导入。</p>
<p>依次执行下面的命令，导入基础的一些配置,我这里将所有的都导入一下，其中core.ldif是默认已经加载了的，不用导入。</p>
<div><pre><code>ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/cosine.ldif
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/nis.ldif
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/inetorgperson.ldif
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/collective.ldif
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/corba.ldif
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/duaconf.ldif
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/dyngroup.ldif
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/java.ldif
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/misc.ldif
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/openldap.ldif
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/pmi.ldif
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/ppolicy.ldif
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>修改域名，新增changedomain.ldif, 这里我自定义的域名为 schengle.com，管理员用户账号为admin。</p>
<p>如果要修改，则修改文件中相应的dc=schengle,dc=com为自己的域名。</p>
<div><pre><code># vim changedomain.ldif
dn: olcDatabase={1}monitor,cn=config
changetype: modify
replace: olcAccess
olcAccess: {0}to * by dn.base=&quot;gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth&quot; read by dn.base=&quot;cn=admin,dc=schengle,dc=com&quot; read by * none

dn: olcDatabase={2}hdb,cn=config
changetype: modify
replace: olcSuffix
olcSuffix: dc=schengle,dc=com

dn: olcDatabase={2}hdb,cn=config
changetype: modify
replace: olcRootDN
olcRootDN: cn=admin,dc=schengle,dc=com

dn: olcDatabase={2}hdb,cn=config
changetype: modify
replace: olcRootPW
olcRootPW: {SSHA}UyPmWBn2MeDFMFlJmyLycGZkNV8Mr8n9

dn: olcDatabase={2}hdb,cn=config
changetype: modify
add: olcAccess
olcAccess: {0}to attrs=userPassword,shadowLastChange by dn=&quot;cn=admin,dc=schengle,dc=com&quot; write by anonymous auth by self write by * none
olcAccess: {1}to dn.base=&quot;&quot; by * read
olcAccess: {2}to * by dn=&quot;cn=admin,dc=schengle,dc=com&quot; write by * read
# ldapmodify -Y EXTERNAL -H ldapi:/// -f changedomain.ldif
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>最后这里有5个修改，所以执行会输出5行表示成功。</p>
<p><img src="./images/20190426161145765.png" alt="img" /></p>
<ol start="3">
<li>启用memberof功能</li>
</ol>
<p>新增add-memberof.ldif, 开启memberof支持并新增用户支持memberof配置</p>
<div><pre><code># vim add-memberof.ldif
dn: cn=module{0},cn=config
cn: modulle{0}
objectClass: olcModuleList
objectclass: top
olcModuleload: memberof.la
olcModulePath: /usr/lib64/openldap

dn: olcOverlay={0}memberof,olcDatabase={2}hdb,cn=config
objectClass: olcConfig
objectClass: olcMemberOf
objectClass: olcOverlayConfig
objectClass: top
olcOverlay: memberof
olcMemberOfDangling: ignore
olcMemberOfRefInt: TRUE
olcMemberOfGroupOC: groupOfUniqueNames
olcMemberOfMemberAD: uniqueMember
olcMemberOfMemberOfAD: memberOf
# vim refint1.ldif
dn: cn=module{0},cn=config
add: olcmoduleload
olcmoduleload: refint
# vim refint2.ldif
dn: olcOverlay=refint,olcDatabase={2}hdb,cn=config
objectClass: olcConfig
objectClass: olcOverlayConfig
objectClass: olcRefintConfig
objectClass: top
olcOverlay: refint
olcRefintAttribute: memberof uniqueMember  manager owner
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>依次执行下面命令，加载配置，顺序不能错</p>
<div><pre><code>ldapadd -Q -Y EXTERNAL -H ldapi:/// -f add-memberof.ldif
ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f refint1.ldif
ldapadd -Q -Y EXTERNAL -H ldapi:/// -f refint2.ldif
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="4">
<li>创建组织和组织单元</li>
</ol>
<p>我们来创建一个叫做 schengle company 的组织，并在其下创建一个 admin 的组织角色（该组织角色内的用户具有管理整个 LDAP 的权限）和 People 和 Group 两个组织单元：</p>
<div><pre><code><span># vim base.ldif</span>
dn: <span>dc</span><span>=</span>schengle,dc<span>=</span>com
objectClass: <span>top</span>
objectClass: dcObject
objectClass: organization
o: Schengle Company
dc: schengle
 
dn: <span>cn</span><span>=</span>admin,dc<span>=</span>schengle,dc<span>=</span>com
objectClass: organizationalRole
cn: admin
 
dn: <span>ou</span><span>=</span>People,dc<span>=</span>schengle,dc<span>=</span>com
objectClass: organizationalUnit
ou: People
 
dn: <span>ou</span><span>=</span>Group,dc<span>=</span>schengle,dc<span>=</span>com
objectClass: organizationalRole
cn: Group
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><blockquote>
<p>一共执行4次下面的命令，要不然会失败，每次只执行一段</p>
</blockquote>
<p>执行命令，添加配置, 这里要注意修改域名为自己配置的域名，然后需要输入上面我们生成的密码</p>
<div><pre><code>ldapadd -x -D cn=admin,dc=schengle,dc=com -W -f base.ldif
</code></pre>
<div><span>1</span><br></div></div><p>通过以上的所有步骤，我们就设置好了一个 LDAP 目录树：其中基准 dc=schengle,dc=com 是该树的根节点，其下有一个管理域 cn=admin,dc=schengle,dc=com 和两个组织单元 ou=People,dc=schengle,dc=com 及 ou=Group,dc=schengle,dc=com。</p>
<h2 id="安装phpldapadmin"> 安装phpldapadmin</h2>
<p>ldap装好后，下面安装web界面phpldapadmin。登录phpldapadmin界面</p>
<div><pre><code><span># yum安装时，会自动安装apache和php的依赖。</span>
<span># 注意： phpldapadmin很多没更新了，只支持php5，如果你服务器的环境是php7，则会有问题，页面会有各种报错</span>
yum <span>install</span> -y phpldapadmin
 
<span># 修改apache的phpldapadmin配置文件</span>
<span># 修改如下内容，放开外网访问，这里只改了2.4版本的配置，因为centos7 默认安装的apache为2.4版本。所以只需要改2.4版本的配置就可以了</span>
<span># 如果不知道自己apache版本，执行 rpm -qa|grep httpd 查看apache版本</span>
 
<span>vim</span> /etc/httpd/conf.d/phpldapadmin.conf
-----------------------------------------------------------------
  <span>&lt;</span>IfModule mod_authz_core.c<span>></span>
    <span># Apache 2.4</span>
    Require all granted
  <span>&lt;</span>/IfModule<span>></span>
-----------------------------------------------------------------
 
 
<span># 修改配置用DN登录ldap</span>
<span>vim</span> /etc/phpldapadmin/config.php
-----------------------------------------------------------------
<span># 398行，默认是使用uid进行登录，我这里改为cn，也就是用户名</span>
<span>$servers</span>-<span>></span>setValue<span>(</span>‘login’,‘attr’,‘dn’<span>)</span><span>;</span>
// <span>$servers</span>-<span>></span>setValue<span>(</span>‘login’,‘attr’,‘uid’<span>)</span><span>;</span>
 
<span># 460行，关闭匿名登录，否则任何人都可以直接匿名登录查看所有人的信息</span>
<span>$servers</span>-<span>></span>setValue<span>(</span><span>'login'</span>,<span>'anon_bind'</span>,false<span>)</span><span>;</span>
 
<span># 519行，设置用户属性的唯一性，这里我将cn,sn加上了，以确保用户名的唯一性</span>
<span>$servers</span>-<span>></span>setValue<span>(</span><span>'unique'</span>,<span>'attrs'</span>,array<span>(</span><span>'mail'</span>,<span>'uid'</span>,<span>'uidNumber'</span>,<span>'cn'</span>,<span>'sn'</span><span>))</span><span>;</span>
-----------------------------------------------------------------
 
 
<span># 启动apache</span>
systemctl start httpd
systemctl <span>enable</span> httpd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>登录phpldapadmin界面</p>
<p>上一步，启动了apache服务后，在浏览器上访问: http://ip/ldapadmin ，然后使用上面定义的用户，进行登录，如下：</p>
<p><img src="./images/image-20191210175624957.png" alt="image-20191210175624957" />
OK，到此openldap和phpldapadmin 就安装完成了</p>
<blockquote>
<p>参考链接：</p>
<p>https://blog.csdn.net/weixin_41004350/article/details/89521170</p>
<p>openldap系列文章：</p>
<p>https://www.ilanni.com/?tag=openldap</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">phpldapadmin操作指导</title>
    <id>https://clay-wangzhi.com/openldap/phpldapadmin%E6%93%8D%E4%BD%9C%E6%8C%87%E5%AF%BC/</id>
    <link href="https://clay-wangzhi.com/openldap/phpldapadmin%E6%93%8D%E4%BD%9C%E6%8C%87%E5%AF%BC/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="phpldapadmin操作指导"> phpldapadmin操作指导</h1>
<h3 id="_1-在浏览器中打开http-ip-phpldapadmin"> 1.<strong><strong>在浏览器中打开</strong></strong>http://IP/phpldapadmin</h3>
<h3 id="_2-点击【login】按钮-输入管理员密码。"> 2. 点击【Login】按钮，输入管理员密码。</h3>
<p><img src="./images/1327931-20180831110424329-793110324.png" alt="img" /></p>
<h3 id="_3-点击【创建新条目】"> 3.****点击【<strong><strong>创建新条目</strong></strong>】.</h3>
<p><img src="./images/1327931-20180831110429812-17489868.png" alt="img" /></p>
<h3 id="_4-点击【generic-postfix-group】"> 4. 点击【<strong><strong>Generic: Postfix Group</strong></strong>】.</h3>
<p><img src="./images/1327931-20180831110436692-1272423331.png" alt="img" /></p>
<h3 id="_5-输入【users】-点击【创建对象】"> 5. 输入【Users】, 点击【<strong><strong>创建对象</strong></strong>】</h3>
<p><img src="./images/1327931-20180831110503252-505929691.png" alt="img" /></p>
<h3 id="_6-点击【提交】"> 6. 点击【<strong><strong>提交</strong></strong>】</h3>
<p><img src="./images/1327931-20180831110509143-992814925.png" alt="img" /></p>
<h3 id="_7-下一步添加用户-点击刚才所创建的组【users】"> 7. 下一步添加用户****，****点击刚才所创建的组【<strong><strong>u</strong></strong>sers】</h3>
<h3 id="_8-点击【创建一个子条目】"> 8****. 点击【<strong><strong>创建一个子条目</strong></strong>】</h3>
<p><img src="./images/1327931-20180831110516069-1260241219.png" alt="img" /></p>
<h3 id="_9-点击【generic-user-account】按钮。"> 9****. 点击【Generic: User Account】按钮。</h3>
<p><img src="./images/1327931-20180831110522490-1008013931.png" alt="img" /></p>
<h3 id="_10-根据自己的情况-添加信息然后点击【创建对象】"> 10.<strong><strong>根据自己的情况，添加信息</strong></strong>然后点击【创建对象】</h3>
<p>示例：</p>
<p><img src="./images/1327931-20180831110530109-967678460.png" alt="img" /></p>
<h3 id="_11-点击【提交】"> 11. 点击【<strong><strong>提交</strong></strong>】</h3>
<p><img src="./images/1327931-20180831110540330-1343019554.png" alt="img" /></p>
<h3 id="_12-点击新增的用户-点击右侧-【增加新的属性】"> 12.<strong><strong>点击</strong></strong>新增的用户，点击右侧****【<strong><strong>增加新的属性</strong></strong>】</h3>
<p><img src="./images/1327931-20180831110546251-141798944.png" alt="img" /></p>
<h3 id="_13-选择属性【email】"> 13.****选择属性【Email】</h3>
<p><img src="./images/1327931-20180831110551737-1997743890.png" alt="img" /></p>
<h3 id="_14-添好email地址"> 14. 添好Email地址</h3>
<p>示例如下。</p>
<p><img src="./images/1327931-20180831110557247-126754661.png" alt="img" /></p>
<p>15.点击【Update Object】</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">显示当前正在编辑的文件名</title>
    <id>https://clay-wangzhi.com/other/21%20vim/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <link href="https://clay-wangzhi.com/other/21%20vim/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="显示当前正在编辑的文件名"> 显示当前正在编辑的文件名</h2>
<p>正常模式下 :f 或CTRL+G</p>
<h2 id="vim粘贴"> vim粘贴</h2>
<p>要粘贴时：set paste</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">curl方式执行shell脚本时如何传参</title>
    <id>https://clay-wangzhi.com/other/23%20%E6%9C%AA%E5%88%86%E7%B1%BB/curl%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E6%97%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E5%8F%82/</id>
    <link href="https://clay-wangzhi.com/other/23%20%E6%9C%AA%E5%88%86%E7%B1%BB/curl%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E6%97%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E5%8F%82/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="curl方式执行shell脚本时如何传参"> curl方式执行shell脚本时如何传参</h2>
<p>有时候shell脚本可以放在http页面上，不用download，可以直接执行。</p>
<p>通常我们可以用curl的方式执行http页面上的shell脚本。 一般方式是：</p>
<div><pre><code>curl ftp://192.168.166.21:/system_optimize.sh | bash
</code></pre>
<div><span>1</span><br></div></div><p>这样脚本就可以在本地机器上执行了。</p>
<p>但是需要传入参数的脚本。我们可以用下面的方式传入shell参数</p>
<ul>
<li>-s方式</li>
</ul>
<div><pre><code>curl -s ftp://192.168.166.21:/system_optimize.sh | bash -s arg1 arg2
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>&lt; 方式</li>
</ul>
<div><pre><code>bash &lt;(curl -s ftp://192.168.166.21:/system_optimize.sh) arg1 arg2
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>注意 &lt;( 之间不要有空格！！！</p>
</blockquote>
<ul>
<li>若参数中带有<code>-</code>，则可使用长选项<code>--</code>解决</li>
</ul>
<div><pre><code>curl -s ftp://192.168.166.21:/system_optimize.sh | bash -s -- arg1 arg2
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>若参数为”-p arg -d arg”,则可使用以下命令执行</li>
</ul>
<div><pre><code>curl -s ftp://192.168.166.21:/system_optimize.sh | bash -s -- -p arg1 -d arg2
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>不止是curl的输入，其他方式的输入也满足。可以通过以下例子深入理解下</li>
</ul>
<div><pre><code>echo &#39;i=1; for a in $@; do echo &quot;$i = $a&quot;; i=$((i+1)); done&#39; | bash -s -- -a1 -a2 -
</code></pre>
<div><span>1</span><br></div></div><h2 id="bash选项"> Bash选项</h2>
<p>Bash选项</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-B</td>
<td>brace expansion</td>
<td>开启<a href="">大括号展开</a>(默认 setting = on)</td>
</tr>
<tr>
<td>+B</td>
<td>brace expansion</td>
<td>关闭大括号展开</td>
</tr>
<tr>
<td>-C</td>
<td>noclobber</td>
<td>防止重定向时覆盖文件(可能会被&gt;|覆盖)</td>
</tr>
<tr>
<td>-D</td>
<td>(none)</td>
<td>列出用双引号引用起来的, 以$为前缀的字符串, 但是不执行脚本中的命令</td>
</tr>
<tr>
<td>-a</td>
<td>all export</td>
<td>export(导出)所有定义过的变量</td>
</tr>
<tr>
<td>-b</td>
<td>notify</td>
<td>当后台运行的作业终止时, 给出通知(脚本中并不常见)</td>
</tr>
<tr>
<td>-c ...</td>
<td>(none)</td>
<td>从...中读取命令</td>
</tr>
<tr>
<td>checkjobs</td>
<td>(none)</td>
<td>通知有活跃shell<a href="http://tldp.org/LDP/abs/html/x9644.html#JOBSREF" target="_blank" rel="noopener noreferrer">任务</a>的用户退出。<a href="http://tldp.org/LDP/abs/html/bashver4.html#BASH4REF" target="_blank" rel="noopener noreferrer">Bash 4</a>版本中引入，仍然处于&quot;实验&quot;阶段. 用法:shopt -s checkjobs .(注意：可能会hang！</td>
</tr>
<tr>
<td>-e</td>
<td>errexit</td>
<td>当脚本发生第一个错误时, 就退出脚本, 换种说法就是, 当一个命令返回非零值时, 就退出脚本(除了<a href="http://tldp.org/LDP/abs/html/loops1.html#UNTILLOOPREF" target="_blank" rel="noopener noreferrer">until</a>或<a href="http://tldp.org/LDP/abs/html/loops1.html#WHILELOOPREF" target="_blank" rel="noopener noreferrer">while loops</a>, <a href="http://tldp.org/LDP/abs/html/testconstructs.html#TESTCONSTRUCTS1" target="_blank" rel="noopener noreferrer">if-tests</a>, <a href="http://tldp.org/LDP/abs/html/list-cons.html#LCONS1" target="_blank" rel="noopener noreferrer">list constructs</a>)</td>
</tr>
<tr>
<td>-f</td>
<td>noglob</td>
<td>禁用文件名扩展(就是禁用globbing)</td>
</tr>
<tr>
<td>globstar</td>
<td><a href="http://tldp.org/LDP/abs/html/bashver4.html#GLOBSTARREF" target="_blank" rel="noopener noreferrer">globbing star-match</a></td>
<td>打开<a href="http://tldp.org/LDP/abs/html/globbingref.html" target="_blank" rel="noopener noreferrer">globbling</a>操作符(Bash <a href="http://tldp.org/LDP/abs/html/bashver4.html#BASH4REF" target="_blank" rel="noopener noreferrer">4+</a>). 使用方法：shopt -s globstar</td>
</tr>
<tr>
<td>-i</td>
<td>interactive</td>
<td>让脚本以交互模式运行</td>
</tr>
<tr>
<td>-n</td>
<td>noexec</td>
<td>从脚本中读取命令, 但是不执行它们(做语法检查)</td>
</tr>
<tr>
<td>-o Option-Name</td>
<td>(none)</td>
<td>调用Option-Name选项</td>
</tr>
<tr>
<td>-o posix</td>
<td>POSIX</td>
<td>修改Bash或被调用脚本的行为, 使其符合<a href="http://tldp.org/LDP/abs/html/sha-bang.html#POSIX2REF" target="_blank" rel="noopener noreferrer">POSIX</a>标准.</td>
</tr>
<tr>
<td>-o pipefail</td>
<td>pipe failure</td>
<td>创建一个管道去返回最后一条命令的<a href="http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF" target="_blank" rel="noopener noreferrer">退出状态码</a>，这个返回值是一个非0的返回值</td>
</tr>
<tr>
<td>-p</td>
<td>privileged</td>
<td>以&quot;suid&quot;身份来运行脚本(小心!)</td>
</tr>
<tr>
<td>-r</td>
<td>restricted</td>
<td>以受限模式来运行脚本(参考 <a href="http://tldp.org/LDP/abs/html/restricted-sh.html" target="_blank" rel="noopener noreferrer">22</a>).</td>
</tr>
<tr>
<td>-s</td>
<td>stdin</td>
<td>从stdin 中读取命令</td>
</tr>
<tr>
<td>-t</td>
<td>(none)</td>
<td>执行完第一个命令之后, 就退出</td>
</tr>
<tr>
<td>-u</td>
<td>nounset</td>
<td>如果尝试使用了未定义的变量, 就会输出一个错误消息, 然后强制退出</td>
</tr>
<tr>
<td>-v</td>
<td>verbose</td>
<td>在执行每个命令之前, 把每个命令打印到stdout上</td>
</tr>
<tr>
<td>-x</td>
<td>xtrace</td>
<td>与-v选项类似, 但是会打印完整命令</td>
</tr>
<tr>
<td>-</td>
<td>(none)</td>
<td>选项结束标志. 后面的参数为<a href="http://tldp.org/LDP/abs/html/internalvariables.html#POSPARAMREF" target="_blank" rel="noopener noreferrer">位置参数</a>.</td>
</tr>
<tr>
<td>--</td>
<td>(none)</td>
<td>unset(释放)位置参数. 如果指定了参数列表(-- arg1 arg2), 那么位置 参数将会依次设置到参数列表中.</td>
</tr>
</tbody>
</table>
<p>重点是后面的&quot;-&quot;和&quot;--&quot;，理解一下</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Nginx升级加固SSL/TLS协议信息泄露漏洞(CVE-2016-2183)和HTTP服务器的缺省banner漏洞</title>
    <id>https://clay-wangzhi.com/other/23%20%E6%9C%AA%E5%88%86%E7%B1%BB/nginx%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/</id>
    <link href="https://clay-wangzhi.com/other/23%20%E6%9C%AA%E5%88%86%E7%B1%BB/nginx%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="nginx升级加固ssl-tls协议信息泄露漏洞-cve-2016-2183-和http服务器的缺省banner漏洞"> Nginx升级加固SSL/TLS协议信息泄露漏洞(CVE-2016-2183)和HTTP服务器的缺省banner漏洞</h2>
<blockquote>
<p>⚠️ 注意：要根据实际情况进行修改，这只是大体的思路</p>
</blockquote>
<div><pre><code>cd /tmp
wget  https://www.openssl.org/source/openssl-1.1.0k.tar.gz
tar zxvf openssl-1.1.0k.tar.gz -C /usr/local

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code># 打开nginx源文件下的/usr/local/src/nginx-1.9.9/auto/lib/openssl/conf文件：
vi /root/nginx-1.14.2/auto/lib/openssl/conf
# 找到以下代码,差不多三四十行
CORE_INCS=&quot;$CORE_INCS $OPENSSL/.openssl/include&quot;
CORE_DEPS=&quot;$CORE_DEPS $OPENSSL/.openssl/include/openssl/ssl.h&quot;
CORE_LIBS=&quot;$CORE_LIBS $OPENSSL/.openssl/lib/libssl.a&quot;
CORE_LIBS=&quot;$CORE_LIBS $OPENSSL/.openssl/lib/libcrypto.a&quot;
CORE_LIBS=&quot;$CORE_LIBS $NGX_LIBDL&quot;
# 修改成以下代码
CORE_INCS=&quot;$CORE_INCS $OPENSSL/include&quot;
CORE_DEPS=&quot;$CORE_DEPS $OPENSSL/include/openssl/ssl.h&quot;
CORE_LIBS=&quot;$CORE_LIBS $OPENSSL/lib/libssl.a&quot;
CORE_LIBS=&quot;$CORE_LIBS $OPENSSL/lib/libcrypto.a&quot;
CORE_LIBS=&quot;$CORE_LIBS $NGX_LIBDL&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code>cd /usr/local/openssl-1.1.0k/
mkdir lib
cp libssl.a libcrypto.a lib

./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-openssl=/usr/local/openssl-1.1.0k
make -j 8
cd /usr/local/nginx/sbin/
cp nginx nginx.bak
cd /opt/nginx-1.16.1
cp -f objs/nginx /usr/local/nginx/sbin/

ps -ef|grep nginx
kill -USR2 `master 进程号`
#关闭旧的woker进程，kill -WINCH旧的master进程号
kill -WINCH `master 进程号`
#关闭旧的master进程
kill -QUIT `master 进程号`

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="nginx缺省banner修改"> Nginx缺省banner修改</h3>
<div><pre><code>[root@Test ~]# vim nginx-1.19.1/src/http/ngx_http_header_filter_module.c 

需要修改：

static u_char ngx_http_server_string[] = &quot;Server: nginx&quot; CRLF;
static u_char ngx_http_server_full_string[] = &quot;Server: &quot; NGINX_VER CRLF;
static u_char ngx_http_server_build_string[] = &quot;Server: &quot; NGINX_VER_BUILD CRLF;

修改成：

static u_char ngx_http_server_string[] = &quot;Server: unknow&quot; CRLF;
static u_char ngx_http_server_full_string[] = &quot;Server: unknow&quot;  CRLF;
static u_char ngx_http_server_build_string[] = &quot;Server: unknow&quot;  CRLF;

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>然后重新编译，热升级nginx</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">查看哪些表被锁住了</title>
    <id>https://clay-wangzhi.com/other/23%20%E6%9C%AA%E5%88%86%E7%B1%BB/oracle%E6%9F%A5%E7%9C%8B%E5%93%AA%E4%BA%9B%E8%A1%A8%E8%A2%AB%E9%94%81%E4%BD%8F%E4%BA%86/</id>
    <link href="https://clay-wangzhi.com/other/23%20%E6%9C%AA%E5%88%86%E7%B1%BB/oracle%E6%9F%A5%E7%9C%8B%E5%93%AA%E4%BA%9B%E8%A1%A8%E8%A2%AB%E9%94%81%E4%BD%8F%E4%BA%86/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="查看哪些表被锁住了"> 查看哪些表被锁住了</h2>
<div><pre><code><span>select</span> b<span>.</span>owner<span>,</span>b<span>.</span>object_name<span>,</span>a<span>.</span>session_id<span>,</span>a<span>.</span>locked_mode <span>from</span> v$locked_object a<span>,</span>dba_objects b <span>where</span> b<span>.</span>object_id <span>=</span> a<span>.</span>OBJECT_ID<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="查询引起死锁的会话"> 查询引起死锁的会话</h2>
<div><pre><code><span>select</span> b<span>.</span>username<span>,</span>b<span>.</span>sid<span>,</span>b<span>.</span><span>serial</span><span>#,logon_time from v$locked_object a , v$session b where a.session_id = b.sid order by b.LOGON_TIME;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="查出sid和serial"> 查出sid和serial#</h2>
<div><pre><code><span>select</span> sid<span>,</span><span>serial</span><span>#,paddr from v$session where sid = 259;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="查v-process视图-得到spid"> 查v$process视图,得到spid</h2>
<div><pre><code>select spid from v$process where addr= &#39;00000003E32BDE28&#39;;
</code></pre>
<div><span>1</span><br></div></div><h2 id="杀死进程-sid-serial"> 杀死进程(sid,serial#)</h2>
<div><pre><code><span>alter</span> system <span>kill</span> <span>session</span> <span>'259,37152'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">PrometheusAlert</title>
    <id>https://clay-wangzhi.com/other/23%20%E6%9C%AA%E5%88%86%E7%B1%BB/promethues-alerts/</id>
    <link href="https://clay-wangzhi.com/other/23%20%E6%9C%AA%E5%88%86%E7%B1%BB/promethues-alerts/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="prometheusalert"> PrometheusAlert</h1>
<p>Prometheus Alert是开源的运维告警中心消息转发系统,支持主流的监控系统Prometheus,Zabbix,日志系统Graylog和数据可视化系统Grafana发出的预警消息,支持钉钉,微信,华为云短信,腾讯云短信,腾讯云电话,阿里云短信,阿里云电话等</p>
<h3 id="文档"> 文档</h3>
<p>https://feiyu563.gitbook.io/prometheusalert/</p>
<h3 id="自定义的告警模板"> 自定义的告警模板</h3>
<div><pre><code>{{ $var := .externalURL}}{{ range $k,$v:=.alerts }}
{{if eq $v.status &quot;resolved&quot;}}
## [Prometheus恢复信息]({{$v.generatorURL}})

&gt; &lt;font color=&quot;info&quot;&gt;告警名称&lt;/font&gt;：[{{$v.labels.alertname}}]({{$var}})

&gt; &lt;font color=&quot;info&quot;&gt;告警级别&lt;/font&gt;：{{$v.labels.severity}}

&gt; &lt;font color=&quot;info&quot;&gt;当前状态&lt;/font&gt;：{{$v.status}}

&gt; &lt;font color=&quot;info&quot;&gt;告警分组&lt;/font&gt;：{{$v.labels.team}}

&gt; &lt;font color=&quot;info&quot;&gt;开始时间&lt;/font&gt;：{{GetCSTtime $v.startsAt}}

&gt; &lt;font color=&quot;info&quot;&gt;结束时间&lt;/font&gt;：{{GetCSTtime $v.endsAt}}

&gt; &lt;font color=&quot;info&quot;&gt;实例地址&lt;/font&gt;：{{$v.labels.instance}}

**{{$v.annotations.description}}**
{{else}}
## [ &lt;font color=&quot;#FF0000&quot;&gt;Prometheus告警信息&lt;/font&gt;]({{$v.generatorURL}})
&gt; &lt;font color=&quot;#FF0000&quot;&gt;告警名称&lt;/font&gt;：[{{$v.labels.alertname}}]({{$var}})

&gt; &lt;font color=&quot;#FF0000&quot;&gt;告警级别&lt;/font&gt;：{{$v.labels.severity}}

&gt; &lt;font color=&quot;#FF0000&quot;&gt;当前状态&lt;/font&gt;：{{$v.status}}

&gt; &lt;font color=&quot;#FF0000&quot;&gt;告警分组&lt;/font&gt;：{{$v.labels.team}}

&gt; &lt;font color=&quot;#FF0000&quot;&gt;开始时间&lt;/font&gt;：{{GetCSTtime $v.startsAt}}

&gt; &lt;font color=&quot;#FF0000&quot;&gt;实例地址&lt;/font&gt;：{{$v.labels.instance}}

**{{$v.annotations.description}}**
{{end}}
{{ end }}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">调优的目的：</title>
    <id>https://clay-wangzhi.com/other/23%20%E6%9C%AA%E5%88%86%E7%B1%BB/%E8%B0%83%E4%BC%98/</id>
    <link href="https://clay-wangzhi.com/other/23%20%E6%9C%AA%E5%88%86%E7%B1%BB/%E8%B0%83%E4%BC%98/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="调优的目的"> 调优的目的：</h2>
<ol>
<li>根据不同的角色调优的方法是不一样的</li>
<li>找到性能瓶颈以及缓解这个瓶颈（CPU，内存，IO调度、网络、使用的应用程序）</li>
<li>通常做两种调优：
response time:  Web服务器，用户感受度好
throughput: 	文件服务器，拷贝的速度</li>
</ol>
<h2 id="性能调优的效率问题"> 性能调优的效率问题：</h2>
<h3 id="业务级调优"> 业务级调优</h3>
<p>尽量在业务级调，效果最明显</p>
<p>例如： 网站一定要使用Apache吗?
例如：将原有的调度器由LVS换成F5-BigIP
例如：能否禁用一些不必要的服务如蓝牙、smart card，makewathis, updatadb</p>
<h3 id="应用级调优"> 应用级调优</h3>
<p>NFS，Samba，Apache、Nginx、MySQL、Oracle、LVS本身调优				
对于日志的处理： 只要有日志产生，就会存盘fsync()，可以调整记录的日志等级或延后日志写，从而避免大量的I/O操作
kernel级调优		最后的希望，kernel调优具有普遍性</p>
<p>自上往下，效果越来越不明显</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">安装python解释器，配置好path变量。</title>
    <id>https://clay-wangzhi.com/other/vscode/%E4%BD%BF%E7%94%A8vscode%E6%89%93%E9%80%A0python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</id>
    <link href="https://clay-wangzhi.com/other/vscode/%E4%BD%BF%E7%94%A8vscode%E6%89%93%E9%80%A0python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <updated>2021-05-11T06:41:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="安装python解释器-配置好path变量。"> 安装python解释器，配置好path变量。</h2>
<p>下载网址：https://www.python.org/downloads/release/python-374/</p>
<p>注意区分64位还是32位的。</p>
<p>安装python的时候，建议将python添加到path环境变量的复选框勾上，并且使用自定义安装，因为可以自定义安装目录，我是安装在C:\Python37中的</p>
<p><img src="./images/1809823-20191024094355579-1616094075.png" alt="img" /></p>
<p><img src="./images/1809823-20191024094501565-869967624.png" alt="img" /></p>
<h2 id="安装virtualenv"> 安装virtualenv</h2>
<p>win+R输入cmd后点确定，然后执行：</p>
<div><pre><code>pip install virtualenv
</code></pre>
<div><span>1</span><br></div></div><h2 id="下载并安装好vscode编辑器"> 下载并安装好vscode编辑器</h2>
<p>（安装时，将复选框全部勾上）</p>
<p>下载地址：https://code.visualstudio.com/</p>
<h2 id="在vscode中安装python插件"> 在vscode中安装python插件</h2>
<p>按下快捷键Ctrl+Shift+X，进入插件管理页面
在搜索框中搜索python关键字
点击下载量最高的那个进行安装，一般都是第一个。</p>
<p><img src="./images/1809823-20191024100941643-2124999412.png" alt="img" /></p>
<p>vscode安装了上面这个插件后，能干什么？</p>
<ul>
<li>
<p>这个插件不是python语言的解释器，vscode想要运行python代码，必须另外指定在windows上安装的python解释器路径才可以。</p>
</li>
<li>
<p>这个插件被安装上后，vscode就具有了调用python解释器的功能。其实就是在setting.json和launch.json这两个配置文件中，可以添加python相关的配置了，比如通过python.pythonPath的值找到python解释器的位置等等。</p>
</li>
<li>
<p>可以通过按下ctrl键，点击函数，打开函数的所在文件和定义位置。</p>
</li>
<li>
<p>具有代码提示功能。</p>
</li>
</ul>
<p><img src="./images/1809823-20191024135540391-1446811264.png" alt="img" /></p>
<h2 id="准备一个项目并用vscode打开"> 准备一个项目并用vscode打开</h2>
<blockquote>
<p>第一步：创建一个总项目目录</p>
<p>D:\CodeProjects</p>
<p>第二步：创建一个python总项目目录</p>
<p>D:\CodeProjects\PythonProjects</p>
<p>第三步：创建一个测试项目目录</p>
<p>D:\CodeProjects\PythonProjects\opms</p>
<p>第四步：在指定项目中创建python虚拟环境</p>
<p>win+R输入cmd后点确定，依次执行下面三条命令：（-p后面的参数，可以换成其它python解释器的路径）</p>
<div><pre><code>D:
cd D:\CodeProjects\PythonProjects\opms
virtualenv .venv -p &quot;C:\Python37\python.exe&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第五步：右击opms项目目录，使用vscode打开（一般情况下，一个vscode界面只能打开一个项目目录）</p>
</blockquote>
<h2 id="为项目运行时指定特定的python解释器"> 为项目运行时指定特定的python解释器</h2>
<p>第一步：为新打开的项目生成setting.json配置文件</p>
<blockquote>
<p>按下快捷键ctrl+shift+p，输入interpreter，单击筛选出来的结果“Python: Select Interpreter&quot;，就会跳出windows系统上已经安装的所有python解释器，我们这里随便选择一个即可，因为我们之后会自定义setting.json配置文件中的值，这一步只是为了生成setting.json这个配置文件。</p>
<p><img src="./images/1809823-20191024111926404-1427330908.png" alt="img" /></p>
<p>补充：你如果和我一样，在打开项目之前已经在项目中创建了python虚拟环境，那么在选择interpreter时，vscode也会将本项目目录下的虚拟环境中的python解释器也列出来，此时，你可以直接选择这个解释器即可。</p>
<p><img src="./images/1809823-20191024114429432-201149058.png" alt="img" /></p>
</blockquote>
<p>第二步：修改setting.json配置文件，指定python.pythonPath的值为opms项目目录下python虚拟环境中的python解释器路径</p>
<blockquote>
<p><img src="./images/1809823-20191024110414553-848173359.png" alt="img" /></p>
</blockquote>
<p>7.为项目运行时指定入口文件和参数</p>
<p>第一步：为新打开的项目生成launch.json配置文件</p>
<blockquote>
<p>点击Debug，点击Add Configuration，点击Python，然后根据你的项目，在Python File、Django、Flask中选择一个，我这里只是为了说明，选择Python File，你们请根据自己的项目类型的进行选择。</p>
<p><img src="./images/1809823-20191024113513104-1372597605.png" alt="img" /></p>
</blockquote>
<p>第二步：解释launch.json配置文件中configurations列表的作用</p>
<blockquote>
<p>program这个键，用来指定项目运行时的入口文件的，其中${file}表示当前文件，${workspaceFolder}表示项目根目录，对于django项目来说，入口文件应该是项目根目录下的manage.py文件，所以可以配置为&quot;program&quot;: &quot;${workspaceFolder}\manage.py&quot;。</p>
<p>args这个键，用来指定项目运行时，跟在入口文件后面的参数，对于django项目来说，运行参数应该是：runserver 0.0.0.0:8080 --noreload --nothreading ，所以可以配置为：</p>
<p>&quot;args&quot;:[&quot;runserver&quot;,&quot;0.0.0.0:8080&quot;,&quot;--noreload&quot;,&quot;--nothreading&quot;] 。</p>
<p>name这个键，用来命名配置名称的，因为在configurations列表中可以定义多个配置，不同的配置命名要相互区分。</p>
<p>type和request这两个键是必须项，在不同的配置中都要存在的，而它们的值也是固定的。&quot;type&quot;: &quot;python&quot; , &quot;request&quot;: &quot;launch&quot;。</p>
</blockquote>
<p>8.测试一下</p>
<p>在项目目录中，创建一个test.py文件，写入代码后，点击文件上方的绿色三角形按钮运行当前文件。</p>
<blockquote>
<p>之所以能够点击按钮就可以运行当前文件，是因为我使用了Python File这个configurations运行配置，参数&quot;program&quot;: &quot;${file}&quot;，表示当前文件。</p>
<p><img src="./images/1809823-20191024181603712-2000588466.png" alt="img" /></p>
</blockquote>
<p>有时候vscode会报错如下：</p>
<p>无法加载文件 D:\CodeProjects\PythonProjects\opms.venv\Scripts\activate.ps1，因为在此系统上禁止运行脚本。</p>
<p><img src="./images/1809823-20191024153804972-561219001.png" alt="img" /></p>
<p>解决办法：</p>
<blockquote>
<p>第一步：以管理员身份运行powershell
第二步：执行：get-ExecutionPolicy，回复Restricted，表示状态是禁止的。
第三步：执行：set-ExecutionPolicy RemoteSigned
第四步：选择Y，回车。</p>
</blockquote>
<h2 id="关于python虚拟环境的解释"> 关于python虚拟环境的解释</h2>
<blockquote>
<p>python虚拟环境是一个非常好用的东西，以前我以为只有activate激活这个虚拟环境，才可以使用这个虚拟环境中安装的各个模块。现在，我知道之前的认知是局限的。</p>
<p>其实，你只需要使用虚拟环境中的python.exe解释器的绝对路径就可以使用这个虚拟环境中安装的python模块了，根本不需要激活。不信的话，你试试：</p>
<p>比如我创建了一个venv虚拟环境：D:\CodeProjects\PythonProjects\opms.venv\</p>
<p>然后，我运行下面的命令得到的模块列表和全局解释器中的模块列表是不一样的（此时我并没有激活这个虚拟环境）：</p>
<p>D:\CodeProjects\PythonProjects\opms.venv\Scripts\pip  list</p>
<p>当使用activate激活一个虚拟环境时，我们就从cmd或者terminal当前窗口中进入到了一个子窗口中了，在这个子窗口中，PATH这个环境变量被临时更改了，当前这个虚拟环境中的Scripts路径就被加入到PATH环境变量中了，那么我们在这个子窗口中运行的python命令、pip命令等也就通过PATH这个环境变量自动查找，然后指向了虚拟环境Scripts目录中的解释器了，这也就解释了为何激活了这个虚拟环境，在这个窗口中切换到任何一个目录中，执行python或者pip命令都能使用和查看这个虚拟环境的所有模块的原因。</p>
</blockquote>
<h2 id="配置django项目的运行参数"> 配置django项目的运行参数</h2>
<p>一般我们运行django项目的命令是：  python manage.py runserver 0.0.0.0:8080</p>
<p>这个命令分为两部分，第一部分是python解释器，我们在settings.json设置，剩下的参数manage.py runserver 0.0.0.0:8080我们需要在launch.json中设置。</p>
<p>我粘贴出我在launch.json文件中设置的内容：</p>
<p>[<img src="./images/copycode.gif" alt="复制代码" />](javascript:void(0)😉</p>
<div><pre><code>    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;Python: Current File&quot;,
            &quot;type&quot;: &quot;python&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${file}&quot;,
            &quot;console&quot;: &quot;integratedTerminal&quot;
        },
        {
            &quot;name&quot;:&quot;Python: Django&quot;,
            &quot;type&quot;:&quot;python&quot;,
            &quot;request&quot;:&quot;launch&quot;,
            &quot;program&quot;:&quot;${workspaceFolder}\\manage.py&quot;,
            &quot;console&quot;:&quot;integratedTerminal&quot;,
            &quot;args&quot;:[
                &quot;runserver&quot;,
                &quot;0.0.0.0:8080&quot;,
                &quot;--noreload&quot;,
                &quot;--nothreading&quot;
            ],
            &quot;django&quot;:true
        }
    ] 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>此时如果要运行django项目的话，方法如下：</p>
<blockquote>
<p>点击左边栏目中的小乌龟，</p>
<p>点击齿轮图标旁边的下拉框，选择Python: Django，</p>
<p>然后点击左边绿色三角形的运行按钮即可。</p>
</blockquote>
<p><img src="./images/1809823-20190928205359265-672999965.png" alt="img" /></p>
<h2 id="配置vscode的文件图标和主题美化"> 配置vscode的文件图标和主题美化</h2>
<blockquote>
<p>按下快捷键Ctrl+Shift+X，进入插件管理页面
在搜索框中搜索这两个插件并安装：Material Icon Theme 和 Son of Obsidian Theme
然后点击左下角的齿轮图标，选择并点击File Icon Theme,在出现的展示中，选择并点击Material Icon Theme即可。</p>
<p><img src="./images/1809823-20190928211305845-549111763.png" alt="img" /></p>
<p>此时，我们就会发现我们的python文件的图标已经变成了经典的头尾相接的两条蟒蛇了。</p>
<p><img src="./images/1809823-20191024134941874-380471130.png" alt="img" /></p>
</blockquote>
<p>13.启用自动格式化代码工具yapf（我用的是推荐的autopep8）</p>
<blockquote>
<p>第一步：在项目指定的python解释器中安装yapf模块</p>
<div><pre><code>cd D:\CodeProjects\PythonProjects\opms\.venv\Scripts
activate
pip install yapf
deactivate.bat
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第二步：在项目中的settings.json配置文件中，添加：&quot;python.formatting.provider&quot;: &quot;yapf&quot;，如下：</p>
<p><img src="./images/1809823-20191024154647910-1896543092.png" alt="img" /></p>
<p>第三步：按Alt+Shift+F即可自动格式化代码</p>
</blockquote>
<p>测试一下：</p>
<p>未经代码格式化之前的代码如下：</p>
<p><img src="./images/1809823-20191024155009882-1482382316.png" alt="img" /></p>
<p>按Alt+Shift+F后，代码如下：</p>
<p><img src="./images/1809823-20191024155114340-395399786.png" alt="img" /></p>
<p>14.启用pylint进行代码编写时格式规范检查</p>
<blockquote>
<p>第一步：在项目指定的python解释器中安装pylint模块</p>
<div><pre><code>cd D:\CodeProjects\PythonProjects\opms\.venv\Scripts
activate
pip install pylint
deactivate.bat
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第二步：启用pylint功能，在settings.json文件中添加：&quot;python.linting.pylintEnabled&quot;: true，如下：</p>
<p><img src="./images/1809823-20191024162433256-353199912.png" alt="img" /></p>
<p>第三步：关于pylint检查项的一些定制</p>
<p>&quot;python.linting.pylintArgs&quot;: [&quot;--disable=C,broad-except,unused-variable&quot;,],</p>
<p><img src="./images/1809823-20191024182305562-745231240.png" alt="img" /></p>
<p>检查项按大类分，大约有四个：C、R、E、W，C类应该是与变量、函数名等命名有关的规范，我们把C类检查全部禁用，E类应该是检查模块、类、函数等是否存在，这个是最有用的，W类应该是与声明的变量是否被使用、使用的异常捕捉类是否细化等检查相关，这个可以根据具体的情况具体禁用。R类还不太清楚。</p>
<p>那么如何禁用具体的检查项呢？</p>
<p>首先，我们将鼠标停留在报出异常的代码上，如下：</p>
<p><img src="./images/1809823-20191024174359019-1472829681.png" alt="img" /></p>
<p>然后，就可以看到异常是unused-variable了，我们将这个异常检查项在settings.json中禁用掉即可。其它的异常检查项也是这么查看和禁用。</p>
<p>第四步：Django项目需要安装额外的规范检查模块</p>
<div><pre><code>pip install pylint_django
</code></pre>
<div><span>1</span><br></div></div><p>第五步：在settings.json配置文件中为django项目添加加载检查模块</p>
<p>&quot;python.linting.pylintArgs&quot;: [
&quot;--load-plugins&quot;,
&quot;pylint_django&quot;,
],</p>
<p><img src="./images/1809823-20191024182912313-1550192011.png" alt="img" /></p>
</blockquote>
<h2 id="记录一下vscode中的一些快捷键"> 记录一下vscode中的一些快捷键</h2>
<ul>
<li>
<p>终止程序运行：ctrl + `</p>
</li>
<li>
<p>侧边栏显示和隐藏：ctrl + B</p>
</li>
<li>
<p>格式化代码：Alt+Shift+F</p>
</li>
<li>
<p>格式化选中部分的代码：Ctrl + K Ctrl + F</p>
</li>
<li>
<p>打开Git可视管理：Ctrl + Shift + G</p>
</li>
</ul>
<p>补充：</p>
<p>格式化代码的快捷键用起来太麻烦了，将它更改为常用的ctrl+alt+l（L的小写）的方式。</p>
<p>按ctrl+k ctrl+s打开快捷键修改的界面，搜索框中搜索shift+alt+f，快速定位到要修改的快捷键：</p>
<p><img src="./images/1809823-20191119130519077-417424220.png" alt="img" /></p>
<p>修改完成后，如下所示，记得更换搜索关键词：</p>
<p><img src="./images/1809823-20191119130646807-2122638239.png" alt="img" /></p>
<h2 id="新建python文件时自动添加头部信息"> 新建python文件时自动添加头部信息</h2>
<p>第一步：</p>
<p>点击File，点击Preferences，点击User Snippets，输入python，点击跳出来的&quot;python.json(Python)&quot;，在打开的python.json文件中，先清空文件原内容，然后添加：</p>
<p>请看：下面的内容，适合python2，在python3中，请将#!/usr/bin/python3(或者用虚拟环境中的python解释器）和#encoding:utf-8替换对应位置的内容。</p>
<div><pre><code>{
    &quot;HEADER&quot;:{
        &quot;prefix&quot;: &quot;header&quot;,
        &quot;body&quot;: [
        &quot;#!/usr/bin/python&quot;,
        &quot;# -*- encoding: utf-8 -*-&quot;,
        &quot;&#39;&#39;&#39;&quot;,
        &quot;@File    :   $TM_FILENAME&quot;,
        &quot;@Time    :   $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;,
        &quot;@Author  :   DesignerA &quot;,
        &quot;@Version :   1.0&quot;,
        &quot;@Contact :   DesignerA@qq.com&quot;,
        &quot;@WebSite :   www.cnblogs.com/DesignerA&quot;,
        &quot;&#39;&#39;&#39;&quot;,
        &quot;# Start typing your code from here&quot;,
        &quot;$0&quot;
    ],
    }   
} 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>第二步：</p>
<p>在新建的python文件开头输入header，然后回车，就会自动出现上面定义的头部信息了(我已经替换对应位置的内容为python3了），如下：</p>
<p><img src="./images/1809823-20191025104553418-61291872.png" alt="img" /></p>
<p>17.vscode配置git管理代码</p>
<p>第一步：先到git官网下载并安装windows 64位版的git，git官网下载地址：https://git-scm.com/downloads，注意，安装Git的过程中，选择VS Code作为git的默认编辑器，其它都默认即可，如下图：</p>
<p><img src="./images/1809823-20191107094409648-1081928631.png" alt="img" /></p>
<p>第二步：为git配置环境变量，默认情况下，git被安装在C:\Program Files\Git\目录下，我们需要将这个目录下的bin目录添加到Path环境变量中。如下图</p>
<p><img src="./images/1809823-20191107103843696-1444117909.png" alt="img" /></p>
<p>第三步：设置vscode与git关联，依次打开：File -&gt; Preferences -&gt; Settings -&gt; Extensions -&gt; Git -&gt;Path (Edit in settings.json)</p>
<p>在打开的settings.json文件中，配置git的可执行文件路径，如下：</p>
<div><pre><code>//启用git
&quot;git.enabled&quot;: true, 
//启用自动刷新
&quot;git.autorefresh&quot;: true,
//启用自动提取
&quot;git.autofetch&quot;: true,
//同步前进行确认
&quot;git.confirmSync&quot;: true,
//配置git可执行文件路径
&quot;git.path&quot;:&quot;C:\\Program Files\\Git\bin\\git.exe&quot;,
&quot;terminal.integrated.shell.windows&quot;: &quot;C:\\Program Files\\Git\\bin\\bash.exe&quot;,
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><img src="./images/1809823-20191107102510744-202119607.png" alt="img" /></p>
<p>第四步：配置git用户名与邮箱（git暂存时需要用到它们）</p>
<div><pre><code>git config --global user.name &quot;xxxxxxx&quot;
git config --global user.email &quot;xxxxxxx@qq.com&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>第五步：在github上新建一个仓库，然后使用命令git clone &quot;仓库地址&quot; ，将仓库克隆到本地目录中。 如果是私有仓库，这步执行后，会要求你输入github账户密码。</p>
<p>第六步：让git记住密码，这样不用每次都填写</p>
<div><pre><code>git config --global credential.helper store
</code></pre>
<div><span>1</span><br></div></div><p>第七步：找到git下来的仓库目录，然后右击目录，选择使用vscode打开</p>
<p>第八步：你编辑这个项目中的文件后，你要先点击小勾暂存所有更改，输入你的提交消息（随便输点你本次提交的说明信息）</p>
<p>说明：这里的commit并不是提交到github，而是提交到本地的暂存区，而且必须要先提交到本地的暂存区，之后才可以使用push将暂存区中的内容推送到github仓库中。</p>
<p><img src="./images/1809823-20191107142454405-769542664.png" alt="img" /></p>
<p>第九步：将更改提交到github仓库中，从图中可以看到第八步执行完后，本次的更改已经写入到暂存区了。点击Push后，可以到github仓库中看下仓库中的内容是否已经更改</p>
<p><img src="./images/1809823-20191107142940191-882413579.png" alt="img" /></p>
<h2 id="vscode添加浏览器预览html代码功能"> vscode添加浏览器预览html代码功能</h2>
<p>第一步：按下快捷键Ctrl+Shift+X，进入插件管理页面，搜索并安装插件open in browser</p>
<p><img src="./images/1809823-20191107111943913-1369276819.png" alt="img" /></p>
<p>第二步：修改vscode预览html文件默认使用的浏览器，不修改的话，默认使用IE。当然，这一步可以不执行，因为右击html文件的时候可以选择Open In Other Browers</p>
<p>​        依次打开：File -&gt; Preferences -&gt; Settings -&gt; Extensions -&gt; plugin open-in-brower -&gt;Auto Complete: Extra Paths (Edit in settings.json)然后在打开的settings.json配置文件中添加：</p>
<div><pre><code>//如果是火狐，就设置firefox
&quot;open-in-browser.default&quot;: &quot;chrome&quot;,
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><img src="./images/1809823-20191107112853772-2002089952.png" alt="img" /></p>
<h2 id="vscode利用远程服务器环境调试项目-五星推荐"> vscode利用远程服务器环境调试项目（五星推荐）</h2>
<p>这个还是很好用的，可以不需要在windows服务器上安装python执行环境了。而且，python中的一些与系统操作相关的模块，windows上安装起来也非常麻烦。</p>
<p>第一步：按下快捷键Ctrl+Shift+X，进入插件管理页面，搜索并安装插件Remote Development</p>
<p><img src="./images/1809823-20191118092715192-399355687.png" alt="img" /></p>
<p>第二步：windows上安装openssh客户端，这里提供一个使用powershell安装的方法</p>
<p>首先，以管理员身份打开powershell</p>
<p>然后，输入命令在线查询可获取的安装包 Get-WindowsCapability -Online | ? Name -like 'OpenSSH*'</p>
<p><img src="./images/1809823-20191118094734763-1541493353.png" alt="img" /></p>
<p>最后，如果状态显示NotPresent的话，可以使用命令进行安装，命令为Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0</p>
<p>提示：随着 Windows 10 2018 年 4 月更新的发布，OpenSSH 客户端已正式推出并在 Windows 10 中默认安装。</p>
<p>补充：有些人的电脑系统可能是windows7的，这里再提供一个在windows7上安装openssh客户端的方法</p>
<p>首先，下载cygwin，下载网址为: https://www.cygwin.com/</p>
<p><img src="./images/1809823-20191120225326765-1888543090.png" alt="img" /></p>
<p>然后，安装它，安装过程中，当出现选择要安装的包时，我们将View切换为Full，并在搜索框中搜索openssh，在出现的搜索结果中，我们将openssh中的skip改为8.1p1-1，然后再点击下一步完成安装。如下图，下图中因为我已经安装过了，所以openssh这里没有显示skip：</p>
<p><img src="./images/1809823-20191120230219685-1632606585.png" alt="img" /></p>
<p>再然后，我们需要将Cygwin安装目录下的bin目录的绝对路径添加到Path环境变量中。Cygwin默认的安装路径为：C:\cygwin64，所以我们需要将C:\cygwin64\bin添加到Path环境变量中，如下图所示：</p>
<p><img src="./images/1809823-20191120230912717-363541959.png" alt="img" /></p>
<p>最后，验证一下。我们打开cmd，输入ssh回车看看是否有输出，有输出信息就表示openssh客户端安装成功了：</p>
<p><img src="./images/1809823-20191120231056489-255714313.png" alt="img" /></p>
<p>备注：这个Cygwin软件被安装上后，不但可以使用ssh客户端了，另外很多linux上的命令我们也都可以在cmd中使用了，比如ls和pwd等。原因就是这些命令工具都被提供在C:\cygwin64\bin目录下。你可以到这个目录下看看。挺好的软件，给个大大的赞。</p>
<p>第三步：准备一台centos虚拟机或者ubuntu虚拟机，确保虚拟机上的ssh server服务已经开启，并允许远程连接。比如我准备的是centos7虚拟机，IP地址为192.168.247.133</p>
<p>第四步：按下快捷键ctrl+shift+p 搜索Remote-SSH:Settings，在打开的页面中，点击Edit in settings.json，在其中添加&quot;remote.SSH.showLoginTerminal&quot;: true,如下图:</p>
<p><img src="./images/1809823-20191118100720720-1004879806.png" alt="img" /></p>
<p>第五步：点击左下角的绿色图标，选择Remote-SSH：Connect to Host 然后点击 Configure SSH Hosts 然后选择点第一个config，默认应该是一个空白的文件，在其中添加如下的配置：</p>
<div><pre><code>Host Centos7.5_python3
    HostName 192.168.247.133
    Port 22
    User root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="./images/1809823-20191118101524704-1699733717.png" alt="img" /></p>
<p>备注：其中Host后面的名称，可以随便命名，HostName后面的IP地址是准备的虚拟机IP地址，Port后跟的是ssh server服务监听的端口号，默认是22，User后跟的是远程连接的用户名，我这里使用超级用户连接。</p>
<p>这里补充一点：</p>
<p>每次连接远程服务器，打开项目都要输入一次密码，是否很烦？（当然我并没有觉得烦）如果有人觉得烦的话，可以先在本地windows系统和远程服务器之间做好ssh免密登陆，然后在上面这个config文件中，在User配置下一行（缩进和User要一致），添加IdentityFile C:\Users....ssh\id_rsa即可，其中IdentityFile参数后面跟的是windows上的rsa私钥文件。</p>
<p>第六步：点击vscode左边栏的远程连接图标，如下：</p>
<p><img src="./images/1809823-20191118101908730-1174731395.png" alt="img" /></p>
<p>第七步：点击配置后的远程虚拟机名称旁边的那个按钮，输入密码进行登陆到服务器上，如下：</p>
<p><img src="./images/1809823-20191118102152158-767875613.png" alt="img" /></p>
<p>备注，如果vscode初次连接这台虚拟机的话，那么需要等待几分钟，因为vscode要做一些初始化工作。</p>
<p>第八步：连上虚拟机后，可以通过下图中标识的顺序打开远程服务器上的项目，当然每次打开项目都是需要再次输入密码的。这也是为了安全考虑。</p>
<p>在打开的项目中新建文件，删除文件，修改文件等操作，不需要再次输入密码。</p>
<p><img src="./images/1809823-20191118103510878-1427529685.png" alt="img" /></p>
<p>第九步：运行项目或测试脚本的方法</p>
<p>感觉这个功能，在一定程度上，都可以代替secure crt或xshell远程连接工具和ftp上传下载客户端了。很强大。</p>
<p><img src="./images/1809823-20191118104120944-788931545.png" alt="img" /></p>
<p>补充：</p>
<p>没有语法检查，代码自动提示和补全功能，开发真的是一个很难受的事情，那么怎么在远程服务器上使用这些功能呢？下面就是补全这一点的方法：</p>
<p>首先：按下快捷键Ctrl+Shift+X，进入插件管理页面，搜索python，然后，点击Install in SSH:Centos7.5_python3，如下图：</p>
<p><img src="./images/1809823-20191118114031066-1405256168.png" alt="img" /></p>
<p>然后：在打开的项目中，生成launch.json和settings.json这两个配置文件，方法在最上面，和配置windows本地开发环境一样，我们在settings.json中配置一个远程服务器上的python解释器，如下图：</p>
<p><img src="./images/1809823-20191118114509491-1223802505.png" alt="img" /></p>
<p>最后：运行python文件的方法</p>
<p><img src="./images/1809823-20191118114747283-713667578.png" alt="img" /></p>
<p>第十步：重新打开远程服务器上项目的方法</p>
<p>点击File，点击Close Folder，这个操作，会重新连接服务器。</p>
<p>也没找到其它的方法，就这么做吧。</p>
<blockquote>
<p>转载链接：https://www.cnblogs.com/DesignerA/p/11604200.html</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">写作前</title>
    <id>https://clay-wangzhi.com/other/%E5%86%99%E4%BD%9C/IT%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/</id>
    <link href="https://clay-wangzhi.com/other/%E5%86%99%E4%BD%9C/IT%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="写作前"> 写作前</h2>
<h3 id="trello"> trello</h3>
<p>官网地址:https://trello.com/</p>
<p>这是一款任务管理工具，类似于敏捷开发中看板，我们可以快速管理任务。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1419561-20200403080637678-850065086.jpg" alt="img" /></p>
<p>日常工作我只要想到一个 <strong>idea</strong>，就会第一时间先记录到 <strong>idea</strong> 列表中。这里千万不要高估自己的记忆力，如果想到了，感觉记录下来。以前上午灵光一现想到一个 <strong>idea</strong>，准备晚上写一下，然后晚上就想不起来。。。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1419561-20200403080637826-836232793.jpg" alt="img" /></p>
<p>前期准备时，可以将收集到的资料，素材，全部放到具体卡片中。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1419561-20200403080637970-706620287.jpg" alt="img" /></p>
<p>当我们开始写作后，拖动到下一个列表，完成之后，再拖到下一个列表，这样写作任务非常清晰。</p>
<p><strong>trello</strong> 十分强大，这里只是用了小功能，感兴趣的同学可以深入研究一下。</p>
<h2 id="写作中"> 写作中</h2>
<h3 id="typora-picgo-码云"> typora+PicGo+码云</h3>
<p><strong>markdown 编辑器</strong>：typora，下载地址：https://typora.io/</p>
<p><strong>图床工具</strong>：PicGo，下载地址：https://github.com/Molunerfinn/PicGo/releases</p>
<p>就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具，就目前使用种类而言，<strong>PicGo</strong> 算得上一款比较优秀的图床工具。</p>
<blockquote>
<p>这边使用<code>PicGo+码云</code>来实现markdown图床，也可以使用Github，不过考虑网络问题选择码云。</p>
</blockquote>
<ul>
<li>安装成功界面</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200730102149683.png" alt="image-20200730102149683" /></p>
<ul>
<li>找到底下插件设置，使用码云需要另外安装插件，搜索gitee安装插件，有两个插件都可以用</li>
</ul>
<blockquote>
<p>注意：安装<code>gitee-uploader 1.1.2</code>插件，必须要先安装<code>node.js</code>才能安装插件，我这里安装的是<code>gitee 2.0.2</code></p>
</blockquote>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200730102308996.png" alt="image-20200730102308996" /></p>
<ul>
<li>建立gitee码云图床库，就是在码云新建一个仓库，步骤：</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200323195546145.png" alt="image-20200323195546145" /></p>
<ul>
<li>接下来配置PicGO，安装Gitee插件成功，就会出现Gitee图床栏目：</li>
</ul>
<div><pre><code>url：https://getee.com
owner：写你的码云用户名
repo：仓库名称
token：填入码云的私人令牌
path：路径，一般写上img
message：可以不用写
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200730102607452.png" alt="image-20200730102607452" /></p>
<ul>
<li>设置PicGo开机自启</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200716205307568.png" alt="image-20200716205307568" /></p>
<ul>
<li>配置Typora，点击 文件，偏好设置，选择图像，设置PicGo二进制文件的路径：</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200323201738802.png" alt="image-20200323201738802" /></p>
<ul>
<li>Typora使用下面这个url跟PicGo连接的，所以PicGo的设置也要对应，默认一般就是。</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/ipicgo.png" alt="img" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/ipcigo2.png" alt="image-20200323204010678" /></p>
<ul>
<li>不过PicGo的Server监听端口会经常变动（比如电脑重启后）,就需要修改不然Typora图片也会上传失败。</li>
</ul>
<h3 id="代码图片生成器"> 代码图片生成器</h3>
<p>官网地址:https://carbon.now.sh/</p>
<p>生成比较精美的代码图片，不用担心一些网站不支持代码格式。</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1419561-20200403080639617-2113865405.jpg" alt="1419561-20200403080639617-2113865405" /></p>
<p>另外 <strong>carbon</strong> 还有 IDEA，vscode 等插件，安装之后，可以快速使用。</p>
<h2 id="写作后"> 写作后</h2>
<p>写作完成之后，我们需要将文章发布到微信公众号以及其他博客平台。</p>
<h3 id="微信公众号"> 微信公众号</h3>
<p>由于之前文章采用 <strong>markdown</strong> 写作，而微信公众号编辑器不支持渲染 <strong>markdown</strong>，这就导致我们需要自己排版。虽然排版我们可以使用 <strong>135 编辑器</strong>，<strong>壹伴插件</strong>等完成，不过还是很麻烦。</p>
<p>追求方便的同学可以使用自动排版 <strong>markdown</strong> 的网站，里面支持样式也是比较简洁好看。</p>
<p>官网地址：</p>
<p>http://md.aclickall.com/</p>
<p>https://mdnice.com/</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1419561-20200403080640489-1946118352.jpg" alt="1419561-20200403080640489-1946118352" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1419561-20200403080640732-64891255.jpg" alt="1419561-20200403080640732-64891255" /></p>
<h3 id="其他博客平台"> 其他博客平台</h3>
<p>目前个人还会把文章分发到掘金，博客园，<strong>segmentfault</strong> 等，这些平台都支持 <strong>markdown</strong>,可以直接将 <strong>markdown</strong> 直接复制过去。不过分发平台较多，一个个发还是比较麻烦。</p>
<p>下面推荐两个工具，自动分发文章到各个博客网站。</p>
<p>官网地址：</p>
<p>https://openwrite.cn/</p>
<p>https://github.com/ystcode/BlogHelper</p>
<p><strong>openwrite</strong>，该平台目前采用会员机制，年付会员 <strong>99</strong> 元。免费版可以使用 <strong>BlogHelper</strong> 。</p>
<h2 id="参考文章"> 参考文章</h2>
<ul>
<li>https://www.cnblogs.com/goodAndyxublog/p/12624282.html</li>
<li>https://www.cnblogs.com/qtzd/p/12554902.html</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">高可用开源方案 Keepalived VS Heartbeat对比</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/12.1%20keepalived%E5%92%8Cheartbeat%E5%AF%B9%E6%AF%94/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/12.1%20keepalived%E5%92%8Cheartbeat%E5%AF%B9%E6%AF%94/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="高可用开源方案-keepalived-vs-heartbeat对比"> 高可用开源方案 Keepalived VS Heartbeat对比</h1>
<p>最近因为项目需要，简单的试用了两款高可用开源方案：Keepalived和Heartbeat。两者都很流行，但差异还是很大的，现将试用过程中的感受以及相关知识点简单总结一下，供大家选择方案的时候参考。</p>
<p>1）<strong>Keepalived使用更简单</strong>：从安装、配置、使用、维护等角度上对比，Keepalived都比Heartbeat要简单得多，尤其是Heartbeat2.1.4后拆分成3个子项目，安装、配置、使用都比较复杂，尤其是出问题的时候，都不知道具体是哪个子系统出问题了；而Keepalived只有1个安装文件、1个配置文件，配置文件也简单很多；</p>
<p>2）<strong>Heartbeat功能更强大</strong>：Heartbeat虽然复杂，但功能更强大，配套工具更全，适合做大型集群管理，而Keepalived主要用于集群倒换，基本没有管理功能；</p>
<p>3）<strong>协议不同</strong>：Keepalived使用VRRP协议进行通信和选举，Heartbeat使用心跳进行通信和选举；Heartbeat除了走网络外，还可以通过串口通信，貌似更可靠；</p>
<p>4）<strong>使用方式基本类似</strong>：如果要基于两者设计高可用方案，最终都要根据业务需要写自定义的脚本，Keepalived的脚本没有任何约束，随便怎么写都可以；Heartbeat的脚本有约束，即要支持service start/stop/restart这种方式，而且Heartbeart提供了很多默认脚本，简单的绑定ip，启动apache等操作都已经有了；</p>
<p>使用建议：<strong>优先使用Keepalived</strong>，当Keepalived不够用的时候才选择Heartbeat</p>
<p>转载链接：https://blog.csdn.net/educast/article/details/50377575</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Elastic Stack 家族成员及其应用场景</title>
    <id>https://clay-wangzhi.com/monitor/elk/summarize/scene/</id>
    <link href="https://clay-wangzhi.com/monitor/elk/summarize/scene/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="elastic-stack-家族成员及其应用场景"> Elastic Stack 家族成员及其应用场景</h1>
<h2 id="elastic-stack-生态圈"> Elastic Stack 生态圈</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567739481410.png" alt="" /></p>
<h3 id="logstash-数据处理管道"> Logstash： 数据处理管道</h3>
<ul>
<li>
<p>开源的服务端数据处理管道，支持从不同来源采集数据，转换数据，并将数据发送到不通的存储库中</p>
</li>
<li>
<p>发展</p>
<ul>
<li>Logstash诞生于2009年，最初用来做日志的采集与处理</li>
<li>2013年被Elasticsearch收购</li>
</ul>
</li>
<li>
<p>特性</p>
<ul>
<li>实时解析和转换数据
<ul>
<li>从IP地址破译出地理坐标</li>
<li>将PII数据匿名化，完全排除敏感字段</li>
</ul>
</li>
<li>可扩展 - 200多个插件（日志/数据库/Acsigh/Netflow）</li>
<li>可靠性安全
<ul>
<li>logstash会通过持久化队列来保证至少将运行中的事件送达一次</li>
<li>数据传输加密</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567739654345.png" alt="" /></p>
<h3 id="kibana-可视化分析利器"> Kibana：可视化分析利器</h3>
<ul>
<li>Kibana名字的含义：Kiwifruit + Banana</li>
<li>数据可视化工具，帮助用户解开对数据的任何疑问</li>
<li>基于logstash的工具，2013年加入Elastic公司</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567739969747.png" alt="" /></p>
<h3 id="beats-轻量级的数据采集器"> Beats：轻量级的数据采集器</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567740031729.png" alt="" /></p>
<h3 id="x-pack-商业化套件"> X-pack：商业化套件</h3>
<ul>
<li>6.3之前的版本，X-pack以插件方式安装</li>
<li>X-pack开源之后，ElasticSearch &amp; Kibana支持OSS版和Basic两种版本
<ul>
<li>部分X-pack功能支持免费使用，6.8和7.1开始，Security功能免费</li>
</ul>
</li>
<li>OSS，Basic，黄金级，白金级</li>
</ul>
<h2 id="elk应用场景"> ELK应用场景</h2>
<ul>
<li>网站搜索/垂直搜索/代码搜索</li>
<li>日志管理与分析/安全指标监控/应用性能监控/WEB支取舆情分</li>
</ul>
<h3 id="日志的重要性"> 日志的重要性</h3>
<ul>
<li>为什么重要
<ul>
<li>运维：医生给病人看病，日志就是病人对自己的陈述</li>
<li>恶意攻击，恶意注册，刷单，恶意密码猜测</li>
</ul>
</li>
<li>挑战
<ul>
<li>关注点很多，任何一个点都有可能引起问题</li>
<li>日志分散在很多机器，出了问题时，才发现日志被删了</li>
<li>很多运维人员是消防员，哪里有问题去哪里</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567740850711.png" alt="" /></p>
<h3 id="日志管理流程"> 日志管理流程</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567740876961.png" alt="" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/1567740904642.png" alt="" /></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="监控"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Redis-集群</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/blog-knowledge/Redis-1/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/blog-knowledge/Redis-1/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。</p>

<h2 id="数据分布"> 数据分布</h2>
<h3 id="数据分布理论"> 数据分布理论</h3>
<p>分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。如下图</p>
<p><img src="/images/redis1.png" alt="avatar" /></p>
<h3 id="redis数据分区"> Redis数据分区</h3>
<p>Redis Cluser采用虚拟槽分区，所有的键根据哈希函数映射到0~16383整数槽内，计算公式：slot=CRC16（key）&amp;16383。每一个节点负责维护一部分槽以及槽所映射的键值数据，如下图</p>
<p><img src="/images/redis2.png" alt="avatar" /></p>
<h3 id="集群功能限制"> 集群功能限制</h3>
<p>Redis集群相对单机在功能上存在一些限制，限制如下：</p>
<p>1）key批量操作支持有限。如mset、mget，目前只支持具有相同slot值的key执行批量操作。对于映射为不同slot值的key由于执行mget、mget等操作可能存在于多个节点上因此不被支持。
2）key事务操作支持有限。同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能。
3）key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash、list等映射到不同的节点。
4）不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模式下只能使用一个数据库空间，即db0。
5）复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p>
<h2 id="搭建集群"> 搭建集群</h2>
<h3 id="准备节点"> 准备节点</h3>
<p>Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。建议为集群内所有节点统一目录，一般划分三个目录：conf、data、log，分别存放配置、数据和日志相关文件。</p>
<div><pre><code># 节点端口
port 6379
#  开启集群模式
cluster-enabled yes
#  节点超时时间，单位毫秒
cluster-node-timeout 15000
#  集群内部配置文件
cluster-config-file &quot;nodes-6379.conf&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>其他配置和单机模式一致即可，配置文件命名规则redis-{port}.conf，准备好配置后启动所有节点，命令如下：</p>
<div><pre><code>redis-server conf/redis-6379.conf
redis-server conf/redis-6380.conf
redis-server conf/redis-6381.conf
redis-server conf/redis-6382.conf
redis-server conf/redis-6383.conf
redis-server conf/redis-6384.conf
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>检查节点日志是否正确，日志内容如下：</p>
<div><pre><code>cat log/redis-6379.log
* No cluster configuration found, I&#39;m cfb28ef1deee4e0fa78da86abe5d24566744411e
# Server started, Redis version 3.0.7
* The server is now ready to accept connections on port 6379
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>6379节点启动成功，第一次启动时如果没有集群配置文件，它会自动创建一份，文件名称采用cluster-config-file参数项控制，建议采用node-{port}.conf格式定义，通过使用端口号区分不同节点，防止同一机器下多个节点彼此覆盖，造成集群信息异常。如果启动时存在集群配置文件，节点会使用配置文件内容初始化集群信息。启动过程如下图</p>
<p><img src="/images/redis3.png" alt="avator" /></p>
<p>集群模式的Redis除了原有的配置文件之外又加了一份集群配置文件。当集群内节点信息发生变化，如添加节点、节点下线、故障转移等。节点会自动保存集群状态到配置文件中。需要注意的是，Redis自动维护集群配置文件，不要手动修改，防止节点重启时产生集群信息错乱。如节点6379首次启动后生成集群配置如下：</p>
<div><pre><code>#cat data/nodes-6379.conf
cfb28ef1deee4e0fa78da86abe5d24566744411e 127.0.0.1:6379 myself,master - 0 0 0 connected
vars currentEpoch 0 lastVoteEpoch 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>文件内容记录了集群初始状态，这里最重要的是节点ID，它是一个40位16进制字符串，用于唯一标识集群内一个节点，之后很多集群操作都要借助于节点ID来完成。需要注意是，节点ID不同于运行ID。节点ID在集群初始化时只创建一次，节点重启时会加载集群配置文件进行重用，而Redis的运行ID每次重启都会变化。在节点6380执行cluster nodes命令获取集群节点状态：</p>
<div><pre><code>127.0.0.1:6380&gt;cluster nodes
8e41673d59c9568aa9d29fb174ce733345b3e8f1 127.0.0.1:6380 myself,master - 0 0 0 connected
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>每个节点目前只能识别出自己的节点信息。我们启动6个节点，但每个节点彼此并不知道对方的存在，下面通过节点握手让6个节点彼此建立联系从而组成一个集群。</p>
<h3 id="节点握手"> 节点握手</h3>
<p>节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信，达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命令：cluster meet{ip}{port}，如下图：</p>
<p><img src="/images/redis4.png" alt="avator" /></p>
<p>图中执行的命令是：cluster meet127.0.0.16380让节点6379和6380节点进行握手通信。cluster meet命令是一个异步命令，执行之后立刻返回。内部发起与目标节点进行握手通信，如下图：</p>
<p><img src="/images/redis5.png" alt="avator" /></p>
<p>1）节点6379本地创建6380节点信息对象，并发送meet消息。
2）节点6380接受到meet消息后，保存6379节点信息并回复pong消息。
3）之后节点6379和6380彼此定期通过ping/pong消息进行正常的节点通信。
这里的meet、ping、pong消息是Gossip协议通信的载体，之后的节点通信部分做进一步介绍，它的主要作用是节点彼此交换状态数据信息。6379和6380节点通过meet命令彼此建立通信之后，集群结构如下图：</p>
<p><img src="/images/redis6.png" alt="avator" /></p>
<p>对节点6379和6380分别执行cluster nodes命令，可以看到它们彼此已经感知到对方的存在。</p>
<div><pre><code>127.0.0.1:6379&gt; cluster nodes
cfb28ef1deee4e0fa78da86abe5d24566744411e 127.0.0.1:6379 myself,master - 0 0
0 connected
8e41673d59c9568aa9d29fb174ce733345b3e8f1 127.0.0.1:6380 master - 0 1468073534265
1 connected
127.0.0.1:6380&gt; cluster nodes
cfb28ef1deee4e0fa78da86abe5d24566744411e 127.0.0.1:6379 master - 0 1468073571641
0 connected
8e41673d59c9568aa9d29fb174ce733345b3e8f1 127.0.0.1:6380 myself,master - 0 0
1 connected
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>下面分别执行meet命令让其他节点加入到集群中：</p>
<div><pre><code>127.0.0.1:6379&gt;cluster meet 127.0.0.1 6381
127.0.0.1:6379&gt;cluster meet 127.0.0.1 6382
127.0.0.1:6379&gt;cluster meet 127.0.0.1 6383
127.0.0.1:6379&gt;cluster meet 127.0.0.1 6384
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>我们只需要在集群内任意节点上执行cluster meet命令加入新节点，握手状态会通过消息在集群内传播，这样其他节点会自动发现新节点并发起握手流程。最后执行cluster nodes命令确认6个节点都彼此感知并组成集群：</p>
<div><pre><code>127.0.0.1:6379&gt; cluster nodes
4fa7eac4080f0b667ffeab9b87841da49b84a6e4 127.0.0.1:6384 master - 0 1468073975551
5 connected
cfb28ef1deee4e0fa78da86abe5d24566744411e 127.0.0.1:6379 myself,master - 0 0 0 connected
be9485a6a729fc98c5151374bc30277e89a461d8 127.0.0.1:6383 master - 0 1468073978579
4 connected
40622f9e7adc8ebd77fca0de9edfe691cb8a74fb 127.0.0.1:6382 master - 0 1468073980598
3 connected
8e41673d59c9568aa9d29fb174ce733345b3e8f1 127.0.0.1:6380 master - 0 1468073974541
1 connected
40b8d09d44294d2e23c7c768efc8fcd153446746 127.0.0.1:6381 master - 0 1468073979589
2 connected
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>节点建立握手之后集群还不能正常工作，这时集群处于下线状态，所有的数据读写都被禁止。通过如下命令可以看到：</p>
<div><pre><code>127.0.0.1:6379&gt; set hello redis
(error) CLUSTERDOWN The cluster is down
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>通过cluster info命令可以获取集群当前状态：</p>
<div><pre><code>127.0.0.1:6379&gt; cluster info
cluster_state:fail
cluster_slots_assigned:0
cluster_slots_ok:0
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:0
...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>从输出内容可以看到，被分配的槽（cluster_slots_assigned）是0，由于目前所有的槽没有分配到节点，因此集群无法完成槽到节点的映射。只有当16384个槽全部分配给节点后，集群才进入在线状态。</p>
<h3 id="分配槽"> 分配槽</h3>
<p>Redis集群把所有的数据映射到16384个槽中。每个key会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过cluster addslots命令为节点分配槽。这里利用bash特性批量设置槽（slots），命令如下：</p>
<div><pre><code>redis-cli -h 127.0.0.1 -p 6379 cluster addslots {0...5461}
redis-cli -h 127.0.0.1 -p 6380 cluster addslots {5462...10922}
redis-cli -h 127.0.0.1 -p 6381 cluster addslots {10923...16383}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>把16384个slot平均分配给6379、6380、6381三个节点。执行cluster info查看集群状态，如下所示：</p>
<div><pre><code>127.0.0.1:6379&gt; cluster info
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:5
cluster_my_epoch:0
cluster_stats_messages_sent:4874
cluster_stats_messages_received:4726
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>当前集群状态是OK，集群进入在线状态。所有的槽都已经分配给节点，执行cluster nodes命令可以看到节点和槽的分配关系：</p>
<div><pre><code>127.0.0.1:6379&gt; cluster nodes
4fa7eac4080f0b667ffeab9b87841da49b84a6e4 127.0.0.1:6384 master - 0 1468076240123
5 connected
cfb28ef1deee4e0fa78da86abe5d24566744411e 127.0.0.1:6379 myself,master - 0 0 0 connected
0-5461
be9485a6a729fc98c5151374bc30277e89a461d8 127.0.0.1:6383 master - 0 1468076239622
4 connected
40622f9e7adc8ebd77fca0de9edfe691cb8a74fb 127.0.0.1:6382 master - 0 1468076240628
3 connected
8e41673d59c9568aa9d29fb174ce733345b3e8f1 127.0.0.1:6380 master - 0 1468076237606
1 connected
5462-10922
40b8d09d44294d2e23c7c768efc8fcd153446746 127.0.0.1:6381 master - 0 1468076238612
2 connected
10923-16383
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>目前还有三个节点没有使用，作为一个完整的集群，每个负责处理槽的节点应该具有从节点，保证当它出现故障时可以自动进行故障转移。集群模式下，Reids节点角色分为主节点和从节点。首次启动的节点和被分配槽的节点都是主节点，从节点负责复制主节点槽信息和相关的数据。使用cluster replicate {nodeId}命令让一个节点成为从节点。其中命令执行必须在对应的从节点上执行，nodeId是要复制主节点的节点ID，命令如下：</p>
<div><pre><code>127.0.0.1:6382&gt;cluster replicate cfb28ef1deee4e0fa78da86abe5d24566744411e
OK
127.0.0.1:6383&gt;cluster replicate 8e41673d59c9568aa9d29fb174ce733345b3e8f1
OK
127.0.0.1:6384&gt;cluster replicate 40b8d09d44294d2e23c7c768efc8fcd153446746
OK
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Redis集群模式下的主从复制使用了之前介绍的Redis复制流程，依然支持全量和部分复制。复制（replication）完成后，整个集群的结构如下图：</p>
<p><img src="/images/redis7.png" alt="avator" /></p>
<p>通过cluster nodes命令查看集群状态和复制关系，如下所示：</p>
<div><pre><code>127.0.0.1:6379&gt; cluster nodes
4fa7eac4080f0b667ffeab9b87841da49b84a6e4 127.0.0.1:6384 slave 40b8d09d44294d2e2
3c7c768efc8fcd153446746 0 1468076865939 5 connected
cfb28ef1deee4e0fa78da86abe5d24566744411e 127.0.0.1:6379 myself,master - 0 0 0 connected
0-5461
be9485a6a729fc98c5151374bc30277e89a461d8 127.0.0.1:6383 slave 8e41673d59c9568aa
9d29fb174ce733345b3e8f1 0 1468076868966 4 connected
40622f9e7adc8ebd77fca0de9edfe691cb8a74fb 127.0.0.1:6382 slave cfb28ef1deee4e0fa
78da86abe5d24566744411e 0 1468076869976 3 connected
8e41673d59c9568aa9d29fb174ce733345b3e8f1 127.0.0.1:6380 master - 0 1468076870987 1
connected 5462-10922
40b8d09d44294d2e23c7c768efc8fcd153446746 127.0.0.1:6381 master - 0 1468076867957 2
connected 10923-16383
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>目前为止，我们依照Redis协议手动建立一个集群。它由6个节点构成，3个主节点负责处理槽和相关数据，3个从节点负责故障转移。手动搭建集群便于理解集群建立的流程和细节，不过读者也从中发现集群搭建需要很多步骤，当集群节点众多时，必然会加大搭建集群的复杂度和运维成本。因此Redis官方提供了redis-trib.rb工具方便我们快速搭建集群。</p>
<h3 id="用redis-trib-rb搭建集群"> 用redis-trib.rb搭建集群</h3>
<p>redis-trib.rb是采用Ruby实现的Redis集群管理工具。内部通过Cluster相关命令帮我们简化集群创建、检查、槽迁移和均衡等常见运维操作，使用之前需要安装Ruby依赖环境。下面介绍搭建集群的详细步骤。</p>
<p>1.Ruby环境准备</p>
<p>安装Ruby：</p>
<div><pre><code>--  下载 ruby
wget https:// cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1.tar.gz
--  安装 ruby
tar xvf ruby-2.3.1.tar.gz
./configure -prefix=/usr/local/ruby
make
make install
cd /usr/local/ruby
sudo cp bin/ruby /usr/local/bin
sudo cp bin/gem /usr/local/bin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>安装rubygem redis依赖：</p>
<div><pre><code>wget http:// rubygems.org/downloads/redis-3.3.0.gem
gem install -l redis-3.3.0.gem
gem list --check redis gem
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>安装redis-trib.rb：</p>
<div><pre><code>sudo cp /{redis_home}/src/redis-trib.rb /usr/local/bin
</code></pre>
<div><span>1</span><br></div></div><p>安装完Ruby环境后，执行redis-trib.rb命令确认环境是否正确，输出如下：</p>
<div><pre><code># redis-trib.rb
Usage: redis-trib &lt;command&gt; &lt;options&gt; &lt;arguments ...&gt;
create host1:port1 ... hostN:portN
--replicas &lt;arg&gt;
check host:port
info host:port
fix host:port
--timeout &lt;arg&gt;
reshard host:port
--from &lt;arg&gt;
--to &lt;arg&gt;
--slots &lt;arg&gt;
--yes
--timeout &lt;arg&gt;
--pipeline &lt;arg&gt;
... 忽略 ...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>从redis-trib.rb的提示信息可以看出，它提供了集群创建、检查、修复、均衡等命令行工具。这里我们关注集群创建命令，使用redis-trib.rb create命令可快速搭建集群。</p>
<p>2.准备节点</p>
<p>首先我们跟之前内容一样准备好节点配置并启动：</p>
<div><pre><code>redis-server conf/redis-6481.conf
redis-server conf/redis-6482.conf
redis-server conf/redis-6483.conf
redis-server conf/redis-6484.conf
redis-server conf/redis-6485.conf
redis-server conf/redis-6486.conf
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>3.创建集群</p>
<p>启动好6个节点之后，使用redis-trib.rb create命令完成节点握手和槽分配过程，命令如下：</p>
<div><pre><code>redis-trib.rb create --replicas 1 127.0.0.1:6481 127.0.0.1:6482 127.0.0.1:6483 127.0.0.1:6484 127.0.0.1:6485 127.0.0.1:6486
</code></pre>
<div><span>1</span><br></div></div><p>--replicas参数指定集群中每个主节点配备几个从节点，这里设置为1。</p>
<p>我们出于测试目的使用本地IP地址127.0.0.1，如果部署节点使用不同的IP地址，redis-trib.rb会尽可能保证主从节点不分配在同一机器下，因此会重新排序节点列表顺序。节点列表顺序用于确定主从角色，先主节点之后是从节点。创建过程中首先会给出主从节点角色分配的计划，如下所示。</p>
<div><pre><code>&gt;&gt;&gt; Creating cluster
&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...
Using 3 masters:
127.0.0.1:6481
127.0.0.1:6482
127.0.0.1:6483
Adding replica 127.0.0.1:6484 to 127.0.0.1:6481
Adding replica 127.0.0.1:6485 to 127.0.0.1:6482
Adding replica 127.0.0.1:6486 to 127.0.0.1:6483
M: 869de192169c4607bb886944588bc358d6045afa 127.0.0.1:6481
slots:0-5460 (5461 slots) master
M: 6f9f24923eb37f1e4dce1c88430f6fc23ad4a47b 127.0.0.1:6482
slots:5461-10922 (5462 slots) master
M: 6228a1adb6c26139b0adbe81828f43a4ec196271 127.0.0.1:6483
slots:10923-16383 (5461 slots) master
S: 22451ea81fac73fe7a91cf051cd50b2bf308c3f3 127.0.0.1:6484
replicates 869de192169c4607bb886944588bc358d6045afa
S: 89158df8e62958848134d632e75d1a8d2518f07b 127.0.0.1:6485
replicates 6f9f24923eb37f1e4dce1c88430f6fc23ad4a47b
S: bcb394c48d50941f235cd6988a40e469530137af 127.0.0.1:6486
replicates 6228a1adb6c26139b0adbe81828f43a4ec196271
Can I set the above configuration (type &#39;yes&#39; to accept):
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>当我们同意这份计划之后输入yes，redis-trib.rb开始执行节点握手和槽分配操作，输出如下：</p>
<div><pre><code>&gt;&gt;&gt; Nodes configuration updated
&gt;&gt;&gt; Assign a different config epoch to each node
&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join..
&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:6481)
... 忽略 ...
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>最后的输出报告说明：16384个槽全部被分配，集群创建成功。这里需要注意给redis-trib.rb的节点地址必须是不包含任何槽/数据的节点，否则会拒绝创建集群。</p>
<p>4.集群完整性检查</p>
<p>集群完整性指所有的槽都分配到存活的主节点上，只要16384个槽中有一个没有分配给节点则表示集群不完整。可以使用redis-trib.rb check命令检测之前创建的两个集群是否成功，check命令只需要给出集群中任意一个节点地址就可以完成整个集群的检查工作，命令如下：</p>
<div><pre><code>redis-trib.rb check 127.0.0.1:6379
redis-trib.rb check 127.0.0.1:6481
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当最后输出如下信息，提示集群所有的槽都已分配到节点：</p>
<div><pre><code>[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="节点通信"> 节点通信</h2>
<h3 id="通信流程"> 通信流程</h3>
<p>在分布式存储中需要提供维护节点元数据信息的机制，所谓元数据是指：节点负责哪些数据，是否出现故障等状态信息。常见的元数据维护方式分为：集中式和P2P方式。Redis集群采用P2P的Gossip（流言）协议，Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播，如下图：</p>
<p><img src="/images/redis8.png" alt="avator" /></p>
<p>通信过程说明：
1）集群中的每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口上加10000。</p>
<p>2）每个节点在固定周期内通过特定规则选择几个节点发送ping消息。</p>
<p>3）接收到ping消息的节点用pong消息作为响应。</p>
<p>集群中每个节点通过一定规则挑选要通信的节点，每个节点可能知道全部节点，也可能仅知道部分节点，只要这些节点彼此可以正常通信，最终它们会达到一致的状态。当节点出故障、新节点加入、主从角色变化、槽信息变更等事件发生时，通过不断的ping/pong消息通信，经过一段时间后所有的节点都会知道整个集群全部节点的最新状态，从而达到集群状态同步的目的。</p>
<h3 id="gossip消息"> Gossip消息</h3>
<p>Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息，了解这些消息有助于我们理解集群如何完成信息交换。</p>
<p>常用的Gossip消息可分为：ping消息、pong消息、meet消息、fail消息
等，它们的通信模式如下图：</p>
<p><img src="/images/redis9.png" alt="avator" /></p>
<p>​	·meet消息：用于通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换。</p>
<p>​	·ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消息发送封装了自身节点和部分其他节点的状态数据。</p>
<p>​	·pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。</p>
<p>​	·fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。</p>
<p>所有的消息格式划分为：消息头和消息体。消息头包含发送节点自身状态数据，接收节点根据消息头就可以获取到发送节点的相关数据，结构如下：</p>
<div><pre><code>typedef struct {
char sig[4]; /*  信号标示 */
uint32_t totlen; /*  消息总长度 */
uint16_t ver; /*  协议版本 */
uint16_t type; /*  消息类型 , 用于区分 meet,ping,pong 等消息 */
uint16_t count; /*  消息体包含的节点数量，仅用于 meet,ping,ping 消息类型 */
uint64_t currentEpoch; /*  当前发送节点的配置纪元 */
uint64_t configEpoch; /*  主节点 / 从节点的主节点配置纪元 */
uint64_t offset; /*  复制偏移量 */
char sender[CLUSTER_NAMELEN]; /*  发送节点的 nodeId */
unsigned char myslots[CLUSTER_SLOTS/8]; /*  发送节点负责的槽信息 */
char slaveof[CLUSTER_NAMELEN]; /*  如果发送节点是从节点，记录对应主节点的 nodeId */
uint16_t port; /*  端口号 */
uint16_t flags; /*  发送节点标识 , 区分主从角色，是否下线等 */
unsigned char state; /*  发送节点所处的集群状态 */
unsigned char mflags[3]; /*  消息标识 */
union clusterMsgData data /*  消息正文 */;
} clusterMsg;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>集群内所有的消息都采用相同的消息头结构clusterMsg，它包含了发送节点关键信息，如节点id、槽映射、节点标识（主从角色，是否下线）等。消息体在Redis内部采用clusterMsgData结构声明，结构如下：</p>
<div><pre><code>union clusterMsgData {
/* ping,meet,pong 消息体 */
struct {
/* gossip 消息结构数组 */
clusterMsgDataGossip gossip[1];
} ping;
/* FAIL  消息体 */
struct {
clusterMsgDataFail about;
} fail;
// ...
};
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>当接收到ping、meet消息时，接收节点会解析消息内容并根据自身的识
别情况做出相应处理，对应流程如下图：</p>
<p><img src="/images/redis10.png" alt="avator" /></p>
<p><img src="/images/redis11.png" alt="avator" /></p>
<p>接收节点收到ping/meet消息时，执行解析消息头和消息体流程：
​	·解析消息头过程：消息头包含了发送节点的信息，如果发送节点是新节点且消息是meet类型，则加入到本地节点列表；如果是已知节点，则尝试更新发送节点的状态，如槽映射关系、主从角色等状态。</p>
<p>​	·解析消息体过程：如果消息体的clusterMsgDataGossip数组包含的节点是新节点，则尝试发起与新节点的meet握手流程；如果是已知节点，则根据cluster MsgDataGossip中的flags字段判断该节点是否下线，用于故障转移。
​	消息处理完后回复pong消息，内容同样包含消息头和消息体，发送节点接收到回复的pong消息后，采用类似的流程解析处理消息并更新与接收节点最后通信时间，完成一次消息通信。</p>
<h3 id="节点选择"> 节点选择</h3>
<p>虽然Gossip协议的信息交换机制具有天然的分布式特性，但它是有成本的。由于内部需要频繁地进行节点信息交换，而ping/pong消息会携带当前节点和部分其他节点的状态数据，势必会加重带宽和计算的负担。Redis集群内节点通信采用固定频率（定时任务每秒执行10次）。因此节点每次选择需要通信的节点列表变得非常重要。通信节点选择过多虽然可以做到信息及时交换但成本过高。节点选择过少会降低集群内所有节点彼此信息交换频率，从而影响故障判定、新节点发现等需求的速度。因此Redis集群的Gossip协议需要兼顾信息交换实时性和成本开销，通信节点选择的规则如下图：</p>
<p><img src="/images/redis12.png" alt="avator" /></p>
<p>​	根据通信节点选择的流程可以看出消息交换的成本主要体现在单位时间
选择发送消息的节点数量和每个消息携带的数据量。</p>
<p>1.选择发送消息的节点数量
​	集群内每个节点维护定时任务默认每秒执行10次，每秒会随机选取5个节点找出最久没有通信的节点发送ping消息，用于保证Gossip信息交换的随机性。每100毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster_node_timeout/2，则立刻发送ping消息，防止该节点信息太长时间未更新。根据以上规则得出每个节点每秒需要发送ping消息的数量=1+10*num（node.pong_received&gt;cluster_node_timeout/2），因此cluster_node_timeout参数对消息发送的节点数量影响非常大。当我们的带宽资源紧张时，可以适当调大这个参数，如从默认15秒改为30秒来降低带宽占用率。过度调大cluster_node_timeout会影响消息交换的频率从而影响故障转移、槽信息更新、新节点发现的速度。因此需要根据业务容忍度和资源消耗进行平衡。同时整个集群消息总交换量也跟节点数成正比。
2.消息数据量
​	每个ping消息的数据量体现在消息头和消息体中，其中消息头主要占用空间的字段是myslots[CLUSTER_SLOTS/8]，占用2KB，这块空间占用相对固定。消息体会携带一定数量的其他节点信息用于信息交换。具体数量见以下伪代码：</p>
<div><pre><code>def get_wanted():
int total_size = size(cluster.nodes)
#  默认包含节点总量的 1/10
int wanted = floor(total_size/10);
if wanted &lt; 3:
#  至少携带 3 个其他节点信息
wanted = 3;
if wanted &gt; total_size -2 :
#  最多包含 total_size - 2 个
wanted = total_size - 2;
return wanted;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>根据伪代码可以看出消息体携带数据量跟集群的节点数息息相关，更大的集群每次消息通信的成本也就更高，因此对于Redis集群来说并不是大而全的集群更好，对于集群规模控制的建议见后续集群详解。</p>
<h2 id="集群伸缩"> 集群伸缩</h2>
<h3 id="伸缩原理"> 伸缩原理</h3>
<p>Redis集群提供了灵活的节点扩容和收缩方案。在不影响集群对外服务的情况下，可以为集群添加节点进行扩容也可以下线部分节点进行缩容，如下图</p>
<p><img src="/images/redis13.png" alt="avator" /></p>
<p>从上图看出，Redis集群可以实现对节点的灵活上下线控制。其中原理可抽象为槽和对应数据在不同节点之间灵活移动。首先来看我们之前搭建的集群槽和数据与节点的对应关系，如下图：</p>
<p><img src="/images/redis14.png" alt="avator" /></p>
<p><img src="/images/redis15.png" alt="avator" /></p>
<p>三个主节点分别维护自己负责的槽和对应的数据，如果希望加入1个节点实现集群扩容时，需要通过相关命令把一部分槽和数据迁移给新节点，如下图：</p>
<p><img src="/images/redis16.png" alt="avator" /></p>
<p>图中每个节点把一部分槽和数据迁移到新的节点6385，每个节点负责的槽和数据相比之前变少了从而达到了集群扩容的目的。这里我们故意忽略了槽和数据在节点之间迁移的细节，目的是想让读者重点关注在上层槽和节点分配上来，理解集群的水平伸缩的上层原理：集群伸缩=槽和数据在节点之间的移动，下面将介绍集群扩容和收缩的细节。</p>
<h3 id="扩容集群"> 扩容集群</h3>
<p>​	扩容是分布式存储最常见的需求，Redis集群扩容操作可分为如下步
骤：
1）准备新节点。
2）加入集群。
3）迁移槽和数据。</p>
<p>1.准备新节点
需要提前准备好新节点并运行在集群模式下，新节点建议跟集群内的节点配置保持一致，便于管理统一。准备好配置后启动两个节点命令如下：</p>
<div><pre><code>redis-server conf/redis-6385.conf
redis-server conf/redis-6386.conf
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>启动后的新节点作为孤儿节点运行，并没有其他节点与之通信.</p>
<p>2.加入集群
新节点依然采用cluster meet命令加入到现有集群中。在集群内任意节点
执行cluster meet命令让6385和6386节点加入进来，命令如下：</p>
<div><pre><code>127.0.0.1:6379&gt; cluster meet 127.0.0.1 6385
127.0.0.1:6379&gt; cluster meet 127.0.0.1 6386
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>集群内新旧节点经过一段时间的ping/pong消息通信之后，所有节点会发现新节点并将它们的状态保存到本地。例如我们在6380节点上执行cluster nodes命令可以看到新节点信息，如下所示：</p>
<div><pre><code>127.0.0.1:6380&gt;cluster ndoes
1a205dd8b2819a00dd1e8b6be40a8e2abe77b756 127.0.0.1:6385 master - 0 1469347800759
7 connected
475528b1bcf8e74d227104a6cf1bf70f00c24aae 127.0.0.1:6386 master - 0 1469347798743
8 connected
...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>​	新节点刚开始都是主节点状态，但是由于没有负责的槽，所以不能接受任何读写操作。对于新节点的后续操作我们一般有两种选择：
​	·为它迁移槽和数据实现扩容。
​	·作为其他主节点的从节点负责故障转移。</p>
<p>​	redis-trib.rb工具也实现了为现有集群添加新节点的命令，还实现了直接
添加为从节点的支持，命令如下：</p>
<div><pre><code>redis-trib.rb add-node new_host:new_port existing_host:existing_port --slave
--master-id &lt;arg&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>​	内部同样采用cluster meet命令实现加入集群功能。对于之前的加入集群操作，我们可以采用如下命令实现新节点加入：</p>
<div><pre><code>redis-trib.rb add-node 127.0.0.1:6385 127.0.0.1:6379
redis-trib.rb add-node 127.0.0.1:6386 127.0.0.1:6379
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>运维提示</p>
<p>​	正式环境建议使用redis-trib.rb add-node命令加入新节点，该命令内部会执行新节点状态检查，如果新节点已经加入其他集群或者包含数据，则放弃集群加入操作并打印如下信息：</p>
<div><pre><code>[ERR] Node 127.0.0.1:6385 is not empty. Either the node already knows other
nodes (check with CLUSTER NODES) or contains some key in database 0.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果我们手动执行cluster meet命令加入已经存在于其他集群的节点，会造成被加入节点的集群合并到现有集群的情况，从而造成数据丢失和错乱，后果非常严重，线上谨慎操作。</p>
<p>3.迁移槽和数据
​	加入集群后需要为新节点迁移槽和相关数据，槽在迁移过程中集群可以正常提供读写服务，迁移过程是集群扩容最核心的环节，下面详细讲解。
​	（1）槽迁移计划
​	槽是Redis集群管理数据的基本单位，首先需要为新节点制定槽的迁移计划，确定原有节点的哪些槽需要迁移到新节点。迁移计划需要确保每个节点负责相似数量的槽，从而保证各节点的数据均匀。例如，在集群中加入6385节点，如图10-21所示。加入6385节点后，原有节点负责的槽数量从6380变为4096个。</p>
<p>槽迁移计划确定后开始逐个把槽内数据从源节点迁移到目标节点，如下图：</p>
<p><img src="/images/redis17.png" alt="avator" /></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2017-09-16T21:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">sed命令详解</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/blog-knowledge/shell-sed/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/blog-knowledge/shell-sed/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>Let's learn the sed command together！</p>

<h2 id="概述"> 概述</h2>
<p>sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理是，当前处理的行存储在临时缓冲区中，成为“pattern space”,接着用sed命令处理缓冲区中的内容，处理完后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，知道文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p>
<h2 id="语法"> 语法</h2>
<h3 id="命令格式"> 命令格式</h3>
<p>sed [option] 'command' input_file</p>
<h3 id="常用选项"> 常用选项</h3>
<ul>
<li>-n 使用安静silent模式。在一般sed的用法中，所有来自stdin的内容一般都会列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行（或者动作）才会被列出来</li>
<li>-e 进行多项编辑，即对输入行应用多条sed命令时使用</li>
<li>-f 指定sed脚本的文件名</li>
<li>-i 直接修改读取的文件内容，而不是由屏幕输出</li>
<li>-r 让sed命令支持扩展的正则表达式（默认是基础正则表达式）</li>
</ul>
<h3 id="常用命令"> 常用命令</h3>
<ul>
<li>
<p><code>a\</code>：追加行，<code>a\</code>的后面跟上字符串<code>s</code>（多行字符串可以用<code>\n</code>分隔），则会在当前选择的行的后面都加上字符串<code>s</code></p>
</li>
<li>
<p><code>c\：</code>替换行，<code>c\</code>后面跟上字符串<code>s</code>（多行字符串可以用<code>\n</code>分隔），则会将当前选中的行替换成字符串<code>s</code></p>
</li>
<li>
<p><code>i\</code>：插入行，<code>i\</code>后面跟上字符串<code>s</code>(多行字符串可以用<code>\n</code>分隔)，则会在当前选中的行的前面都插入字符串<code>s</code></p>
</li>
<li>
<p><code>d</code>：删除行<code>delete</code>，该命令会将当前选中的行删除</p>
</li>
<li>
<p><code>p</code>：打印<code>print</code>，该命令会打印当前选择的行到屏幕上</p>
</li>
<li>
<p><code>y</code>：替换字符，通常<code>y</code>命令的用法是这样的：<code>y/Source-chars/Dest-chars/</code>，分割字符<code>/</code>可以用任意单字符代替，用<code>Dest-chars</code>中对应位置的字符替换掉<code>Soutce-chars</code>中对应位置的字符</p>
</li>
<li>
<p><code>s</code>：替换字符串，通常<code>s</code>命令的用法是这样的：<code>1,$s/Regexp/Replacement/Flags</code>，分隔字符<code>/</code>可以用其他任意单字符代替，用<code>Replacement</code>替换掉匹配字符串</p>
</li>
</ul>
<h3 id="替换选项"> 替换选项</h3>
<ul>
<li>
<p><code>\digit</code>：<code>Replacement</code>中可含有后向引用中的<code>\digit</code>(<code>digit</code>是<code>1</code>至<code>9</code>)，引用前面定义的子表达</p>
</li>
<li>
<p><code>&amp;</code>：代表模版空间中的整个匹配部分</p>
</li>
<li>
<p><code>\L</code>：将在其后的替换部分转换成小写字母，直到发现一个<code>\U</code>或<code>\E</code>，<code>GNU</code>扩展功能</p>
</li>
<li>
<p><code>\l</code>：将下一个字符转换成小写字母，<code>GNU</code>扩展功能</p>
</li>
<li>
<p><code>\U</code>：将在其后的替换部分转换成大写字母，直到发现一个<code>\L</code>或<code>\E</code>，<code>GNU</code>扩展功能</p>
</li>
<li>
<p><code>\u</code>：将下一个字符转换成大写字母，<code>GNU</code>扩展功能</p>
</li>
<li>
<p><code>\E</code>：停止由<code>\L</code>或<code>\U</code>指示开始的大小写转换，<code>GNU</code>扩展功能</p>
</li>
</ul>
<h3 id="标记选项"> 标记选项</h3>
<ul>
<li>
<p><code>g</code>：将用<code>Replacement</code>替换模版空间中所有匹配<code>Regexp</code>的部分，则不仅仅是第一个匹配部分</p>
</li>
<li>
<p><code>digit</code>：只用<code>Replacement</code>替换模版空间中第<code>digit</code>(<code>digit</code>是<code>1</code>至<code>9</code>)个匹配<code>Regexp</code>的部分</p>
</li>
<li>
<p><code>p</code>：若发生了替换操作，指示显示模版空间中新的数据</p>
</li>
<li>
<p><code>w file-name</code>：若发生了替换操作，指示将模版空间中新的数据写入指定的文件<code>file-name</code>中</p>
</li>
<li>
<p><code>i</code>：表示进行<code>Regexp</code>匹配时，是不区分大小写字母的</p>
</li>
</ul>
<h2 id="示例"> 示例</h2>
<h3 id="a命令"> <code>a</code>命令</h3>
<ul>
<li><code>sed '1,$a\add one' test.txt</code> 从第一行到最后一行所有行后追加<code>&quot;add one&quot;</code>字符串行</li>
<li><code>sed '/first/a\add one' test.txt</code> 在匹配到<code>first</code>行追加<code>&quot;add one&quot;</code>字符串行</li>
</ul>
<h3 id="c命令"> <code>c</code>命令</h3>
<ul>
<li>
<p><code>sed '1,$c\add one' test.txt</code> 从第一行到最后一行所有行替换为<code>&quot;add one&quot;</code>字符串行</p>
</li>
<li>
<p><code>sed '/first/c\add one' test.txt</code> 将匹配到<code>first</code>行替换为<code>&quot;add one&quot;</code>字符串行</p>
</li>
</ul>
<h3 id="i命令"> <code>i</code>命令</h3>
<p>与<code>a</code>命令类似，只不过在匹配的行前面插入字符串行，不举例了。</p>
<h3 id="d命令"> <code>d</code>命令</h3>
<ul>
<li><code>sed '4,$d' test.txt</code> 从第四行到最后一行全部删除</li>
</ul>
<h3 id="p命令"> <code>p</code>命令</h3>
<ul>
<li><code>sed -n '/^first.*end$/p' test.txt</code> 以<code>first</code>开头<code>end</code>结尾的所有行全部打印，<strong>-n选项</strong>和<strong>p命令</strong>一起使用表示只打印那些发生替换的行</li>
</ul>
<h3 id="s命令"> <code>s</code>命令</h3>
<ul>
<li><code>sed 's/line/text/g' test.txt</code> 将所有行的<code>line</code>替换为<code>text</code>，<code>g</code>代表全局选项，没有<code>g</code>只替换所有行的第一个匹配项</li>
<li><code>sed '/^first.*end$/s/line/text/g' test.txt</code> 匹配以<code>first</code>开头<code>end</code>结尾的所有行，然后将<code>line</code>全部替换为<code>text</code></li>
<li><code>sed 's/\(.*\)line$/\1/g' test.txt</code> 本例中的<code>\(\)</code>中包裹的内容表示正则表达式的第<code>n</code>部分，<code>.*</code>表示任意字符串，所以此例相当于删除所有行末的<code>line</code></li>
<li><code>sed -i 's/book/books/g' test.txt</code> 直接编辑文件<strong>选项-i</strong>，会匹配file文件中每一行的第一个book替换为books</li>
</ul>
<h3 id="e命令"> <code>e</code>命令</h3>
<div><pre><code>sed -e &#39;1,5d&#39; -e &#39;s/test/check/&#39; file
</code></pre>
<div><span>1</span><br></div></div><p>上面sed表达式的第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</p>
<h3 id="n命令"> <code>n</code>命令</h3>
<p>如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续：</p>
<div><pre><code>sed &#39;/test/{ n; s/aa/bb/; }&#39; file
</code></pre>
<div><span>1</span><br></div></div><h3 id="q命令"> <code>q</code>命令</h3>
<p>打印完第10行后，退出sed</p>
<div><pre><code>sed &#39;10q&#39; file
</code></pre>
<div><span>1</span><br></div></div><h3 id="w命令"> <code>w</code>命令</h3>
<p>在example中所有包含test的行都被写入file里：</p>
<div><pre><code>sed -n &#39;/test/w file&#39; example
</code></pre>
<div><span>1</span><br></div></div><h3 id="已匹配字符串标记"> 已匹配字符串标记&amp;</h3>
<p>正则表达式 \w+ 匹配每一个单词，使用 [&amp;] 替换它，&amp; 对应于之前所匹配到的单词：</p>
<div><pre><code>echo this is a test line | sed &#39;s/\w\+/[&amp;]/g&#39;
[this] [is] [a] [test] [line]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>所有以192.168.0.1开头的行都会被替换成它自已加localhost：</p>
<div><pre><code>sed &#39;s/^192.168.0.1/&amp;localhost/&#39; file
192.168.0.1localhost
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="子串匹配标记-1"> 子串匹配标记\1</h3>
<p>匹配给定样式的其中一部分：</p>
<div><pre><code>echo this is digit 7 in a number | sed &#39;s/digit \([0-9]\)/\1/&#39;
this is 7 in a number
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>命令中 digit 7，被替换成了 7。样式匹配到的子串是 7，(..) 用于匹配子串，对于匹配到的第一个子串就标记为 <strong>\1</strong>，依此类推匹配到的第二个结果就是 <strong>\2</strong>，例如：</p>
<div><pre><code>echo aaa BBB | sed &#39;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&#39;
BBB aaa
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>love被标记为1，所有loveable会被替换成lovers，并打印出来：</p>
<div><pre><code>sed -n &#39;s/\(love\)able/\1rs/p&#39; file
</code></pre>
<div><span>1</span><br></div></div><h3 id="选定行的范围-逗号"> 选定行的范围：,（逗号）</h3>
<p>所有在模板test和check所确定的范围内的行都被打印：</p>
<div><pre><code>sed -n &#39;/test/,/check/p&#39; file
</code></pre>
<div><span>1</span><br></div></div><p>打印从第5行开始到第一个包含以test开始的行之间的所有行：</p>
<div><pre><code>sed -n &#39;5,/^test/p&#39; file
</code></pre>
<div><span>1</span><br></div></div><p>对于模板test和west之间的行，每行的末尾用字符串aaa bbb替换：</p>
<div><pre><code>sed &#39;/test/,/west/s/$/aaa bbb/&#39; file
</code></pre>
<div><span>1</span><br></div></div><h3 id="打印奇数行或偶数行"> 打印奇数行或偶数行</h3>
<p>方法1：</p>
<div><pre><code>sed -n &#39;p;n&#39; test.txt  #奇数行
sed -n &#39;n;p&#39; test.txt  #偶数行

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>方法2：</p>
<div><pre><code>sed -n &#39;1~2p&#39; test.txt  #奇数行
sed -n &#39;2~2p&#39; test.txt  #偶数行
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="基本正则表达式"> 基本正则表达式</h2>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>将<code>*</code>前面的正则表达式匹配的结果重复任意次(含<code>0</code>次)。</td>
</tr>
<tr>
<td><code>\+</code></td>
<td>与星号(<code>*</code>)相同，只是至少重复<code>1</code>次，<code>GNU</code>的扩展功能。</td>
</tr>
<tr>
<td><code>\?</code></td>
<td>与星号(<code>*</code>)相同，只是最多重复<code>1</code>次，<code>GNU</code>的扩展功能。</td>
</tr>
<tr>
<td><code>\{i\}</code></td>
<td>与星号(<code>*</code>)相同，只是重复指定的<code>i</code>次。</td>
</tr>
<tr>
<td><code>\{i,j\}</code></td>
<td>与星号(<code>*</code>)相同，只是重复<code>i</code>至<code>j</code>次。</td>
</tr>
<tr>
<td><code>\{i, \}</code></td>
<td>与星号(<code>*</code>)相同，只是至少重复<code>i</code>次。</td>
</tr>
<tr>
<td><code>\(regexp\)</code></td>
<td>将<code>regexp</code>看作一个整体，用于后向引用，与<code>\digit</code>配合使用。</td>
</tr>
<tr>
<td><code>.</code></td>
<td>匹配任意单个字符。</td>
</tr>
<tr>
<td><code>^</code></td>
<td>匹配模版空间开始处的<code>NULL</code>字符串。</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配的是模版空间结束处的<code>NULL</code>字符串。</td>
</tr>
<tr>
<td><code>[list]</code></td>
<td>匹配方括号中的字符列表中的任意一个。</td>
</tr>
<tr>
<td><code>[^list]</code></td>
<td>否定匹配方括号中的字符列表中的任意一个。</td>
</tr>
<tr>
<td><code>regexp1\|regexp2</code></td>
<td>用在相邻的正则表达式之间，表示匹配这些正则表达式中任一个都可以。匹配是从左向右开始的，一旦匹配成功就停止匹配。</td>
</tr>
<tr>
<td><code>regexp1regexp2</code></td>
<td>匹配<code>regexp1</code>和<code>regexp2</code>的连接结果。</td>
</tr>
<tr>
<td><code>\digit</code></td>
<td>匹配正则表达式前半部分定义的后向引用的第<code>digit</code>个子表达式。<code>digit</code>为<code>1</code>至<code>9</code>的数字, <code>1</code>为从左开始。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>匹配换行符。</td>
</tr>
<tr>
<td><code>\meta</code></td>
<td>将元字符<code>meta</code>转换成普通字符，以便匹配该字符本身，有<code>$</code>、 <code>*</code>、 <code>.</code>、 <code>[</code>、 <code>\</code> 和 <code>^</code>。</td>
</tr>
</tbody>
</table>
<h2 id="扩展正则表达式"> 扩展正则表达式</h2>
<p>扩展正则表达式除了以下元字符与基本正则表达式不同外，其余相似。</p>
<table>
<thead>
<tr>
<th>基本正则表达式</th>
<th>扩展正则表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\?</code></td>
<td><code>?</code></td>
</tr>
<tr>
<td><code>\+</code></td>
<td><code>+</code></td>
</tr>
<tr>
<td><code>\|</code></td>
<td><code>|</code></td>
</tr>
<tr>
<td><code>\{ \}</code></td>
<td><code>{ }</code></td>
</tr>
<tr>
<td><code>\( \)</code></td>
<td><code>( )</code></td>
</tr>
</tbody>
</table>
<h2 id="常用转义字符"> 常用转义字符</h2>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\a</code></td>
<td>匹配一个<code>BEL</code>字符。</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>匹配一个换页字符。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>匹配一个换行字符。</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>匹配一个回车字符。</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>匹配一个水平<code>Tab</code>字符。</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>匹配一个垂直<code>Tab</code>字符。</td>
</tr>
<tr>
<td><code>\cX</code></td>
<td>匹配<code>Control+X</code>，<code>X</code>是任意字符。</td>
</tr>
<tr>
<td><code>\dXXX</code></td>
<td>匹配一个<code>ASCII</code>码是十进制<code>XXX</code>的字符。</td>
</tr>
<tr>
<td><code>\oXXX</code></td>
<td>匹配一个<code>ASCII</code>码是八进制<code>XXX</code>的字符。</td>
</tr>
<tr>
<td><code>\xXX</code></td>
<td>匹配一个<code>ASCII</code>码是十六进制<code>XX</code>的字符。</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配任意一个单词字符(字母、数字和下划线)。</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配任意一个非单词字符。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配一个单词的边界符：字符的左边是一个单词字符，并且右边是一个非单词字符，反之亦然。</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>匹配除单词边界符外所有字符：字符的左边和右边同时是单词字符或非单词字符。</td>
</tr>
</tbody>
</table>
<h2 id="参考文章"> 参考文章</h2>
<p>https://qianngchn.github.io/wiki/4.html#s%E5%91%BD%E4%BB%A4</p>
<p>http://man.linuxde.net/sed</p>
<p>https://www.cnblogs.com/edwardlost/archive/2010/09/17/1829145.html</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2017-09-24T21:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">docker搭建redis集群</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/blog-knowledge/Redis-2/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/blog-knowledge/Redis-2/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>docker搭建redis集群</p>

<h2 id="下载镜像"> 下载镜像</h2>
<div><pre><code>docker pull redis
</code></pre>
<div><span>1</span><br></div></div><h2 id="准备配置文件"> 准备配置文件</h2>
<div><pre><code>mkdir /home/docker/redis/  
wget https://raw.githubusercontent.com/antirez/redis/3.0/redis.conf -O /home/docker/redis/redis.conf
cd /home/docker/redis/  
sed -i &#39;s/# slaveof &lt;masterip&gt; &lt;masterport&gt;/slaveof redis-master 6379/g&#39; redis.conf  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="启动redis容器"> 启动redis容器</h2>
<div><pre><code>docker run --name redis-master -p 6379:6379 -d redis
docker run --link redis-master:redis-master -v /home/docker/redis/redis.conf:/usr/local/etc/redis/redis.conf --name redis-slave1 -d redis redis-server /usr/local/etc/redis/redis.conf
docker run --link redis-master:redis-master -v /home/docker/redis/redis.conf:/usr/local/etc/redis/redis.conf --name redis-slave2 -d redis redis-server /usr/local/etc/redis/redis.conf
docker run --link redis-master:redis-master -v /home/docker/redis/redis.conf:/usr/local/etc/redis/redis.conf --name redis-slave3 -d redis redis-server /usr/local/etc/redis/redis.conf 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="查看redis集群"> 查看redis集群</h2>
<div><pre><code>redis-cli 
127.0.0.1:6379&gt; info
# Server
redis_version:3.0.6
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:48bba53ba79f07ac
redis_mode:standalone
os:Linux 3.13.0-27-generic x86_64
arch_bits:64
multiplexing_api:epoll
gcc_version:4.9.2
process_id:1
run_id:6d552d47e50137b6ee40697d7254891aa5dbdb68
tcp_port:6379
uptime_in_seconds:21554
uptime_in_days:0
hz:10
lru_clock:10637013
config_file:

# Clients
connected_clients:1
client_longest_output_list:0
client_biggest_input_buf:0
blocked_clients:0

# Memory
used_memory:1926248
used_memory_human:1.84M
used_memory_rss:4419584
used_memory_peak:1963096
used_memory_peak_human:1.87M
used_memory_lua:36864
mem_fragmentation_ratio:2.29
mem_allocator:jemalloc-3.6.0

# Persistence
loading:0
rdb_changes_since_last_save:0
rdb_bgsave_in_progress:0
rdb_last_save_time:1453456066
rdb_last_bgsave_status:ok
rdb_last_bgsave_time_sec:0
rdb_current_bgsave_time_sec:-1
aof_enabled:0
aof_rewrite_in_progress:0
aof_rewrite_scheduled:0
aof_last_rewrite_time_sec:-1
aof_current_rewrite_time_sec:-1
aof_last_bgrewrite_status:ok
aof_last_write_status:ok

# Stats
total_connections_received:5
total_commands_processed:64476
instantaneous_ops_per_sec:3
total_net_input_bytes:2426080
total_net_output_bytes:92455
instantaneous_input_kbps:0.14
instantaneous_output_kbps:0.02
rejected_connections:0
sync_full:3
sync_partial_ok:0
sync_partial_err:0
expired_keys:0
evicted_keys:0
keyspace_hits:0
keyspace_misses:0
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:222
migrate_cached_sockets:0

# Replication
role:master
connected_slaves:3
slave0:ip=172.17.0.2,port=6379,state=online,offset=30087,lag=1
slave1:ip=172.17.0.3,port=6379,state=online,offset=30101,lag=0
slave2:ip=172.17.0.4,port=6379,state=online,offset=30087,lag=1
master_repl_offset:30101
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2
repl_backlog_histlen:30100

# CPU
used_cpu_sys:7.37
used_cpu_user:5.34
used_cpu_sys_children:0.00
used_cpu_user_children:0.00

# Cluster
cluster_enabled:0

# Keyspace
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br></div></div><p>转载链接：https://segmentfault.com/a/1190000004353368</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2017-09-17T21:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">keepalived详解</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/blog-knowledge/%E9%9B%86%E7%BE%A4-keepalived/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/blog-knowledge/%E9%9B%86%E7%BE%A4-keepalived/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>Let’s learn keepalived together！</p>

<h2 id="keepalived介绍"> keepalived介绍</h2>
<p>keepalived观察其名可知，保持存活，在网络里面就是保持在线了，也就是所谓的高可用或热备，它集群管理中保证集群高可用的一个服务软件，其功能类似于heartbeat，用来防止单点故障(单点故障是指一旦某一点出现故障就会导致整个系统架构的不可用)的发生。说到keepalived就不得不说VRRP协议，可以说这个协议就是keepalived实现的基础，那么首先我们来看看VRRP协议。</p>
<h2 id="vrrp协议介绍"> VRRP协议介绍</h2>
<p>学过网络的朋友都知道，网络在设计的时候必须考虑到冗余容灾，包括线路冗余，设备冗余等，防止网络存在单点故障，那在路由器或三层交换机处实现冗余就显得尤为重要。</p>
<p>在网络里面有个协议就是来做这事的，这个协议就是VRRP协议，Keepalived就是巧用VRRP协议来实现高可用性(HA)的发生。</p>
<p>VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。对于VRRP，需要清楚知道的是：</p>
<p>1）VRRP是用来实现路由器冗余的协议。
2）VRRP协议是为了消除在静态缺省路由环境下路由器单点故障引起的网络失效而设计的主备模式的协议，使得发生故障而进行设计设备功能切换时可以不影响内外数据通信，不需要再修改内部网络的网络参数。
3）VRRP协议需要具有IP备份，优先路由选择，减少不必要的路由器通信等功能。
4）VRRP协议将两台或多台路由器设备虚拟成一个设备，对外提供虚拟路由器IP（一个或多个）。然而，在路由器组内部，如果实际拥有这个对外IP的路由器如果工作正常的话，就是master，或者是通过算法选举产生的，MASTER实现针对虚拟路由器IP的各种网络功能，如ARP请求，ICMP，以及数据的转发等，其他设备不具有该IP，状态是BACKUP。除了接收MASTER的VRRP状态通告信息外，不执行对外的网络功能，当主级失效时，BACKUP将接管原先MASTER的网络功能。
5）VRRP协议配置时，需要配置每个路由器的虚拟路由ID(VRID)和优先权值，使用VRID将路由器进行分组，具有相同VRID值的路由器为同一个组，VRID是一个0-255的整整数，；同一个组中的路由器通过使用优先权值来选举MASTER。，优先权大者为MASTER，优先权也是一个0-255的正整数。</p>
<h2 id="keepalived工作原理"> keepalived工作原理</h2>
<p>keepalived可提供vrrp以及health-check功能，可以只用它提供双机浮动的vip（vrrp虚拟路由功能），这一样可以简单实现一个双机热备高可用的功能：keepalived是以VRRP虚拟路由冗余协议为基础实现高可用的，可以认为是现实路由高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到VRRP包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master。这样的话就可以保证路由器的高可用了。</p>
<p>下图是keepalived的组件图</p>
<p><img src="/images/keepalived1.png" alt="" /></p>
<p>keepalived也是模块化设计，不同模块负责不同的功能，它主要有三个模块，分别是core、check和VRRP，其中：</p>
<p>core模块：为keepalived的核心组件，负责主进程的启动、维护以及全局配置文件的加载和解析；</p>
<p>check：负责健康检查，包括常见的各种检查方式；</p>
<p>VRRP模块：是来实现VRRP协议的。</p>
<p>system call：系统调用</p>
<p>watch dog：监控check和vrrp进程的看管者，check负责检测子进程的健康状态，当其检测到master上的服务不可用时则通告vrrp将其转移至backup服务器上。</p>
<p>除此之外，keepalived还有下面两个组件：</p>
<p>libipfwc:iptables（ipchains）库，配置LVS会用到</p>
<p>libipvs*：配置LVS会用到</p>
<p>注意，keepalived和LVS完全是两码事，只不过他们各负其责相互配合而已。</p>
<p>keepalived正常启动的时候，共启动3个进程：
一个是父进程，负责监控其子进程；一个是VRRP子进程，另外一个是checkers子进程；
两个子进程都被系统watchlog看管，两个子进程各自负责复杂自己的事。
Healthcheck子进程检查各自服务器的健康状况，，例如http,lvs。如果healthchecks进程检查到master上服务不可用了，就会通知本机上的VRRP子进程，让他删除通告，并且去掉虚拟IP，转换为BACKUP状态。</p>
<h2 id="keepalived作用"> Keepalived作用</h2>
<p>Keepalived主要用作RealServer的健康状态检查以及LoadBalance主机和BackUP主机之间failover的实现。Keepalived的作用是检测web服务器的状态，如果有一台web服务器死机，或工作出现故障，Keepalived将检测到，并将有故障的web服务器从系统中剔除，当web服务器工作正常后Keepalived自动将web服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的web服务器。</p>
<p>----------------------------------------------------------------------------------------------------------------------------
Keepalived和Heartbeat之间的对比
1）Keepalived使用更简单：从安装、配置、使用、维护等角度上对比，Keepalived都比Heartbeat要简单得多，尤其是Heartbeat2.1.4后拆分成3个子项目，安装、配置、使用都比较复杂，尤其是出问题的时候，都不知道具体是哪个子系统出问题了；而Keepalived只有1个安装文件、1个配置文件，配置文件也简单很多；
2）Heartbeat功能更强大：Heartbeat虽然复杂，但功能更强大，配套工具更全，适合做大型集群管理，而Keepalived主要用于集群倒换，基本没有管理功能；
3）协议不同：Keepalived使用VRRP协议进行通信和选举，Heartbeat使用心跳进行通信和选举；Heartbeat除了走网络外，还可以通过串口通信，貌似更可靠；
Keepalived使用的vrrp协议方式，虚拟路由冗余协议 ；Heartbeat是基于主机或网络的服务的高可用方式；
Keepalived的目的是模拟路由器的双机；Heartbeat的目的是用户service的双机
4）使用方式基本类似：如果要基于两者设计高可用方案，最终都要根据业务需要写自定义的脚本，Keepalived的脚本没有任何约束，随便怎么写都可以；Heartbeat的脚本有约束，即要支持service
start/stop/restart这种方式，而且Heartbeart提供了很多默认脚本，简单的绑定ip，启动apache等操作都已经有了；</p>
<p>使用建议：
优先使用Keepalived，当Keepalived不够用的时候才选择Heartbeat
lvs的高可用建议用Keepavlived
业务的高可用用Heartbeat
--------------------------------------------------------------------------------------------------------------------------</p>
<h2 id="keepalived的配置文件"> Keepalived的配置文件</h2>
<p>keepalived只有一个配置文件keepalived.conf，配置文件里面主要包括以下几个配置项，分别是global_defs、static_ipaddress、static_routes、VRRP_script、VRRP_instance和virtual_server。</p>
<p>总的来说，keepalived主要有三类区域配置，注意不是三种配置文件，是一个配置文件里面三种不同类别的配置区域：
1）全局配置(Global Configuration)
2）VRRPD配置
3）LVS配置</p>
<p>下面就重点来说说这三类区域的配置：</p>
<p>1）全局配置
全局配置又包括两个子配置：
全局定义(global definition)
静态路由配置(static ipaddress/routes)</p>
<p>1--全局定义(global definition)配置范例：</p>
<div><pre><code>global_defs
{
notification_email
{
admin@example.com
}
notification_email_from admin@example.com
smtp_server 127.0.0.1
stmp_connect_timeout 30
router_id node1
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>全局配置解析
global_defs全局配置标识，表面这个区域{}是全局配置</p>
<div><pre><code>notification_email
{
admin@example.com
admin@ywlm.net
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>表示keepalived在发生诸如切换操作时需要发送email通知，以及email发送给哪些邮件地址，邮件地址可以多个，每行一个
notification_email_from admin@example.com
表示发送通知邮件时邮件源地址是谁
smtp_server 127.0.0.1
表示发送email时使用的smtp服务器地址，这里可以用本地的sendmail来实现
smtp_connect_timeout 30
连接smtp连接超时时间
router_id node1
机器标识</p>
<p>2--静态地址和路由配置范例</p>
<div><pre><code>static_ipaddress
{
192.168.1.1/24 brd + dev eth0 scope global
192.168.1.2/24 brd + dev eth1 scope global
}
static_routes
{
src $SRC_IP to $DST_IP dev $SRC_DEVICE
src $SRC_IP to $DST_IP via $GW dev $SRC_DEVICE
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这里实际上和系统里面用命令配置IP地址和路由的曹一样，例如：
192.168.1.1/24 brd + dev eth0 scope global 相当于: ip addr add 192.168.1.1/24 brd + dev eth0 scope global
就是给eth0配置IP地址
路由同理
一般这个区域不需要配置
这里实际上就是给服务器配置真实的IP地址和路由的，在复杂的环境下可能需要配置，一般不会用这个来配置，我们可以直接用vi /etc/sysconfig/network-script/ifcfg-eth1来配置，切记这里可不是VIP哦，不要搞混淆了，切记切记！</p>
<p>2）VRRPD配置
VRRPD配置包括三个类：
VRRP同步组(synchroization group)
VRRP实例(VRRP Instance)
VRRP脚本</p>
<p>1--VRRP同步组(synchroization group)配置范例</p>
<div><pre><code>vrrp_sync_group VG_1 {
group {
http
mysql
}
notify_master /path/to/to_master.sh
notify_backup /path_to/to_backup.sh
notify_fault “/path/fault.sh VG_1”
notify /path/to/notify.sh
smtp_alert
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>其中：
group {
http
mysql
}
http和mysql是实例名和下面的实例名一致</p>
<p>notify_master /path/to/to_master.sh：表示当切换到master状态时，要执行的脚本
notify_backup /path_to/to_backup.sh：表示当切换到backup状态时，要执行的脚本
notify_fault “/path/fault.sh VG_1”
notify /path/to/notify.sh：
smtp alter表示切换时给global defs中定义的邮件地址发送右键通知</p>
<p>2--VRRP实例(instance)配置范例</p>
<div><pre><code>vrrp_instance http {
state MASTER
interface eth0
dont_track_primary
track_interface {
eth0
eth1
}
mcast_src_ip &lt;IPADDR&gt;
garp_master_delay 10
virtual_router_id 51
priority 100
advert_int 1
authentication {
auth_type PASS
autp_pass 1234
}
virtual_ipaddress {
#&lt;IPADDR&gt;/&lt;MASK&gt; brd &lt;IPADDR&gt; dev &lt;STRING&gt; scope &lt;SCOPT&gt; label &lt;LABEL&gt;
192.168.200.17/24 dev eth1
192.168.200.18/24 dev eth2 label eth2:1
}
virtual_routes {
# src &lt;IPADDR&gt; [to] &lt;IPADDR&gt;/&lt;MASK&gt; via|gw &lt;IPADDR&gt; dev &lt;STRING&gt; scope &lt;SCOPE&gt; tab
src 192.168.100.1 to 192.168.109.0/24 via 192.168.200.254 dev eth1
192.168.110.0/24 via 192.168.200.254 dev eth1
192.168.111.0/24 dev eth2
192.168.112.0/24 via 192.168.100.254
}
nopreempt
preemtp_delay 300
debug
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>state：state指定instance(Initial)的初始状态，就是说在配置好后，这台服务器的初始状态就是这里指定的，但这里指定的不算，还是得要通过竞选通过优先级来确定，里如果这里设置为master，但如若他的优先级不及另外一台，那么这台在发送通告时，会发送自己的优先级，另外一台发现优先级不如自己的高，那么他会就回抢占为master
interface：实例绑定的网卡，因为在配置虚拟IP的时候必须是在已有的网卡上添加的
dont track primary：忽略VRRP的interface错误
track interface：跟踪接口，设置额外的监控，里面任意一块网卡出现问题，都会进入故障(FAULT)状态，例如，用nginx做均衡器的时候，内网必须正常工作，如果内网出问题了，这个均衡器也就无法运作了，所以必须对内外网同时做健康检查
mcast
src
ip：发送多播数据包时的源IP地址，这里注意了，这里实际上就是在那个地址上发送VRRP通告，这个非常重要，一定要选择稳定的网卡端口来发送，这里相当于heartbeat的心跳端口，如果没有设置那么就用默认的绑定的网卡的IP，也就是interface指定的IP地址
garp master delay：在切换到master状态后，延迟进行免费的ARP(gratuitous ARP)请求
virtual router id：这里设置VRID，这里非常重要，相同的VRID为一个组，他将决定多播的MAC地址
priority 100：设置本节点的优先级，优先级高的为master
advert int：检查间隔，默认为1秒
virtual</p>
<p>ipaddress：这里设置的就是VIP，也就是虚拟IP地址，他随着state的变化而增加删除，当state为master的时候就添加，当state为backup的时候删除，这里主要是有优先级来决定的，和state设置的值没有多大关系，这里可以设置多个IP地址
virtual routes：原理和virtual ipaddress一样，只不过这里是增加和删除路由
lvs sync daemon interface：lvs syncd绑定的网卡
authentication：这里设置认证
auth type：认证方式，可以是PASS或AH两种认证方式
auth pass：认证密码
nopreempt：设置不抢占，这里只能设置在state为backup的节点上，而且这个节点的优先级必须别另外的高
preempt delay：抢占延迟
debug：debug级别
notify master：和sync group这里设置的含义一样，可以单独设置，例如不同的实例通知不同的管理人员，http实例发给网站管理员，mysql的就发邮件给DBA</p>
<p>3--VRRP脚本范例</p>
<div><pre><code>vrrp_script check_running {
   script “/usr/local/bin/check_running”
   interval 10
   weight 10
}
vrrp_instance http {
   state BACKUP
   smtp_alert
   interface eth0
   virtual_router_id 101
   priority 90
   advert_int 3
   authentication {
   auth_type PASS
   auth_pass whatever
   }
   virtual_ipaddress {
   1.1.1.1
   }
   track_script {
   check_running weight 20
   }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>首先在vrrp_script区域定义脚本名字和脚本执行的间隔和脚本执行的优先级变更</p>
<div><pre><code>vrrp_script check_running {
script “/usr/local/bin/check_running”
interval 10     #脚本执行间隔
weight 10      #脚本结果导致的优先级变更：10表示优先级+10；-10则表示优先级-10
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后在实例(vrrp_instance)里面引用，有点类似脚本里面的函数引用一样：先定义，后引用函数名</p>
<div><pre><code>track_script {
check_running weight 20
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意：VRRP脚本(vrrp_script)和VRRP实例(vrrp_instance)属于同一个级别</p>
<p>3)LVS配置
如果你没有配置LVS+keepalived，那么无需配置这段区域，如果你用的是nginx来代替LVS，这无需配置这款，这里的LVS配置是专门为keepalived+LVS集成准备的。
注意了，这里LVS配置并不是指真的安装LVS然后用ipvsadm来配置它，而是用keepalived的配置文件来代替ipvsadm来配置LVS，这样会方便很多，一个配置文件搞定这些，维护方便，配置方便是也！
这里LVS配置也有两个配置
一个是虚拟主机组配置
一个是虚拟主机配置</p>
<p>1--虚拟主机组配置文件详解
这个配置是可选的，根据需求来配置吧，这里配置主要是为了让一台realserver上的某个服务可以属于多个Virtual Server，并且只做一次健康检查:
virtual_server_group <STRING> { # VIP port <IPADDR> <PORT> <IPADDR> <PORT> fwmark <INT> }</p>
<p>2--虚拟主机配置
virtual server可以以下面三种的任意一种来配置:
a）virtual server IP port
b）virtual server fwmark int
c）virtual server group string</p>
<p>下面以第一种比较常用的方式来配详细解说一下：</p>
<div><pre><code>virtual_server 192.168.1.2 80 {                     #设置一个virtual server: VIP:Vport
delay_loop 3                                                  # service polling的delay时间，即服务轮询的时间间隔
 
lb_algo rr|wrr|lc|wlc|lblc|sh|dh                        #LVS调度算法
lb_kind NAT|DR|TUN                                      #LVS集群模式                     
persistence_timeout 120                                #会话保持时间（秒为单位），即以用户在120秒内被分配到同一个后端realserver
persistence_granularity &lt;NETMASK&gt;              #LVS会话保持粒度，ipvsadm中的-M参数，默认是0xffffffff，即每个客户端都做会话保持
protocol TCP                                                  #健康检查用的是TCP还是UDP
ha_suspend                                                   #suspendhealthchecker’s activity
virtualhost &lt;string&gt;                                       #HTTP_GET做健康检查时，检查的web服务器的虚拟主机（即host：头）
 
sorry_server &lt;IPADDR&gt; &lt;PORT&gt;                 #备用机，就是当所有后端realserver节点都不可用时，就用这里设置的，也就是临时把所有的请求都发送到这里啦
 
real_server &lt;IPADDR&gt; &lt;PORT&gt;                    #后端真实节点主机的权重等设置，主要，后端有几台这里就要设置几个
{
weight 1                                                         #给每台的权重，0表示失效(不知给他转发请求知道他恢复正常)，默认是1
inhibit_on_failure                                            #表示在节点失败后，把他权重设置成0，而不是冲IPVS中删除
 
notify_up &lt;STRING&gt; | &lt;QUOTED-STRING&gt;  #检查服务器正常(UP)后，要执行的脚本
notify_down &lt;STRING&gt; | &lt;QUOTED-STRING&gt; #检查服务器失败(down)后，要执行的脚本
HTTP_GET                                                     #健康检查方式
{
url {                                                                #要坚持的URL，可以有多个
path /                                                             #具体路径
digest &lt;STRING&gt;                                           
status_code 200                                            #返回状态码
}
connect_port 80                                            #监控检查的端口
 
bindto &lt;IPADD&gt;                                             #健康检查的IP地址
connect_timeout   3                                       #连接超时时间
nb_get_retry 3                                               #重连次数
delay_before_retry 2                                      #重连间隔
} # END OF HTTP_GET|SSL_GET
 
#下面是常用的健康检查方式，健康检查方式一共有HTTP_GET|SSL_GET|TCP_CHECK|SMTP_CHECK|MISC_CHECK这些
#TCP方式
TCP_CHECK {
connect_port 80
bindto 192.168.1.1
connect_timeout 4
} # TCP_CHECK
 
# SMTP方式，这个可以用来给邮件服务器做集群
SMTP_CHECK
host {
connect_ip &lt;IP ADDRESS&gt;
connect_port &lt;PORT&gt;                                     #默认检查25端口
14 KEEPALIVED
bindto &lt;IP ADDRESS&gt;
}
connect_timeout &lt;INTEGER&gt;
retry &lt;INTEGER&gt;
delay_before_retry &lt;INTEGER&gt;
# “smtp HELO
helo_name &lt;STRING&gt;|&lt;QUOTED-STRING&gt;
} #SMTP_CHECK
 
#MISC方式，这个可以用来检查很多服务器只需要自己会些脚本即可
MISC_CHECK
{
misc_path &lt;STRING&gt;|&lt;QUOTED-STRING&gt; #外部程序或脚本
misc_timeout &lt;INT&gt;                                    #脚本或程序执行超时时间
 
misc_dynamic                                               #这个就很好用了，可以非常精确的来调整权重，是后端每天服务器的压力都能均衡调配，这个主要是通过执行的程序或脚本返回的状态代码来动态调整weight值，使权重根据真实的后端压力来适当调整，不过这需要有过硬的脚本功夫才行哦
#返回0：健康检查没问题，不修改权重
#返回1：健康检查失败，权重设置为0
#返回2-255：健康检查没问题，但是权重却要根据返回代码修改为返回码-2，例如如果程序或脚本执行后返回的代码为200，#那么权重这回被修改为 200-2
}
} # Realserver
} # Virtual Server
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><p>转载地址：</p>
<p>https://www.cnblogs.com/kevingrace/p/6248941.html</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2017-09-15T21:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">每天一个linux命令（21）-find之xargs</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8821%EF%BC%89-find/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8821%EF%BC%89-find/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>在使用 find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。</p>

<p>find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。</p>
<p>在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； 而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。</p>
<p>使用实例：</p>
<p>1） 查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件</p>
<div><pre><code>#ll
总计 312
-rw-r--r-- 1 root root 302108 11-03 06:19 log2012.log
-rw-r--r-- 1 root root      0 11-12 22:25 log2013.log
-rw-r--r-- 1 root root      0 11-12 22:25 log2014.log
drwxr-xr-x 6 root root   4096 10-27 01:58 scf
drwxrwxrwx 2 root root   4096 11-12 19:32 test3
drwxrwxrwx 2 root root   4096 11-12 19:32 test4
# find . -type f -print | xargs file
./log2014.log: empty
./log2013.log: empty
./log2012.log: ASCII text
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>2）在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中</p>
<div><pre><code># find / -name &quot;core&quot; -print | xargs echo &quot;&quot; &gt;/tmp/core.log
# cd /tmp
# ll
总计 16
-rw-r--r-- 1 root root 1524 11-12 22:29 core.log
drwx------ 2 root root 4096 11-12 22:24 ssh-TzcZDx1766
drwx------ 2 root root 4096 11-12 22:28 ssh-ykiRPk1815
drwx------ 2 root root 4096 11-03 07:11 vmware-root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>3）在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限</p>
<div><pre><code># ll
总计 312
-rw-r--r-- 1 root root 302108 11-03 06:19 log2012.log
-rw-r--r-- 1 root root      0 11-12 22:25 log2013.log
-rw-r--r-- 1 root root      0 11-12 22:25 log2014.log
drwxr-xr-x 6 root root   4096 10-27 01:58 scf
drwxrwxrwx 2 root root   4096 11-12 19:32 test3
drwxrwxrwx 2 root root   4096 11-12 19:32 test4
# find . -perm -7 -print | xargs chmod o-w
# ll
总计 312
-rw-r--r-- 1 root root 302108 11-03 06:19 log2012.log
-rw-r--r-- 1 root root      0 11-12 22:25 log2013.log
-rw-r--r-- 1 root root      0 11-12 22:25 log2014.log
drwxr-xr-x 6 root root   4096 10-27 01:58 scf
drwxrwxr-x 2 root root   4096 11-12 19:32 test3
drwxrwxr-x 2 root root   4096 11-12 19:32 test4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>说明：</p>
<p>执行命令后，文件夹scf、test3和test4的权限都发生改变</p>
<p>4）用grep命令在所有的普通文件中搜索hostname这个词</p>
<div><pre><code># find . -type f -print | xargs grep &quot;hostname&quot;
./log2013.log:hostnamebaidu=baidu.com
./log2013.log:hostnamesina=sina.com
./log2013.log:hostnames=true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>5）用grep命令在当前目录下的所有普通文件中搜索hostnames这个词</p>
<div><pre><code># find . -name \* -type f -print | xargs grep &quot;hostnames&quot;
./log2013.log:hostnamesina=sina.com
./log2013.log:hostnames=true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>说明：</p>
<p>注意，在上面的例子中， \用来取消find命令中的*在shell中的特殊含义。</p>
<p>6）使用xargs执行mv</p>
<div><pre><code># ll
总计 316
-rw-r--r-- 1 root root 302108 11-03 06:19 log2012.log
-rw-r--r-- 1 root root     61 11-12 22:44 log2013.log
-rw-r--r-- 1 root root      0 11-12 22:25 log2014.log
drwxr-xr-x 6 root root   4096 10-27 01:58 scf
drwxrwxr-x 2 root root   4096 11-12 22:54 test3
drwxrwxr-x 2 root root   4096 11-12 19:32 test4
# cd test4/
# ll
总计 0[root@localhost test4]# cd ..
# find . -name &quot;*.log&quot; | xargs -i mv {} test4
# ll
总计 12drwxr-xr-x 6 root root 4096 10-27 01:58 scf
drwxrwxr-x 2 root root 4096 11-13 05:50 test3
drwxrwxr-x 2 root root 4096 11-13 05:50 test4
# cd test4/
# ll
总计 304
-rw-r--r-- 1 root root 302108 11-12 22:54 log2012.log
-rw-r--r-- 1 root root     61 11-12 22:54 log2013.log
-rw-r--r-- 1 root root      0 11-12 22:54 log2014.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>7）find后执行xargs提示xargs: argument line too long解决方法：</p>
<div><pre><code>#find . -type f -atime +0 -print0 | xargs -0 -l1 -t rm -f
rm -f 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>说明：</p>
<p>-l1是一次处理一个；-t是处理之前打印出命令</p>
<p>8）使用-i参数默认的前面输出用{}代替，-I参数可以指定其他代替字符，如例子中的[]</p>
<div><pre><code># ll
总计 12drwxr-xr-x 6 root root 4096 10-27 01:58 scf
drwxrwxr-x 2 root root 4096 11-13 05:50 test3
drwxrwxr-x 2 root root 4096 11-13 05:50 test4
# cd test4
# find . -name &quot;file&quot; | xargs -I [] cp [] ..
# ll
总计 304
-rw-r--r-- 1 root root 302108 11-12 22:54 log2012.log
-rw-r--r-- 1 root root     61 11-12 22:54 log2013.log
-rw-r--r-- 1 root root      0 11-12 22:54 log2014.log
# cd ..
# ll
总计 316
-rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log
-rw-r--r-- 1 root root     61 11-13 06:03 log2013.log
-rw-r--r-- 1 root root      0 11-13 06:03 log2014.log
drwxr-xr-x 6 root root   4096 10-27 01:58 scf
drwxrwxr-x 2 root root   4096 11-13 05:50 test3
drwxrwxr-x 2 root root   4096 11-13 05:50 test4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>说明：</p>
<p>使用-i参数默认的前面输出用{}代替，-I参数可以指定其他代替字符，如例子中的[]</p>
<p>9）xargs的-p参数的使用</p>
<div><pre><code># ll
总计 0
-rw-r--r-- 1 root root 0 11-13 06:06 log2015.log
# cd ..
# ll
总计 316
-rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log
-rw-r--r-- 1 root root     61 11-13 06:03 log2013.log
-rw-r--r-- 1 root root      0 11-13 06:03 log2014.log
drwxr-xr-x 6 root root   4096 10-27 01:58 scf
drwxrwxr-x 2 root root   4096 11-13 06:06 test3
drwxrwxr-x 2 root root   4096 11-13 05:50 test4
# cd test3
#  find . -name &quot;*.log&quot; | xargs -p -i mv {} ..
mv ./log2015.log .. ?...y
# ll
总计 0
# cd ..
# ll
总计 316
-rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log
-rw-r--r-- 1 root root     61 11-13 06:03 log2013.log
-rw-r--r-- 1 root root      0 11-13 06:03 log2014.log
-rw-r--r-- 1 root root      0 11-13 06:06 log2015.log
drwxr-xr-x 6 root root   4096 10-27 01:58 scf
drwxrwxr-x 2 root root   4096 11-13 06:08 test3
drwxrwxr-x 2 root root   4096 11-13 05:50 test4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>说明：</p>
<p>-p参数会提示让你确认是否执行后面的命令,y执行，n不执行。</p>
<p>转载链接：</p>
<p>http://www.cnblogs.com/peida/archive/2012/11/15/2770888.html</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2018-07-27T18:50:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">每天一个linux命令（29）-chown</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8829%EF%BC%89-chown/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8829%EF%BC%89-chown/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将文件拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。</p>

<h2 id="语法"> 语法</h2>
<p><code>chown(选项)(参数)</code></p>
<h2 id="选项"> 选项</h2>
<div><pre><code>-c或——changes：效果类似“-v”参数，但仅回报更改的部分；
-f或--quite或——silent：不显示错误信息；
-h或--no-dereference：只对符号连接的文件作修改，而不更改其他任何相关文件；
-R或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；
-v或——version：显示指令执行过程；
--dereference：效果和“-h”参数相同；
--help：在线帮助；
--reference=&lt;参考文件或目录&gt;：把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同；
--version：显示版本信息。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="参数"> 参数</h2>
<p>用户：组：指定所有者和所属工作组。当省略“：组”，仅改变文件所有者；
文件：指定要改变所有者和工作组的文件列表。支持多个文件和目标，支持shell通配符。</p>
<h2 id="功能"> 功能</h2>
<p>通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。</p>
<h2 id="常用实例"> 常用实例</h2>
<p>1）<strong>改变拥有者和群组</strong></p>
<div><pre><code># ll
---xr--r-- 1 root users 302108 11-30 08:39 linklog.log
---xr--r-- 1 root users 302108 11-30 08:39 log2012.log
# chown mail:mail log2012.log 
# ll
---xr--r-- 1 root users 302108 11-30 08:39 linklog.log
---xr--r-- 1 mail mail  302108 11-30 08:39 log2012.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>2）<strong>改变文件拥有者</strong></p>
<div><pre><code>ll
总计 604
---xr--r-- 1 root users 302108 11-30 08:39 linklog.log
---xr--r-- 1 mail mail  302108 11-30 08:39 log2012.log
# chown root: log2012.log 
# ll
总计 604
---xr--r-- 1 root users 302108 11-30 08:39 linklog.log
---xr--r-- 1 root mail  302108 11-30 08:39 log2012.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>3）<strong>改变文件群组</strong></p>
<div><pre><code># ll
总计 604
---xr--r-- 1 root users 302108 11-30 08:39 linklog.log
---xr--r-- 1 root root  302108 11-30 08:39 log2012.log
# chown :mail log2012.log 
# ll
总计 604
---xr--r-- 1 root users 302108 11-30 08:39 linklog.log
---xr--r-- 1 root mail  302108 11-30 08:39 log2012.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>4）**改变指定目录以及其子目录下的所有文件的拥有者和群组 **</p>
<div><pre><code># ll
drwxr-xr-x 2 root users   4096 11-30 08:39 test6
# chown -R -v root:mail test6
“test6/log2014.log” 的所有者已更改为 root:mail
“test6/linklog.log” 的所有者已更改为 root:mail
“test6/log2015.log” 的所有者已更改为 root:mail
“test6/log2013.log” 的所有者已更改为 root:mail
“test6/log2012.log” 的所有者已保留为 root:mail
“test6/log2017.log” 的所有者已更改为 root:mail
“test6/log2016.log” 的所有者已更改为 root:mail
“test6” 的所有者已更改为 root:mail
# ll
drwxr-xr-x 2 root mail   4096 11-30 08:39 test6
# cd test6
# ll
总计 604
---xr--r-- 1 root mail 302108 11-30 08:39 linklog.log
---xr--r-- 1 root mail 302108 11-30 08:39 log2012.log
-rw-r--r-- 1 root mail     61 11-30 08:39 log2013.log
-rw-r--r-- 1 root mail      0 11-30 08:39 log2014.log
-rw-r--r-- 1 root mail      0 11-30 08:39 log2015.log
-rw-r--r-- 1 root mail      0 11-30 08:39 log2016.log
-rw-r--r-- 1 root mail      0 11-30 08:39 log2017.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>参考链接：</p>
<p>http://www.cnblogs.com/peida/archive/2012/12/04/2800684.html</p>
<p>http://man.linuxde.net/chown</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2018-07-27T18:58:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">每天一个linux命令（33）-du</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8833%EF%BC%89-du/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8833%EF%BC%89-du/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>du命令</strong>也是查看使用空间的，但是与<a href="http://man.linuxde.net/df" target="_blank" rel="noopener noreferrer">df</a>命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的。</p>

<h2 id="语法"> 语法</h2>
<p><code>du [选项][文件]</code></p>
<h2 id="选项"> 选项</h2>
<div><pre><code>-a或-all 显示目录中个别文件的大小。
-b或-bytes 显示目录或文件大小时，以byte为单位。
-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。
-k或--kilobytes 以KB(1024bytes)为单位输出。
-m或--megabytes 以MB为单位输出。
-s或--summarize 仅显示总计，只列出最后加总的值。
-h或--human-readable 以K，M，G为单位，提高信息的可读性。
-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。
-L&lt;符号链接&gt;或--dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。
-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。
-X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。
--exclude=&lt;目录或文件&gt; 略过指定的目录或文件。
-D或--dereference-args 显示指定符号链接的源文件大小。
-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。
-l或--count-links 重复计算硬件链接的文件。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="常用实例"> 常用实例</h2>
<p>1）显示目录或者文件所占空间</p>
<div><pre><code># du
608     ./test6
308     ./test4
4       ./scf/lib
4       ./scf/service/deploy/product
4       ./scf/service/deploy/info
12      ./scf/service/deploy
16      ./scf/service
4       ./scf/doc
4       ./scf/bin
32      ./scf
8       ./test3
1288    .
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>说明：</p>
<p>只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的1288为当前目录的总大小</p>
<p>2）显示指定文件所占空间</p>
<div><pre><code># du log2012.log 
300     log2012.log
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>3）查看指定目录的所占空间</p>
<div><pre><code># du scf
4       scf/lib
4       scf/service/deploy/product
4       scf/service/deploy/info
12      scf/service/deploy
16      scf/service
4       scf/doc
4       scf/bin
32      scf
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>4）显示多个文件所占空间</p>
<div><pre><code># du log30.tar.gz log31.tar.gz 
4       log30.tar.gz
4       log31.tar.gz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>5）只显示总和的大小</p>
<div><pre><code># du -s
1288    .
# du -s scf
32      scf
# cd ..
# du -s test
1288    test
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>6）方便阅读的格式显示</p>
<div><pre><code># du -h test
608K    test/test6
308K    test/test4
4.0K    test/scf/lib
4.0K    test/scf/service/deploy/product
4.0K    test/scf/service/deploy/info
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>7）文件和目录都显示</p>
<div><pre><code># du -ah test
4.0K    test/log31.tar.gz
4.0K    test/test13.tar.gz
0       test/linklog.log
0       test/test6/log2014.log
300K    test/test6/linklog.log
0       test/test6/log2015.log
4.0K    test/test6/log2013.log
300K    test/test6/log2012.log
0       test/test6/log2017.log
0       test/test6/log2016.log
608K    test/test6
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>8）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</p>
<div><pre><code># du -c log30.tar.gz log31.tar.gz 
4       log30.tar.gz
4       log31.tar.gz
8       总计
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>说明：</p>
<p>加上-c选项后，du不仅显示两个目录各自占用磁盘空间的大小，还在最后一行统计它们的总和。</p>
<p>9）按照空间大小排序</p>
<div><pre><code># du|sort -nr|more
1288    .
608     ./test6
308     ./test4
32      ./scf
16      ./scf/service
12      ./scf/service/deploy
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>10）输出当前目录下各个子目录所使用的空间</p>
<div><pre><code># du -h  --max-depth=1
608K    ./test6
308K    ./test4
32K     ./scf
8.0K    ./test3
1.3M    .
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>参考链接：</p>
<p>http://www.cnblogs.com/peida/archive/2012/12/10/2810755.html</p>
<p>http://man.linuxde.net/du</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2018-07-27T19:03:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">每天一个linux命令（36）-date</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8836%EF%BC%89-date/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8836%EF%BC%89-date/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>在linux环境中，不管是编程还是其他维护，时间是必不可少的，也经常会用到时间的运算，熟练运用date命令来表示自己想要表示的时间，肯定可以给自己的工作带来诸多方便。</p>

<h2 id="语法"> 语法</h2>
<p><code>date(选项)(参数)</code></p>
<h2 id="选项"> 选项</h2>
<div><pre><code>-d&lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；
-s&lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；
-u：显示GMT；
--help：在线帮助；
--version：显示版本信息。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="参数"> 参数</h2>
<p>&lt;+时间日期格式&gt;：指定显示时使用的日期时间格式。</p>
<h2 id="日期格式字符串列表"> 日期格式字符串列表</h2>
<div><pre><code>%H 小时，24小时制（00~23）
%I 小时，12小时制（01~12）
%k 小时，24小时制（0~23）
%l 小时，12小时制（1~12）
%M 分钟（00~59）
%p 显示出AM或PM
%r 显示时间，12小时制（hh:mm:ss %p）
%s 从1970年1月1日00:00:00到目前经历的秒数
%S 显示秒（00~59）
%T 显示时间，24小时制（hh:mm:ss）
%X 显示时间的格式（%H:%M:%S）
%Z 显示时区，日期域（CST）
%a 星期的简称（Sun~Sat）
%A 星期的全称（Sunday~Saturday）
%h,%b 月的简称（Jan~Dec）
%B 月的全称（January~December）
%c 日期和时间（Tue Nov 20 14:12:58 2012）
%d 一个月的第几天（01~31）
%x,%D 日期（mm/dd/yy）
%j 一年的第几天（001~366）
%m 月份（01~12）
%w 一个星期的第几天（0代表星期天）
%W 一年的第几个星期（00~53，星期一为第一天）
%y 年的最后两个数字（1999则是99）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id="常用实例"> 常用实例</h2>
<p>1）格式化输出：</p>
<div><pre><code>#date +&quot;%Y-%m-%d&quot;
2018-03-29
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>2）输出昨天日期：</p>
<div><pre><code>#date -d &quot;1 day ago&quot; +&quot;%Y-%m-%d&quot;
2018-03-28
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>3）2秒后输出：</p>
<div><pre><code>#date -d &quot;2 second&quot; +&quot;%Y-%m-%d %H:%M:%S&quot; 
2018-03-29 10:08:37
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>4）apache格式转换：</p>
<div><pre><code>date -d &quot;Dec 5, 2009 12:00:37 AM&quot; +&quot;%Y-%m-%d %H:%M.%S&quot;
2009-12-05 00:00.37
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>5）格式转换后时间游走：</p>
<div><pre><code>date -d &quot;Dec 5, 2009 12:00:37 AM 2 year ago&quot; +&quot;%Y-%m-%d %H:%M.%S&quot;
2007-12-05 00:00.37
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>6）加减操作：</p>
<div><pre><code>date +%Y%m%d                   //显示前天年月日
date -d &quot;+1 day&quot; +%Y%m%d       //显示前一天的日期
date -d &quot;-1 day&quot; +%Y%m%d       //显示后一天的日期
date -d &quot;-1 month&quot; +%Y%m%d     //显示上一月的日期
date -d &quot;+1 month&quot; +%Y%m%d     //显示下一月的日期
date -d &quot;-1 year&quot; +%Y%m%d      //显示前一年的日期
date -d &quot;+1 year&quot; +%Y%m%d      //显示下一年的日期
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>7）设定时间</p>
<div><pre><code>date -s                        //设置当前时间，只有root权限才能设置，其他只能查看
date -s 20120523               //设置成20120523，这样会把具体时间设置成空00:00:00
date -s 01:01:01               //设置具体时间，不会对日期做更改
date -s &quot;01:01:01 2012-05-23&quot;  //这样可以设置全部时间
date -s &quot;01:01:01 20120523&quot;    //这样可以设置全部时间
date -s &quot;2012-05-23 01:01:01&quot;  //这样可以设置全部时间
date -s &quot;20120523 01:01:01&quot;    //这样可以设置全部时间
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>8）有时需要检查一组命令花费的时间，举例：</p>
<div><pre><code>#!/bin/bash

start=$(date +%s)
nmap man.linuxde.net &amp;&gt; /dev/null

end=$(date +%s)
difference=$(( end - start ))
echo $difference seconds.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>参考链接：</p>
<p>http://man.linuxde.net/date</p>
<p>http://www.cnblogs.com/peida/archive/2012/12/13/2815687.html</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2018-07-27T19:07:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">每天一个linux命令（35）-diff</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8835%EF%BC%89-diff/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8835%EF%BC%89-diff/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>diff 命令是 linux上非常重要的工具，用于比较文件的内容，特别是比较两个版本不同的文件以找到改动的地方。diff在命令行中打印每一个行的改动。最新版本的diff还支持二进制文件。diff程序的输出被称为补丁 (patch)，因为Linux系统中还有一个patch程序，可以根据diff的输出将a.c的文件内容更新为b.c。diff是svn、cvs、git等版本控制工具不可或缺的一部分。</p>

<h2 id="语法"> 语法</h2>
<p><code>diff(选项)(参数)</code></p>
<h2 id="选项"> 选项</h2>
<div><pre><code>-&lt;行数&gt;：指定要显示多少行的文本。此参数必须与-c或-u参数一并使用；
-a或——text：diff预设只会逐行比较文本文件；
-b或--ignore-space-change：不检查空格字符的不同；
-B或--ignore-blank-lines：不检查空白行；
-c：显示全部内容，并标出不同之处；
-C&lt;行数&gt;或--context&lt;行数&gt;：与执行“-c-&lt;行数&gt;”指令相同；
-d或——minimal：使用不同的演算法，以小的单位来做比较；
-D&lt;巨集名称&gt;或ifdef&lt;巨集名称&gt;：此参数的输出格式可用于前置处理器巨集；
-e或——ed：此参数的输出格式可用于ed的script文件；
-f或-forward-ed：输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处；
-H或--speed-large-files：比较大文件时，可加快速度；
-l&lt;字符或字符串&gt;或--ignore-matching-lines&lt;字符或字符串&gt;：若两个文件在某几行有所不同，而之际航同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异；
-i或--ignore-case：不检查大小写的不同；
-l或——paginate：将结果交由pr程序来分页；
-n或——rcs：将比较结果以RCS的格式来显示；
-N或--new-file：在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录，文件A 若使用-N参数，则diff会将文件A 与一个空白的文件比较；
-p：若比较的文件为C语言的程序码文件时，显示差异所在的函数名称；
-P或--unidirectional-new-file：与-N类似，但只有当第二个目录包含了第一个目录所没有的文件时，才会将这个文件与空白的文件做比较；
-q或--brief：仅显示有无差异，不显示详细的信息；
-r或——recursive：比较子目录中的文件；
-s或--report-identical-files：若没有发现任何差异，仍然显示信息；
-S&lt;文件&gt;或--starting-file&lt;文件&gt;：在比较目录时，从指定的文件开始比较；
-t或--expand-tabs：在输出时，将tab字符展开；
-T或--initial-tab：在每行前面加上tab字符以便对齐；
-u，-U&lt;列数&gt;或--unified=&lt;列数&gt;：以合并的方式来显示文件内容的不同；
-v或——version：显示版本信息；
-w或--ignore-all-space：忽略全部的空格字符；
-W&lt;宽度&gt;或--width&lt;宽度&gt;：在使用-y参数时，指定栏宽；
-x&lt;文件名或目录&gt;或--exclude&lt;文件名或目录&gt;：不比较选项中所指定的文件或目录；
-X&lt;文件&gt;或--exclude-from&lt;文件&gt;；您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件；
-y或--side-by-side：以并列的方式显示文件的异同之处；
--help：显示帮助；
--left-column：在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容；
--suppress-common-lines：在使用-y参数时，仅显示不同之处。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id="参数"> 参数</h2>
<ul>
<li>文件1：指定要比较的第一个文件；</li>
<li>文件2：指定要比较的第二个文件。</li>
</ul>
<h2 id="功能"> 功能</h2>
<p>diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的时候，diff命令会比较两个目录下名字相同的文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。</p>
<h2 id="常用实例"> 常用实例</h2>
<p>1）比较两个文件</p>
<div><pre><code># diff log2014.log log2013.log 
3c3
&lt; 2014-03
---
&gt; 2013-03
8c8
&lt; 2013-07
---
&gt; 2013-08
11,12d10
&lt; 2013-11
&lt; 2013-12
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>说明：</p>
<p>上面的“3c3”和“8c8”表示log2014.log和log20143log文件在3行和第8行内容有所不同；&quot;11,12d10&quot;表示第一个文件比第二个文件多了第11和12行。</p>
<p>diff 的normal 显示格式有三种提示:</p>
<p>a - add</p>
<p>c - change</p>
<p>d - delete</p>
<p>2）并排格式输出</p>
<div><pre><code># diff log2014.log log2013.log  -y -W 50
2013-01                 2013-01
2013-02                 2013-02
2014-03               | 2013-03
2013-04                 2013-04
2013-05                 2013-05
2013-06                 2013-06
2013-07                 2013-07
2013-07               | 2013-08
2013-09                 2013-09
2013-10                 2013-10
2013-11               &lt;
2013-12               &lt;
# diff log2013.log log2014.log  -y -W 50
2013-01                 2013-01
2013-02                 2013-02
2013-03               | 2014-03
2013-04                 2013-04
2013-05                 2013-05
2013-06                 2013-06
2013-07                 2013-07
2013-08               | 2013-07
2013-09                 2013-09
                      &gt; 2013-11
                      &gt; 2013-12
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>说明：</p>
<p>“|”表示前后2个文件内容有不同</p>
<p>“&lt;”表示后面文件比前面文件少了1行内容</p>
<p>“&gt;”表示后面文件比前面文件多了1行内容</p>
<p>3）上下文输出格式</p>
<div><pre><code># diff log2013.log log2014.log  -c
*** log2013.log 2012-12-07 16:36:26.000000000 +0800
--- log2014.log 2012-12-07 18:01:54.000000000 +0800
***************
*** 1,10 ****
  2013-01
  2013-02
! 2013-03
  2013-04
  2013-05
  2013-06
  2013-07
! 2013-08
  2013-09
  2013-10
--- 1,12 ----
  2013-01
  2013-02
! 2014-03
  2013-04
  2013-05
  2013-06
  2013-07
! 2013-07
  2013-09
  2013-10
+ 2013-11
+ 2013-12
# diff log2014.log log2013.log  -c
*** log2014.log 2012-12-07 18:01:54.000000000 +0800
--- log2013.log 2012-12-07 16:36:26.000000000 +0800
***************
*** 1,12 ****
  2013-01
  2013-02
! 2014-03
  2013-04
  2013-05
  2013-06
  2013-07
! 2013-07
  2013-09
  2013-10
- 2013-11
- 2013-12
--- 1,10 ----
  2013-01
  2013-02
! 2013-03
  2013-04
  2013-05
  2013-06
  2013-07
! 2013-08
  2013-09
  2013-10
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><p>说明：</p>
<p>这种方式在开头两行作了比较文件的说明，这里有三中特殊字符：</p>
<p>“＋” 比较的文件的后者比前着多一行</p>
<p>“－” 比较的文件的后者比前着少一行</p>
<p>“！” 比较的文件两者有差别的行</p>
<p>4）统一格式输出</p>
<div><pre><code># diff log2014.log log2013.log  -u
--- log2014.log 2012-12-07 18:01:54.000000000 +0800
+++ log2013.log 2012-12-07 16:36:26.000000000 +0800
@@ -1,12 +1,10 @@
 2013-01
 2013-02
-2014-03
+2013-03
 2013-04
 2013-05
 2013-06
 2013-07
-2013-07
+2013-08
 2013-09
 2013-10
-2013-11
-2013-12
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>说明：</p>
<p>它的第一部分，也是文件的基本信息：</p>
<p>--- log2014.log 2012-12-07 18:01:54.000000000 +0800</p>
<p>+++ log2013.log 2012-12-07 16:36:26.000000000 +0800</p>
<p>&quot;---&quot;表示变动前的文件，&quot;+++&quot;表示变动后的文件。</p>
<p>第二部分，变动的位置用两个@作为起首和结束。</p>
<p>@@ -1,12 +1,10 @@</p>
<p>前面的&quot;-1,12&quot;分成三个部分：减号表示第一个文件（即log2014.log），&quot;1&quot;表示第1行，&quot;12&quot;表示连续12行。合在一起，就表示下面是第一个文件从第1行开始的连续12行。同样的，&quot;+1,10&quot;表示变动后，成为第二个文件从第1行开始的连续10行。</p>
<p>5）比较文件夹不同</p>
<div><pre><code># diff test3 test6
Only in test6: linklog.log
Only in test6: log2012.log
diff test3/log2013.log test6/log2013.log
1,10c1,3
&lt; 2013-01
&lt; 2013-02
&lt; 2013-03
&lt; 2013-04
&lt; 2013-05
&lt; 2013-06
&lt; 2013-07
&lt; 2013-08
&lt; 2013-09
&lt; 2013-10
---
&gt; hostnamebaidu=baidu.com
&gt; hostnamesina=sina.com
&gt; hostnames=true
diff test3/log2014.log test6/log2014.log
1,12d0
&lt; 2013-01
&lt; 2013-02
&lt; 2014-03
&lt; 2013-04
&lt; 2013-05
&lt; 2013-06
&lt; 2013-07
&lt; 2013-07
&lt; 2013-09
&lt; 2013-10
&lt; 2013-11
&lt; 2013-12
Only in test6: log2015.log
Only in test6: log2016.log
Only in test6: log2017.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>6）比较两个文件不同，并生产补丁</p>
<div><pre><code># diff -ruN log2013.log log2014.log &gt;patch.log
# ll
总计 12
-rw-r--r-- 2 root root  80 12-07 16:36 log2013.log
-rw-r--r-- 1 root root  96 12-07 18:01 log2014.log
-rw-r--r-- 1 root root 248 12-07 21:33 patch.log
# cat patch.log 
--- log2013.log 2012-12-07 16:36:26.000000000 +0800
+++ log2014.log 2012-12-07 18:01:54.000000000 +0800
@@ -1,10 +1,12 @@
 2013-01
 2013-02
-2013-03
+2014-03
 2013-04
 2013-05
 2013-06
 2013-07
-2013-08
+2013-07
 2013-09
 2013-10
+2013-11
+2013-12
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>7）打补丁</p>
<div><pre><code># cat log2013.log
2013-01
2013-02
2013-03
2013-04
2013-05
2013-06
2013-07
2013-08
2013-09
2013-10
# patch log2013.log patch.log 
patching file log2013.log
# cat log2013.log 
2013-01
2013-02
2014-03
2013-04
2013-05
2013-06
2013-07
2013-07
2013-09
2013-10
2013-11
2013-12
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>参考链接：</p>
<p>http://www.cnblogs.com/peida/archive/2012/12/12/2814048.html</p>
<p>http://man.linuxde.net/diff</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2018-07-27T19:05:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">每天一个linux命令（42）-killall</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8842%EF%BC%89-killall/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8842%EF%BC%89-killall/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>Linux系统中的killall命令用于杀死指定名字的进程（kill processes by name）。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。</p>

<h2 id="语法"> 语法</h2>
<p><code>killall(选项)(参数)</code></p>
<h2 id="选项"> 选项</h2>
<div><pre><code>-Z 只杀死拥有scontext 的进程
-e 要求匹配进程名称
-I 忽略小写
-g 杀死进程组而不是进程
-i 交互模式，杀死进程前先询问用户
-l 列出所有的已知信号名称
-q 不输出警告信息
-s 发送指定的信号
-v 报告信号是否成功发送
-w 等待进程死亡
--help 显示帮助信息
--version 显示版本显示
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="参数"> 参数</h2>
<p>进程名称：指定要杀死的进程名称</p>
<h2 id="常用实例"> 常用实例</h2>
<p>1）杀死所有同名进程</p>
<div><pre><code># ps -ef|grep vi
root     17581 17398  0 17:51 pts/0    00:00:00 vi test.txt
root     17640 17612  0 17:51 pts/2    00:00:00 vi test.log
root     17642 17582  0 17:51 pts/1    00:00:00 grep vi
# killall vi
# ps -ef|grep vi
root     17645 17582  0 17:52 pts/1    00:00:00 grep vi
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>2）向进程发送指定信号</p>
<div><pre><code># vi &amp; 
[1] 17646[root@localhost ~]# killall -TERM vi
[1]+  Stopped                 vi
# vi &amp; 
[2] 17648
# ps -ef|grep vi
root     17646 17582  0 17:54 pts/1    00:00:00 vi
root     17648 17582  0 17:54 pts/1    00:00:00 vi
root     17650 17582  0 17:55 pts/1    00:00:00 grep vi
[2]+  Stopped                 vi
# killall -TERM vi
# ps -ef|grep vi
root     17646 17582  0 17:54 pts/1    00:00:00 vi
root     17648 17582  0 17:54 pts/1    00:00:00 vi
root     17653 17582  0 17:55 pts/1    00:00:00 grep vi
# killall -KILL vi
[1]-  已杀死               vi
[2]+  已杀死               vi
# ps -ef|grep vi
root     17656 17582  0 17:56 pts/1    00:00:00 grep vi
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>3）把所有的登录后的shell给杀掉</p>
<div><pre><code># w
 18:01:03 up 41 days, 18:53,  3 users,  load average: 0.00, 0.00, 0.00USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    10.2.0.68        14:58    9:52   0.10s  0.10s -bash
root     pts/1    10.2.0.68        17:51    0.00s  0.02s  0.00s w
root     pts/2    10.2.0.68        17:51    9:24   0.01s  0.01s -bash
# killall -9 bash
# w
 18:01:48 up 41 days, 18:54,  1 user,  load average: 0.07, 0.02, 0.00USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    10.2.0.68        18:01    0.00s  0.01s  0.00s w
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>说明：</p>
<p>运行命令：killall -9 bash 后，所有bash都会被卡掉了，所以当前所有连接丢失了。需要重新连接并登录。</p>
<p>参考链接：</p>
<p>http://www.cnblogs.com/peida/archive/2012/12/21/2827366.html</p>
<p>http://man.linuxde.net/killall</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2018-07-27T19:13:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">每天一个linux命令（46）-iostat</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8846%EF%BC%89-iostat/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8846%EF%BC%89-iostat/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>Linux系统中的 iostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。iostat属于sysstat软件包。可以用yum install sysstat 直接安装。</p>

<h2 id="语法"> 语法</h2>
<p><code>iostat(选项)(参数)</code></p>
<h2 id="选项"> 选项</h2>
<div><pre><code>-c：仅显示CPU使用情况；
-d：仅显示设备利用率；
-k：显示状态以千字节每秒为单位，而不使用块每秒；
-m：显示状态以兆字节每秒为单位；
-p：仅显示块设备和所有被使用的其他分区的状态；
-t：显示每个报告产生时的时间；
-V：显示版号并退出；
-x：显示扩展状态。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="参数"> 参数</h2>
<ul>
<li>
<p>间隔时间：每次报告的间隔时间（秒）；</p>
</li>
<li>
<p>次数：显示报告的次数。</p>
</li>
</ul>
<h2 id="常用实例"> 常用实例</h2>
<p>1）显示所有设备负载情况</p>
<div><pre><code># iostat 
Linux 2.6.32-696.10.2.el6.x86_64 (dzh-hw-bj3219)        04/04/2018      _x86_64_        (8 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.81    0.03    0.16    0.04    0.07   98.90

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
xvda              0.38         0.10         5.71     729274   43157304
xvdb             30.95         7.62       686.84   57636578 5194927160
dm-0             85.98         7.62       686.84   57635962 5194927160
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>说明：</p>
<p>cpu属性值说明：</p>
<p>%user：CPU处在用户模式下的时间百分比。</p>
<p>%nice：CPU处在带NICE值的用户模式下的时间百分比。</p>
<p>%system：CPU处在系统模式下的时间百分比。</p>
<p>%iowait：CPU等待输入输出完成时间的百分比。</p>
<p>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</p>
<p>%idle：CPU空闲时间百分比。</p>
<p>备注：如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。</p>
<p>2）定时显示所有信息</p>
<div><pre><code>iostat 2 3
</code></pre>
<div><span>1</span><br></div></div><p>说明：</p>
<p>每隔 2秒刷新显示，且显示3次</p>
<p>3）显示指定磁盘信息</p>
<div><pre><code># iostat -d xvda
Linux 2.6.32-696.10.2.el6.x86_64 (dzh-hw-bj3219)        04/04/2018      _x86_64_        (8 CPU)

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
xvda              0.38         0.10         5.71     729290   43160264
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>4）显示tty和cpu信息</p>
<div><pre><code># iostat -t
Linux 2.6.32-696.10.2.el6.x86_64 (dzh-hw-bj3219)        04/04/2018      _x86_64_        (8 CPU)

04/04/2018 02:25:52 PM
avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.81    0.03    0.16    0.04    0.07   98.90

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
xvda              0.38         0.10         5.71     729290   43160960
xvdb             30.95         7.62       686.87   57637978 5195407104
dm-0             85.99         7.62       686.87   57637362 5195407104
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>5）以m为单位显示所有信息</p>
<div><pre><code># iostat -m
Linux 2.6.32-696.10.2.el6.x86_64 (dzh-hw-bj3219)        04/04/2018      _x86_64_        (8 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.81    0.03    0.16    0.04    0.07   98.90

Device:            tps    MB_read/s    MB_wrtn/s    MB_read    MB_wrtn
xvda              0.38         0.00         0.00        356      21075
xvdb             30.95         0.00         0.34      28143    2536858
dm-0             85.99         0.00         0.34      28143    2536858
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>6）查看TPS和吞吐量信息</p>
<div><pre><code># iostat -d -k 1 1 
Linux 2.6.32-696.10.2.el6.x86_64 (dzh-hw-bj3219)        04/04/2018      _x86_64_        (8 CPU)

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
xvda              0.38         0.05         2.85     364653   21581388
xvdb             30.95         3.81       343.44   28819121 2597806052
dm-0             85.99         3.81       343.44   28818813 2597806052
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>说明：</p>
<p>tps：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。“一次传输”请求的大小是未知的。</p>
<p>kB_read/s：每秒从设备（drive expressed）读取的数据量；</p>
<p>kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；</p>
<p>kB_read：读取的总数据量；kB_wrtn：写入的总数量数据量；</p>
<p>这些单位都为Kilobytes。</p>
<p>7）查看设备使用率（%util）、响应时间（await）</p>
<div><pre><code># iostat -d -x -k 1 1 
Linux 2.6.32-696.10.2.el6.x86_64 (dzh-hw-bj3219)        04/04/2018      _x86_64_        (8 CPU)

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
xvda              0.00     0.33    0.00    0.38     0.05     2.85    15.16     0.00    3.11    1.94    3.12   1.06   0.04
xvdb              0.00    55.03    0.13   30.83     3.81   343.45    22.44     0.33   10.74    3.87   10.76   0.12   0.37
dm-0              0.00     0.00    0.13   85.86     3.81   343.45     8.08     0.33    3.89    3.88    3.89   0.04   0.37
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>说明：</p>
<p>rrqm/s：  每秒进行 merge 的读操作数目.即 delta(rmerge)/s</p>
<p>wrqm/s： 每秒进行 merge 的写操作数目.即 delta(wmerge)/s</p>
<p>r/s：  每秒完成的读 I/O 设备次数.即 delta(rio)/s</p>
<p>w/s：  每秒完成的写 I/O 设备次数.即 delta(wio)/s</p>
<p>rsec/s：  每秒读扇区数.即 delta(rsect)/s</p>
<p>wsec/s： 每秒写扇区数.即 delta(wsect)/s</p>
<p>rkB/s：  每秒读K字节数.是 rsect/s 的一半,因为每扇区大小为512字节.(需要计算)</p>
<p>wkB/s：  每秒写K字节数.是 wsect/s 的一半.(需要计算)</p>
<p>avgrq-sz：平均每次设备I/O操作的数据大小 (扇区).delta(rsect+wsect)/delta(rio+wio)</p>
<p>avgqu-sz：平均I/O队列长度.即 delta(aveq)/s/1000 (因为aveq的单位为毫秒).</p>
<p>await：  平均每次设备I/O操作的等待时间 (毫秒).即 delta(ruse+wuse)/delta(rio+wio)</p>
<p>svctm： 平均每次设备I/O操作的服务时间 (毫秒).即 delta(use)/delta(rio+wio)</p>
<p>%util： 一秒中有百分之多少的时间用于 I/O 操作,或者说一秒中有多少时间 I/O 队列是非空的，即 delta(use)/s/1000 (因为use的单位为毫秒)</p>
<p>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。</p>
<p>idle小于70% IO压力就较大了，一般读取速度有较多的wait。</p>
<p>同时可以结合vmstat 查看查看b参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比，高过30%时IO压力高)。</p>
<p>另外 await 的参数也要多和 svctm 来参考。差的过高就一定有 IO 的问题。</p>
<p>avgqu-sz 也是个做 IO 调优时需要注意的地方，这个就是直接每次操作的数据的大小，如果次数多，但数据拿的小的话，其实 IO 也会很小。如果数据拿的大，才IO 的数据会高。也可以通过 avgqu-sz × ( r/s or w/s ) = rsec/s or wsec/s。也就是讲，读定速度是这个来决定的。</p>
<p>svctm 一般要小于 await (因为同时等待的请求的等待时间被重复计算了)，svctm 的大小一般和磁盘性能有关，CPU/内存的负荷也会对其有影响，请求过多也会间接导致 svctm 的增加。await 的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明 I/O 队列太长，应用得到的响应时间变慢，如果响应时间超过了用户可以容许的范围，这时可以考虑更换更快的磁盘，调整内核 elevator 算法，优化应用，或者升级 CPU。</p>
<p>队列长度(avgqu-sz)也可作为衡量系统 I/O 负荷的指标，但由于 avgqu-sz 是按照单位时间的平均值，所以不能反映瞬间的 I/O 洪水。</p>
<p>​       形象的比喻：
​       r/s+w/s 类似于交款人的总数
​      平均队列长度(avgqu-sz)类似于单位时间里平均排队人的个数
​      平均服务时间(svctm)类似于收银员的收款速度
​      平均等待时间(await)类似于平均每人的等待时间
​      平均I/O数据(avgrq-sz)类似于平均每人所买的东西多少
​       I/O 操作率 (%util)类似于收款台前有人排队的时间比例
​       设备IO操作:总IO(io)/s = r/s(读) +w/s(写) =1.46 + 25.28=26.74
​      平均每次设备I/O操作只需要0.36毫秒完成,现在却需要10.57毫秒完成，因为发出的	请求太多(每秒26.74个)，假如请求时同时发出的，可以这样计算平均等待时间:
​      平均等待时间=单个I/O服务器时间*(1+2+...+请求总数-1)/请求总数
​       每秒发出的I/0请求很多,但是平均队列就4,表示这些请求比较均匀,大部分处理还是比较及时。</p>
<p>8）查看cpu状态</p>
<div><pre><code># iostat -c 1 3
Linux 2.6.32-696.10.2.el6.x86_64 (dzh-hw-bj3219)        04/04/2018      _x86_64_        (8 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.81    0.03    0.16    0.04    0.07   98.90

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           2.29    0.13    0.38    0.00    0.13   97.07

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           4.32    0.00    0.51    0.13    0.00   95.04
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>参考链接：</p>
<p>http://www.cnblogs.com/peida/archive/2012/12/28/2837345.html</p>
<p>http://man.linuxde.net/iostat</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2018-07-27T19:17:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">每天一个linux命令（45）-vmstat</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8845%EF%BC%89-vmstat/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8845%EF%BC%89-vmstat/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可对操作系统的虚拟内存、进程、CPU活动进行监控。他是对系统整体情况进行统计，不足之处是无法对某个进程今次那个深入分析。vmstat工具提供了一种低开销的系统性能观察方式。因为vmstat本身就是低开销工具，在非常高负荷的服务器上，你需要查看并监控系统的健康情况，在控制窗口还是能够使用vmstat命令前，我们先了解下Linux系统中关于物理内存和虚拟内存相关信息。</p>

<p>物理内存和虚拟内存区别：</p>
<p>我们知道，直接从物理内存读取数据要比从硬盘读写数据要快的多，因此，我们希望所有数据的读取和写入都在内存完成，而内存是有限的，这样就引出了物理内存与虚拟内存的概念。</p>
<p>物理内存就是系统硬件提供的内存大小，是真正的内存，在linux下还有一个虚拟内存的概念，虚拟内存就是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为交换空间（Swap Space）。</p>
<p>作为物理内存的扩展，linux会在物理内存不足时，使用交换分区的虚拟内存，更详细的说，就是内核会将暂时不用的内存块信息写到交换空间，这样以来，物理内存得到了释放，这块内存就是用于其目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。</p>
<p>linux的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候讲物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</p>
<p>要深入了解linux内存运行机制，需要知道下面提到的几个方面：</p>
<p>首先，linux系统会不时的进行页面，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，linux也会交换出暂时不用的内存页面。这可以避免等待交互所需的时间。</p>
<p>其次，linux进行页面交换是有条件的，不时所有页面在不用时都交换到虚拟内存，linux内核根据“最近最经常使用”算法，仅仅将一些不经常使用的页面文件交换到虚拟内存，有时我们会看到这么一个现象：linux物理内存还有很多，但是交换空间也使用了很多。其实，这并不奇怪，例如，一个占用很大内存的进程运行时，需要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存是，刚才被交换出去的页面文件并不会自动的交换进物理内存，除非有这个必要，那么此刻系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。关于这点，不用担心什么，只要知道是怎么一回事就可以了。</p>
<p>最后，交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页面，他们又会被马上交换出去，如此以来，虚拟内存中可能没有足够空间来存储这些交换页面，最终会导致linux出现假死机、服务异常等问题，linux虽然可以在一段时间内自行恢复，但是恢复后的系统已经基本不可用了。</p>
<p>因此，合理规划和设计linux内存的使用，是非常重要的。</p>
<p>虚拟内存原理：</p>
<p>在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。</p>
<p>在linux内存管理中，主要是通过“调页Paging”和“交换Swapping”来完成上述的内存调度。调页算法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整个进程，而不是部分页面，全部交换到磁盘上。</p>
<p>分页（Page）写入磁盘的过程被称作Page-Out，分页（Page）从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中（因为已经被Page-Out了），此时就发生了分页错误（Page Fault）。</p>
<p>当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。尽管Page-Out不是经常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态也被称作thrashing（颠簸）。</p>
<h2 id="语法"> 语法</h2>
<p><code>vmstat(选项)(参数)</code></p>
<h2 id="选项"> 选项</h2>
<div><pre><code>-a：显示活动内页；
-f：显示启动后创建的进程总数；
-m：显示slab信息；
-n：头信息仅显示一次；
-s：以表格方式显示事件计数器和内存状态；
-d：报告磁盘状态；
-p：显示指定的硬盘分区状态；
-S：输出信息的单位。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="参数"> 参数</h2>
<ul>
<li>事件间隔：状态信息刷新的时间间隔；</li>
<li>次数：显示报告的次数。</li>
</ul>
<h2 id="常用实例"> 常用实例</h2>
<p>1）显示虚拟内存使用情况</p>
<div><pre><code># vmstat 5 6
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0      0 3029876 199616 690980    0    0     0     2    3    2  0  0 100  0  0
 0      0 3029752 199616 690980    0    0     0    41 1009   39  0  0 100  0  0
 0      0 3029752 199616 690980    0    0     0     3 1004   36  0  0 100  0  0
 0      0 3029752 199616 690980    0    0     0     4 1004   36  0  0 100  0  0
 0      0 3029752 199616 690980    0    0     0     6 1003   33  0  0 100  0  0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>说明：</p>
<p>字段说明：</p>
<p>Procs（进程）：</p>
<p>r: 运行队列中进程数量</p>
<p>b: 等待IO的进程数量</p>
<p>Memory（内存）：</p>
<p>swpd: 使用虚拟内存大小</p>
<p>free: 可用内存大小</p>
<p>buff: 用作缓冲的内存大小</p>
<p>cache: 用作缓存的内存大小</p>
<p>Swap：</p>
<p>si: 每秒从交换区写到内存的大小</p>
<p>so: 每秒写入交换区的内存大小</p>
<p>IO：（现在的Linux版本块的大小为1024bytes）</p>
<p>bi: 每秒读取的块数</p>
<p>bo: 每秒写入的块数</p>
<p>系统：</p>
<p>in: 每秒中断数，包括时钟中断。</p>
<p>cs: 每秒上下文切换数。</p>
<p>CPU（以百分比表示）：</p>
<p>us: 用户进程执行时间(user time)</p>
<p>sy: 系统进程执行时间(system time)</p>
<p>id: 空闲时间(包括IO等待时间),中央处理器的空闲时间 。以百分比表示。</p>
<p>wa: 等待IO时间</p>
<p>备注： 如果 r经常大于 4 ，且id经常少于40，表示cpu的负荷很重。如果pi，po 长期不等于0，表示内存不足。如果disk 经常不等于0， 且在 b中的队列 大于3， 表示 io性能不好。Linux在具有高稳定性、可靠性的同时，具有很好的可伸缩性和扩展性，能够针对不同的应用和硬件环境调整，优化出满足当前应用需要的最佳性能。因此企业在维护Linux系统、进行系统调优时，了解系统性能分析工具是至关重要的。</p>
<p>命令：</p>
<p>vmstat 5 5</p>
<p>表示在5秒时间内进行5次采样。将得到一个数据汇总他能够反映真正的系统情况。</p>
<p>2）显示活跃和非活跃内存</p>
<div><pre><code># vmstat -a 2 5
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r  b   swpd   free  inact active   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 3029752 387728 513008    0    0     0     2    3    2  0  0 100  0  0
 0  0      0 3029752 387728 513076    0    0     0     0 1005   34  0  0 100  0  0
 0  0      0 3029752 387728 513076    0    0     0    22 1004   36  0  0 100  0  0
 0  0      0 3029752 387728 513076    0    0     0     0 1004   33  0  0 100  0  0
 0  0      0 3029752 387728 513076    0    0     0     0 1003   32  0  0 100  0  0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>说明：</p>
<p>使用-a选项显示活跃和非活跃内存时，所显示的内容除增加inact和active外，其他显示内容与例子1相同。</p>
<p>字段说明：</p>
<p>Memory（内存）：</p>
<p>inact: 非活跃内存大小（当使用-a选项时显示）</p>
<p>active: 活跃的内存大小（当使用-a选项时显示）</p>
<p>3）查看系统已经fork了多少次</p>
<div><pre><code># vmstat -f
     12744849 forks
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>说明：</p>
<p>这个数据是从/proc/stat中的processes字段里取得的</p>
<p>4）查看内存使用的详细信息</p>
<div><pre><code># vmstat -s
      4043760  total memory
      1013884  used memory
       513012  active memory
       387728  inactive memory
      3029876  free memory
       199616  buffer memory
       690980  swap cache
      6096656  total swap
            0  used swap
      6096656  free swap
        83587 non-nice user cpu ticks
          132 nice user cpu ticks
       278599 system cpu ticks
    913344692 idle cpu ticks
       814550 IO-wait cpu ticks
        10547 IRQ cpu ticks
        21261 softirq cpu ticks
            0 stolen cpu ticks
       310215 pages paged in
     14254652 pages paged out
            0 pages swapped in
            0 pages swapped out
    288374745 interrupts
    146680577 CPU context switches
   1351868832 boot time
       367291 forks 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>说明：</p>
<p>这些信息的分别来自于/proc/meminfo,/proc/stat和/proc/vmstat。</p>
<p>5）查看磁盘的读/写</p>
<div><pre><code># vmstat -d
disk- ------------reads------------ ------------writes----------- -----IO------
       total merged sectors      ms  total merged sectors      ms    cur    sec
ram0       0      0       0       0      0      0       0       0      0      0
ram1       0      0       0       0      0      0       0       0      0      0
ram2       0      0       0       0      0      0       0       0      0      0
ram3       0      0       0       0      0      0       0       0      0      0
ram4       0      0       0       0      0      0       0       0      0      0
ram5       0      0       0       0      0      0       0       0      0      0
ram6       0      0       0       0      0      0       0       0      0      0
ram7       0      0       0       0      0      0       0       0      0      0
ram8       0      0       0       0      0      0       0       0      0      0
ram9       0      0       0       0      0      0       0       0      0      0
ram10      0      0       0       0      0      0       0       0      0      0
ram11      0      0       0       0      0      0       0       0      0      0
ram12      0      0       0       0      0      0       0       0      0      0
ram13      0      0       0       0      0      0       0       0      0      0
ram14      0      0       0       0      0      0       0       0      0      0
ram15      0      0       0       0      0      0       0       0      0      0
sda    33381   6455  615407   63224 2068111 1495416 28508288 15990289      0  10491
hdc        0      0       0       0      0      0       0       0      0      0
fd0        0      0       0       0      0      0       0       0      0      0
md0        0      0       0       0      0      0       0       0      0      0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>这些信息主要来自于/proc/diskstats.</p>
<p>merged:表示一次来自于合并的写/读请求,一般系统会把多个连接/邻近的读/写请求合并到一起来操作</p>
<p>6）查看/dev/sda1磁盘的读/写</p>
<div><pre><code># df
文件系统                 1K-块      已用      可用 已用% 挂载点
/dev/sda3            1119336548  27642068 1034835500   3% /tmpfs                 32978376         0  32978376   0% /dev/shm
/dev/sda1              1032088     59604    920056   7% /boot
# vmstat -p /dev/sda1
sda1          reads   read sectors  writes    requested writes
               18607    4249978          6         48
# vmstat -p /dev/sda3
sda3          reads   read sectors  writes    requested writes
              429350   35176268   28998789  980301488
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>说明：</p>
<p>这些信息主要来自于/proc/diskstats。</p>
<p>reads:来自于这个分区的读的次数。</p>
<p>read sectors:来自于这个分区的读扇区的次数。</p>
<p>writes:来自于这个分区的写的次数。</p>
<p>requested writes:来自于这个分区的写请求次数。</p>
<p>7）查看系统的slab信息</p>
<div><pre><code># vmstat -m
Cache                       Num  Total   Size  Pages
ip_conntrack_expect           0      0    136     28
ip_conntrack                  3     13    304     13
ip_fib_alias                 11     59     64     59
ip_fib_hash                  11     59     64     59
AF_VMCI                       0      0    960      4
bio_map_info                100    105   1064      7
dm_mpath                      0      0   1064      7
jbd_4k                        0      0   4096      1
dm_uevent                     0      0   2608      3
dm_tio                        0      0     24    144
dm_io                         0      0     48     77
scsi_cmd_cache               10     10    384     10
sgpool-128                   32     32   4096      1
sgpool-64                    32     32   2048      2
sgpool-32                    32     32   1024      4
sgpool-16                    32     32    512      8
sgpool-8                     45     45    256     15
scsi_io_context               0      0    112     34
ext3_inode_cache          51080  51105    760      5
ext3_xattr                   36     88     88     44
journal_handle               18    144     24    144
journal_head                 56     80     96     40
revoke_table                  4    202     16    202
revoke_record                 0      0     32    112
uhci_urb_priv                 0      0     56     67
UNIX                         13     33    704     11
flow_cache                    0      0    128     30
msi_cache                    33     59     64     59
cfq_ioc_pool                 14     90    128     30
cfq_pool                     12     90    216     18
crq_pool                     16     96     80     48
deadline_drq                  0      0     80     48
as_arq                        0      0     96     40
mqueue_inode_cache            1      4    896      4
isofs_inode_cache             0      0    608      6
hugetlbfs_inode_cache         1      7    576      7
Cache                       Num  Total   Size  Pages
ext2_inode_cache              0      0    720      5
ext2_xattr                    0      0     88     44
dnotify_cache                 0      0     40     92
dquot                         0      0    256     15
eventpoll_pwq                 3     53     72     53
eventpoll_epi                 3     20    192     20
inotify_event_cache           0      0     40     92
inotify_watch_cache           1     53     72     53
kioctx                        0      0    320     12
kiocb                         0      0    256     15
fasync_cache                  0      0     24    144
shmem_inode_cache           254    290    768      5
posix_timers_cache            0      0    128     30
uid_cache                     0      0    128     30
ip_mrt_cache                  0      0    128     30
tcp_bind_bucket               3    112     32    112
inet_peer_cache               0      0    128     30
secpath_cache                 0      0     64     59
xfrm_dst_cache                0      0    384     10
ip_dst_cache                  5     10    384     10
arp_cache                     1     15    256     15
RAW                           3      5    768      5
UDP                           5     10    768      5
tw_sock_TCP                   0      0    192     20
request_sock_TCP              0      0    128     30
TCP                           4      5   1600      5
blkdev_ioc                   14    118     64     59
blkdev_queue                 20     30   1576      5
blkdev_requests              13     42    272     14
biovec-256                    7      7   4096      1
biovec-128                    7      8   2048      2
biovec-64                     7      8   1024      4
biovec-16                     7     15    256     15
biovec-4                      7     59     64     59
biovec-1                     23    202     16    202
bio                         270    270    128     30
utrace_engine_cache           0      0     64     59
Cache                       Num  Total   Size  Pages
utrace_cache                  0      0     64     59
sock_inode_cache             33     48    640      6
skbuff_fclone_cache           7      7    512      7
skbuff_head_cache           319    390    256     15
file_lock_cache               1     22    176     22
Acpi-Operand               4136   4248     64     59
Acpi-ParseExt                 0      0     64     59
Acpi-Parse                    0      0     40     92
Acpi-State                    0      0     80     48
Acpi-Namespace             2871   2912     32    112
delayacct_cache              81    295     64     59
taskstats_cache               4     53     72     53
proc_inode_cache           1427   1440    592      6
sigqueue                      0      0    160     24
radix_tree_node           13166  13188    536      7
bdev_cache                   23     24    832      4
sysfs_dir_cache            5370   5412     88     44
mnt_cache                    26     30    256     15
inode_cache                2009   2009    560      7
dentry_cache              60952  61020    216     18
filp                        479   1305    256     15
names_cache                   3      3   4096      1
avc_node                     14     53     72     53
selinux_inode_security      994   1200     80     48
key_jar                       2     20    192     20
idr_layer_cache              74     77    528      7
buffer_head              164045 164800     96     40
mm_struct                    51     56    896      4
vm_area_struct             1142   1958    176     22
fs_cache                     35    177     64     59
files_cache                  36     55    768      5
signal_cache                 72    162    832      9
sighand_cache                68     84   2112      3
task_struct                  76     80   1888      2
anon_vma                    458    864     24    144
pid                          83    295     64     59
shared_policy_node            0      0     48     77
Cache                       Num  Total   Size  Pages
numa_policy                  37    144     24    144
size-131072(DMA)              0      0 131072      1
size-131072                   0      0 131072      1
size-65536(DMA)               0      0  65536      1
size-65536                    1      1  65536      1
size-32768(DMA)               0      0  32768      1
size-32768                    2      2  32768      1
size-16384(DMA)               0      0  16384      1
size-16384                    5      5  16384      1
size-8192(DMA)                0      0   8192      1
size-8192                     7      7   8192      1
size-4096(DMA)                0      0   4096      1
size-4096                   110    111   4096      1
size-2048(DMA)                0      0   2048      2
size-2048                   602    602   2048      2
size-1024(DMA)                0      0   1024      4
size-1024                   344    352   1024      4
size-512(DMA)                 0      0    512      8
size-512                    433    480    512      8
size-256(DMA)                 0      0    256     15
size-256                   1139   1155    256     15
size-128(DMA)                 0      0    128     30
size-64(DMA)                  0      0     64     59
size-64                    5639   5782     64     59
size-32(DMA)                  0      0     32    112
size-128                    801    930    128     30
size-32                    3005   3024     32    112
kmem_cache                  137    137   2688      1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br></div></div><p>这组信息来自于/proc/slabinfo。</p>
<p>slab:由于内核会有许多小对象，这些对象构造销毁十分频繁，比如i-node，dentry，这些对象如果每次构建的时候就向内存要一个页(4kb)，而其实只有几个字节，这样就会非常浪费，为了解决这个问题，就引入了一种新的机制来处理在同一个页框中如何分配小存储区，而slab可以对小对象进行分配,这样就不用为每一个对象分配页框，从而节省了空间，内核对一些小对象创建析构很频繁，slab对这些小对象进行缓冲,可以重复利用,减少内存分配次数。</p>
<p>参考链接：</p>
<p>http://www.cnblogs.com/peida/archive/2012/12/25/2833108.html</p>
<p>http://man.linuxde.net/vmstat</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2018-07-27T19:16:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">每天一个linux命令（49）-lsof</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8849%EF%BC%89-lsof/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8849%EF%BC%89-lsof/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。</p>

<h2 id="语法"> 语法</h2>
<p><code>lsof(选项)</code></p>
<h2 id="选项"> 选项</h2>
<div><pre><code>-a：列出打开文件存在的进程；
-c&lt;进程名&gt;：列出指定进程所打开的文件；
-g：列出GID号进程详情；
-d&lt;文件号&gt;：列出占用该文件号的进程；
+d&lt;目录&gt;：列出目录下被打开的文件；
+D&lt;目录&gt;：递归列出目录下被打开的文件；
-n&lt;目录&gt;：列出使用NFS的文件；
-i&lt;条件&gt;：列出符合条件的进程。（4、6、协议、:端口、 @ip ）
-p&lt;进程号&gt;：列出指定进程号所打开的文件；
-u：列出UID号进程详情；
-h：显示帮助信息；
-v：显示版本信息。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="命令功能"> 命令功能</h2>
<p>用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为 lsof 需要访问核心内存和各种文件，所以需要root用户执行。</p>
<p>lsof打开的文件可以是：</p>
<p>1.普通文件</p>
<p>2.目录</p>
<p>3.网络文件系统的文件</p>
<p>4.字符或设备文件</p>
<p>5.(函数)共享库</p>
<p>6.管道，命名管道</p>
<p>7.符号链接</p>
<p>8.网络文件（例如：NFS file、网络socket，unix域名socket）</p>
<p>9.还有其它类型的文件，等等</p>
<h2 id="常用实例"> 常用实例</h2>
<p>1）无任何参数</p>
<div><pre><code># lsof
command     PID USER   FD      type             DEVICE     SIZE       NODE NAME
init          1 root  cwd       DIR                8,2     4096          2 /
init          1 root  rtd       DIR                8,2     4096          2 /
init          1 root  txt       REG                8,2    43496    6121706 /sbin/init
init          1 root  mem       REG                8,2   143600    7823908 /lib64/ld-2.5.so
init          1 root  mem       REG                8,2  1722304    7823915 /lib64/libc-2.5.so
init          1 root  mem       REG                8,2    23360    7823919 /lib64/libdl-2.5.so
init          1 root  mem       REG                8,2    95464    7824116 /lib64/libselinux.so.1
init          1 root  mem       REG                8,2   247496    7823947 /lib64/libsepol.so.1
init          1 root   10u     FIFO               0,17                1233 /dev/initctl
migration     2 root  cwd       DIR                8,2     4096          2 /
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>说明：</p>
<p><strong>lsof输出各列信息的意义如下：</strong></p>
<ul>
<li>COMMAND：进程的名称</li>
<li>PID：进程标识符</li>
<li>PPID：父进程标识符（需要指定-R参数）</li>
<li>USER：进程所有者</li>
<li>PGID：进程所属组</li>
<li>FD：文件描述符，应用程序通过文件描述符识别该文件。</li>
</ul>
<p>文件描述符列表：</p>
<ol>
<li>cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改</li>
<li>txt：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序</li>
<li>lnn：library references (AIX);</li>
<li>er：FD information error (see NAME column);</li>
<li>jld：jail directory (FreeBSD);</li>
<li>ltx：shared library text (code and data);</li>
<li>mxx ：hex memory-mapped type number xx.</li>
<li>m86：DOS Merge mapped <a href="http://man.linuxde.net/file" target="_blank" rel="noopener noreferrer">file</a>;</li>
<li>mem：memory-mapped file;</li>
<li>mmap：memory-mapped device;</li>
<li>pd：parent directory;</li>
<li>rtd：root directory;</li>
<li><a href="http://man.linuxde.net/tr" target="_blank" rel="noopener noreferrer">tr</a>：kernel trace file (OpenBSD);</li>
<li>v86  VP/ix mapped file;</li>
<li>0：表示标准输出</li>
<li>1：表示标准输入</li>
<li>2：表示标准错误</li>
</ol>
<p>一般在标准输出、标准错误、标准输入后还跟着文件状态模式：</p>
<ol>
<li>u：表示该文件被打开并处于读取/写入模式。</li>
<li>r：表示该文件被打开并处于只读模式。</li>
<li><a href="http://man.linuxde.net/w" target="_blank" rel="noopener noreferrer">w</a>：表示该文件被打开并处于。</li>
<li>空格：表示该文件的状态模式为unknow，且没有锁定。</li>
<li>-：表示该文件的状态模式为unknow，且被锁定。</li>
</ol>
<p>同时在文件状态模式后面，还跟着相关的锁：</p>
<ol>
<li>N：for a Solaris NFS lock of unknown type;</li>
<li>r：for <a href="http://man.linuxde.net/read" target="_blank" rel="noopener noreferrer">read</a> lock on part of the file;</li>
<li>R：for a read lock on the entire file;</li>
<li>w：for a <a href="http://man.linuxde.net/write" target="_blank" rel="noopener noreferrer">write</a> lock on part of the file;（文件的部分写锁）</li>
<li>W：for a write lock on the entire file;（整个文件的写锁）</li>
<li>u：for a read and write lock of any length;</li>
<li>U：for a lock of unknown type;</li>
<li>x：for an SCO OpenServer Xenix lock on part      of the file;</li>
<li>X：for an SCO OpenServer Xenix lock on the      entire file;</li>
<li>space：if there is no lock.</li>
</ol>
<p>文件类型：</p>
<ol>
<li>
<p>DIR：表示目录。</p>
</li>
<li>
<p>CHR：表示字符类型。</p>
</li>
<li>
<p>BLK：块设备类型。</p>
</li>
<li>
<p>UNIX： UNIX 域套接字。</p>
</li>
<li>
<p>FIFO：先进先出 (FIFO) 队列。</p>
</li>
<li>
<p>IPv4：网际协议 (IP) 套接字。</p>
</li>
<li>
<p>DEVICE：指定磁盘的名称</p>
</li>
<li>
<p>SIZE：文件的大小</p>
</li>
<li>
<p>NODE：索引节点（文件在磁盘上的标识）</p>
</li>
<li>
<p>NAME：打开文件的确切名称</p>
</li>
</ol>
<p>2）查看谁正在使用某个文件，也就是说查找某个文件相关的进程</p>
<div><pre><code># lsof /bin/bash
COMMAND   PID USER  FD   TYPE DEVICE   SIZE    NODE NAME
bash    24159 root txt    REG    8,2 801528 5368780 /bin/bash
bash    24909 root txt    REG    8,2 801528 5368780 /bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>3）递归查看某个目录的文件信息</p>
<div><pre><code># lsof test/test3
COMMAND   PID USER   FD   TYPE DEVICE SIZE    NODE NAME
bash    24941 root  cwd    DIR    8,2 4096 2258872 test/test3
vi      24976 root  cwd    DIR    8,2 4096 2258872 test/test3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>说明：</p>
<p>使用了+D，对应目录下的所有子目录和文件都会被列出</p>
<p>4）不使用+D选项，遍历查看某个目录的所有文件信息的方法</p>
<div><pre><code># lsof |grep &#39;test/test3&#39;
bash      24941 root  cwd       DIR                8,2     4096    2258872 /opt/soft/test/test3
vi        24976 root  cwd       DIR                8,2     4096    2258872 /opt/soft/test/test3
vi        24976 root    4u      REG                8,2    12288    2258882 /opt/soft/test/test3/.log2013.log.swp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>5）列出某个用户打开的文件信息</p>
<div><pre><code># lsof -u username
</code></pre>
<div><span>1</span><br></div></div><p>说明:</p>
<p>-u 选项，u其实是user的缩写</p>
<p>6）列出某个程序进程所打开的文件信息</p>
<div><pre><code># lsof -c mysql
</code></pre>
<div><span>1</span><br></div></div><p>说明:</p>
<p>-c 选项将会列出所有以mysql这个进程开头的程序的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符了</p>
<p>7）列出多个进程多个打开的文件信息</p>
<div><pre><code># lsof -c mysql -c apache
</code></pre>
<div><span>1</span><br></div></div><p>8）列出某个用户以及某个进程所打开的文件信息</p>
<div><pre><code># lsof  -u test -c mysql 
</code></pre>
<div><span>1</span><br></div></div><p>9）列出除了某个用户外的被打开的文件信息</p>
<div><pre><code># lsof -u ^root
</code></pre>
<div><span>1</span><br></div></div><p>说明：</p>
<p>^这个符号在用户名之前，将会把是root用户打开的进程不让显示</p>
<p>10）通过某个进程号显示该进行打开的文件</p>
<div><pre><code># lsof -p 1
</code></pre>
<div><span>1</span><br></div></div><p>11）列出多个进程号对应的文件信息</p>
<div><pre><code># lsof -p 1,2,3
</code></pre>
<div><span>1</span><br></div></div><p>12）列出除了某个进程号，其他进程号所打开的文件信息</p>
<div><pre><code># lsof -p ^1
</code></pre>
<div><span>1</span><br></div></div><p>13）列出所有的网络连接</p>
<div><pre><code># lsof -i
</code></pre>
<div><span>1</span><br></div></div><p>14）列出所有tcp 网络连接信息</p>
<div><pre><code># lsof -i tcp
</code></pre>
<div><span>1</span><br></div></div><p>15）列出所有udp网络连接信息</p>
<div><pre><code># lsof -i udp
</code></pre>
<div><span>1</span><br></div></div><p>16）列出谁在使用某个端口</p>
<div><pre><code># lsof -i :3306
</code></pre>
<div><span>1</span><br></div></div><p>17）列出谁在使用某个特定的udp端口</p>
<div><pre><code># lsof -i udp:55
</code></pre>
<div><span>1</span><br></div></div><p>18）特定的tcp端口</p>
<div><pre><code># lsof -i tcp:80
</code></pre>
<div><span>1</span><br></div></div><p>19）列出某个用户的所有活跃的网络端口</p>
<div><pre><code># lsof -a -u test -i
</code></pre>
<div><span>1</span><br></div></div><p>20）列出所有网络文件系统</p>
<div><pre><code># lsof -N
</code></pre>
<div><span>1</span><br></div></div><p>21）域名socket文件</p>
<div><pre><code># lsof -u
</code></pre>
<div><span>1</span><br></div></div><p>22）某个用户组所打开的文件信息</p>
<div><pre><code># lsof -g 5555
</code></pre>
<div><span>1</span><br></div></div><p>23）根据文件描述列出对应的文件信息</p>
<div><pre><code># lsof -d description(like 2)
# lsof  -d  txt
# lsof  -d  1
# lsof  -d  2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>说明：</p>
<p>0表示标准输入，1表示标准输出，2表示标准错误，从而可知：所以大多数应用程序所打开的文件的 FD 都是从 3 开始</p>
<p>24）根据文件描述范围列出文件信息</p>
<div><pre><code># lsof -d 2-3
</code></pre>
<div><span>1</span><br></div></div><p>25）列出COMMAND列中包含字符串&quot; sshd&quot;，且文件描符的类型为txt的文件信息</p>
<div><pre><code># lsof -c sshd -a -d txt
COMMAND   PID USER  FD   TYPE DEVICE   SIZE    NODE NAME
sshd     2756 root txt    REG    8,2 409488 1027867 /usr/sbin/sshd
sshd    24155 root txt    REG    8,2 409488 1027867 /usr/sbin/sshd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>26）列出被进程号为1234的进程所打开的所有IPV4 network files</p>
<div><pre><code># lsof -i 4 -a -p 1234
</code></pre>
<div><span>1</span><br></div></div><p>27）列出目前连接主机peida.linux上端口为：20，21，22，25，53，80相关的所有文件信息，且每隔3秒不断的执行lsof指令</p>
<div><pre><code># lsof -i @peida.linux:20,21,22,25,53,80  -r  3
</code></pre>
<div><span>1</span><br></div></div><p>参考链接：</p>
<p>http://www.cnblogs.com/peida/archive/2013/02/26/2932972.html</p>
<p>https://man.linuxde.net/lsof</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2018-07-27T19:20:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">每天一个linux命令（52）-ping</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8852%EF%BC%89-ping/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8852%EF%BC%89-ping/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>Linux系统的ping命令是常用的网络命令，它通常用来测试与目标主机的连通性，我们经常会说“ping一下某机器，看是不是开着”、不能打开网页时会说“你先ping网关地址192.168.1.1试试”。它通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。</p>

<p>linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。</p>
<h2 id="语法"> 语法</h2>
<p><code>ping(选项)(参数)</code></p>
<h2 id="选项"> 选项</h2>
<div><pre><code>-d：使用Socket的SO_DEBUG功能；
-c&lt;完成次数&gt;：设置完成要求回应的次数；
-f：极限检测；
-i&lt;间隔秒数&gt;：指定收发信息的间隔时间；
-I&lt;网络界面&gt;：使用指定的网络界面送出数据包；
-l&lt;前置载入&gt;：设置在送出要求信息之前，先行发出的数据包；
-n：只输出数值；
-p&lt;范本样式&gt;：设置填满数据包的范本样式；
-q：不显示指令执行过程，开头和结尾的相关信息除外；
-r：忽略普通的Routing Table，直接将数据包送到远端主机上；
-R：记录路由过程；
-s&lt;数据包大小&gt;：设置数据包的大小；
-t&lt;存活数值&gt;：设置存活数值TTL的大小；
-v：详细显示指令的执行过程。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="参数"> 参数</h2>
<p>目的主机：指定发送ICMP报文的目的主机。</p>
<h2 id="功能"> 功能</h2>
<p>ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。</p>
<p>ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。</p>
<h2 id="常用实例"> 常用实例</h2>
<p>1）ping的通的情况</p>
<div><pre><code># ping 192.168.120.205
PING 192.168.120.205 (192.168.120.205) 56(84) bytes of data.
64 bytes from 192.168.120.205: icmp_seq=1 ttl=64 time=0.720 ms
64 bytes from 192.168.120.205: icmp_seq=2 ttl=64 time=0.181 ms
--- 192.168.120.205 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4000ms
rtt min/avg/max/mdev = 0.181/0.293/0.720/0.214 ms
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>2）ping不同的情况</p>
<div><pre><code># ping 192.168.120.202
PING 192.168.120.202 (192.168.120.202) 56(84) bytes of data.
From 192.168.120.204 icmp_seq=1 Destination Host Unreachable
From 192.168.120.204 icmp_seq=2 Destination Host Unreachable
-- 192.168.120.202 ping statistics ---
8 packets transmitted, 0 received, +6 errors, 100% packet loss, time 7005ms
, pipe 4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>3）ping指定次数</p>
<div><pre><code># ping -c 10 192.168.120.206
PING 192.168.120.206 (192.168.120.206) 56(84) bytes of data.
64 bytes from 192.168.120.206: icmp_seq=1 ttl=64 time=1.25 ms
64 bytes from 192.168.120.206: icmp_seq=2 ttl=64 time=0.260 ms
64 bytes from 192.168.120.206: icmp_seq=3 ttl=64 time=0.242 ms
64 bytes from 192.168.120.206: icmp_seq=4 ttl=64 time=0.271 ms
64 bytes from 192.168.120.206: icmp_seq=5 ttl=64 time=0.274 ms
64 bytes from 192.168.120.206: icmp_seq=6 ttl=64 time=0.295 ms
64 bytes from 192.168.120.206: icmp_seq=7 ttl=64 time=0.269 ms
64 bytes from 192.168.120.206: icmp_seq=8 ttl=64 time=0.270 ms
64 bytes from 192.168.120.206: icmp_seq=9 ttl=64 time=0.253 ms
64 bytes from 192.168.120.206: icmp_seq=10 ttl=64 time=0.289 ms

--- 192.168.120.206 ping statistics ---
10 packets transmitted, 10 received, 0% packet loss, time 9000ms
rtt min/avg/max/mdev = 0.242/0.367/1.251/0.295 ms
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>4）时间间隔和次数限制的ping</p>
<div><pre><code># ping -c 10 -i 0.5 192.168.120.206
PING 192.168.120.206 (192.168.120.206) 56(84) bytes of data.
64 bytes from 192.168.120.206: icmp_seq=1 ttl=64 time=1.24 ms
64 bytes from 192.168.120.206: icmp_seq=2 ttl=64 time=0.235 ms
64 bytes from 192.168.120.206: icmp_seq=3 ttl=64 time=0.244 ms
64 bytes from 192.168.120.206: icmp_seq=4 ttl=64 time=0.300 ms
64 bytes from 192.168.120.206: icmp_seq=5 ttl=64 time=0.255 ms
64 bytes from 192.168.120.206: icmp_seq=6 ttl=64 time=0.264 ms
64 bytes from 192.168.120.206: icmp_seq=7 ttl=64 time=0.263 ms
64 bytes from 192.168.120.206: icmp_seq=8 ttl=64 time=0.331 ms
64 bytes from 192.168.120.206: icmp_seq=9 ttl=64 time=0.247 ms
64 bytes from 192.168.120.206: icmp_seq=10 ttl=64 time=0.244 ms

--- 192.168.120.206 ping statistics ---
10 packets transmitted, 10 received, 0% packet loss, time 4499ms
rtt min/avg/max/mdev = 0.235/0.362/1.241/0.294 ms
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>5）多参数使用</p>
<div><pre><code># ping -i 3 -s 1024 -t 255 192.168.120.206
PING 192.168.120.206 (192.168.120.206) 1024(1052) bytes of data.
1032 bytes from 192.168.120.206: icmp_seq=1 ttl=64 time=1.99 ms
1032 bytes from 192.168.120.206: icmp_seq=2 ttl=64 time=0.694 ms
1032 bytes from 192.168.120.206: icmp_seq=3 ttl=64 time=0.300 ms
1032 bytes from 192.168.120.206: icmp_seq=4 ttl=64 time=0.481 ms
1032 bytes from 192.168.120.206: icmp_seq=5 ttl=64 time=0.415 ms
1032 bytes from 192.168.120.206: icmp_seq=6 ttl=64 time=0.600 ms
1032 bytes from 192.168.120.206: icmp_seq=7 ttl=64 time=0.411 ms
1032 bytes from 192.168.120.206: icmp_seq=8 ttl=64 time=0.281 ms
1032 bytes from 192.168.120.206: icmp_seq=9 ttl=64 time=0.318 ms
1032 bytes from 192.168.120.206: icmp_seq=10 ttl=64 time=0.362 ms
1032 bytes from 192.168.120.206: icmp_seq=11 ttl=64 time=0.408 ms
1032 bytes from 192.168.120.206: icmp_seq=12 ttl=64 time=0.445 ms
1032 bytes from 192.168.120.206: icmp_seq=13 ttl=64 time=0.397 ms
1032 bytes from 192.168.120.206: icmp_seq=14 ttl=64 time=0.406 ms
1032 bytes from 192.168.120.206: icmp_seq=15 ttl=64 time=0.458 ms

--- 192.168.120.206 ping statistics ---
15 packets transmitted, 15 received, 0% packet loss, time 41999ms
rtt min/avg/max/mdev = 0.281/0.531/1.993/0.404 ms
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>说明：</p>
<p>-i 3 发送周期为 3秒 -s 设置发送包的大小为1024 -t 设置TTL值为 255</p>
<p>参考链接：</p>
<p>http://man.linuxde.net/ping</p>
<p>http://www.cnblogs.com/peida/archive/2013/03/06/2945407.html</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2018-07-27T19:23:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">每天一个linux命令（53）-traceroute</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8853%EF%BC%89-traceroute/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/linux%E5%91%BD%E4%BB%A4/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8853%EF%BC%89-traceroute/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<p>通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。</p>

<p>在大多数情况下，我们会在linux主机系统下，直接执行命令行：</p>
<p>traceroute hostname</p>
<p>而在Windows系统下是执行tracert的命令：</p>
<p>tracert hostname</p>
<h2 id="语法"> 语法</h2>
<p><code>traceroute(选项)(参数)</code></p>
<h2 id="选项"> 选项</h2>
<div><pre><code>-d：使用Socket层级的排错功能；
-f&lt;存活数值&gt;：设置第一个检测数据包的存活数值TTL的大小；
-F：设置勿离断位；
-g&lt;网关&gt;：设置来源路由网关，最多可设置8个；
-i&lt;网络界面&gt;：使用指定的网络界面送出数据包；
-I：使用ICMP回应取代UDP资料信息；
-m&lt;存活数值&gt;：设置检测数据包的最大存活数值TTL的大小；
-n：直接使用IP地址而非主机名称；
-p&lt;通信端口&gt;：设置UDP传输协议的通信端口；
-r：忽略普通的Routing Table，直接将数据包送到远端主机上。
-s&lt;来源地址&gt;：设置本地主机送出数据包的IP地址；
-t&lt;服务类型&gt;：设置检测数据包的TOS数值；
-v：详细显示指令的执行过程；
-w&lt;超时秒数&gt;：设置等待远端主机回报的时间；
-x：开启或关闭数据包的正确性检验。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="参数"> 参数</h2>
<p>主机：指定目的主机IP地址或主机名。</p>
<h2 id="功能"> 功能</h2>
<p>traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p>
<p>具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;...][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小]</p>
<h2 id="常用实例"> 常用实例</h2>
<p>1）traceroute 用法简单、最常用的用法</p>
<div><pre><code># traceroute www.baidu.com
traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets
 1  192.168.74.2 (192.168.74.2)  2.606 ms  2.771 ms  2.950 ms
 2  211.151.56.57 (211.151.56.57)  0.596 ms  0.598 ms  0.591 ms
 3  211.151.227.206 (211.151.227.206)  0.546 ms  0.544 ms  0.538 ms
 4  210.77.139.145 (210.77.139.145)  0.710 ms  0.748 ms  0.801 ms
 5  202.106.42.101 (202.106.42.101)  6.759 ms  6.945 ms  7.107 ms
 6  61.148.154.97 (61.148.154.97)  718.908 ms * bt-228-025.bta.net.cn (202.106.228.25)  5.177 ms
 7  124.65.58.213 (124.65.58.213)  4.343 ms  4.336 ms  4.367 ms
 8  202.106.35.190 (202.106.35.190)  1.795 ms 61.148.156.138 (61.148.156.138)  1.899 ms  1.951 ms
 9  * * *
30  * * *
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>说明：</p>
<p>记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。</p>
<p>有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。</p>
<p>有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。</p>
<p>如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。</p>
<p>2）跳数设置</p>
<div><pre><code># traceroute -m 10 www.baidu.com
traceroute to www.baidu.com (61.135.169.105), 10 hops max, 40 byte packets
 1  192.168.74.2 (192.168.74.2)  1.534 ms  1.775 ms  1.961 ms
 2  211.151.56.1 (211.151.56.1)  0.508 ms  0.514 ms  0.507 ms
 3  211.151.227.206 (211.151.227.206)  0.571 ms  0.558 ms  0.550 ms
 4  210.77.139.145 (210.77.139.145)  0.708 ms  0.729 ms  0.785 ms
 5  202.106.42.101 (202.106.42.101)  7.978 ms  8.155 ms  8.311 ms
 6  bt-228-037.bta.net.cn (202.106.228.37)  772.460 ms bt-228-025.bta.net.cn (202.106.228.25)  2.152 ms 61.148.154.97 (61.148.154.97)  772.107 ms
 7  124.65.58.221 (124.65.58.221)  4.875 ms 61.148.146.29 (61.148.146.29)  2.124 ms 124.65.58.221 (124.65.58.221)  4.854 ms
 8  123.126.6.198 (123.126.6.198)  2.944 ms 61.148.156.6 (61.148.156.6)  3.505 ms 123.126.6.198 (123.126.6.198)  2.885 ms
 9  * * *
10  * * *
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>3）显示IP地址，不查主机名</p>
<div><pre><code># traceroute -n www.baidu.com
traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets
 1  211.151.74.2  5.430 ms  5.636 ms  5.802 ms
 2  211.151.56.57  0.627 ms  0.625 ms  0.617 ms
 3  211.151.227.206  0.575 ms  0.584 ms  0.576 ms
 4  210.77.139.145  0.703 ms  0.754 ms  0.806 ms
 5  202.106.42.101  23.683 ms  23.869 ms  23.998 ms
 6  202.106.228.37  247.101 ms * *
 7  61.148.146.29  5.256 ms 124.65.58.213  4.386 ms  4.373 ms
 8  202.106.35.190  1.610 ms 61.148.156.138  1.786 ms 61.148.3.34  2.089 ms
 9  * * *
30  * * *
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>4）探测包使用的基本UDP端口设置6888</p>
<div><pre><code># traceroute -p 6888 www.baidu.com
traceroute to www.baidu.com (220.181.111.147), 30 hops max, 40 byte packets
 1  211.151.74.2 (211.151.74.2)  4.927 ms  5.121 ms  5.298 ms
 2  211.151.56.1 (211.151.56.1)  0.500 ms  0.499 ms  0.509 ms
 3  211.151.224.90 (211.151.224.90)  0.637 ms  0.631 ms  0.641 ms
 4  * * *
 5  220.181.70.98 (220.181.70.98)  5.050 ms  5.313 ms  5.596 ms
 6  220.181.17.94 (220.181.17.94)  1.665 ms !X * *
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>5）把探测包的个数设置为值4</p>
<div><pre><code># traceroute -q 4 www.baidu.com
traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets
 1  211.151.74.2 (211.151.74.2)  40.633 ms  40.819 ms  41.004 ms  41.188 ms
 2  211.151.56.57 (211.151.56.57)  0.637 ms  0.633 ms  0.627 ms  0.619 ms
 3  211.151.227.206 (211.151.227.206)  0.505 ms  0.580 ms  0.571 ms  0.569 ms
 4  210.77.139.145 (210.77.139.145)  0.753 ms  0.800 ms  0.853 ms  0.904 ms
 5  202.106.42.101 (202.106.42.101)  7.449 ms  7.543 ms  7.738 ms  7.893 ms
 6  61.148.154.97 (61.148.154.97)  316.817 ms bt-228-025.bta.net.cn (202.106.228.25)  3.695 ms  3.672 ms *
 7  124.65.58.213 (124.65.58.213)  3.056 ms  2.993 ms  2.960 ms 61.148.146.29 (61.148.146.29)  2.837 ms
 8  61.148.3.34 (61.148.3.34)  2.179 ms  2.295 ms  2.442 ms 202.106.35.190 (202.106.35.190)  7.136 ms
 9  * * * *
30  * * * *
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>6）绕过正常的路由表，直接发送到网络相连的主机</p>
<div><pre><code># traceroute -r www.baidu.com
traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets
connect: 网络不可达
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>7）把对外发探测包的等待响应时间设置为3秒</p>
<div><pre><code># traceroute -w 3 www.baidu.com
traceroute to www.baidu.com (61.135.169.105), 30 hops max, 40 byte packets
 1  211.151.74.2 (211.151.74.2)  2.306 ms  2.469 ms  2.650 ms
 2  211.151.56.1 (211.151.56.1)  0.621 ms  0.613 ms  0.603 ms
 3  211.151.227.206 (211.151.227.206)  0.557 ms  0.560 ms  0.552 ms
 4  210.77.139.145 (210.77.139.145)  0.708 ms  0.761 ms  0.817 ms
 5  202.106.42.101 (202.106.42.101)  7.520 ms  7.774 ms  7.902 ms
 6  bt-228-025.bta.net.cn (202.106.228.25)  2.890 ms  2.369 ms 61.148.154.97 (61.148.154.97)  471.961 ms
 7  124.65.58.221 (124.65.58.221)  4.490 ms  4.483 ms  4.472 ms
 8  123.126.6.198 (123.126.6.198)  2.948 ms 61.148.156.6 (61.148.156.6)  7.688 ms  7.756 ms
 9  * * *
30  * * *
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>说明：</p>
<p>Traceroute的工作原理：</p>
<p>Traceroute最简单的基本用法是：traceroute hostname</p>
<p>Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器...... traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？</p>
<p>Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。</p>
<p>Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。</p>
<p>windows之tracert:</p>
<p>格式：</p>
<p>​	tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name</p>
<p>参数说明：</p>
<p>tracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name</p>
<p>该诊断实用程序通过向目的地发送具有不同生存时间 (TL) 的 Internet 控制信息协议 (CMP) 回应报文，以确定至目的地的路由。路径上的每个路由器都要在转发该 ICMP 回应报文之前将其 TTL 值至少减 1，因此 TTL 是有效的跳转计数。当报文的 TTL 值减少到 0 时，路由器向源系统发回 ICMP 超时信息。通过发送 TTL 为 1 的第一个回应报文并且在随后的发送中每次将 TTL 值加 1，直到目标响应或达到最大 TTL 值，Tracert 可以确定路由。通过检查中间路由器发发回的 ICMP 超时 (ime Exceeded) 信息，可以确定路由器。注意，有些路由器“安静”地丢弃生存时间 (TLS) 过期的报文并且对 tracert 无效。</p>
<p>参数：</p>
<p>-d 指定不对计算机名解析地址。</p>
<p>-h maximum_hops 指定查找目标的跳转的最大数目。</p>
<p>-jcomputer-list 指定在 computer-list 中松散源路由。</p>
<p>-w timeout 等待由 timeout 对每个应答指定的毫秒数。</p>
<p>target_name 目标计算机的名称。</p>
<p>实例：</p>
<div><pre><code>C:\Users\Administrator&gt;tracert www.58.com

Tracing route to www.58.com [221.187.111.30]
over a maximum of 30 hops:

  1     1 ms     1 ms     1 ms  10.58.156.1
  2     1 ms    &lt;1 ms    &lt;1 ms  10.10.10.1
  3     1 ms     1 ms     1 ms  211.103.193.129
  4     2 ms     2 ms     2 ms  10.255.109.129
  5     1 ms     1 ms     3 ms  124.205.98.205
  6     2 ms     2 ms     2 ms  124.205.98.253
  7     2 ms     6 ms     1 ms  202.99.1.125
  8     5 ms     6 ms     5 ms  118.186.0.113
  9   207 ms     *        *     118.186.0.106
 10     8 ms     6 ms    11 ms  124.238.226.201
 11     6 ms     7 ms     6 ms  219.148.19.177
 12    12 ms    12 ms    16 ms  219.148.18.117
 13    14 ms    17 ms    16 ms  219.148.19.125
 14    13 ms    13 ms    12 ms  202.97.80.113
 15     *        *        *     Request timed out.
 16    12 ms    12 ms    17 ms  bj141-147-82.bjtelecom.net [219.141.147.82]
 17    13 ms    13 ms    12 ms  202.97.48.2
 18     *        *        *     Request timed out.
 19    14 ms    14 ms    12 ms  221.187.224.85
 20    15 ms    13 ms    12 ms  221.187.104.2
 21     *        *        *     Request timed out.
 22    15 ms    17 ms    18 ms  221.187.111.30

Trace complete.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>参考链接：</p>
<p>http://www.cnblogs.com/peida/archive/2013/03/07/2947326.html</p>
<p>http://man.linuxde.net/traceroute</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2018-07-27T19:24:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">白天做运维，晚上搞副业赚钱</title>
    <id>https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/%E7%99%BD%E5%A4%A9%E5%81%9A%E8%BF%90%E7%BB%B4%EF%BC%8C%E6%99%9A%E4%B8%8A%E6%90%9E%E5%89%AF%E4%B8%9A%E8%B5%9A%E9%92%B1/</id>
    <link href="https://clay-wangzhi.com/other/%E5%BE%85%E6%95%B4%E7%90%86/%E7%99%BD%E5%A4%A9%E5%81%9A%E8%BF%90%E7%BB%B4%EF%BC%8C%E6%99%9A%E4%B8%8A%E6%90%9E%E5%89%AF%E4%B8%9A%E8%B5%9A%E9%92%B1/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="白天做运维-晚上搞副业赚钱"> 白天做运维，晚上搞副业赚钱</h1>
<p>作为 <code>运维工程师</code>，除了固定工作外，你有想过副业变现提升收入吗？</p>
<p>谁不想凭自己的努力赚点钱，让自己和家人过得更好呢？</p>
<h2 id="_1-送外卖-写公号-录教程"> 1 送外卖？写公号？录教程？</h2>
<p>你有对副业变现，增加收入，有深入研究么？</p>
<h3 id="_1-1-送外卖-卖血汗"> 1.1 送外卖，卖血汗？</h3>
<p>No，这个并不合适我，我第一次送外卖，就骑电动车摔了，摔了好几处伤，恢复了一个月，还把手机摔坏了，总共送了两单，赚了20元，很显然，不适合我。</p>
<h3 id="_1-2-写公众号-然后接广告"> 1.2 写公众号，然后接广告？</h3>
<p>可以，我看IT大佬<code>程序员小灰</code>说道，公众号仍然是所有自媒体中变现最好的方式，没有之一。</p>
<p>当然，可以肯定的是，想短时间内去涨粉，实在太难了！</p>
<p>我三年前，刚入<code>运维</code>行业时，写过公众号，但基本圈不了粉，后来也就没再推广过，我记得粉丝只有20人，其中大多数是我的亲戚，同学等（失败啊~~）。</p>
<h3 id="_1-3-录教程-直接卖"> 1.3 录教程，直接卖？</h3>
<p>直说吧，挑战非常大！当你立志想输出一套 NX 的课程，那你对技术的理解就不再是表层上简单应用了，比如某技术深层次实现原理、系统架构设计是否合理、是否满足高可用、高性能、高并发等特殊场景？对吧？</p>
<p>目前在线还没有这个实力~~~</p>
<h2 id="_2-如何才能更好落地-赚更多的钱"> 2 如何才能更好落地？赚更多的钱？</h2>
<p>作为运维人员，我不建议大家兼职送外卖，如果没有很深的功底，也不建议大家录教程。</p>
<p>我建议大家写公众号，<strong>要知道，写作确实是一个倒逼自己提升自己能力的很好方式！</strong></p>
<p>而且还有以下好处：</p>
<ul>
<li>沉淀自己的知识体系</li>
<li>方式自己回来查阅</li>
<li>求职加分项</li>
</ul>
<h2 id="_3-如何运营自己的公众号"> 3 如何运营自己的公众号？</h2>
<h3 id="_3-1-取个好名字"> 3.1 取个好名字</h3>
<p>要通俗易懂，而且全网ID最好统一，</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">博客主页</title>
    <id>https://clay-wangzhi.com/</id>
    <link href="https://clay-wangzhi.com/"/>
    <updated>2021-05-11T08:47:06.000Z</updated>
    <content type="html"><![CDATA[<p>相关配置文档请见 <a href="https://vuepress-theme-hope.github.io/zh/guide/layout/blog/" target="_blank" rel="noopener noreferrer">博客主页</a></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">4. 内核参数优化</title>
    <id>https://clay-wangzhi.com/web/nginx/core/</id>
    <link href="https://clay-wangzhi.com/web/nginx/core/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-内核参数优化"> 4. 内核参数优化</h1>
<h2 id="linux内核参数优化-网络模块"> linux内核参数优化（网络模块）</h2>
<p>在Linux下调整内核参数，可以直接编辑配置文件<code>/etc/sysctl.conf</code>，然后执行<code>sysctl -p</code>命令生效</p>
<p>文件内容如下：</p>
<div><pre><code>net.ipv4.ip_forward = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.default.accept_source_route = 0
kernel.sysrq = 0
kernel.core_uses_pid = 1
kernel.msgmnb = 65536
kernel.msgmax = 65536
kernel.shmmax = 68719476736
kernel.shmall = 268435456
net.core.wmem_default = 8388608
net.core.rmem_default = 8388608
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.core.somaxconn = 262144
net.core.netdev_max_backlog = 262144
net.ipv4.tcp_max_orphans = 262144
net.ipv4.tcp_max_tw_buckets = 6000
net.ipv4.tcp_tw_recycle = 0
net.ipv4.tcp_timestamps = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_syn_backlog = 30000
net.ipv4.tcp_syn_retries = 1
net.ipv4.tcp_synack_retries = 1
net.ipv4.ip_local_port_range = 1024 65000
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_keepalive_time = 30
net.ipv4.tcp_sack = 1
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_rmem = 4096 87380 4194304
net.ipv4.tcp_wmem = 4096 65536 4194304
net.ipv4.tcp_mem = 524288 699050 1048576
vm.swappiness = 0
vm.min_free_kbytes = 65536
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><ul>
<li>
<p>net.core.somaxconn = 262144</p>
<p>web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。</p>
</li>
<li>
<p>net.core.netdev_max_backlog = 262144</p>
<p>每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</p>
</li>
<li>
<p>net.ipv4.tcp_max_orphans = 262144</p>
<p>系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。</p>
</li>
<li>
<p>net.ipv4.tcp_max_tw_buckets = 6000</p>
<p>对于tcp连接，服务端和客户端通信完后状态变为timewait，假如某台服务器非常忙，连接数特别多的话，那么这个timewait数量就会越来越大。</p>
<p>毕竟它也是会占用一定的资源，所以应该有一个最大值，当超过这个值，系统就会删除最早的连接，这样始终保持在一个数量级。
这个数值就是由net.ipv4.tcp_max_tw_buckets这个参数来决定的。</p>
<p>CentOS7.6版本，默认为16384，可以使用sysctl -a |grep tw_buckets来查看它的值，可以适当把它调低，比如调整到6000，毕竟这个状态的连接太多也是会消耗资源的。</p>
<p>但不要把它调到几十、几百这样，因为这种状态的tcp连接也是有用的，如果同样的客户端再次和服务端通信，就不用再次建立新的连接了，用这个旧的通道，省时省力。</p>
</li>
<li>
<p>net.ipv4.tcp_tw_recycle = 0</p>
<p>启用TIME-WAIT状态sockets快速回收功能;用于快速减少在TIME-WAIT状态TCP连接数。1表示启用;0表示关闭。但是要特别留意的是：这个选项一般不推荐启用，因为在NAT(Network Address Translation)网络下，会导致大量的TCP连接建立错误，从而引起网站访问故障。</p>
<p>实际上，net.ipv4.tcp_tw_recycle功能的开启，要需要net.ipv4.tcp_timestamps（一般系统默认是开启这个功能的）这个开关开启后才有效果；
当tcp_tw_recycle 开启时（tcp_timestamps 同时开启，快速回收 socket 的效果达到），对于位于NAT设备后面的 Client来说，是一场灾难！
会导致到NAT设备后面的Client连接Server不稳定（有的 Client 能连接 server，有的 Client 不能连接 server）。</p>
</li>
<li>
<p>net.ipv4.tcp_tw_reuse = 1</p>
<p>开启重用功能，允许将TIME-WAIT状态的sockets重新用于新的TCP连接。这个功能启用是安全的，一般不要去改动！</p>
</li>
<li>
<p>net.ipv4.tcp_syncookies = 1</p>
<p>tcp三次握手中，客户端向服务端发起syn请求，服务端收到后，也会向客户端发起syn请求同时连带ack确认，
假如客户端发送请求后直接断开和服务端的连接，不接收服务端发起的这个请求，服务端会重试多次，
这个重试的过程会持续一段时间（通常高于30s），当这种状态的连接数量非常大时，服务器会消耗很大的资源，从而造成瘫痪，
正常的连接进不来，这种恶意的半连接行为其实叫做syn flood攻击。
设置为1，是开启SYN Cookies，开启后可以避免发生上述的syn flood攻击。
开启该参数后，服务端接收客户端的ack后，再向客户端发送ack+syn之前会要求client在短时间内回应一个序号，
如果客户端不能提供序号或者提供的序号不对则认为该客户端不合法，于是不会发ack+syn给客户端，更涉及不到重试。</p>
</li>
<li>
<p>net.ipv4.tcp_max_syn_backlog = 30000</p>
<p>该参数定义系统能接受的最大半连接状态的tcp连接数。客户端向服务端发送了syn包，服务端收到后，会记录一下，
该参数决定最多能记录几个这样的连接。在CentOS7，默认是256，当有syn flood攻击时，这个数值太小则很容易导致服务器瘫痪，
实际上此时服务器并没有消耗太多资源（cpu、内存等），所以可以适当调大它，比如调整到30000。</p>
</li>
<li>
<p>net.ipv4.tcp_syn_retries = 1</p>
<p>该参数适用于客户端，它定义发起syn的最大重试次数，默认为6，建议改为1。</p>
</li>
<li>
<p>net.ipv4.tcp_synack_retries = 1</p>
<p>该参数适用于服务端，它定义发起syn+ack的最大重试次数，默认为5，建议改为1，可以适当预防syn flood攻击。</p>
</li>
<li>
<p>net.ipv4.ip_local_port_range = 1024 65000</p>
<p>该参数定义端口范围，系统默认保留端口为1024及以下，以上部分为自定义端口。这个参数适用于客户端，
当客户端和服务端建立连接时，比如说访问服务端的80端口，客户端随机开启了一个端口和服务端发起连接，
这个参数定义随机端口的范围。默认为32768 61000，建议调整为1025 65000。</p>
</li>
<li>
<p>net.ipv4.tcp_fin_timeout = 30</p>
<p>如果套接字由本端要求关闭，这个参数 决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。</p>
</li>
<li>
<p>net.ipv4.tcp_keepalive_time = 30</p>
<p>tcp连接状态里，有一个是established状态，只有在这个状态下，客户端和服务端才能通信。正常情况下，当通信完毕，
客户端或服务端会告诉对方要关闭连接，此时状态就会变为timewait，如果客户端没有告诉服务端，
并且服务端也没有告诉客户端关闭的话（例如，客户端那边断网了），此时需要该参数来判定。
比如客户端已经断网了，但服务端上本次连接的状态依然是established，服务端为了确认客户端是否断网，
就需要每隔一段时间去发一个探测包去确认一下看看对方是否在线。这个时间就由该参数决定。它的默认值为7200秒，建议设置为30秒。</p>
</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">3. nginx配置文件详解</title>
    <id>https://clay-wangzhi.com/web/nginx/config/</id>
    <link href="https://clay-wangzhi.com/web/nginx/config/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_3-nginx配置文件详解"> 3. nginx配置文件详解</h1>
<p>配置文件详解</p>
<div><pre><code><span>user</span> nginx<span>;</span>
<span>worker_processes</span>  <span>8</span><span>;</span>
<span>worker_cpu_affinity</span> auto<span>;</span>
<span>#worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;</span>
<span>error_log</span>  <span>/</span>var<span>/</span>log<span>/</span>nginx<span>/</span>error<span>.</span>log  error<span>;</span>
<span>pid</span>        <span>/</span>var<span>/</span>run<span>/</span>nginx<span>.</span><span>pid</span><span>;</span>
<span>worker_rlimit_nofile</span> <span>65535</span><span>;</span>

<span>events</span> <span>{</span>
    <span>use</span> epoll<span>;</span>
    <span>worker_connections</span>  <span>20480</span><span>;</span>
<span>}</span>

<span>http</span> <span>{</span>
    <span>include</span>       mime<span>.</span><span>types</span><span>;</span>
    <span>default_type</span>  application<span>/</span>octet<span>-</span>stream<span>;</span>
    <span>log_format</span>  prod <span>'$remote_addr|$remote_user|[$time_local]|$request|'</span>
                     <span>'$status|$body_bytes_sent|$http_referer|'</span>
                     <span>'$http_user_agent|$request_time|$host|$upstream_addr|$upstream_response_time'</span><span>;</span>
    
    <span>access_log</span>  <span>/</span>var<span>/</span>log<span>/</span>nginx<span>/</span>access<span>.</span>log  prod<span>;</span>
    
    <span>charset</span>  utf<span>-</span><span>8</span><span>;</span>
    <span>fastcgi_intercept_errors</span> on<span>;</span>
    <span>server_names_hash_bucket_size</span> <span>256</span><span>;</span>
    <span>client_header_buffer_size</span> <span>32</span>k<span>;</span>
    <span>large_client_header_buffers</span> <span>4</span> <span>128</span>k<span>;</span>

    <span>server_tokens</span> off<span>;</span>
    <span>sendfile</span> on<span>;</span>
    <span>tcp_nopush</span> on<span>;</span>
    <span>tcp_nodelay</span> on<span>;</span>
    <span>#支持ssi包含文件</span>
    <span>ssi</span> on<span>;</span>
    <span>ssi_silent_errors</span> on<span>;</span>
<span>#   ssi_types text/html;</span>

    <span>keepalive_timeout</span>  <span>90</span><span>;</span>
    <span>client_header_timeout</span> <span>10</span><span>;</span>
    <span>client_body_timeout</span> <span>20</span><span>;</span>
    
    <span>client_max_body_size</span> <span>200</span>m<span>;</span>
    <span>client_body_buffer_size</span>  <span>128</span>k<span>;</span>

    <span># include /etc/nginx/gzip.conf;</span>
    <span>gzip</span> on<span>;</span>
	<span>gzip_buffers</span> <span>4</span> <span>8</span>k<span>;</span>
	<span>gzip_comp_level</span> <span>6</span><span>;</span>
	<span>gzip_disable</span> <span>"MSIE [1-6]\."</span><span>;</span>
	<span>gzip_http_version</span> <span>1.1</span><span>;</span>
	<span>gzip_min_length</span> <span>1000</span><span>;</span>
	<span>gzip_proxied</span> any<span>;</span>
	<span>gzip_vary</span> on<span>;</span>
	<span>gzip_types</span> text<span>/</span>plain text<span>/</span>css application<span>/</span>javascript application<span>/</span>x<span>-</span>javascript text<span>/</span>xml application<span>/</span>xml application<span>/</span>xml<span>+</span>rss text<span>/</span>javascript application<span>/</span>json image<span>/</span>jpeg image<span>/</span>gif image<span>/</span>png image<span>/</span>jpg<span>;</span>
    

    <span># include /etc/nginx/proxy.conf;</span>
    <span>proxy_connect_timeout</span> <span>90</span><span>;</span>
	<span>proxy_read_timeout</span> <span>90</span><span>;</span>
	<span>proxy_send_timeout</span> <span>90</span><span>;</span>
	<span>proxy_buffer_size</span> <span>32</span>k<span>;</span>
	<span>proxy_buffers</span> <span>4</span> <span>64</span>k<span>;</span>
	<span>proxy_busy_buffers_size</span> <span>128</span>k<span>;</span>
    
    
    <span># include /etc/nginx/backend.conf;</span>
    <span>upstream</span> my_server_pool <span>{</span>
        <span>server</span> <span>192.168</span><span>.1</span><span>.109</span><span>:</span><span>80</span> weight<span>=</span><span>1</span> max_fails<span>=</span><span>2</span> fail_timeout<span>=</span><span>30</span><span>;</span>
        <span>server</span> <span>192.168</span><span>.1</span><span>.108</span><span>:</span><span>80</span> weight<span>=</span><span>2</span> max_fails<span>=</span><span>2</span> fail_timeout<span>=</span><span>30</span><span>;</span>
    <span>}</span>
    
    <span>include</span> <span>/</span>etc<span>/</span>nginx<span>/</span>conf<span>.</span>d<span>/</span>h5<span>.</span>conf<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br></div></div><h2 id="_1-样例文件解释"> 1 样例文件解释</h2>
<div><pre><code><span>http</span> <span>{</span>
    <span># 引入文件 mime.types，是一个文件扩展名与文件类型的映射表</span>
    <span>include</span>       mime<span>.</span><span>types</span><span>;</span>
    <span># 指定默认MIME类型为二进制字节流(即下载文件)  </span>
    <span>default_type</span>  application<span>/</span>octet<span>-</span>stream<span>;</span>
    <span># 定义输出日志的格式</span>
    <span># 1.$remote_addr 与$http_x_forwarded_for(反向代理服务器) 用以记录客户端的ip地址；</span>
    <span># 2.$remote_user ：用来记录客户端用户名称；</span>
    <span># 3.$time_local ：用来记录访问时间与时区；</span>
    <span># 4.$request  ：用来记录请求的url与http协议</span>
    <span># 5.$status ：用来记录请求状态； </span>
    <span># 6.$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span>
    <span># 7.$http_referer ：用来记录从那个页面链接访问过来的；</span>
    <span># 8.$http_user_agent ：记录客户端浏览器的相关信息</span>
    <span># 9.$request_time ：整个请求的总时间</span>
    <span># 10.$host变量的值按照如下优先级获得：请求行中的host.请求头中的Host头部.与一条请求匹配的server name.</span>
    <span># 11.$upstream_addr ：后台upstream的地址，即真正提供服务的主机地址，如10.10.10.100:80</span>
    <span># 12.$upstream_response_time ：请求过程中，upstream响应时间    </span>
    <span>log_format</span>  main  <span>'$remote_addr - $remote_user [$time_local] "$request" '</span>
                      <span>'$status $body_bytes_sent "$http_referer" '</span>
                      <span>'"$http_user_agent" "$http_x_forwarded_for"'</span><span>;</span>

    <span>log_format</span>  prod <span>'$remote_addr|$remote_user|[$time_local]|$request|'</span>
                     <span>'$status|$body_bytes_sent|$http_referer|'</span>
                     <span>'$http_user_agent|$request_time|$host|$upstream_addr|$upstream_response_time'</span><span>;</span>
    
    <span># 指定access_log的存放路径、格式和缓存大小</span>
    <span>access_log</span>  <span>/</span>var<span>/</span>log<span>/</span>nginx<span>/</span>access<span>.</span>log  prod<span>;</span>
    
    <span># 指定编码格式，若网页格式与此不同，将被自动转码</span>
    <span>charset</span>  utf<span>-</span><span>8</span><span>;</span>
    <span># 允许nginx使用error_page处理错误信息，传递4xx和5xx错误信息到客户端</span>
    <span>fastcgi_intercept_errors</span> on<span>;</span>
    
    <span>server_names_hash_bucket_size</span> <span>256</span><span>;</span>
    <span>client_header_buffer_size</span> <span>32</span>k<span>;</span>
    <span>large_client_header_buffers</span> <span>4</span> <span>128</span>k<span>;</span>
    
    <span>#定义白名单ip列表变量</span>
	<span>geo</span> <span>$whiteip_list</span> <span>{</span>     
    	default <span>1</span><span>;</span>
    	<span>127.0</span><span>.0</span><span>.1</span> <span>0</span><span>;</span>
    	<span>192.168</span><span>.0</span><span>.167</span> <span>0</span><span>;</span>
    	<span>192.168</span><span>.0</span><span>.48</span> <span>0</span><span>;</span>
	<span>}</span>

	<span>#用map指令映射将白名单列表中客户端请求ip为空串 </span>
	<span>map</span> <span>$whiteip_list</span> <span>$limit</span> <span>{</span>
    	<span>1</span> <span>$binary_remote_addr</span><span>;</span>
    	<span>0</span> <span>""</span><span>;</span>
	<span>}</span>
    

	<span>#当某个IP访问example.com这个域名时，此IP得并发连接超过10，则会报503（Service Temporarily Unavailable），</span>
	<span>#表示服务暂时不可用，此时会返回给用户我们事先定义好错误页面。由“limit_conn conn_ip 10;”实现。</span>
	<span>limit_conn_zone</span> <span>$limit</span> zone<span>=</span>conn_ip<span>:</span><span>10</span>m<span>;</span>
	<span>#当访问example.com这个域名的连接总数超过1000时，同样会报503，返回定义好的错误页面。</span>
	<span>#由“limit_conn conn_server 1000;”实现</span>
	<span>limit_conn_zone</span> <span>$limit</span> zone<span>=</span>conn_server<span>:</span><span>10</span>m<span>;</span>
	<span>#当达到最大限制连接数后，记录日志的等级</span>
	<span>limit_conn_log_level</span> info<span>;</span>  <span>#[info | notice | warn | error(默认)]</span>
	<span>#当超过限制时，返回的状态码（默认是503），code值只能设置在400到599之间</span>
	limit_conn_status <span>503</span><span>;</span>

	<span>#利用令牌桶原理，来限制用户的连接频率</span>
	<span>#rate每个IP平均处理的请求频率为每秒一次，此值可以设置成每秒处理请求数或者每分钟处理请求数，但必须是整数。</span>
	<span>#所以如果你需要指定每秒处理少于1个的请求，2秒处理一个请求，可以使用 “30r/m”。</span>
	<span>limit_req_zone</span>  <span>$limit</span> zone<span>=</span>req_ip<span>:</span><span>10</span>m rate<span>=</span><span>10</span>r<span>/</span>s<span>;</span>

    <span># 用户认证</span>
    <span># yum install httpd-tools               #适用centos</span>
    <span># sudo apt-get install apache2-utils    #适用ubuntu</span>
    <span># 生成用户密码文件</span>
    <span># htpasswd -c /data/.htpasswd user1 </span>
    <span>auth_basic</span>  <span>"User Login"</span><span>;</span>
    <span>auth_basic_user_file</span>  <span>/</span>data<span>/</span><span>.</span>htpasswd<span>;</span>

    <span># 隐藏nginx版本号</span>
    <span>server_tokens</span> off<span>;</span>
     <span># sendfile 指令用于指定 Nginx 是否调用Linux 的 sendfile 函数（zero copy 方式）来输出文件，提高文件传输效率 </span>
    <span>sendfile</span> on<span>;</span>
    <span># 告诉nginx在一个数据包里发送所有头文件，而不一个接一个的发送。就是说数据包不会马上传送出去，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞。</span>
    <span>tcp_nopush</span> on<span>;</span>
    <span># 不缓存data-sends（关闭 Nagle 算法），这个能够提高高频发送小数据报文的实时性</span>
    <span>tcp_nodelay</span> on<span>;</span>
    <span>#支持ssi包含文件</span>
    <span>ssi</span> on<span>;</span>
    <span>ssi_silent_errors</span> on<span>;</span>
<span>#   ssi_types text/html;</span>
    
    <span># 启用目录浏览</span>
    <span># autoindex on;</span>
    <span># 显示出文件的确切／大概大小：on确切大小，单位是bytes；off大概大小，单位是kB或者MB或者GB</span>
    <span># autoindex_exact_size off;</span>
    <span># off显示的文件时间为GMT时间，on显示的文件时间为文件的服务器时间</span>
    <span># autoindex_localtime on; </span>

     <span># 指定客户端连接保持活动的超时时间（单位：秒），超过时间，服务器会关闭连接,太短或者太长都不一定合适，当然，最好是根据业务自身的情况来动态地调整该参数</span>
    <span>keepalive_timeout</span>  <span>90</span><span>;</span>
    <span># 客户端向服务端发送一个完整的 request header 的超时时间。如果客户端在指定时间内没有发送一个完整的 request header，Nginx 返回 HTTP 408（Request Timed Out）。</span>
    <span>client_header_timeout</span> <span>10</span><span>;</span>
    <span># 指定客户端与服务端建立连接后发送 request body 的超时时间。如果客户端在指定时间内没有发送任何内容，Nginx 返回 HTTP 408（Request Timed Out）。</span>
    <span>client_body_timeout</span> <span>20</span><span>;</span>

    <span># 客户端请求单个文件的最大字节数,这个参数的设置限制了上传文件的大小。</span>
    <span>client_max_body_size</span> <span>200</span>m<span>;</span>
    <span># 当客户端以POST方法提交一些数据到服务端时，会先写入到client_body_buffer中，如果buffer写满会写到临时文件里，建议调整为128k</span>
    <span>client_body_buffer_size</span>  <span>128</span>k<span>;</span>
    

    <span>#利用令牌桶原理，来限制用户的连接频率</span>
	<span>#rate每个IP平均处理的请求频率为每秒一次，此值可以设置成每秒处理请求数或者每分钟处理请求数，但必须是整数。</span>
	<span>#所以如果你需要指定每秒处理少于1个的请求，2秒处理一个请求，可以使用 “30r/m”。</span>
    <span>limit_req_zone</span> <span>$binary_remote_addr</span> zone<span>=</span>one<span>:</span><span>10</span>m rate<span>=</span><span>10000</span>r<span>/</span>s<span>;</span>
    <span>limit_conn_zone</span> <span>$binary_remote_addr</span> zone<span>=</span>addr<span>:</span><span>10</span>m<span>;</span>
    
    <span># include /etc/nginx/gzip.conf;</span>
    <span>gzip</span> on<span>;</span>
	<span>gzip_buffers</span> <span>4</span> <span>8</span>k<span>;</span>
	<span>gzip_comp_level</span> <span>6</span><span>;</span>
	<span>gzip_disable</span> <span>"MSIE [1-6]\."</span><span>;</span>
	<span>gzip_http_version</span> <span>1.1</span><span>;</span>
	<span>gzip_min_length</span> <span>1000</span><span>;</span>
	<span>gzip_proxied</span> any<span>;</span>
	<span>gzip_vary</span> on<span>;</span>
	<span>gzip_types</span> text<span>/</span>plain text<span>/</span>css application<span>/</span>javascript application<span>/</span>x<span>-</span>javascript text<span>/</span>xml application<span>/</span>xml application<span>/</span>xml<span>+</span>rss text<span>/</span>javascript application<span>/</span>json image<span>/</span>jpeg image<span>/</span>gif image<span>/</span>png image<span>/</span>jpg<span>;</span>

    <span>#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。</span>
    <span>fastcgi_connect_timeout</span> <span>300</span><span>;</span>
    <span>fastcgi_send_timeout</span> <span>300</span><span>;</span>
    <span>fastcgi_read_timeout</span> <span>300</span><span>;</span>
    <span>fastcgi_buffer_size</span> <span>64</span>k<span>;</span>
    <span>fastcgi_buffers</span> <span>4</span> <span>64</span>k<span>;</span>
    <span>fastcgi_busy_buffers_size</span> <span>128</span>k<span>;</span>
    <span>fastcgi_temp_file_write_size</span> <span>128</span>k<span>;</span>

    <span># include /etc/nginx/proxy.conf;</span>
    <span>#反向代理</span>
    <span># nginx跟后端服务器连接超时时间(代理连接超时)</span>
	<span>proxy_connect_timeout</span> <span>90</span><span>;</span>
    <span># 连接成功后，后端服务器响应时间(代理接收超时)</span>
	<span>proxy_read_timeout</span> <span>90</span><span>;</span>
    <span># 后端服务器数据回传时间(代理发送超时)</span>
	<span>proxy_send_timeout</span> <span>90</span><span>;</span>
    <span># 设置代理服务器（nginx）保存用户头信息的缓冲区大小</span>
	<span>proxy_buffer_size</span> <span>32</span>k<span>;</span>
    <span># proxy_buffers缓冲区</span>
	<span>proxy_buffers</span> <span>4</span> <span>64</span>k<span>;</span>
    <span># 高负荷下缓冲大小（proxy_buffers*2）</span>
	<span>proxy_busy_buffers_size</span> <span>128</span>k<span>;</span>
    <span># 设定缓存文件夹大小，大于这个值，将从upstream服务器传</span>
    <span>proxy_temp_file_write_size</span> <span>64</span>k<span>;</span>
    
    
    <span>#反向代理缓存目录</span>
    <span>proxy_cache_path</span> <span>/</span>data<span>/</span><span>proxy</span><span>/</span>cache levels<span>=</span><span>1</span><span>:</span><span>2</span> keys_zone<span>=</span>cache_one<span>:</span><span>500</span>m inactive<span>=</span><span>1</span>d max_size<span>=</span><span>1</span>g<span>;</span>
    <span>#levels=1:2 设置目录深度，第一层目录是1个字符，第2层是2个字符</span>
    <span>#keys_zone:设置web缓存名称和内存缓存空间大小</span>
    <span>#inactive:自动清除缓存文件时间。</span>
    <span>#max_size:硬盘空间最大可使用值。</span>
    <span>#指定临时缓存文件的存储路径(路径需和上面路径在同一分区)</span>
    <span>proxy_temp_path</span> <span>/</span>data<span>/</span><span>proxy</span><span>/</span>temp

    <span># include /etc/nginx/backend.conf;  </span>
    <span># 负载均衡服务器池</span>
    <span>upstream</span> my_server_pool <span>{</span>
        <span>#调度算法</span>
        <span>#1.轮循（默认）（weight轮循权值）</span>
        <span>#2.ip_hash：根据每个请求访问IP的hash结果分配。（会话保持）</span>
        <span>#3.fair:根据后端服务器响应时间最短请求。（upstream_fair模块）</span>
        <span>#4.url_hash:根据访问的url的hash结果分配。（需hash软件包）</span>
        <span>#参数：</span>
        <span>#down：表示不参与负载均衡</span>
        <span>#backup:备份服务器</span>
        <span>#max_fails:允许最大请求错误次数</span>
        <span>#fail_timeout:请求失败后暂停服务时间。</span>
        <span>server</span> <span>192.168</span><span>.1</span><span>.109</span><span>:</span><span>80</span> weight<span>=</span><span>1</span> max_fails<span>=</span><span>2</span> fail_timeout<span>=</span><span>30</span><span>;</span>
        <span>server</span> <span>192.168</span><span>.1</span><span>.108</span><span>:</span><span>80</span> weight<span>=</span><span>2</span> max_fails<span>=</span><span>2</span> fail_timeout<span>=</span><span>30</span><span>;</span>
    <span>}</span>
    
    <span># 指明包含进来的其他配置文件</span>
    <span>include</span> <span>/</span>etc<span>/</span>nginx<span>/</span>conf<span>.</span>d<span>/</span>h5<span>.</span>conf<span>;</span>
    <span># 虚拟主机定义</span>
    <span>server</span> <span>{</span>
        <span># 监听端口</span>
        <span>listen</span>       <span>80</span><span>;</span> 
        <span>#listen     443;</span>
        <span># 访问域名</span>
        <span>server_name</span>  example<span>.</span>com<span>;</span>

        <span># 编码格式，若网页格式与此不同，将被自动转码</span>
        <span>#charset utf-8;</span>

        <span># 虚拟主机访问日志定义</span>
        <span>#access_log  logs/host.access.log  main;</span>

        <span># 申请的证书zip包中一般含有如下三个文件：</span>
        <span># SSL 凭证(例如: ssl_certificate.crt,或称最终实体凭证, 公钥凭证或身份验证凭证)</span>
        <span># 中继CA凭证(例如: IntermediateCA.crt, 或称信任链凭证或SSL凭证的签名者/发行人)</span>
        <span># 私钥文件(例如: private.key, 生成凭证签章要求(CSR)的时候建立的)</span>
        <span>#</span>
        <span># nginx的配置特殊地方: 需要合并SSL凭证和中继CA凭证, 即:</span>
        <span>#   cat ssl_certificate.crt IntermediateCA.crt >> your_domain_name.crt</span>
        <span># 注意：-----END CERTIFICATE----------BEGIN CERTIFICATE-----需要调整为：</span>
        <span>#   -----END CERTIFICATE-----</span>
        <span>#   -----BEGIN CERTIFICATE-----</span>
        <span># 否则启动时出错，即SSL: error:0906D066:PEM routines:PEM_read_bio:bad end line</span>
        <span>#</span>
        <span>ssl</span> on<span>;</span>  
        <span>#虚拟主机的证书文件  </span>
        <span>ssl_certificate</span> <span>/</span>etc<span>/</span><span>ssl</span><span>/</span>your_domain_name<span>.</span>crt<span>;</span> <span>#合并SSL凭证和中继CA凭证的文件</span>
        <span>#虚拟主机私钥文件  </span>
        <span>ssl_certificate_key</span> <span>/</span>etc<span>/</span><span>ssl</span><span>/</span>your_domain_name<span>.</span>key<span>;</span> <span>#私钥文件</span>
        <span># 支持ssl协议版本</span>
        <span>ssl_protocols</span> TLSv1 TLSv1<span>.</span><span>1</span> TLSv1<span>.</span><span>2</span><span>;</span>
        <span># 客户端一侧的连接可以复用ssl session cache中缓存 的ssl参数的有效时长；</span>
		<span>ssl_session_timeout</span> <span>5</span>m<span>;</span>
        <span># 指定支持加密算法；</span>
        <span>ssl_ciphers</span> AESGCM<span>:</span>ALL<span>:</span><span>!</span>DH<span>:</span><span>!</span>EXPORT<span>:</span><span>!</span>RC4<span>:</span><span>+</span>HIGH<span>:</span><span>!</span>MEDIUM<span>:</span><span>!</span>LOW<span>:</span><span>!</span>aNULL<span>:</span><span>!</span>eNULL<span>;</span>
        <span># 服务端倾向使用的加密算法；</span>
   		<span>ssl_prefer_server_ciphers</span> on<span>;</span>



        <span># 匹配URL</span>
        <span>location</span> <span>/</span> <span>{</span>
            <span># 定义默认网站根目录位置</span>
            <span>root</span>   html<span>;</span>
            <span># 定义首页索引文件的名称，按以下顺序匹配</span>
            <span>index</span>  <span>index</span><span>.</span>html <span>index</span><span>.</span>htm <span>index</span><span>.</span>php<span>;</span>

            <span>#反向代理缓存设置命令(proxy_cache zone|off,默认关闭所以要设置)</span>
            <span>proxy_cache</span> cache_one<span>;</span>
            <span>#对不同的状态码缓存不同时间</span>
            <span>proxy_cache_valid</span> <span>200</span> <span>304</span> <span>12</span>h<span>;</span>
            <span>#设置以什么样参数获取缓存文件名</span>
            <span>proxy_cache_key</span> <span>$host</span><span>$uri</span><span>$is_args</span><span>$args</span><span>;</span>
            <span>#后7端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span>
            <span>proxy_set_header</span> Host <span>$host</span><span>;</span>
            <span>proxy_set_header</span> X<span>-</span>Real<span>-</span>IP <span>$remote_addr</span><span>;</span> 
            <span>proxy_set_header</span> X<span>-</span>Forwarded<span>-</span>For <span>$proxy_add_x_forwarded_for</span><span>;</span>
            <span>#nginx反向代理隐藏响应头，多个代理情况下也可以写到http段里面</span>
            <span>proxy_hide_header</span> X<span>-</span>Application<span>-</span>Context<span>;</span>
            <span>#代理设置</span>
            <span>proxy_pass</span>   <span>http</span><span>:</span><span>/</span><span>/</span>my_server_pool<span>;</span> 
            <span>#文件过期时间控制</span>
            <span>expires</span>    <span>1</span>d<span>;</span>

            <span>#限制某个IP来源的连接并发数，此处为10个</span>
            <span>limit_conn</span> conn_ip <span>10</span><span>;</span>
            <span>#限制某个虚拟服务器的总连接数，此处为1000个</span>
            <span>limit_conn</span> conn_server <span>1000</span><span>;</span>
            <span>#限制带宽, 每个连接只允许最大5kb/s的速度进行下载</span>
            <span>limit_rate</span> <span>5</span>k<span>;</span>

            <span>#burst=5这个配置的意思是设置一个大小为5的缓冲区，当有大量请求（爆发）过来时，</span>
            <span>#超过了访问频次限制的请求可以先放到这个缓冲区内，如果此缓冲区也满了则会返回503</span>
            <span>#nodelay 如果设置此参数，超过访问频次而且缓冲区也满了的时候就会直接返回503，如果没有设置，则所有请求会等待排队</span>
            <span>limit_req</span> zone<span>=</span>req_ip burst<span>=</span><span>5</span><span>;</span>
            <span>#limit_req zone=req_ip burst=5 nodelay;</span>
        <span>}</span>

        <span>location</span> <span>/</span>download <span>{</span>
            <span>#限制IP访问</span>
            <span>deny</span> <span>192.168</span><span>.0</span><span>.2</span>；
            <span>allow</span> <span>192.168</span><span>.0</span><span>.0</span><span>/</span><span>24</span><span>;</span>
            <span>allow</span> <span>192.168</span><span>.1</span><span>.1</span><span>;</span>
            <span>deny</span> all<span>;</span>
        <span>}</span>

        <span>#静态文件，nginx自己处理</span>
        <span>location</span> <span>~</span> <span>^</span><span>/</span><span>(</span>images<span>|</span>javascript<span>|</span>js<span>|</span>css<span>|</span>flash<span>|</span>media<span>|</span>static<span>)</span><span>/</span> <span>{</span>
            <span>access_log</span> off<span>;</span>  <span>#关闭access_log，即不记录访问日志</span>
            <span>#过期30天，静态文件不怎么更新，过期可以设大一点，</span>
            <span>#如果频繁更新，则可以设置得小一点。</span>
            <span>expires</span> <span>30</span>d<span>;</span>
        <span>}</span>

        <span># 发生 404 错误时返回 404.html页面</span>
        <span>#error_page  404              /404.html;</span>

        <span># redirect server error pages to the static page /50x.html</span>
        <span>#</span>
        <span># 发生 50x 错误时使用 50x.html</span>
        <span>error_page</span>   <span>500</span> <span>502</span> <span>503</span> <span>504</span>  <span>/</span><span>50</span>x<span>.</span>html<span>;</span>
        <span>location</span> <span>=</span> <span>/</span><span>50</span>x<span>.</span>html <span>{</span>
            <span>root</span>   html<span>;</span>
        <span>}</span>

        <span># 将 PHP 脚本请求全部转发给 FastCGI（127.0.0.1:9000）处理</span>
        <span># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span>
        <span>#</span>
        <span>location</span> <span>~</span> \<span>.</span>php$ <span>{</span>
            <span>fastcgi_pass</span>   <span>127.0</span><span>.0</span><span>.1</span><span>:</span><span>9000</span><span>;</span>
            <span>fastcgi_index</span>  <span>index</span><span>.</span>php<span>;</span>
            <span>fastcgi_param</span>  SCRIPT_FILENAME  <span>$document_root</span><span>$fastcgi_script_name</span><span>;</span>
            <span># 引入文件，fastcgi的默认配置参数</span>
            <span>include</span>        fastcgi_params<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br></div></div><h2 id="_2-全局变量"> 2 全局变量</h2>
<div><pre><code>$args ： #这个变量等于请求行中的参数，同$query_string
$content_length ： 请求头中的Content-length字段。
$content_type ： 请求头中的Content-Type字段。
$document_root ： 当前请求在root指令中指定的值。
$host ： 请求主机头字段，否则为服务器名称。
$http_user_agent ： 客户端agent信息
$http_cookie ： 客户端cookie信息
$limit_rate ： 这个变量可以限制连接速率。
$request_method ： 客户端请求的动作，通常为GET或POST。
$remote_addr ： 客户端的IP地址。
$remote_port ： 客户端的端口。
$remote_user ： 已经经过Auth Basic Module验证的用户名。
$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。
$scheme ： HTTP方法（如http，https）。
$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。
$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。
$server_name ： 服务器名称。
$server_port ： 请求到达服务器的端口号。
$request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。
$uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。
$document_uri ： 与$uri相同。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>
<p>参考链接：</p>
<p>https://jasonhzy.github.io/2017/09/03/nginx/</p>
<p>https://blog.csdn.net/tzy233/article/details/79780444</p>
<p>https://blog.csdn.net/Powerful_Fy/article/details/102845921</p>
<p>https://www.linuxidc.com/Linux/2018-01/150100.htm</p>
<p>https://www.jianshu.com/p/73e2cd39722c</p>
<p>https://www.cnblogs.com/my_life/articles/7070805.html</p>
<p>https://www.jianshu.com/nb/27610173</p>
<p>http://nginx.org/en/docs/http/ngx_http_core_module.html#variables</p>
<p>http://nginx.org/en/docs/</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">6.1 Nginx出现403 forbidden的三种原因</title>
    <id>https://clay-wangzhi.com/web/nginx/forbidden/</id>
    <link href="https://clay-wangzhi.com/web/nginx/forbidden/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_6-1-nginx出现403-forbidden的三种原因"> 6.1 Nginx出现403 forbidden的三种原因</h1>
<p>引起<code>nginx 403 forbidden</code>通常是三种情况：一是缺少主页文件，二是权限问题，三是<code>SELinux</code>状态。</p>
<h2 id="缺少主页文件"> 缺少主页文件</h2>
<div><pre><code><span>server</span> <span>{</span>
    <span>listen</span> <span>80</span><span>;</span>
    <span>server_name</span> localhost<span>;</span>
    <span>index</span> <span>index</span><span>.</span>php <span>index</span><span>.</span>html<span>;</span>
    <span># index index.html index.htm;</span>
    <span>root</span> <span>/</span>clay<span>/</span>clay1<span>/</span>clay2<span>/</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果在<code>/clay/clay1/clay2/</code>下面没有<code>index.php</code>或<code>index.html</code>的时候，直接文件，会报403 forbidden。</p>
<blockquote>
<p>当index文件问<code>index.html</code>时，index指令可以省略不写</p>
</blockquote>
<h2 id="权限问题"> 权限问题</h2>
<p>主要原因是<code>nginx</code>启动用户没有，查看主页文件的权限</p>
<p>1）查看<code>nginx</code>启动用户</p>
<div><pre><code><span>ps</span> aux <span>|</span> <span>grep</span> <span>"nginx: worker process"</span> <span>|</span> <span>grep</span> -v <span>"grep"</span> <span>|</span> <span>awk</span> <span>'{ print <span>$1</span> }'</span>
</code></pre>
<div><span>1</span><br></div></div><p>2）查看主页文件权限及递归查看主页文件所在目录权限</p>
<ul>
<li>
<p>主页文件，<code>nginx</code>启动用户要有<code>r</code>权限，读取文件内容的权限</p>
</li>
<li>
<p>递归主页所在的目录，<code>nginx</code>启动用户要有<code>x</code>权限，可以访问目录的内容</p>
<blockquote>
<p>递归目录在上述配置文件中是指<code>/clay/</code>、<code>/clay/clay1/</code>、<code>/clay/clay1/clay2/</code>这三个目录</p>
</blockquote>
</li>
</ul>
<h2 id="selinux为开启状态-enabled"> <code>SELinux</code>为开启状态(enabled)</h2>
<p>1）查看当前<code>selinux</code>的状态</p>
<div><pre><code>/usr/sbin/sestatus 
</code></pre>
<div><span>1</span><br></div></div><p>2）将<code>SELINUX=enforcing</code> 修改为 <code>SELINUX=disabled</code> 状态</p>
<div><pre><code><span>vi</span> /etc/selinux/config

<span>#SELINUX=enforcing</span>
<span>SELINUX</span><span>=</span>disabled
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>3）重启生效</p>
<div><pre><code><span>reboot</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">2. nginx架构基础</title>
    <id>https://clay-wangzhi.com/web/nginx/framework/</id>
    <link href="https://clay-wangzhi.com/web/nginx/framework/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_2-nginx架构基础"> 2. nginx架构基础</h1>
<h2 id="_1-nginx请求处理流程"> 1 Nginx请求处理流程</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200310164648893.png" alt="" /></p>
<h2 id="_2-nginx进程结构"> 2 Nginx进程结构</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200310164732720.png" alt="" /></p>
<h2 id="_3-nginx进程管理-信号"> 3 Nginx进程管理：信号</h2>
<h3 id="_3-1-master进程"> 3.1 Master进程</h3>
<ul>
<li>监控worker进程
<ul>
<li>CHLD</li>
</ul>
</li>
<li>管理worker进程</li>
<li>接收信号
<ul>
<li>TERM，INT</li>
<li>QUIT</li>
<li>HUP</li>
<li>USR1</li>
<li>USR2</li>
<li>WINCH</li>
</ul>
</li>
</ul>
<h3 id="_3-2-worker进程"> 3.2 Worker进程</h3>
<ul>
<li>接收信号
<ul>
<li>TERM，INT</li>
<li>QUIT</li>
<li>USR1</li>
<li>WINCH</li>
</ul>
</li>
</ul>
<h3 id="_3-3-nginx命令行"> 3.3 nginx命令行</h3>
<ul>
<li>reload：HUP</li>
<li>reopen：USR1</li>
<li>stop：TERM</li>
<li>quit：QUIT</li>
</ul>
<h2 id="_4-reload-流程"> 4 reload 流程</h2>
<p>1）向master进程发送HUP信号（reload命令）</p>
<p>2）master进程校验配置语法是否正确</p>
<p>3）master进行打开新的监听端口</p>
<p>4）master进程用新配置启动新的worker子进程</p>
<p>5）master进程向老worker子进程发送QUIT信号</p>
<p>6）老worker进程关闭监听句柄，处理完当前连接后结束进程</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200310170519124.png" alt="" /></p>
<h2 id="_5-热升级流程"> 5 热升级流程</h2>
<p>1）将旧Ningx文件换成新Nginx文件（注意备份）</p>
<p>2）向master进程发送USR2信号</p>
<p>3）master进程修改pid文件名，加后缀.oldbin（进程自动改的，不需要手动改）</p>
<p>4）master进程用新Nginx文件启动新master进程</p>
<p>5）向老master进程发送QUIT信号，关闭老master</p>
<p>6）回滚：向老master发送HUP，向新master发送QUIT</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200310171424958.png" alt="" /></p>
<h2 id="_6-worker进程-优雅的关闭"> 6 worker进程：优雅的关闭</h2>
<p>1）设置定时器<code>worker_shutdown_timeout</code></p>
<p>2）关闭监听句柄</p>
<p>3）关闭空闲连接</p>
<p>4）在循环中等待全部连接关闭</p>
<p>5）退出进程</p>
<h2 id="_7-网络相关"> 7 网络相关</h2>
<h3 id="_7-1-网络传输"> 7.1 网络传输</h3>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200310172023302.png" alt="" /></p>
<h3 id="_7-2-tcp流与报文"> 7.2 TCP流与报文</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200310172138764.png" alt="" /></p>
<h3 id="_7-3-tcp协议与非阻塞接口"> 7.3 TCP协议与非阻塞接口</h3>
<ul>
<li>读事件
<ul>
<li>Accept建立连接</li>
<li>Read读消息</li>
</ul>
</li>
<li>写事件
<ul>
<li>Write写信息</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200310172800752.png" alt="" /></p>
<h2 id="_8-nginx事件循环"> 8 Nginx事件循环</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200310173131875.png" alt="" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200310173315213.png" alt="" /></p>
<h3 id="_8-1-epoll"> 8.1 epoll</h3>
<p><strong>前提</strong></p>
<p>高并发连接中，每次处理的活跃连接数量占比很小</p>
<p><strong>实现</strong></p>
<p>红黑树，链表</p>
<p><strong>使用</strong></p>
<p>创建，操作（添加/修改/删除），获取句柄，关闭</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200310173757670.png" alt="" /></p>
<h2 id="_9-模块分类"> 9 模块分类</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200310174353557.png" alt="" /></p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">3.1 nginx全局块和events块配置</title>
    <id>https://clay-wangzhi.com/web/nginx/global-events/</id>
    <link href="https://clay-wangzhi.com/web/nginx/global-events/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_3-1-nginx全局块和events块配置"> 3.1 nginx全局块和events块配置</h1>
<h2 id="_1-example"> 1 example</h2>
<div><pre><code><span># 运行Nginx进程的用户</span>
<span>user</span> nginx<span>;</span>
<span>worker_processes</span>  <span>8</span><span>;</span>
<span>worker_cpu_affinity</span> auto<span>;</span>

<span># 定义存储某类型的全局错误的日志位置</span>
<span># nginx日志分为很多级别 [debug | info | notice | warn | error | crit | alert | emerg]</span>
<span>error_log</span>  <span>/</span>var<span>/</span>log<span>/</span>nginx<span>/</span>error<span>.</span>log  error<span>;</span>
<span># 指定进程ID（pid）存放的路径 </span>
<span>pid</span>        <span>/</span>var<span>/</span>run<span>/</span>nginx<span>.</span><span>pid</span><span>;</span>
<span># 一个nginx进程打开的最多文件描述符数目，理论值应该是系统的最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n的值保持一致。</span>
<span>worker_rlimit_nofile</span> <span>65535</span><span>;</span>

<span>events</span> <span>{</span>
    <span># 使用epoll的I/O模型，用这个模型来高效处理异步事件</span>
    <span>use</span> epoll<span>;</span>
    <span># 每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为worker_processes*worker_connections。</span>
    <span>worker_connections</span>  <span>20480</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="_2-配置cpu参数"> 2 配置CPU参数</h2>
<p>Nginx默认没有开启利用多核cpu，我们可以通过增加worker_cpu_affinity配置参数来充分利用多核cpu的性能。cpu是任务处理，计算最关键的资源，cpu核越多，性能就越好。</p>
<h3 id="_2-1-nginx-worker-processes"> 2.1 nginx worker_processes</h3>
<p>worker_processes最多开启8个，8个以上性能就不会再提升了，而且稳定性会变的更低，因此8个进程够用了；</p>
<h3 id="_2-2-nginx-worker-cpu-affinity"> 2.2 nginx worker_cpu_affinity</h3>
<p>cpu有多少个核？就有几位数，1代表内核开启，0代表内核关闭；</p>
<p>例如：我有一个服务器是最低配，8核CPU，nginx配置信息则如下：</p>
<div><pre><code><span>worker_processes</span> <span>8</span><span>;</span>
<span>worker_cpu_affinity</span> <span>00000001</span> <span>00000010</span> <span>00000100</span> <span>00001000</span> <span>00010000</span> <span>00100000</span> <span>01000000</span> <span>10000000</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面的配置表示：8核CPU，开启8个进程。</p>
<blockquote>
<p>我其实把<code>nginx worker_cpu_affinity</code>参数通常设置为<code>auto</code></p>
</blockquote>
<h3 id="_2-3-实例"> 2.3 实例</h3>
<p><strong>2核CPU，开启2个进程</strong></p>
<div><pre><code><span>worker_processes</span> <span>2</span><span>;</span>
<span>worker_cpu_affinity</span> <span>01</span> <span>10</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>2核CPU，开启4进程</strong></p>
<div><pre><code><span>worker_processes</span> <span>4</span><span>;</span>
<span>worker_cpu_affinity</span> <span>01</span> <span>10</span> <span>01</span> <span>10</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>2核CPU，开启8进程</strong></p>
<div><pre><code><span>worker_processes</span> <span>8</span><span>;</span>
<span>worker_cpu_affinity</span> <span>01</span> <span>10</span> <span>01</span> <span>10</span> <span>01</span> <span>10</span> <span>01</span> <span>10</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>8核CPU，开启2进程</strong></p>
<div><pre><code><span>worker_processes</span> <span>2</span><span>;</span>
<span>worker_cpu_affinity</span> <span>10101010</span> <span>01010101</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>10101010表示开启了第2,4,6,8内核，01010101表示开始了1,3,5,7内核；</p>
<p>如果多个CPU内核的利用率都相差不多，证明nginx己经成功的利用了多核CPU。</p>
<p>测试结束后，CPU内核的负载应该都同时降低。</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">3.2 nginxHTTP块配置</title>
    <id>https://clay-wangzhi.com/web/nginx/http/</id>
    <link href="https://clay-wangzhi.com/web/nginx/http/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_3-2-nginxhttp块配置"> 3.2 nginxHTTP块配置</h1>
<h2 id="_1-配置块的嵌套"> 1 配置块的嵌套</h2>
<div><pre><code><span>http</span> <span>{</span>
    <span>upstream</span> <span>{</span><span>.</span><span>.</span><span>.</span><span>}</span>
    <span>split_clients</span> <span>{</span><span>.</span><span>.</span><span>.</span><span>}</span>
    <span>map</span> <span>{</span><span>.</span><span>.</span><span>.</span><span>}</span>
    <span>geo</span> <span>{</span><span>.</span><span>.</span><span>.</span><span>}</span>
    <span>server</span> <span>{</span>
        <span>if</span> <span>(</span><span>)</span> <span>{</span><span>.</span><span>.</span><span>.</span><span>}</span>
        <span>location</span> <span>{</span>
            <span>limit_except</span> <span>{</span><span>.</span><span>.</span><span>.</span><span>}</span>
        <span>}</span>
        <span>location</span> <span>{</span>
            <span>location</span> <span>{</span>
                
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>server</span> <span>{</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="_2-指令的合并"> 2 指令的合并</h2>
<ul>
<li>值指令：存储配置项的值
<ul>
<li>可以合并</li>
<li>示例：root，access_log，gzip</li>
</ul>
</li>
<li>动作类指令：指定行为
<ul>
<li>不可以合并</li>
<li>示例：rewrite，proxy_pass</li>
<li>生效阶段：server_rewrite阶段，rewrite阶段，content阶段</li>
</ul>
</li>
</ul>
<p><strong>存储值的指令继承规则：向上覆盖</strong></p>
<ul>
<li>子配置不存在时，直接使用父配置块</li>
<li>子配置存在时，直接覆盖父配置块</li>
</ul>
<div><pre><code><span>server</span> <span>{</span>
    <span>listen</span> <span>8080</span><span>;</span>
    <span>root</span> <span>/</span>home<span>/</span>geek<span>/</span>nginx<span>/</span>html<span>;</span>
    <span>access_log</span> logs<span>/</span>geek<span>.</span>access<span>.</span>log main<span>;</span>
    <span>location</span> <span>/</span>test <span>{</span>
        <span>root</span> <span>/</span>home<span>/</span>geek<span>/</span>nginx<span>/</span>test<span>;</span>
        <span>access_log</span> logs<span>/</span>access<span>.</span>test<span>.</span>log main<span>;</span>
    <span>}</span>
    <span>location</span> <span>/</span>dlib <span>{</span>
        <span>alias</span> dlib<span>/</span><span>;</span>
    <span>}</span>
    <span>location</span> <span>/</span> <span>{</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="_3-http请求处理时的11个阶段"> 3 HTTP请求处理时的11个阶段</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200317095602291.png" alt="" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200317095641772.png" alt="" /></p>
<h2 id="_4-正则表达式"> 4 正则表达式</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200317093833697.png" alt="" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200317094000335.png" alt="" /></p>
<h2 id="_5-提取用户真实ip"> 5 提取用户真实ip</h2>
<p>如何拿到真实的用户ip地址？</p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200317095930682.png" alt="" /></p>
<p>拿到真实用户ip后如何使用？</p>
<p>基于变量：如binary_remote_addr、remote_addr这样的变量，其值就为真实的IP！这样做连接限制（limit_conn模块）才有意义！</p>
<p><strong>步骤</strong></p>
<ol>
<li>
<p>安装realip模块</p>
<p>realip是Nginx内置模块，需要在编译Nginx时加上<code>--with-http_realip_module</code>参数来启用它。</p>
</li>
<li>
<p>配置语法</p>
<div><pre><code>set_real_ip_from 192.168.1.0/24; #真实服务器上一级代理的IP地址或者IP段,可以写多行。
set_real_ip_from 192.168.2.1;
real_ip_header X-Forwarded-For;  #从哪个header头检索出要的IP地址。
real_ip_recursive on; #递归的去除所配置中的可信IP。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这里详细讲下<code>real_ip_recursive</code>的用途：递归的去除所配置中的可信IP，排除set_real_ip_from里面出现的IP。如果出现了未出现这些IP段的IP，那么这个IP将被认为是用户的IP。</p>
</li>
<li>
<p>配置实例</p>
<div><pre><code><span>location</span> <span>/</span> <span>{</span>
    <span>root</span> html<span>/</span><span>;</span>
    <span>proxy_set_header</span> X<span>-</span>Forwarded<span>-</span>For <span>$proxy_add_x_forwarded_for</span><span>;</span>
    <span>set_real_ip_from</span> <span>192.168</span><span>.1</span><span>.0</span><span>/</span><span>24</span><span>;</span>
    <span>set_real_ip_from</span> <span>192.168</span><span>.2</span><span>.1</span><span>;</span>
    <span>real_ip_header</span> X<span>-</span>Forwarded<span>-</span>For<span>;</span>
    real_ip_recursive on<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
</ol>
<h2 id="_6-定义404错误页面"> 6 定义404错误页面</h2>
<h3 id="_6-1-nginx自己的错误页面"> 6.1 Nginx自己的错误页面</h3>
<p>Nginx访问一个静态的html 页面，当这个页面没有的时候，Nginx抛出404，那么如何返回给客户端404呢？</p>
<p>看下面的配置，这种情况下不需要修改任何参数，就能实现这个功能。</p>
<div><pre><code><span>server</span> <span>{</span>
    <span>listen</span> <span>80</span><span>;</span>
    <span>server_name</span> www<span>.</span>test<span>.</span>com<span>;</span>
    <span>root</span> <span>/</span>var<span>/</span>www<span>/</span>test<span>;</span>
    <span>index</span> <span>index</span><span>.</span>html <span>index</span><span>.</span>htm<span>;</span>
    <span>location</span> <span>/</span> <span>{</span>
        
    <span>}</span>
    <span># 定义错误页面码，如果出现相应的错误页面码，转发到那里。</span>
    <span>error_page</span> <span>404</span> <span>403</span> <span>500</span> <span>502</span> <span>503</span> <span>504</span> <span>/</span><span>404.</span>html<span>;</span>
    <span># 承接上面的location</span>
    <span>location</span> <span>=</span> <span>/</span><span>404.</span>html <span>{</span>
        <span># 放错误页面的目录路径。</span>
        <span>root</span> <span>/</span>usr<span>/</span>share<span>/</span>nginx<span>/</span>html<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_6-2-反向代理的错误页面"> 6.2 反向代理的错误页面</h3>
<p>如果后台Tomcat处理报错抛出404，想把这个状态叫Nginx反馈给客户端或者重定向到某个连接，配置如下：</p>
<div><pre><code><span>upstream</span> www <span>{</span>
    <span>server</span> <span>192.168</span><span>.1</span><span>.201</span><span>:</span><span>8080</span> weight<span>=</span><span>20</span> max_fails<span>=</span><span>2</span> fail_timeout<span>=</span><span>30</span>s
        <span>ip_hash</span><span>;</span>
<span>}</span>
<span>server</span> <span>{</span>
    <span>listen</span> <span>80</span><span>;</span>
    <span>server_name</span> www<span>.</span>test<span>.</span>com<span>;</span>
    <span>root</span> <span>/</span>var<span>/</span>www<span>/</span>test<span>;</span>
    <span>index</span> <span>index</span><span>.</span>html<span>;</span>
    <span>location</span> <span>/</span> <span>{</span>
        <span>if</span><span>(</span><span>$request_uri</span> <span>~</span><span>*</span> <span>'^/$'</span><span>)</span> <span>{</span>
            <span>rewrite</span> <span>.</span><span>*</span> <span>http</span><span>:</span><span>/</span><span>/</span>www<span>.</span>test2<span>.</span>com<span>/</span><span>index</span><span>.</span>html redirect<span>;</span>
        <span>}</span>
        <span># 关键参数：这个变量开启后，我们才能自定义错误页面，当后端返回404，nginx拦截错误，定义错误页面</span>
        <span>proxy_intercept_errors</span> on<span>;</span>
        <span>proxy_pass</span> <span>http</span><span>:</span><span>/</span><span>/</span>www<span>;</span>
        <span>proxy_set_header</span> HOST <span>$host</span><span>;</span>
    <span>}</span>
    <span>error_page</span> <span>404</span> <span>/</span><span>404.</span>html<span>;</span>
    <span>location</span> <span>=</span> <span>/</span><span>404.</span>html <span>{</span>
        <span>root</span> <span>/</span>usr<span>/</span>share<span>/</span>nginx<span>/</span>html<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="_6-3-nginx解析php代码的错误页面"> 6.3 Nginx解析php代码的错误页面</h3>
<p>如果后端是php解析的，需要加一个变量</p>
<p>在http段中加一个变量</p>
<p><code>fastcgi_intercept_errors on</code>就可以了。</p>
<blockquote>
<p>参考链接：</p>
<p>https://www.hi-linux.com/posts/53006.html</p>
<p>https://blog.csdn.net/lijunwyf/article/details/79611003</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">3.4 nginxLOCATION块配置</title>
    <id>https://clay-wangzhi.com/web/nginx/location/</id>
    <link href="https://clay-wangzhi.com/web/nginx/location/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_3-4-nginxlocation块配置"> 3.4 nginxLOCATION块配置</h1>
<p><code>nginx</code>中<code>location</code>的匹配模式有以下几种：</p>
<ul>
<li>
<p>精确匹配：以<code>=</code>开头，只有完全匹配才能生效，例子<code>location = /uri</code></p>
</li>
<li>
<p>非正则匹配：以<code>^~</code>开头，<code>^</code>表示非、<code>~</code>表示正则，例子<code>location ^~ /uri</code></p>
</li>
<li>
<p>正则匹配：</p>
<ul>
<li>以<code>~</code>开头，表示区分大小写的正则匹配，例子<code>location ~ pattern</code></li>
<li>以<code>!~</code>开头，表示区分大小写不匹配的正则，例子<code>location !~ pattern</code></li>
<li>以<code>~*</code>开头，表示不区分大小写的正则匹配，例子<code>location ~* pattern</code></li>
<li>以<code>!~*</code>开头，表示不区分大小写不匹配的正则，例子<code>location !~* pattern</code></li>
</ul>
</li>
<li>
<p>普通匹配：不带任何修饰符，例子<code>location /uri</code>、<code>location /</code></p>
</li>
</ul>
<blockquote>
<p>我们暂且把非正则匹配和普通匹配称为前缀匹配</p>
</blockquote>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/nginx中location匹配流程图.png" alt="nginx中location匹配流程图" /></p>
<h2 id="_1-匹配模式优先级"> 1 匹配模式优先级</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200320195331145.png" alt="" /></p>
<div><pre><code>location = /uri 　　　=开头表示精确匹配，只有完全匹配上才能生效。
location ^~ /uri 　　^~ 开头对URL路径进行前缀匹配，并且在正则之前。无正则普通匹配（^ 表示“非”，~ 表示“正则”，字符意思是：不要继续匹配正则）
location ~ pattern 　~开头表示区分大小写的正则匹配。!~为区分大小写不匹配的正则
location ~* pattern 　~*开头表示不区分大小写的正则匹配。!~*为不区分大小写不匹配的正则
location /uri 　　　　不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。
location / 　　　　　通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注意：
前缀匹配，如果有包含关系时，按最大匹配原则进行匹配。比如在前缀匹配：location /dir1与location /dir1/dir2，如有请求http://localhost/dir1/dir2/file将最终匹配到location /dir1/dir2</p>
<p>优先级：
(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location <sub>,</sub>* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</p>
<blockquote>
<p>上述的优先级不完全正确</p>
</blockquote>
<p>具体规则：</p>
<p>等号类型（=）的优先级最高。一旦匹配成功，则不再查找其他location的匹配项</p>
<p>剩下的几种匹配优先级略复杂，具体可以查看Nginx官方文档（http://nginx.org/en/docs/http/ngx_http_core_module.html#location）</p>
<ul>
<li>
<p>^~和普通匹配。</p>
<p>使用前缀匹配，不支持正则表达式，如果有多个location匹配成功的话，不会终止匹配过程，会记忆表达式最长的那个。</p>
</li>
<li>
<p>如果上一步得到的最长的location为^~类型，则表示阻断正则表达式，不再匹配正则表达式</p>
</li>
<li>
<p>如果上一步得到的最长的location不是^~类型，继续匹配正则表达式，只要有一个正则成功，则使用这个正则的location，立即返回结果，并结束解析过程</p>
</li>
</ul>
<p><strong>“最长”命中</strong></p>
<p>^~和普通命中，都是优先使用匹配最长的结果，示例如下：</p>
<p><strong>例子1</strong></p>
<div><pre><code><span>location</span> <span>/</span>test_1 <span>{</span>
    <span>return</span> <span>400</span><span>;</span>
<span>}</span>
<span>location</span> <span>^</span><span>~</span> <span>/</span>test <span>{</span>
    <span>return</span> <span>401</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如上如果path为/test_1，返回的是400，说明^~优先级并不比普通匹配高</p>
<p><strong>例子2</strong></p>
<div><pre><code><span>location</span> <span>/</span>test_1 <span>{</span>
    <span>return</span> <span>400</span><span>;</span>
<span>}</span>
<span>location</span> <span>^</span><span>~</span> <span>/</span>test <span>{</span>
    <span>return</span> <span>401</span><span>;</span>
<span>}</span>
<span>location</span> <span>~</span> <span>/</span>test <span>{</span>
    <span>return</span> <span>402</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>如上如果path为/test_1，返回的是402，此时^~和普通匹配只记住了最长一个location /test_1，不会阻止正则</p>
<p>如果path为/test，返回401，此时^~和普通匹配只记住了最长一个location ^~ /test，会阻止正则</p>
<h2 id="_2-路径替换"> 2 路径替换</h2>
<p><strong>规则</strong></p>
<p>配置proxy_pass时，可以实现URL路径的部分替换。</p>
<p>proxy_pass的目标地址，默认不带/，表示只代理域名，url和querystring部分不会变（把请求的path拼接到proxy_pass目标域名之后作为代理的URL）。</p>
<p>如果在目标地址后增加/，则表示把path中location匹配成功的部分剪切掉之后再拼接到proxy_pass目标地址。</p>
<p>比如请求 /a/b.html</p>
<div><pre><code><span>location</span> <span>/</span>a <span>{</span>
    <span>proxy_pass</span> <span>http</span><span>:</span><span>/</span><span>/</span><span>server</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>location</span> <span>/</span>a<span>/</span> <span>{</span>
    <span>proxy_pass</span> <span>http</span><span>:</span><span>/</span><span>/</span><span>server</span><span>/</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如上两个匹配成功后，实际代理的目标url分别是</p>
<p>http://server/a/b.html (把/a/b.html拼接到http://server之后)</p>
<p>http://server/b.html (把/a/b.html的/a/去掉之后，拼接到http://server/之后)</p>
<blockquote>
<p>通过 Nginx Server 访问 <code>http://nginx/nginx_location/some/path</code></p>
<p><code>proxy_pass</code>直接映射到主机的 <code>/test</code></p>
<p>建议location和proxy_pass后面都加上/，否则容易引起混乱。</p>
<table>
<thead>
<tr>
<th>location</th>
<th>proxy_pass</th>
<th>实际访问目标</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/nginx_location/</code></td>
<td><code>http://server/test/</code></td>
<td><code>http://server/test/some/path</code></td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>要求</strong></p>
<p>注意的是，对于location为正则表达式的匹配，proxy_pass的目标地址不可以带/</p>
<p>比如，如下配置会报错：</p>
<div><pre><code><span>location</span> <span>~</span> <span>/</span><span>abc</span><span>(</span><span>.</span><span>*</span><span>)</span> <span>{</span>
    <span>proxy_pass</span>   <span>http</span><span>:</span><span>/</span><span>/</span><span>127.0</span><span>.0</span><span>.1</span><span>/</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果是正则表达式，想要实现proxy_pass的路径替换，可以使用如下方式：</p>
<div><pre><code><span>location</span> <span>~</span> <span>/</span><span>abc</span><span>(</span><span>.</span><span>*</span><span>)</span> <span>{</span>
    <span>proxy_pass</span>   <span>http</span><span>:</span><span>/</span><span>/</span><span>127.0</span><span>.0</span><span>.1</span><span>/</span>$<span>1</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="_3-root和alias的使用"> 3 root和alias的使用</h2>
<p>nginx指定文件路径有两种方式root和alias，</p>
<p>root与alias主要区别在于nginx如何解释location后面的uri，</p>
<p>这会使两者分别以不同的方式将请求映射到服务器文件上。</p>
<h3 id="_3-1-最基本的区别"> 3.1 最基本的区别</h3>
<p>alias 指定的目录是准确的，给location指定一个目录。</p>
<p>root 指定目录的上级目录，并且该上级目录要含有locatoin指定名称的同名目录。</p>
<p>以root方式设置资源路径：</p>
<div><pre><code>语法: root path;
配置块: http、server、location、if
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>以alias 方式设置资源路径</p>
<div><pre><code>语法: alias path;
配置块: location
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Example:</p>
<div><pre><code>location /img/ {
	alias /var/www/image/;
}
#若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件
location /img/ {
	root /var/www/image;
}
#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注意：</p>
<div><pre><code>1.使用alias时，目录名后面一定要加”/“。
2.使用alias标签的目录块中不能使用rewrite的break。
3.alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。
4.alias只能位于location块中
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>所以使用nginx设置root时要注意一个问题，就是如果该root设置的前端目录不是根目录，那么在写root的绝对地址时，要把前端目录的部分省略掉。
我们用设置虚拟目录指向的alias来和root比较一下就非常明显了</p>
<div><pre><code>location /abc/ {   alias /home/html/abc/; }  
</code></pre>
<div><span>1</span><br></div></div><p>在这段配置下，http://test/abc/a.html就指定的是 /home/html/abc/a.html。这段配置亦可改成</p>
<div><pre><code>location /abc/ {   root /home/html/;} 
</code></pre>
<div><span>1</span><br></div></div><p>可以看到，使用root设置目录的绝对路径时，少了/abc,也就是说，使用root来设置前端非根目录时，nginx会组合root和location的路径,即 /home/html/abc/。</p>
<h2 id="_4-try-files指令"> 4 try_files指令</h2>
<div><pre><code>Syntax:	try_files file ... uri;
try_files file ... =code;
Default:	—
Context:	server, location
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>示例</strong></p>
<div><pre><code><span>try_files</span> <span>$uri</span> <span>$uri</span><span>/</span> <span>/</span>test<span>/</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>功能：依次试图访问多个url对应的文件（由root或者alias指令指定），当文件存在是直接返回文件内容，如果所有文件都不存在，则按最后一个URL结果或者code返回</p>
<h2 id="_5-stub-status"> 5 stub_status</h2>
<p>配置示例</p>
<div><pre><code><span>location</span> <span>/</span>basic_status <span>{</span>
	<span>stub_status</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>ngx_http_stub_status_module模块內建的状态页
用于输出nginx的基本状态信息；</p>
<div><pre><code>server{
....
	location /ngxstatus {
		stub_status;
	}
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>信息页返回数值：</p>
<div><pre><code>Active connections: 291
server accepts handled requests
16630948 16630948 31070465
Reading: 6 Writing: 179 Waiting: 106
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>Active connections: 活动状态的连接数；</li>
<li>accepts：已经接受的客户端请求的总数；</li>
<li>handled：已经处理完成的客户端请求的总数；</li>
<li>requests：客户端发来的总的请求数；</li>
<li>Reading：处于读取客户端请求报文首部的连接的连接数；</li>
<li>Writing：处于向客户端发送响应报文过程中的连接数；</li>
<li>Waiting：处于等待客户端发出请求的空闲连接数；</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">3.5 nginx常用模块</title>
    <id>https://clay-wangzhi.com/web/nginx/module/</id>
    <link href="https://clay-wangzhi.com/web/nginx/module/"/>
    <updated>2021-05-11T06:41:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_3-5-nginx常用模块"> 3.5 nginx常用模块</h1>
<h2 id="_1-module-ngx-http-gzip-module"> 1 Module ngx_http_gzip_module</h2>
<p>该<code>ngx_http_gzip_module</code>模块是一个使用“gzip”方法压缩响应的过滤器。这通常有助于将传输数据的大小减少一半甚至更多。</p>
<blockquote>
<p>使用SSL / TLS协议时，压缩的响应可能会受到 <a href="https://en.wikipedia.org/wiki/BREACH" target="_blank" rel="noopener noreferrer">BREACH</a>攻击。</p>
</blockquote>
<p>在实际的应用中我们发现压缩的比率往往在 3 到 10 倍，也就是本来 50k 大小的页面，采用压缩后实际传输的内容大小只有 5 至 15k 大小，这可以大大节省服务器的网络带宽，同时如果应用程序的响应足够快时，网站的速度瓶颈就转到了网络的传输速度上，因此内容压缩后就可以大大的提升页面的浏览速度。</p>
<h3 id="_1-1-example-configuration"> 1.1 Example Configuration</h3>
<div><pre><code>gzip on;
gzip_buffers 4 8k;
gzip_comp_level 6;
gzip_disable &quot;MSIE [1-6]\.&quot;;
gzip_http_version 1.1;
gzip_min_length 1000;
gzip_proxied any;
gzip_vary on;
gzip_types text/plain text/css application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript application/json image/jpeg image/gif image/png image/jpg;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="_1-2-directives"> 1.2 Directives</h3>
<p><strong>gzip</strong></p>
<div><pre><code>Syntax:	gzip on | off;
Default: gzip off;
Context:	http, server, location, if in location
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>启用或禁用gzipping响应。</p>
<p><strong>gzip_buffers</strong></p>
<div><pre><code>Syntax:	gzip_buffers number size;
Default: gzip_buffers 32 4k|16 8k;
Context:	http, server, location
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>设置用于压缩响应的缓冲区<code>*number*</code>和<code>*size*</code>。默认情况下，缓冲区大小等于一个内存页面。这是4K或8K，具体取决于平台。</p>
<p><strong>gzip_comp_level</strong></p>
<div><pre><code>Syntax:	gzip_comp_level level;
Default: gzip_comp_level 1;
Context:	http, server, location
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>设置<code>level</code>响应的gzip压缩。可接受的值范围为1到9。</p>
<p>推荐6压缩级别(级别越高,压的越小,越浪费CPU计算资源)</p>
<p><strong>gzip_disable</strong></p>
<div><pre><code>Syntax:	gzip_disable regex ...;
Default: —
Context:	http, server, location
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>对具有与任何指定正则表达式匹配的“User-Agent”标头字段的请求禁用gzipping响应。</p>
<p>特殊掩码“ <code>msie6</code>”（0.7.12）对应于正则表达式“ <code>MSIE [4-6]\.</code>”，但效果更快。</p>
<p><strong>gzip_http_version</strong></p>
<div><pre><code>Syntax:	gzip_http_version 1.0 | 1.1;
Default: gzip_http_version 1.1;
Context:	http, server, location
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>设置压缩响应所需的最低HTTP请求版本。</p>
<p>99.99%的浏览器基本上都支持gzip解压了，所以可以不用设这个值,保持系统默认即可。</p>
<p><strong>gzip_min_length</strong></p>
<div><pre><code>Syntax:	gzip_min_length length;
Default: gzip_min_length 20;
Context:	http, server, location
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>设置将被gzip压缩的响应的最小长度。长度仅由“Content-Length”响应头字段确定。</p>
<p><strong>gzip_proxied</strong></p>
<div><pre><code>Syntax:	gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any ...;
Default: gzip_proxied off;
Context:	http, server, location
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>根据请求和响应启用或禁用对代理请求的响应的gzipping。请求被代理的事实由“Via”请求头字段的存在确定。该指令接受多个参数：</p>
<ul>
<li><code>off</code>：禁用所有代理请求的压缩，忽略其他参数;</li>
<li><code>expired</code>：如果响应头包含“Expires”字段，其值为禁用缓存，则启用压缩;</li>
<li><code>no-cache</code>：如果响应头包含带有“ <code>no-cache</code>”参数的“Cache-Control”字段，则启用压缩;</li>
<li><code>no-store</code>：如果响应头包含带有“ <code>no-store</code>”参数的“Cache-Control”字段，则启用压缩;</li>
<li><code>private</code>：如果响应头包含带有“ <code>private</code>”参数的“Cache-Control”字段，则启用压缩;</li>
<li><code>no_last_modified</code>：如果响应头不包含“Last-Modified”字段，则启用压缩;</li>
<li><code>no_etag</code>：如果响应头不包含“ETag”字段，则启用压缩;</li>
<li><code>auth</code>：如果请求标头包含“授权”字段，则启用压缩;</li>
<li><code>any</code>：为所有代理请求启用压缩。</li>
</ul>
<p><strong>gzip_types</strong></p>
<div><pre><code>Syntax:	gzip_types mime-type ...;
Default:	gzip_types text/html;
Context:	http, server, location
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>除了“ <code>text/html</code>” 之外，还允许对指定的MIME类型进行gzipping响应。特殊值“ <code>*</code>”匹配任何MIME类型。</p>
<blockquote>
<p>图片类型的文件压缩比例很小，可以不忽略不计，所以图片不建议压缩</p>
</blockquote>
<p><strong>gzip_vary</strong></p>
<div><pre><code>Syntax:	gzip_vary on | off;
Default:	gzip_vary off;
Context:	http, server, location
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果指令<a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html#gzip" target="_blank" rel="noopener noreferrer">gzip</a>， <a href="http://nginx.org/en/docs/http/ngx_http_gzip_static_module.html#gzip_static" target="_blank" rel="noopener noreferrer">gzip_static</a>或<a href="http://nginx.org/en/docs/http/ngx_http_gunzip_module.html#gunzip" target="_blank" rel="noopener noreferrer">gunzip</a> 处于活动状态， 则启用或禁用插入“Vary：Accept-Encoding”响应头字段 。</p>
<h3 id="_1-3-常见问题"> 1.3 常见问题</h3>
<p><strong>调用接口时，返回json乱码的问题</strong></p>
<p>原因：</p>
<p>gzip是nginx的压缩格式。（gzip是浏览器可接受的压缩格式） 但是我们调用接口并没有通过浏览器。所以没有办法对返回的结果进行解压。</p>
<p>解决办法：</p>
<ul>
<li>在响应的<code>location</code>中关闭gzip</li>
<li>或者让后端改代码，增加判断，然后用gzip流的方式进行解压读取</li>
</ul>
<h2 id="_2-module-ngx-http-log-module"> 2 Module ngx_http_log_module</h2>
<h3 id="_2-1-example-configuration"> 2.1 Example Configuration</h3>
<div><pre><code><span>log_format</span> compression <span>'$remote_addr - $remote_user [$time_local] '</span>
                       <span>'"$request" $status $bytes_sent '</span>
                       <span>'"$http_referer" "$http_user_agent" "$gzip_ratio"'</span><span>;</span>

<span>access_log</span> <span>/</span>spool<span>/</span>logs<span>/</span>nginx<span>-</span>access<span>.</span>log compression buffer<span>=</span><span>32</span>k<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_2-2-access-log指令"> 2.2 access_log指令</h3>
<div><pre><code>Syntax:	access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];
		access_log off;
Default:	access_log logs/access.log combined;
Context:	http, server, location, if in location, limit_except
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_2-3-log-format指令"> 2.3 log_format指令</h3>
<div><pre><code>Syntax:	log_format name [escape=default|json|none] string ...;
Default:	log_format combined &quot;...&quot;;
Context:	http
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="_3-rewrite模块"> 3 Rewrite模块</h2>
<h3 id="_3-1-return指令"> 3.1 return指令</h3>
<div><pre><code>Syntax:	return code [text];
		return code URL;
		return URL;
Default:	—
Context:	server, location, if
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>返回状态码</strong></p>
<ul>
<li>nginx自定义
<ul>
<li>444：关闭连接</li>
</ul>
</li>
<li>HTTP1.0标准
<ul>
<li>301：http1.0永久重定向</li>
<li>302：临时重定向，禁止被缓存</li>
</ul>
</li>
<li>HTTP1.1标准
<ul>
<li>303：临时重定向，允许改变方法，禁止被缓存</li>
<li>307：临时重定向，不允许改变方式，禁止被缓存</li>
<li>308：永久重定向，不允许改变方法</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<div><pre><code><span>server</span> <span>{</span>
    <span>server_name</span> wiki<span>.</span>clay<span>-</span>wangzhi<span>.</span>com<span>;</span>
    <span>listen</span> <span>8080</span><span>;</span>
    
    <span>root</span> html<span>/</span><span>;</span>
    <span>error_page</span> <span>404</span><span>/</span><span>403.</span>html<span>;</span>
    <span>return</span> <span>403</span><span>;</span>
    <span>location</span> <span>/</span> <span>{</span>
        <span>return</span> <span>404</span> <span>"find nothing!"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>return指令与errror_page</strong></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200320195040345.png" alt="" /></p>
<h3 id="_3-2-rewrite指令"> 3.2 rewrite指令</h3>
<div><pre><code>Syntax:	rewrite regex replacement [flag];
Default:	—
Context:	server, location, if
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>功能</strong></p>
<ul>
<li>
<p>将regex指定的url替换成replacement这个新的url</p>
<p>可以使用正则表达式及变量提取</p>
</li>
<li>
<p>当replacement以http://或者https://或者$schema开头，则直接返回302重定向</p>
</li>
<li>
<p>替换后的url根据flag指定的方式进行处理</p>
<p>如果在同一级配置块中存在多个rewrite规则，那么会自下而下逐个检查；被某条件规则替换完成后，会重新一轮的替换检查，因此，隐含有循环机制；[flag]所表示的标志位用于控制此循环机制；</p>
<ul>
<li>
<p>last：</p>
<ul>
<li>浏览器地址栏URL地址不变</li>
<li>用replacement这个URI进行新的location匹配，重写完成后停止对当前URI在当前location中后续的其它重写操作，而后对新的URI启动新一轮重写检查；提前重启新一轮循环；</li>
</ul>
</li>
<li>
<p>beak：</p>
<ul>
<li>浏览器地址栏URL地址不变</li>
<li>break指令停止当前脚本指令的执行，等价于独立的break指令,重写完成后停止对当前URI在当前location中后续的其它重写操作，而后直接跳转至重写规则配置块之后的其它配置；结束循环；</li>
</ul>
</li>
<li>
<p>redirect：</p>
<ul>
<li>浏览器地址会显示跳转后的URL地址</li>
<li>返回302临时重定向，</li>
</ul>
</li>
<li>
<p>permanent：</p>
<ul>
<li>浏览器地址会显示跳转后的URL地址</li>
<li>返回301永久重定向</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>功能一句话概括为：使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。</p>
</blockquote>
<p><strong>示例1</strong></p>
<div><pre><code>        <span>root</span> html<span>/</span><span>;</span>
        <span>location</span> <span>/</span>first <span>{</span>
            <span>rewrite</span> <span>/</span><span>first</span><span>(</span><span>.</span><span>*</span><span>)</span> <span>/</span>second$<span>1</span> last<span>;</span>
            <span>return</span> <span>200</span> <span>'first!'</span><span>;</span>
        <span>}</span>

        <span>location</span> <span>/</span>second <span>{</span>
            <span>rewrite</span> <span>/</span><span>second</span><span>(</span><span>.</span><span>*</span><span>)</span> <span>/</span>third$<span>1</span> <span>break</span><span>;</span>
            <span>return</span> <span>200</span> <span>'second!'</span><span>;</span>
        <span>}</span>

        <span>location</span> <span>/</span>third <span>{</span>
            <span>return</span> <span>200</span> <span>'third!'</span><span>;</span>
        <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>访问/first/1.txt的结果为：<code>html/third/1.txt</code>的内容</p>
<p>访问/second/1.txt的结果为：<code>html/third/1.txt</code>的内容</p>
<p>访问/third/1.txt的结果为：<code>third</code>的内容</p>
<p><strong>示例</strong>2</p>
<div><pre><code><span># http://www.test.com/test/abc/1.html ⇒ http://www.test.com/ccc/bbb/2.html</span>
<span>location</span> <span>/</span>test <span>{</span>
    <span>rewrite</span> <span>.</span><span>*</span> <span>/</span>ccc<span>/</span>bbb<span>/</span><span>2.</span>html permanent<span>;</span>
<span>}</span>

<span># http://www.test.com/2015/ccc/bbb/2.html ==> http://www.test.com/2014/ccc/bbb/2.html</span>
<span>location</span> <span>/</span><span>2015</span> <span>{</span>
    <span>rewrite</span> <span>^</span><span>/</span><span>2015</span><span>/</span><span>(</span><span>.</span><span>*</span><span>)</span>$ <span>/</span><span>2014</span><span>/</span>$<span>1</span> permanent<span>;</span>
<span>}</span>

<span># http://www.test.com/2015/ccc/bbb/2.html  ==> http://jd.com/index.php</span>
<span>location</span> <span>/</span><span>2015</span> <span>{</span>
    <span>if</span> <span>(</span><span>$host</span> <span>~</span><span>*</span> test<span>.</span>com<span>)</span> <span>{</span>
        <span>rewrite</span> <span>.</span><span>*</span> <span>http</span><span>:</span><span>/</span><span>/</span>www<span>.</span>jd<span>.</span>com<span>/</span><span>index</span><span>.</span>php permanent<span>;</span>
    <span>}</span>
<span>}</span>

<span># http://www.test.com/kkk/1.html ==> http://jd.com/kkk/1.html</span>
<span>location</span> <span>/</span> <span>{</span>
    <span>root</span> html<span>;</span>
    <span>index</span> <span>index</span><span>.</span>html <span>index</span><span>.</span>htm<span>;</span>
    <span>if</span> <span>(</span><span>$host</span> <span>~</span><span>*</span> test<span>.</span>com<span>)</span> <span>{</span>
        <span>rewrite</span> <span>.</span><span>*</span> <span>http</span><span>:</span><span>/</span><span>/</span>www<span>.</span>jd<span>.</span>com<span>/</span><span>$request_uri</span> permanent<span>;</span>
    <span>}</span>
<span>}</span>

<span># 有时候在访问一个二级子目录时会出现目录后的/无法补齐，如：</span>
<span>#  elinks --dump www.test.com/www  无法访问</span>
<span>#  elinks --dump www.test.com/www/可以访问 </span>
<span>if</span> <span>(</span><span>-</span>d <span>$request_filename</span><span>)</span> <span>{</span>
    <span>rewrite</span> <span>^</span><span>(</span><span>.</span><span>*</span><span>)</span><span>(</span><span>[</span><span>^</span><span>/</span><span>]</span><span>)</span>$ <span>http</span><span>:</span><span>/</span><span>/</span><span>$host</span>$<span>1</span>$<span>2</span><span>/</span> permanent<span>;</span>
<span>}</span>
<span># ^/(.*)([^/])$表示以/符号开始并紧跟着任何字符，同时不是以/为结束的字符串，在我的url中，(.*)表示的ww，([^/])表示的w</span>

<span># http://www.test.com/login/robin.html     ==>  http://www.test.com/reg/login.php?user=robin</span>
<span>location</span> <span>/</span>login <span>{</span>
    <span>rewrite</span> <span>^</span><span>/</span>login<span>/</span><span>(</span><span>.</span><span>*</span><span>)</span>\<span>.</span>html$ <span>/</span>reg<span>/</span>login<span>.</span>php<span>?</span><span>user</span><span>=</span>$<span>1</span> permanent<span>;</span>
<span>}</span>

<span># http://www.test.com/uplook/10-10-10.html  ==>  http://www.test.com/uplook/10/10/10.html </span>
<span>location</span> <span>/</span>uplook <span>{</span>
    <span>rewrite</span> <span>^</span><span>/</span>uplook<span>/</span><span>(</span><span>[</span><span>0</span><span>-</span><span>9</span><span>]</span><span>+</span><span>)</span><span>-</span><span>(</span><span>[</span><span>0</span><span>-</span><span>9</span><span>]</span><span>+</span><span>)</span><span>-</span><span>(</span><span>[</span><span>0</span><span>-</span><span>9</span><span>]</span><span>+</span><span>)</span>\<span>.</span>html$ <span>/</span>uplook<span>/</span>$<span>1</span><span>/</span>$<span>2</span><span>/</span>$<span>3.</span>html permanent<span>;</span>
<span>}</span>

<span># set 指令是用于定义一个变量，并且赋值。应用于server,location,if环境。</span>
<span># http://robin.test.com ==> http://www.test.com/robin</span>
<span># http://zorro.test.com ==> http://www.test.com/zorro</span>
<span>if</span> <span>(</span><span>$host</span> <span>~</span><span>*</span> <span>"^www.test.com$"</span><span>)</span> <span>{</span>
    <span>break</span><span>;</span>
<span>}</span>
<span>if</span> <span>(</span><span>$host</span> <span>~</span><span>*</span> <span>"^(.*)\.test\.com$"</span><span>)</span> <span>{</span>
    <span>set</span> <span>$user</span> $<span>1</span><span>;</span>
    <span>rewrite</span> <span>.</span><span>*</span> <span>http</span><span>:</span><span>/</span><span>/</span>www<span>.</span>test<span>.</span>com<span>/</span><span>$user</span> permanent<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><blockquote>
<p>last 一般写在server和if中，而break一般使用在location中</p>
</blockquote>
<h3 id="_3-3-if指令"> 3.3 if指令</h3>
<div><pre><code>Syntax:	if (condition) { ... }
Default:	—
Context:	server, location
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>规则：条件condition为真，则执行大括号内的指令；遵循值指令的继承规则</p>
<p><strong>if指令的条件表达式</strong></p>
<ul>
<li>检查变量为空或者值是否为0，直接使用
<ul>
<li>当表达式只是一个变量时，如果值为空或任何以 0 开头的字符串都会当做 false</li>
</ul>
</li>
<li>将变量与字符串做匹配，使用=或者!=</li>
<li>将变量与正则表达式做匹配
<ul>
<li>大小写敏感，<sub>或者!</sub></li>
<li>大小写不敏感，<sub>*或者!</sub>*</li>
</ul>
</li>
<li>检查文件是否存在，使用-f或者!-f</li>
<li>检查目录是否存在，使用-d或者!-d</li>
<li>检查文件、目录、软连接是否存在，使用-e或者!-e</li>
<li>检查是否为可执行文件，使用-x或者!-x</li>
</ul>
<p><strong>示例</strong></p>
<div><pre><code><span>if</span> <span>(</span><span>$http_user_agent</span> <span>~</span> MSIE<span>)</span> <span>{</span>
    <span>rewrite</span> <span>^</span><span>(</span><span>.</span><span>*</span><span>)</span>$ <span>/</span>msie<span>/</span>$<span>1</span> <span>break</span><span>;</span>
<span>}</span>
<span>if</span> <span>(</span><span>$http_cookie</span> <span>~</span><span>*</span> <span>"id=([^;]+)(?:;|$)"</span><span>)</span> <span>{</span>
    <span>set</span> <span>$id</span> $<span>1</span><span>;</span>
<span>}</span>
<span>if</span> <span>(</span><span>$repuest_method</span> <span>=</span> POST<span>)</span> <span>{</span>
    <span>return</span> <span>405</span><span>;</span>
<span>}</span>
<span>if</span> <span>(</span><span>$slow</span><span>)</span> <span>{</span>
    <span>limit_rate</span> <span>10</span>k<span>;</span>
<span>}</span>
<span>if</span> <span>(</span><span>$invalid_referer</span><span>)</span> <span>{</span>
    <span>return</span> <span>403</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="_3-4-rewrite-log指令"> 3.4 rewrite_log指令</h3>
<div><pre><code>Syntax: rewrite_log on | off;
Default:    rewrite_log off;
Context:    http, server, location, if
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="_4-realip模块"> 4 realip模块</h2>
<ul>
<li>默认不会编译进Nginx，通过<code>--with-http_reaip_module</code>启用功能</li>
<li>功能：修改客户端地址</li>
<li>指令：set_real_ip_from、real_ip_header、real_ip_recursive</li>
<li>变量：reaip_remote_addr、reaip_remote_port</li>
</ul>
<h3 id="_4-1-directives"> 4.1 Directives</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200317100631841.png" alt="" /></p>
<h2 id="_5-limit-conn模块"> 5 limit_conn模块</h2>
<p>生效阶段：NGX_HTTP_PREACCESS_PHASE阶段</p>
<p>生效范围：全部worker进程（基于共享内存），进入preaccess阶段前不生效，限制的有效性取决于key的设计：依赖postread阶段的realip模块取到真实ip</p>
<h3 id="_5-1-指令"> 5.1 指令</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200321202747188.png" alt="" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200321202819297.png" alt="" /></p>
<h2 id="_6-limit-req模块"> 6 limit_req模块</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200323104235892.png" alt="" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200323104251827.png" alt="" /></p>
<h3 id="_6-1-指令"> 6.1 指令</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200323104336149.png" alt="" /></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200323104534992.png" alt="" /></p>
<p>限制发生时向客户端返回的错误码</p>
<div><pre><code>Syntax:	limit_req_status code;
Default:	limit_req_status 503;
Context:	http, server, location
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>limit_req 与 limit_conn 配置同时生效时， limit_req有效</p>
</blockquote>
<h3 id="_6-2-example"> 6.2 Example</h3>
<div><pre><code><span>http</span> <span>{</span>
    <span>geo</span> <span>$limit</span> <span>{</span>
        default <span>1</span><span>;</span>
        <span>10.0</span><span>.0</span><span>.0</span><span>/</span><span>8</span> <span>0</span><span>;</span>
        <span>192.168</span><span>.0</span><span>.0</span><span>/</span><span>64</span> <span>0</span><span>;</span>
    <span>}</span>
    
    <span>map</span> <span>$limit</span> <span>$limit_key</span> <span>{</span>
        <span>0</span> <span>""</span><span>;</span>
        <span>1</span> <span>$binary_remote_addr</span><span>;</span>
    <span>}</span>
    
    <span>limit_req_zone</span> <span>$limit_key</span> zone<span>=</span>req_zone<span>:</span><span>10</span>m rate<span>=</span><span>5</span>r<span>/</span>s<span>;</span>
    
    <span>server</span> <span>{</span>
        <span>location</span> <span>/</span> <span>{</span>
            <span>limit_req</span> zone<span>=</span>req_zone burst<span>=</span><span>10</span> nodelay<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>这个例子同时使用了geo和map指令。geo块将给在白名单中的IP地址对应的$limit变量分配一个值0，给其它不在白名单中的分配一个值1。然后我们使用一个映射将这些值转为key，如下：</p>
<p>如果<code>$limit</code>变量的值是0，<code>$limit_key</code>变量将被赋值为空字符串</p>
<p>如果<code>$limit</code>变量的值是1，<code>$limit_key</code>变量将被赋值为客户端二进制形式的IP地址</p>
<p>两个指令配合使用，白名单内IP地址的$limit_key变量被赋值为空字符串，不在白名单内的被赋值为客户端的IP地址。当limit_req_zone后的第一个参数是空字符串时，不会应用“流量限制”，所以白名单内的IP地址(10.0.0.0/8和192.168.0.0/24 网段内)不会被限制。其它所有IP地址都会被限制到每秒5个请求。</p>
<p>limit_req指令将限制应用到**/**的location块，允许在配置的限制上最多超过10个数据包的突发，并且不会延迟转发。</p>
<blockquote>
<p>参考链接：</p>
<p>https://www.jianshu.com/p/bbb51f727d46</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">6. nginx的常见问题</title>
    <id>https://clay-wangzhi.com/web/nginx/qa/</id>
    <link href="https://clay-wangzhi.com/web/nginx/qa/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_6-nginx的常见问题"> 6. nginx的常见问题</h1>
<h2 id="nginx前面有多个反向代理时-proxy的正确设置"> nginx前面有多个反向代理时，proxy的正确设置</h2>
<div><pre><code>#proxy_redirect off;
#proxy_set_header Host $host
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>注释掉这两行，让它使用默认配置</p>
<h2 id="nginx解决跨域问题"> nginx解决跨域问题</h2>
<p>在nginx.conf中编辑</p>
<div><pre><code><span>server</span> <span>{</span>
        <span>location</span> <span>/</span> <span>{</span>
            <span>root</span>   html<span>;</span>
            <span>index</span>  <span>index</span><span>.</span>html <span>index</span><span>.</span>htm<span>;</span>
            <span>/</span><span>/</span>允许cros跨域访问
            <span>add_header</span> <span>'Access-Control-Allow-Origin'</span> <span>'*'</span><span>;</span>
        <span>}</span>
 <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="从http跳转到https"> 从http跳转到https</h2>
<p>项目前期使用http，后期为了安全方面的考虑，启用了https。
项目架构：前端使用nginx作为多个tomcat实例的反向代理和负载均衡。
实际上只需要在nginx上启用https即可，使客户端与nginx之后使用https方式通信，而nginx与tomcat之间依然以http方式通信。</p>
<p>现在需要将之前客户端所有的http请求全部都自动重定向为https，只需要在nginx上添加相应配置即可。</p>
<h3 id="使用rewrite指令"> 使用rewrite指令</h3>
<div><pre><code><span>server</span> <span>{</span>
    <span>listen</span> <span>80</span><span>;</span>
    <span>server_name</span> domain<span>.</span>com<span>;</span>
    <span>rewrite</span> <span>^</span><span>(</span><span>.</span><span>*</span><span>)</span> <span>https</span><span>:</span><span>/</span><span>/</span><span>$server_name</span>$<span>1</span> permanent<span>;</span>
<span>}</span>
<span>server</span> <span>{</span>
    <span>listen</span> <span>443</span> <span>ssl</span><span>;</span>
    <span>server_name</span> domain<span>.</span>com<span>;</span>
    <span>ssl</span> on<span>;</span>
    <span>ssl_certificate</span>     <span>/</span>etc<span>/</span>nginx<span>/</span><span>ssl</span><span>/</span>domain<span>.</span>com<span>.</span>crt<span>;</span>
    <span>ssl_certificate_key</span> <span>/</span>etc<span>/</span>nginx<span>/</span><span>ssl</span><span>/</span>domain<span>.</span>com<span>.</span>crt<span>;</span>
    <span># other</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>如果此时nginx作为Tomcat的前端反向代理的话，需要将相应配置放在配置ssl的server块中。</p>
<h3 id="使用return指令"> 使用return指令</h3>
<div><pre><code><span>server</span> <span>{</span>
    <span>listen</span> <span>80</span><span>;</span>
    <span>server_name</span> domain<span>.</span>com<span>;</span>
    <span>return</span> <span>301</span> <span>https</span><span>:</span><span>/</span><span>/</span><span>$server_name</span><span>$request_uri</span><span>;</span>
<span>}</span>
<span>server</span> <span>{</span>
    <span>listen</span> <span>443</span> <span>ssl</span><span>;</span>
    <span>server_name</span> domain<span>.</span>com<span>;</span>
    <span>ssl</span> on<span>;</span>
    <span>ssl_certificate</span>     <span>/</span>etc<span>/</span>nginx<span>/</span><span>ssl</span><span>/</span>domain<span>.</span>com<span>.</span>crt<span>;</span>
    <span>ssl_certificate_key</span> <span>/</span>etc<span>/</span>nginx<span>/</span><span>ssl</span><span>/</span>domain<span>.</span>com<span>.</span>crt<span>;</span>
    <span># other</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>如果此时nginx作为Tomcat的前端反向代理的话，需要将相应配置放在配置ssl的server块中。</p>
<h3 id="使用error-page指令"> 使用error_page指令</h3>
<p>只允许HTTP来访问时，用HTTP访问会让Nginx报497错误，然后利用error_page将链接重定向至HTTPS上。</p>
<div><pre><code><span>server</span> <span>{</span>
    <span>listen</span> <span>80</span><span>;</span>
    <span>listen</span> <span>443</span> <span>ssl</span><span>;</span>
    <span>server_name</span> domain<span>.</span>com<span>;</span>
    <span>ssl</span> on<span>;</span>
    <span>ssl_certificate</span>     <span>/</span>etc<span>/</span>nginx<span>/</span><span>ssl</span><span>/</span>domain<span>.</span>com<span>.</span>crt<span>;</span> 
    <span>ssl_certificate_key</span> <span>/</span>etc<span>/</span>nginx<span>/</span><span>ssl</span><span>/</span>domain<span>.</span>com<span>.</span>crt<span>;</span>
    <span># other</span>
    <span>error_page</span> <span>497</span> <span>https</span><span>:</span><span>/</span><span>/</span><span>$server_name</span><span>$request_uri</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>使用error_page指令时，将http和https的监听配置写在同一个server块中，对应的其他配置也需要在该server配置块中完成。</p>
<p>需要注意的是，此时需要将<code>error_page</code>指令语句写在最后，否则不能生效。</p>
<h2 id="nginx出现403的原因"> nginx出现403的原因</h2>
<h3 id="缺少index-html"> 缺少index.html</h3>
<p>缺少index.html或者index.php文件，就是配置文件中index index.html index.htm这行中的指定的文件</p>
<div><pre><code>server {  
      listen       80;  
      server_name  localhost;  
      index  index.php index.html;  
      root  /data/www/;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果在/data/www/下面没有index.php,index.html的时候，直接文件，会报403 forbidden。</p>
<h3 id="权限问题"> 权限问题</h3>
<p>1）查看nginx的启动用户</p>
<div><pre><code>ps aux | grep &quot;nginx: worker process&quot; | grep -v &quot;grep&quot; | awk &#39;{ print $1 }&#39;
</code></pre>
<div><span>1</span><br></div></div><p><code>index</code>文件的权限，<code>nginx</code>启动用户要有读的权限，<code>index</code>所在的目录要有可以访问目录内容的权限（递归都要有，每一级）</p>
<p>如果nginx没有web目录的操作权限，也会出现403错误。上一级目录权限，有读的权限就行，不必要改为777</p>
<p>解决办法：修改web目录的读写权限，或者是把nginx的启动用户改成目录的所属用户，重启Nginx即可解决</p>
<div><pre><code>chmod -R 777 /data
chmod -R 777 /data/www/
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="selinux设置问题"> SELinux设置问题</h3>
<p>设置为：<code>SELINUX=disabled</code></p>
<h2 id="通过nginx实现蓝绿发布"> 通过nginx实现蓝绿发布</h2>
<p>样例</p>
<p><code>nginx.conf</code>通过两个子配置文件来实现</p>
<div><pre><code><span>include</span> conf<span>.</span>d<span>/</span>v1<span>.</span>conf
<span>#include conf.d/v2.conf</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>v1.conf</code></p>
<div><pre><code><span>upstream</span> app_v1 <span>{</span>
	<span>server</span> <span>192.168</span><span>.1</span><span>.2</span><span>:</span><span>8080</span><span>;</span>
    <span>server</span> <span>192.168</span><span>.1</span><span>.3</span><span>:</span><span>8080</span><span>;</span>
<span>}</span>
<span>upstream</span> app_v2 <span>{</span>
    <span>server</span> <span>192.168</span><span>.1</span><span>.3</span><span>:</span><span>8080</span><span>;</span>
    <span>server</span> <span>192.168</span><span>.1</span><span>.4</span><span>:</span><span>8080</span><span>;</span>
<span>}</span>

<span>server</span> <span>{</span>
    <span>listen</span> <span>80</span><span>;</span>
    <span>server_name</span> localhost<span>;</span>
    <span>set</span> <span>$group</span> <span>"app_v1"</span><span>;</span>
    <span>location</span> <span>/</span> <span>{</span>
        <span>proxy_pass</span> <span>http</span><span>:</span><span>/</span><span>/</span><span>$group</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><code>v2.conf</code></p>
<div><pre><code><span>upstream</span> app_v1 <span>{</span>
	<span>server</span> <span>192.168</span><span>.1</span><span>.2</span><span>:</span><span>8080</span><span>;</span>
    <span>server</span> <span>192.168</span><span>.1</span><span>.3</span><span>:</span><span>8080</span><span>;</span>
<span>}</span>
<span>upstream</span> app_v2 <span>{</span>
    <span>server</span> <span>192.168</span><span>.1</span><span>.3</span><span>:</span><span>8080</span><span>;</span>
    <span>server</span> <span>192.168</span><span>.1</span><span>.4</span><span>:</span><span>8080</span><span>;</span>
<span>}</span>

<span>server</span> <span>{</span>
    <span>listen</span> <span>80</span><span>;</span>
    <span>server_name</span> localhost<span>;</span>
    <span>set</span> <span>$group</span> <span>"app_v2"</span><span>;</span>
    <span>location</span> <span>/</span> <span>{</span>
        <span>proxy_pass</span> <span>http</span><span>:</span><span>/</span><span>/</span><span>$group</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>有的时候还是结合cookie进行使用</p>
<div><pre><code><span>if</span> <span>(</span><span>$http_cookie</span> <span>~</span><span>*</span> <span>"version=V1"</span><span>)</span> <span>{</span>
	<span>set</span> <span>$group</span> app_v1<span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="nginx-allow-多个ip-ipv4的网段表示方法解析"> nginx allow 多个ip &amp; ipv4的网段表示方法解析</h2>
<p>单看<a href="http://www.ttlsa.com/nginx/" target="_blank" rel="noopener noreferrer">nginx</a>模块名<code>ngx_http_access_module</code>,很多人一定很陌生，但是deny和allow相比没一个人不知道的，实际上deny和allow指令属于ngx_http_access_module.我们想控制某个uri或者一个路径不让人访问，在nginx就得靠它了。</p>
<p>nginx的访问控制模块语法很简单，至少比apache好理解，apache的allow和deny的顺序让很多初学者抓头.好了具体看下这个插件的使用方法吧。</p>
<h3 id="_1、安装模块"> 1、安装模块</h3>
<p>这个模块内置在了nginx中，除非你安装中使用了--without-http_access_module。如果你还没安装过nginx，那么请参考下ttlsa之前写的<a href="http://www.ttlsa.com/html/1548.html" target="_blank" rel="noopener noreferrer">nginx安装</a>.</p>
<h3 id="_2、指令"> 2、指令</h3>
<p>allow
语法:    allow address | CIDR | unix: | all;
默认值:    —
配置段:    http, server, location, limit_except</p>
<p>允许某个ip或者一个ip段访问.如果指定unix:,那将允许socket的访问.注意：unix在1.5.1中新加入的功能，如果你的版本比这个低，请不要使用这个方法。</p>
<p>deny
语法:    deny address | CIDR | unix: | all;
默认值:    —
配置段:    http, server, location, limit_except</p>
<p>禁止某个ip或者一个ip段访问.如果指定unix:,那将禁止socket的访问.注意：unix在1.5.1中新加入的功能，如果你的版本比这个低，请不要使用这个方法。</p>
<h3 id="_3-allow、deny实例"> 3. allow、deny实例</h3>
<p>location / {
deny 192.168.1.1;
allow 192.168.1.0/24;
allow 10.1.1.0/16;
allow 2001:0db8::/32;
deny all;
}</p>
<p>从上到下的顺序，类似iptables。匹配到了便跳出。如上的例子先禁止了192.16.1.1，接下来允许了3个网段，其中包含了一个ipv6，最后未匹配的IP全部禁止访问. 在实际生产环境中，我们也会使用nginx 的geo模块配合使用，有兴趣的请参考ttlsa相关文章<a href="http://www.ttlsa.com/html/3203.html" target="_blank" rel="noopener noreferrer">nginx geo使用方法</a>.</p>
<h3 id=""> </h3>
<p>nginx访问控制模块要数nginx里面最简单的指令，只要记住你想禁止谁访问就deny加上IP，想允许则加上allow ip，想禁止或者允许所有，那么allow all或者deny all即可.</p>
<p>但是具体的配置出现很多问题</p>
<p>简单一点举例说明：
ip段：10.0.0.1-10.0.0.255        的表示方法：10.0.0.0/24
ip段：10.0.0.1-10.0.255.255     的表示方法：10.0.0.0/16
ip段：10.0.0.1-10.255.255.255    的表示方法：10.0.0.0/8</p>
<p>利用主机数来计算</p>
<p>1)将主机数目转化为二进制来表示</p>
<p>2)如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为 N，这里肯定 N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位。</p>
<p>3)使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。</p>
<p>如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：</p>
<ol>
<li>700=1010111100</li>
<li>该二进制为十位数，N = 10</li>
<li>将该B类地址的子网掩码255.255.0.0的主机地址全部置 1，得到255.255.255.255 然后再从后向前将后 10位置0,即为： 11111111.11111111.11111100.00000000 即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。</li>
</ol>
<p>二进制表（表1）</p>
<p>0  0  0  0   0  0  0 0</p>
<p>128 64 32 16  8  4   2 1</p>
<p>CIDR值（表2）</p>
<p>子网掩码           CIDR值</p>
<p>255.0.0.0           /8</p>
<p>255.128.0.0          /9</p>
<p>255.192.0.0          /10</p>
<p>255.224.0.0          /11</p>
<p>255.240.0.0          /12</p>
<p>255.248.0.0          /13</p>
<p>255.252.0.0          /14</p>
<p>255.254.0.0          /15</p>
<p>255.255.0.0          /16</p>
<p>255.255.128.0        /17</p>
<p>255.255.192.0        /18</p>
<p>255.255.224.0        /19</p>
<p>255.255.240.0        /20</p>
<p>255.255.248.0        /21</p>
<p>255.255.252.0        /22</p>
<p>255.255.254.0        /23</p>
<p>255.255.255.0        /24</p>
<p>255.255.255.128       /25</p>
<p>255.255.255.192       /26</p>
<p>255.255.255.224       /27</p>
<p>255.255.255.240       /28</p>
<p>255.255.255.248       /29</p>
<p>255.255.255.252       /30</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">1. 初识Nginx</title>
    <id>https://clay-wangzhi.com/web/nginx/</id>
    <link href="https://clay-wangzhi.com/web/nginx/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_1-初识nginx"> 1. 初识Nginx</h1>
<h2 id="_1-nginx的三个主要应用场景"> 1 Nginx的三个主要应用场景</h2>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200102212417067.png" alt="" /></p>
<p>三个主要应用场景为：</p>
<ul>
<li>静态资源服务（通过本地文件系统提供服务）</li>
<li>反向代理服务</li>
<li>API服务（OpenRestydeng ）</li>
</ul>
<h3 id="_1-1-反向代理服务"> 1.1 反向代理服务</h3>
<h4 id="_1-1-1-负载均衡"> 1.1.1 负载均衡</h4>
<p>负载均衡，一般包含两方面的含义。</p>
<ul>
<li>
<p>一方面是，将单一的重负载分担到多个网络节点上做并行处理，每个节点处理结束后将结构汇总返回给用户，这样可以大幅提高网络系统的处理能力；</p>
</li>
<li>
<p>第二个方面的含义是，将大量的前段并发访问或数据流量分担到多个后端网络节点上分别处理，这样可以有效减少前端用户等待响应的时间。</p>
</li>
</ul>
<p>Web服务器、FTP服务器、企业关键应用服务器等关键应用服务器等网络应用方面谈到的负载均衡问题，基本隶属于后一方面的含义。</p>
<p>因此，Nginx服务器的负载均衡主要是对大量前端访问和流量进行分流，以保证前端用户访问效率。可以说，在绝大多数的Nginx应用中，都会或多或少涉及它的负载均衡服务。</p>
<h5 id="复制均衡策略"> 复制均衡策略</h5>
<p>即内置策略和扩展策略。</p>
<ol>
<li>
<p>内置策略主要包括轮询、加权轮询和IP hash三种；</p>
</li>
<li>
<p>扩展策略主要通过第三方模块实现，种类比较丰富，常见的有url hash、fair等。</p>
</li>
</ol>
<blockquote>
<p>在默认情况下，内置策略会被编译进Nginx内核，使用时只需要在Nginx服务器配置中设置相关参数即可；</p>
<p>扩展策略不会编译进Nginx内核，需要手动将第三方模块编译到Nginx内核。</p>
</blockquote>
<p><strong>轮询</strong></p>
<p>轮询策略比较简单，就是将前端请求按顺序（时间顺序或者排列次序）逐一分配到不同的后端节点上，对于出现问题的后端节点自动排除。</p>
<p><strong>加权轮询</strong></p>
<p>加权轮询策略，顾名思义，就是在基本的轮询策略上考虑各后端节点接受请求的权重，指定各后端节点被轮询到的几率。</p>
<p>加权轮询策略主要用于后端节点不均的情况。根据后端节点性能的实际情况，我们可以在Nginx服务器的配置文件中调整权值，使得整个网络对前端请求达到最佳的响应能力。</p>
<p><strong>IP hash</strong></p>
<p><code>IP hash</code>策略，是将前端的访问<code>IP</code>进行<code>hash</code>操作，然后根据<code>hash</code>结果将请求分配给不同的后端节点。</p>
<p>事实上，这种策略可以看作是一种特殊的轮询策略。</p>
<p>通过Nginx的实现，每个前端访问IP会固定访问一个后端节点。这样做的好处是避免考虑前端用户的session在后端多个节点上共享的问题。</p>
<p><strong>url hash</strong></p>
<p>扩展策略中的<code>url hash</code>在形式上和<code>IP hash</code>相近，不同之处在于，<code>IP hash</code>策略是对前端访问IP进行了hash操作，而<code>url hash</code>策略是对前端请求的<code>url</code>进行了<code>hash</code>操作。<code>url hash</code>策略的优点在于，如果后端有缓存服务器，它能够高缓存效率，同时也解决了<code>session</code>的问题；但其缺点是，如果后端节点出现异常，它不能自动排除该节点。后端节点出现异常会导致Nginx服务器返回503错误。</p>
<p><strong>fair</strong></p>
<p>扩展的第三方模块<code>fair</code>则是从另一个角度来实现Nginx服务器负载均衡策略的。该模块将前端请求转发到一个最近负载最小的后台节点。Nginx通过后端节点对请求的响应时间来判断负载情况。响应时间短的节点负载相对就轻。得出判断结果后，Nginx就将前端请求转发到选中的负载最轻的节点。</p>
<h4 id="_1-1-2-web缓存"> 1.1.2 Web缓存</h4>
<p>Squid在Web服务器领域中是一款相当流行的开源代理服务器和Web缓存服务器。作为网页服务器的前置缓存服务器，在很多优秀的站点中，它被用以缓存前端请求，从而提高Web服务器的性能；而且，它还可以缓存万维网、域名系统或者其他网络搜索等，为一个集体提供网路资源共享服务。</p>
<p>Nginx服务器从0.7.48版本开始，也支持了和Squid类似的缓存功能。</p>
<p>Nginx服务器的Web缓存服务主要由Proxy_Cache相关指令集和FastCGI_Cache相关指令集构成。</p>
<p>其中，Proxy_Cache主要用于在Nginx服务器提供反向代理服务时，对后端源服务器的返回内容进行URL缓存；</p>
<p>FastCGI_Cache主要用于对FastCGI的动态程序进行缓存。</p>
<p>另外还有一款常用的第三方模块ngx_cache_purge也是Nginx服务器Web缓存功能中经常用到的。它主要用于清除Nginx服务器上指定的URL缓存。</p>
<p>到Nginx 0.8.32版本，Proxy_Cache和FastCGI_Cache两部分的功能已经比较完善，再配合第三方的ngx_cache_purge模块，Nginx服务器已经具备了Squid所拥有的Web缓存加速功能和清除指定URL缓存的功能；</p>
<p>同时，Nginx服务器对多核CPU的调度比Squid更胜一筹，性能高于Squid，而在反向代理、负载均衡等其他方面，Nginx也不逊于Squid。这使得Nginx服务器可以同时作为负载均衡服务器和Web缓存服务器来使用，基本可以取代Squid。</p>
<h2 id="_2-nginx的优点"> 2 Nginx的优点</h2>
<p><strong>nginx的优点</strong></p>
<ul>
<li>
<p>轻量级，同样起web服务比apache占用更少内存及资源；</p>
</li>
<li>
<p>Nginx 异步非阻塞的方式处理高并发请求，能保持低资源、低消耗、高性能；</p>
</li>
<li>
<p>高度模块化设计，编写模块相对简单，生态圈强大。</p>
</li>
<li>
<p>核心优点：高并发、高性能、高可扩展、高可靠性、热部署、BSD许可证。</p>
</li>
</ul>
<p><strong>Nginx为什么性能高、占用内存少？</strong></p>
<ul>
<li>Nginx采用多进程模式，对每个worker进程来说，独立的进程不需要加锁，互不影响；</li>
<li>一个进程退出后，其他进程继续工作，服务不会中断，master进程则很快启动新的worker进程；</li>
<li>worker进程异常退出肯定是程序有bug导致，但也只会影响当前worker上的请求，不会影响到其他进程的请求，降低风险；</li>
<li>Nginx采用异步非阻塞的方式去处理请求，更加高效。</li>
</ul>
<h2 id="_3-nginx的组成"> 3 Nginx的组成</h2>
<ol>
<li>Nginx二进制可执行文件
<ul>
<li>由各模块源码编译出的一个文件</li>
</ul>
</li>
<li><code>nginx.conf</code>配置文件
<ul>
<li>控制<code>nginx</code>的行为</li>
</ul>
</li>
<li><code>access.log</code>访问日志
<ul>
<li>记录每一条http请求信息</li>
</ul>
</li>
<li><code>error.log</code>错误日志
<ul>
<li>定位问题</li>
</ul>
</li>
</ol>
<h2 id="_4-编译安装nginx"> 4 编译安装Nginx</h2>
<h3 id="_4-1-下载nginx"> 4.1 下载Nginx</h3>
<blockquote>
<p>nginx下载地址：http://nginx.org/download/</p>
<p>在官网找最新稳定版使用：http://nginx.org/en/download.html</p>
</blockquote>
<div><pre><code>cd /opt
wget http://nginx.org/download/nginx-1.16.1.tar.gz
tar -xvf nginx-1.16.1.tar.gz
cd nginx-1.16.1/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_4-2-介绍各目录"> 4.2 介绍各目录</h3>
<div><pre><code><span># ls</span>
auto  CHANGES  CHANGES.ru  conf  configure  contrib  html  LICENSE  <span>man</span>  README  src
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>
<p>auto：包含了很多会在执行configure进行编译配置时调用的检测代码。</p>
</li>
<li>
<p>CHANGES：Nginx的版本更新细节记录。英文版。</p>
</li>
<li>
<p>CHANGES.ru：Nginx的版本更新细节记录。俄文版。</p>
</li>
<li>
<p>conf：Nginx提供的一些默认配置文件。</p>
</li>
<li>
<p>configure：根据系统环境设定Nginx编译选项的执行脚本。</p>
</li>
<li>
<p>contrib：网友贡献的一些有用脚本（对我来说，里面的vim设置很有用，README中有使用方法）。</p>
<ul>
<li>
<div><pre><code>把contrib/vim下的文件移入~/.vim目录下，让vim识别nginx的配置文件节点；
cp -r contrib/vim/* ~/.vim
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
</li>
<li>
<p>html：提供了两个默认html页面，比如index.html的Welcome to nginx!。</p>
</li>
<li>
<p>LICENSE：声明的Nginx源码许可协议。</p>
</li>
<li>
<p>man：Nginx的Man手册，本文文件，可直接用vi或记事本打开。</p>
</li>
<li>
<p>README：读我文件，内容很简单，通告一下官网地址。</p>
</li>
<li>
<p>src：Nginx源码，分门别类，比如实现事件的event等，很清晰。</p>
</li>
</ul>
<h3 id="_4-3-configure"> 4.3 Configure</h3>
<p>先安装相关依赖</p>
<blockquote>
<p>gzip模块需要zlib库</p>
<p>rewrite模块需要pcre库</p>
<p>ssl功能需要openssl库</p>
</blockquote>
<div><pre><code>yum -y install gcc gcc-c++ make zlib-devel pcre-devel openssl-devel
</code></pre>
<div><span>1</span><br></div></div><p>然后运行<code>configure</code>文件</p>
<div><pre><code># ./configure --help
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>--prefix ：指定安装目录</li>
<li>--with：新增模块</li>
<li>--without：删除默认模块</li>
</ul>
<p>运行期中与路径相关的各种参数</p>
<div><pre><code>--prefix=PATH                        #指向安装目录
--sbin-path=PATH                     #指向（执行）程序文件（nginx）
--conf-path=PATH                     #指向配置文件（nginx.conf）
--error-log-path=PATH                #指向错误日志目录
--http-log-path=PATH                 #指定访问日志目录
--pid-path=PATH                      #指向pid文件（nginx.pid）
--lock-path=PATH                     #指向lock文件（nginx.lock）（安装文件锁定，防止安装文件被别人利用，或自己误操作。）
--builddir=PATH                      #指向编译目录
--http-client-body-temp-path=PATH    #设定http客户端请求临时文件路径
--http-proxy-temp-path=PATH          #设定http代理临时文件路径
--http-fastcgi-temp-path=PATH        #设定http fastcgi临时文件路径
--http-uwsgi-temp-path=PATH          #设定http uwsgi临时文件路径
--http-scgi-temp-path=PATH           #设定http scgi临时文件路径

--user=USER                          #指定程序运行时的非特权用户
--group=USER                         #指定程序运行时的非特权用户组

--with-rtsig_module                  #启用rtsig模块支持（实时信号）
--with-file-aio                      #启用file aio支持（一种APL文件传输格式）
--with-ipv6                          #启用ipv6支持
--with-select_module                 #启用select模块支持（一种轮询模式,不推荐在高载环境下使用）禁用：--without-select_module
--with-poll_module                   #启用poll模块支持（功能与select相同，与select特性相同，为一种轮询模式,不推荐在高载环境下使用）
--with-http_ssl_module               #启用支持https请求，需已安装openssl
--with-http_realip_module            #启用ngx_http_realip_module支持（这个模块允许从请求标头更改客户端的IP地址值，默认为关）
--with-http_addition_module          #启用ngx_http_addition_module支持（作为一个输出过滤器，支持不完全缓冲，分部分响应请求）
--with-http_xslt_module              #启用ngx_http_xslt_module支持（过滤转换XML请求）
--with-http_image_filter_module      #启用支持传输JPEG/GIF/PNG 图片过滤，默认为不启用，gd库要用到
--with-http_sub_module               #启用ngx_http_sub_module支持（允许用一些其他文本替换nginx响应中的一些文本）
--with-http_dav_module               #启用ngx_http_dav_module支持（增加PUT,DELETE,MKCOL：创建集合,COPY和MOVE方法）
--with-http_flv_module               #启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件）
--with-http_gzip_static_module       #启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）
--with-http_random_index_module      #启用ngx_http_random_index_module支持（从目录中随机挑选一个目录索引）
--with-http_secure_link_module       #启用ngx_http_secure_link_module支持（计算和检查要求所需的安全链接网址）
--with-http_degradation_module       #启用ngx_http_degradation_module支持（允许在内存不足的情况下返回204或444码）
--with-http_stub_status_module       #启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）
--with-http_perl_module              #启用ngx_http_perl_module支持（该模块使nginx可以直接使用perl或通过ssi调用perl）

--with-mail                          #启用POP3/IMAP4/SMTP代理模块支持
--with-mail_ssl_module               #启用ngx_mail_ssl_module支持
--add-module=                        #启用外部模块支持
--with-cpu-opt=                      #指定编译的CPU，可用的值为: pentium,opteron, amd64, sparc32, sparc64, ppc64等
--with-pcre                          #启用pcre库（默认会自动去找rpm包安装的pcre库文件以及模块）
--with-pcre=                         #指向pcre库文件目录（如果是源码安装就需要指定，rpm包安装就不需要指定了）
--with-pcre-opt=                     #在编译时为pcre库设置附加参数
--with-perl_modules_path=            #设定perl模块路径
--with-perl=                         #设定perl库文件路径
--with-debug                         #启用debug日志
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>安装额外的echo模块</p>
<div><pre><code>cd /opt
git clone https://github.com/openresty/echo-nginx-module
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>./configure \
--prefix=/etc/nginx \
--sbin-path=/usr/sbin/nginx \
--conf-path=/etc/nginx/nginx.conf \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--pid-path=/var/run/nginx.pid \
--lock-path=/var/run/nginx.lock \
--http-client-body-temp-path=/var/cache/nginx/client_temp \
--http-proxy-temp-path=/var/cache/nginx/proxy_temp \
--http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \
--http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \
--http-scgi-temp-path=/var/cache/nginx/scgi_temp \
--user=nginx \
--group=nginx \
--with-compat \
--with-file-aio \
--with-threads \
--with-http_addition_module \
--with-http_auth_request_module \
--with-http_dav_module \
--with-http_flv_module \
--with-http_gunzip_module \
--with-http_gzip_static_module \
--with-http_mp4_module \
--with-http_random_index_module \
--with-http_realip_module \
--with-http_secure_link_module \
--with-http_slice_module \
--with-http_ssl_module \
--with-http_stub_status_module \
--with-http_sub_module \
--with-http_v2_module \
--with-pcre \
--with-mail \
--with-mail_ssl_module \
--with-stream \
--with-stream_realip_module \
--with-stream_ssl_module \
--with-stream_ssl_preread_module \
--with-cc-opt=&#39;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC&#39; \
--with-ld-opt=&#39;-Wl,-z,relro -Wl,-z,now -pie&#39; \
--add-module=/opt/echo-nginx-module

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>执行完后，会生成<code>objs</code>目录</p>
<p>目录下的关键文件<code>ngx_modules.c</code>，它决定了我们编译nginx时，哪些模块会被编译进nginx</p>
<h3 id="_4-4-中间件介绍"> 4.4 中间件介绍</h3>
<p>中间件放在<code>objs/src</code>目下</p>
<h3 id="_4-5-编译"> 4.5 编译</h3>
<div><pre><code>make -j 4
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>-j 参数，指定编译时的CPU数量，可加快编译速度</li>
</ul>
<p>执行完后，在<code>objs</code>目录下生成二进制可执行文件</p>
<blockquote>
<p>注意：如何这时，我们是升级nginx，现在就不需要<code>make install</code>了</p>
</blockquote>
<h3 id="_4-6-安装"> 4.6 安装</h3>
<div><pre><code>make install
</code></pre>
<div><span>1</span><br></div></div><p>执行完成后，会在<code>--prefix</code>目录下生成四个目录，我这里是<code>/home/clay</code>目录下</p>
<ul>
<li>conf： 配置文件目录</li>
<li>html：默认的静态页面存放目录</li>
<li>logs：默认access和error  log存放目录</li>
<li>sbin：二进制可执行文件<code>nginx</code>存放目录</li>
</ul>
<blockquote>
<p>安装nginx，个人还是推荐yum源安装（里面自动包含了日志切割等）</p>
<p>可以yum源安装完成之后，再定制化模块，二次编译</p>
</blockquote>
<h2 id="_5-nginx配置语法"> 5 Nginx配置语法</h2>
<ol>
<li>配置文件由指令与指令块构成</li>
<li>每条指令以<code>;</code>分号结尾，指令与参数见以空格符号分隔</li>
<li>指令块以<code>{ }</code>大括号将多条指令组织在一起</li>
<li><code>include</code>语句允许组合多个配置文件以提升可维护性</li>
<li>使用<code>#</code>符号添加注释，提高可读性</li>
<li>使用<code>$</code>符号，使用变量</li>
<li>部分指令的参数支持正则表达式</li>
</ol>
<p><strong>Example</strong></p>
<div><pre><code><span>http</span> <span>{</span>
    <span>include</span> mime<span>.</span><span>types</span><span>;</span>
    <span>upstream</span> thwp <span>{</span>
        <span>server</span> <span>127.0</span><span>.0</span><span>.1</span><span>:</span><span>8080</span><span>;</span>
    <span>}</span>
    
    <span>server</span> <span>{</span>
        <span>listen</span> <span>443</span> http2<span>;</span>
        <span># Nginx配置语法</span>
        <span>limit_req_zone</span> <span>$binary_remote_addr</span> zone<span>=</span>one<span>:</span><span>10</span>m rate<span>=</span><span>1</span>r<span>/</span>s<span>;</span>
        <span>location</span> <span>~</span><span>*</span> \<span>.</span><span>(</span>gif<span>|</span>jpg<span>|</span>jpeg<span>)</span>$ <span>{</span>
            <span>proxy_cache</span> my_cache<span>;</span>
            <span>expires</span> <span>3</span>m<span>;</span><span>proxy_cache_key</span> <span>$host</span><span>$uri</span><span>$is_args</span><span>$args</span><span>;</span>
            <span>proxy_cache_valid</span> <span>200</span> <span>304</span> <span>302</span> <span>1</span>d<span>;</span>
            <span>proxy_pass</span> <span>http</span><span>:</span><span>/</span><span>/</span>thwp<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="_5-1-配置参数"> 5.1 配置参数</h3>
<h4 id="_5-1-1-时间单位"> 5.1.1 时间单位</h4>
<ul>
<li>ms：milliseconds</li>
<li>s：seconds</li>
<li>m：minutes</li>
<li>h：hours</li>
<li>d：days</li>
<li>w：weeks</li>
<li>M：months，30 days</li>
<li>y：years，365 days</li>
</ul>
<h4 id="_5-1-2-空间单位"> 5.1.2 空间单位</h4>
<ul>
<li>b/B：bytes</li>
<li>k/K：kilobytes</li>
<li>m/M：megabytes</li>
<li>g/G：gifabytes</li>
</ul>
<h2 id="_6-nginx配置文件结构"> 6 Nginx配置文件结构</h2>
<p>nginx配置文件如下：</p>
<div><pre><code><span>user</span> nginx<span>;</span>
<span>worker_processes</span> auto<span>;</span>
<span>error_log</span> <span>/</span>var<span>/</span>log<span>/</span>nginx<span>/</span>error<span>.</span>log<span>;</span>
<span>pid</span> <span>/</span>run<span>/</span>nginx<span>.</span><span>pid</span><span>;</span>
<span>include</span> <span>/</span>usr<span>/</span>share<span>/</span>nginx<span>/</span>modules<span>/</span>\<span>*</span><span>.</span>conf<span>;</span>
<span>events</span> <span>{</span>
    <span>worker_connections</span> <span>1024</span><span>;</span>
<span>}</span>
<span>http</span> <span>{</span>
    <span>log_format</span>  main  <span>'$remote_addr - $remote_user [$time_local] "$request" '</span>
                      <span>'$status $body_bytes_sent "$http_referer" '</span>
                      <span>'"$http_user_agent" "$http_x_forwarded_for"'</span><span>;</span>
    <span>access_log</span>  <span>/</span>var<span>/</span>log<span>/</span>nginx<span>/</span>access<span>.</span>log  main<span>;</span>
    <span>sendfile</span>            on<span>;</span>
    <span>tcp_nopush</span>          on<span>;</span>
    <span>tcp_nodelay</span>         on<span>;</span>
    <span>keepalive_timeout</span>   <span>65</span><span>;</span>
    <span>types_hash_max_size</span> <span>2048</span><span>;</span>
    <span>include</span>             <span>/</span>etc<span>/</span>nginx<span>/</span>mime<span>.</span><span>types</span><span>;</span>
    <span>default_type</span>        application<span>/</span>octet<span>-</span>stream<span>;</span>
    <span>include</span> <span>/</span>etc<span>/</span>nginx<span>/</span>conf<span>.</span>d<span>/</span>\<span>*</span><span>.</span>conf<span>;</span>
    <span>server</span> <span>{</span>
        <span>listen</span>       <span>80</span> default_server<span>;</span>
        <span>listen</span>       <span>[</span><span>:</span><span>:</span><span>]</span><span>:</span><span>80</span> default_server<span>;</span>
        <span>server_name</span>  _<span>;</span>
        <span>root</span>         <span>/</span>usr<span>/</span>share<span>/</span>nginx<span>/</span>html<span>;</span>
        <span>include</span> <span>/</span>etc<span>/</span>nginx<span>/</span>default<span>.</span>d<span>/</span>\<span>*</span><span>.</span>conf<span>;</span>
        <span>location</span> <span>/</span> <span>{</span>
        <span>}</span>
        <span>error_page</span> <span>404</span> <span>/</span><span>404.</span>html<span>;</span>
            <span>location</span> <span>=</span> <span>/</span><span>40</span>x<span>.</span>html <span>{</span>
        <span>}</span>
        <span>error_page</span> <span>500</span> <span>502</span> <span>503</span> <span>504</span> <span>/</span><span>50</span>x<span>.</span>html<span>;</span>
            <span>location</span> <span>=</span> <span>/</span><span>50</span>x<span>.</span>html <span>{</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h3 id="_6-1-基本结构"> 6.1 基本结构</h3>
<ol>
<li>全局快</li>
<li><code>events</code>块</li>
<li><code>http</code>块</li>
</ol>
<p>在http块中，又包含http全局块、多个server块。</p>
<p>每个server块中，可以包含server全局块和多个location块。</p>
<p>在同一配置块中嵌套的配置块，各个之间不存在次序关系。</p>
<p>配置文件支持大量可配置的指令，绝大多数指令不是特定属于某一个块的。同一个指令放在不同层级的块中，其作用域也不同，一般情况下，高一级块中的指令可以作用域自身所在的块和此块包含的所有低层级块。如果某个指令在两个不同层级的块中同时出现，则采用“就近原则”，即以较低层级块中的配置为准。</p>
<h3 id="_6-2-全局块"> 6.2 全局块</h3>
<p>通常包括配置运行Nginx服务器的用户（组）、允许生成的worker process数、Nginx进程PID存放路径、日志的存放路径和类型以及配置文件引入等。</p>
<h3 id="_6-3-events块"> 6.3 events块</h3>
<p>events块涉及的指令主要影响Nginx服务器与用户的网络连接。常用到的设置包括是否开启对多worker process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型处理连接请求，每个worker process可以同时支持的最大连接数等。</p>
<p>这一部分的指令对Nginx服务器的性能影响较大，在实际配置中应该根据实际情况灵活调整。</p>
<h3 id="_6-4-http块"> 6.4 http块</h3>
<p>http块是Nginx服务器配置中重要部分，代理、缓存和日志定义等绝大多数的功能和第三方模块可以放在这个模块中。</p>
<ul>
<li>http</li>
<li>upstream</li>
<li>server</li>
<li>location</li>
</ul>
<h3 id="_6-5-server块"> 6.5 server块</h3>
<p>server块和“虚拟主机”的概念密切联系。为了加深相关配置的理解，在介绍server块之前，简单了解一下虚拟主机的相关内容。</p>
<p>虚拟主机，又称虚拟服务器、主机空间或网页空间，它是一种技术。该技术是为了节省互联网服务器硬件成本而出现的。这里的“主机”或“空间”是由实体的服务器延伸而来，硬件系统可以基于服务器群，或者单个服务器等。对外表现为多个服务器，从而充分利用服务器硬件资源。从用户角度看，一台虚拟主机和一台独立的硬件主机是完全一样的。</p>
<p>在使用Nginx服务器提供Web服务是，利用虚拟主机的技术就可以避免为每一个要运行的网站提供单独的Nginx服务器，也无需为每个网站对应运行一组Nginx进程。虚拟主机技术使得Nginx服务器可以在同一台服务器上只运行一组Nginx进程，就可以运行多个网站。</p>
<p>和http块相同，server块也可以包含自己的全局块，同时可以包含多个location块。在server全局块中，最常见的两个配置项是本虚拟主机的监听配置和本虚拟主机的名称或IP配置。</p>
<h3 id="_6-6-location块"> 6.6 location块</h3>
<p>每个server块中可以包含多个location块。从严格意义上说，location其实是server块的一个指令，只是由于其在整个Nginx配置文档中起着重要的作用，而且Nginx服务器在许多功能上的灵活性往往在location指令的配置中体现出来。</p>
<h2 id="_7-nginx命令行"> 7 Nginx命令行</h2>
<ol>
<li>格式：<code>nginx -s reload</code></li>
<li>帮助：<code>-?</code> <code>-h</code></li>
<li>使用指定的配置位置：<code>-c</code></li>
<li>指定配置指令：<code>-g</code></li>
<li>指定运行目录：<code>-p</code></li>
<li>发送信号：<code>-s</code>
<ul>
<li>立刻停止服务：<code>stop</code></li>
<li>优雅的停止服务：<code>quit</code></li>
<li>重载配置文件：<code>reload</code></li>
<li>重新开始记录日志文件：<code>reopen</code></li>
</ul>
</li>
<li>测试配置文件是否有语法错误：<code>-t</code> <code>-T</code></li>
<li>打印<code>nginx</code>的版本信息、编译信息：<code>-v</code> <code>-V</code></li>
</ol>
<h3 id="_7-1-重载配置文件"> 7.1 重载配置文件</h3>
<div><pre><code>nginx -s reload
</code></pre>
<div><span>1</span><br></div></div><h3 id="_7-2-热部署"> 7.2  热部署</h3>
<p>只是更换二进制文件</p>
<ol>
<li>备份旧的nginx文件</li>
</ol>
<div><pre><code>cd /home/clay/sbin/
cp nginx nginx.old
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>2）将新的编译好的二进制文件，替换掉现在正在运行的二进制文件</p>
<p>首先重新编译出一个<code>nginx</code>二进制可执行文件，<code>./configure</code>然后<code>make</code>，千万不要<code>make install</code>，执行那<code>make</code>就可以了</p>
<div><pre><code>cd /opt/nginx-1.16.1/
cp -f objs/nginx /home/clay/sbin/
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>3）给master进程发送<code>USR2</code>信号</p>
<div><pre><code># ps -ef|grep nginx
root      6159 57006  0 11:18 pts/0    00:00:00 grep --color=auto nginx
root     63076     1  0 09:46 ?        00:00:00 nginx: master process /home/clay/sbin/nginx
nobody   63103 63076  0 09:46 ?        00:00:00 nginx: worker process
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code># kill -USR2 63076
</code></pre>
<div><span>1</span><br></div></div><div><pre><code># ps -ef|grep nginx
root      6216 63076  0 11:19 ?        00:00:00 nginx: master process /home/clay/sbin/nginx
nobody    6217  6216  0 11:19 ?        00:00:00 nginx: worker process
root      6225 57006  0 11:19 pts/0    00:00:00 grep --color=auto nginx
root     63076     1  0 09:46 ?        00:00:00 nginx: master process /home/clay/sbin/nginx
nobody   63103 63076  0 09:46 ?        00:00:00 nginx: worker process
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code># netstat -nplt| grep 80
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      6216/nginx: master  
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>4）关闭旧的woker进程，<code>kill -WINCH</code>旧的master进程号</p>
<div><pre><code># kill -WINCH 63076
# ps -ef|grep nginx
root      6216 63076  0 11:19 ?        00:00:00 nginx: master process /home/clay/sbin/nginx
nobody    6217  6216  0 11:19 ?        00:00:00 nginx: worker process
root      6842 57006  0 11:28 pts/0    00:00:00 grep --color=auto nginx
root     63076     1  0 09:46 ?        00:00:00 nginx: master process /home/clay/sbin/nginx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>5）关闭旧的master进程，<code>kill -QUIT</code>旧的master进程号</p>
<div><pre><code># kill -QUIT 63076
# ps -ef|grep nginx
root      6216     1  0 11:19 ?        00:00:00 nginx: master process /home/clay/sbin/nginx
nobody    6217  6216  0 11:19 ?        00:00:00 nginx: worker process
root      6947 57006  0 11:30 pts/0    00:00:00 grep --color=auto nginx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_7-3-切割日志文件"> 7.3 切割日志文件</h3>
<p>1）mv掉原来的日志</p>
<div><pre><code>mv access.log access.log.bak
</code></pre>
<div><span>1</span><br></div></div><p>2）重新打开日志文件</p>
<div><pre><code>nginx -s reopen
</code></pre>
<div><span>1</span><br></div></div><p><strong>简单说明一下：</strong></p>
<p>1、在没有执行kill -USR1 <code>cat ${pid_path}</code>之前，即便已经对文件执行了mv命令也只是改变了文件的名称，nginx还是会向新命名的文件” access.log.20161024”中照常写入日志数据。原因在于linux系统中，内核是根据文件描述符来找文件的</p>
<p>2、USR1是自定义信号，也就是进程编写者自己确定收到这个信号该干什么。而在nginx中它自己编写了代码当接到USR1信号的时候让nginx重新打开日志文件（重新打开的日志就是配置文件中设置的位置和名称）。</p>
<h2 id="todo"> Todo</h2>
<p>1.(必做)</p>
<p>虚拟主机</p>
<p>基于域名</p>
<p>基于ip地址</p>
<p>基于端口</p>
<p>2.（可先不做）</p>
<p>TLS应用实践</p>
<p>OpenResty安装实践</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">3.3 nginxSERVER块配置</title>
    <id>https://clay-wangzhi.com/web/nginx/server/</id>
    <link href="https://clay-wangzhi.com/web/nginx/server/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_3-3-nginxserver块配置"> 3.3 nginxSERVER块配置</h1>
<h2 id="_1-listen-指令"> 1 Listen 指令</h2>
<p><strong>Example Configuration</strong></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200317093603705.png" alt="" /></p>
<p><strong>Directives</strong></p>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200317093633095.png" alt="" /></p>
<h2 id="_2-server-name指令"> 2 server_name指令</h2>
<h3 id="_2-1-规则"> 2.1 规则</h3>
<ul>
<li>指令后可以跟多个域名，第一个是主域名</li>
<li>*泛域名：进支持在最前或最后（<code>server_name *.baiud.com;</code>）</li>
<li>正则表达式：加<code>~</code>前缀 (<code>server_name www.taohui.tech ~^www\d+\.taohui\.tech$;</code>)</li>
</ul>
<p><strong>用正则表达式创建变量：用小括号()</strong></p>
<p>示例</p>
<div><pre><code><span>server</span> <span>{</span>
    <span>server_name</span> <span>~</span><span>^</span><span>(</span>www\<span>.</span><span>)</span><span>?</span><span>(</span><span>.</span><span>+</span><span>)</span>$<span>;</span>
    <span>location</span> <span>/</span> <span>{</span>
        <span>root</span> <span>/</span>sites<span>/</span>$<span>2</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>server</span> <span>{</span>
    <span>server_name</span> <span>~</span><span>^</span><span>(</span>www\<span>.</span><span>)</span><span>?</span><span>(</span><span>?</span><span>&lt;</span>domain<span>></span><span>.</span><span>+</span><span>)</span>$<span>;</span>
    locatoin <span>/</span> <span>{</span>
        <span>root</span> <span>/</span>sites<span>/</span><span>$domain</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>其他</strong></p>
<ul>
<li>.taohui.tech 可以匹配 taohui.tech *.taohui.tech</li>
<li>_ 匹配所有</li>
<li>“” 匹配没有传递Host头部</li>
</ul>
<h3 id="_2-2-匹配顺序"> 2.2 匹配顺序</h3>
<p>1）精准匹配</p>
<p>2）*在前的泛域名</p>
<p>3）*在后的泛域名</p>
<p>4）按文件中的顺序匹配正则表达式域名</p>
<p>5）default server 匹配第1个，listen指定default</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">5. 状态码</title>
    <id>https://clay-wangzhi.com/web/nginx/status/</id>
    <link href="https://clay-wangzhi.com/web/nginx/status/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_5-状态码"> 5. 状态码</h1>
<h2 id="nginx-code-常用状态码学习小结"> Nginx code 常用状态码学习小结</h2>
<h3 id="nginx-code-status"> Nginx Code Status</h3>
<p>状态码分为五类：</p>
<ol>
<li>100-199 用于指定客户端应相应的某些动作。</li>
<li>200-299 用于表示请求成功。</li>
<li>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。</li>
<li>400-499 用于指出客户端的错误。</li>
<li>500-599 用于指出服务器错误。</li>
</ol>
<hr>
<p><strong>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</strong></p>
<p>201 （已创建） 请求成功并且服务器创建了新的资源。</p>
<p>202 （已接受） 服务器已接受请求，但尚未处理。</p>
<p>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</p>
<p>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</p>
<p>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。</p>
<p>206 （部分内容） 服务器成功处理了部分 GET 请求。</p>
<hr>
<p>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p>
<p>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p>
<p>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<p>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p>
<p>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p>
<p>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p>
<p>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<hr>
<p>400 （错误请求） 服务器不理解请求的语法。</p>
<p>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p>
<p>403 （禁止） 服务器拒绝请求。</p>
<p><strong>404 （未找到） 服务器找不到请求的网页。</strong></p>
<p>405 （方法禁用） 禁用请求中指定的方法。</p>
<p>406 （不接受） 无法使用请求的内容特性响应请求的网页。</p>
<p>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</p>
<p>408 （请求超时） 服务器等候请求时发生超时。</p>
<p>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</p>
<p>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</p>
<p>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</p>
<p>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</p>
<p>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</p>
<p>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</p>
<p>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。</p>
<p>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</p>
<p>417 （未满足期望值） 服务器未满足<code>&quot;期望&quot;</code>请求标头字段的要求。</p>
<p><strong>499 客户端主动断开了连接，有的时候是因为客户端请求超时，主动断开连接。</strong></p>
<hr>
<p><strong>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</strong></p>
<p>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p>
<p><strong>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</strong></p>
<p><strong>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</strong></p>
<p><strong>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</strong></p>
<p>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>
<h3 id="http请求流程"> http请求流程</h3>
<p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/http.png" alt="" /></p>
<p>一个普通的http请求处理流程，如上图所示：
A -&gt; client端发起请求给nginx
B -&gt; nginx处理后，将请求转发到uwsgi，并等待结果
C -&gt; uwsgi处理完请求后，返回数据给nginx
D -&gt; nginx将处理结果返回给客户端
每个阶段都会有一个预设的超时时间，由于网络、机器负载、代码异常等等各种原因，如果某个阶段没有在预期的时间内正常返回，就会导致这次请求异常，进而产生不同的状态码。</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">tomcat注意事项</title>
    <id>https://clay-wangzhi.com/web/tomcat/danger/</id>
    <link href="https://clay-wangzhi.com/web/tomcat/danger/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tomcat注意事项"> tomcat注意事项</h1>
<h2 id="war正确删除姿势"> war正确删除姿势</h2>
<p>tomcat中war包停止后才可以删除</p>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-08T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">tomcat假死现象</title>
    <id>https://clay-wangzhi.com/web/tomcat/dead/</id>
    <link href="https://clay-wangzhi.com/web/tomcat/dead/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tomcat假死现象"> tomcat假死现象</h1>
<h1 id="_1-背景"> 1 背景</h1>
<h2 id="_1-1-编写目的"> 1.1 编写目的</h2>
<p>为了方便大家以后发现进程假死的时候能够正常的分析并且第一时间保留现场快照。</p>
<h2 id="_1-2编写背景"> 1.2编写背景</h2>
<p>最近服务器发现tomcat的应用会偶尔出现无法访问的情况。经过一段时间的观察最近又发现有台tomcat的应用出</p>
<p>现了无法访问情况。简单描述下该台tomcat当时具体的表现：客户端请求没有响应，查看服务器端tomcat的进程</p>
<p>是存活的，查看业务日志的时候发现日志停止没有任何最新的访问日志。连tomcat下面的catalina.log也没有任何</p>
<p>访问记录，基本断定该台tomcat已不能提供服务。</p>
<h1 id="_2-分析步骤"> 2 分析步骤</h1>
<p>根据前面我描述的假死现象，我最先想到的是网络是否出现了问题，是不是有什么丢包严重的情况，于是我开始从</p>
<p>请求的数据流程开始分析，由于我们业务的架构采用的是nginx+tomcat的集群配置，一个请求上来的流向可以用</p>
<p>下图来简单的描述一下：</p>
<h2 id="_2-1检查nginx的网络情况"> 2.1检查nginx的网络情况</h2>
<p>更改nginx的配置，让该台nginx请求只转到本机器的出现问题的tomcat应用上面，在access.log里看是否有网络</p>
<p>请求，结果可以查看到当前所有的网络请求，也就是说可以排除是网络的问题。</p>
<h2 id="_2-2检查tomcat-的网络情况"> 2.2检查tomcat 的网络情况</h2>
<p>分析业务配置的tomcat访问日志xxxx.log上是否有日志访问记录，经过查询该台tomcat应用日志完全没有任何访</p>
<p>问记录，由于我们的部署是本机的nginx转到本机的tomcat应用，所以可以排除不是网络问题。到此基本可以断定</p>
<p>网络没有问题，tomcat 本身出现了假死的情况。在tomcat的日志里有报过OutOfMemoryError的异常，所以可以</p>
<p>肯定tomcat假死的原因是OOM</p>
<h1 id="_3-分析jvm内存溢出"> 3 分析JVM内存溢出</h1>
<h2 id="_3-1为什么会发生内存泄漏"> 3.1<strong>为什么会发生内存泄漏</strong></h2>
<p>在我们学习Java的时候就知道它最为方便的地方就是我们不需要管理内存的分配和释放，一切由JVM自己来进行处</p>
<p>理，当Java对象不再被应用时，等到堆内存不够用时JVM会进行GC处理，清除这些对象占用的堆内存空间，但是</p>
<p>如果对象一直被应用，那么JVM是无法对其进行GC处理的，那么我们创建新的对象时，JVM就没有办法从堆中获取</p>
<p>足够的内存分配给此对象，这时就会导致OOM。我们出现OOM原因，一般都是因为我们不断的往容器里存放对</p>
<p>象，然而容器没有相应的大小限制或清除机制，这样就容易导致OOM。</p>
<h2 id="_3-2快速定位问题"> 3.2<strong>快速定位问题</strong></h2>
<p>当我们的应用服务器占用了过多内存的时候，我们怎么样才能快速的定位问题呢？要想快速定位问题，首先我们</p>
<p>必需获取服务器JVM某时刻的内存快照。Jdk里面提供了很多相应的命令比如：jstack,jstat,jmap,jps等等. 在出现问</p>
<p>题后我们应该快速保留现场。</p>
<p>3.2.1 jstack</p>
<p>可以观察到jvm中当前所有线程的运行情况和线程当前状态.</p>
<p>sudo jstack -F 进程ID</p>
<p>从上面的图我们可以看到tomcat进程里面没有死锁的情况，而且每个线程都处理等待的状态。这个时候我们可以</p>
<p>telnet命令连上tomcat的端口查看tomcat进程是否有任务回应。这时发现tomcat没有任何回应可以证明tomcat应</p>
<p>用已没有响应处理假死状态。</p>
<p>3.2.2 jstat</p>
<p>这是jdk命令中比较重要，也是相当实用的一个命令，可以观察到classloader，compiler，gc相关信息</p>
<p>具体参数如下：</p>
<div><pre><code>-class：统计class loader行为信息
-compile：统计编译行为信息
-gc：统计jdk gc时heap信息
-gccapacity：统计不同的generations（包括新生区，老年区，permanent区）相应的heap容量情况
-gccause：统计gc的情况，（同-gcutil）和引起gc的事件
-gcnew：统计gc时，新生代的情况
-gcnewcapacity：统计gc时，新生代heap容量
-gcold：统计gc时，老年区的情况
-gcoldcapacity：统计gc时，老年区heap容量
-gcpermcapacity：统计gc时，permanent区heap容量
-gcutil：统计gc时，heap情况
-printcompilation：不知道干什么的，一直没用过。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>一般比较常用的几个参数是：</p>
<div><pre><code>sudo jstat -class 2083 1000 10 （每隔1秒监控一次，一共做10次）
</code></pre>
<div><span>1</span><br></div></div><p>查看当时的head情况</p>
<div><pre><code>sudo jstat -gcutil 20683 2000
</code></pre>
<div><span>1</span><br></div></div><p>出现时候截取的数据是gc已经完全没有处理了,因为没有加上full gc的日志所以不确定JVMGC 时间过长，导致应用</p>
<p>暂停.</p>
<p>3.2.3获取内存快照</p>
<p>Jdk自带的jmap可以获取内在某一时刻的快照</p>
<p>命令：jmap -dump:format=b,file=heap.bin &lt;pid&gt;</p>
<p>file：保存路径及文件名</p>
<p>pid：进程编号（windows通过任务管理器查看，linux通过ps aux查看）</p>
<p>dump文件可以通过MemoryAnalyzer分析查看，网址：http://www.eclipse.org/mat/，可以查看dump时对象数</p>
<p>量，内存占用，线程情况等。</p>
<p>从上图我们可以明确的看出此项目的HashMap内存使用率比较高，因为我们的系统都是返回Map的数据结构所以</p>
<p>占用比较高的内存是正常情况。</p>
<p>3.2.4观察运行中的jvm物理内存的占用情况</p>
<p>观察运行中的jvm物理内存的占用情况。我们也可以用jmap命令</p>
<p>参数如下：</p>
<div><pre><code>-heap：打印jvm heap的情况
-histo：打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。
-histo：live: 同上，但是只答应存活对象的情况
-permstat:打印permanent generation heap情况
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>命令使用：</p>
<p><code>jmap -heap 2083</code></p>
<p>可以观察到New Generation（Eden Space，From Space，To Space）,tenured generation,Perm Generation的内存使用情况</p>
<p>上图为tomcat应用出错前JVM的配置信息,可以明确的看到当时的信息:</p>
<p>MaxHeapSize堆内存大小为：3500M</p>
<p>MaxNewSize新生代内存大小：512M</p>
<p>PermSize永久代内存大小:192M</p>
<p>NewRatio设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为2，则年轻代与年老代所占比值为1：2，年轻代占整个堆栈的1/3</p>
<p>SurvivorRatio设置年轻代中Eden区与Survivor区的大小比值。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10</p>
<p>在New Generation中，有一个叫Eden的空间，主要是用来存放新生的对象，还有两个SurvivorSpaces（from,to）, 它们用来存放每次垃圾回收后存活下来的对象。在Old Generation中，主要存放应用程序中生命周期长的内存对象，还有个Permanent Generation，主要用来放JVM自己的反射对象，比如类对象和方法对象等。</p>
<p>从上面的图可以看出来JVM的新生代设置太小，可以看出应用的新生代区完全占满了，无法再往新生代区增加新的对象此时的这些对象都处于活跃状态，所以不会被GC处理，但是tomcat应用还在继续产生新的对象，这样就会导致OOM的发生，这就是导致tomcat假死的原因.</p>
<h1 id="_4-tomcat假死其它情况"> 4 Tomcat假死其它情况</h1>
<p>​     以下是网上资料说的tomcat假的情况：</p>
<ul>
<li>应用本身程序的问题，造成死锁。</li>
<li>load 太高，已经超出服务的极限</li>
<li>jvm GC时间过长，导致应用暂停
<ul>
<li>因为出错项目里面没有打出GC的处理情况，所以不确定此原因是否也是我项目tomcat假死的原因之一。</li>
</ul>
</li>
<li>大量tcp 连接 CLOSE_WAIT
<ul>
<li><code>netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>转载链接：https://www.cnblogs.com/lilyjia/p/5729197.html</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-08T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">生产环境中的tomcat配置</title>
    <id>https://clay-wangzhi.com/web/tomcat/prd/</id>
    <link href="https://clay-wangzhi.com/web/tomcat/prd/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="生产环境中的tomcat配置"> 生产环境中的tomcat配置</h1>
<h2 id="tomcat安全配置"> tomcat安全配置</h2>
<h3 id="版本安全"> 版本安全</h3>
<p>升级当前tomcat版本为最新稳定版本。</p>
<p>在升级版本中，需要注意两点：</p>
<ul>
<li>
<p>尽量避免跨大版本的升级</p>
</li>
<li>
<p>将当前老版本的server.xml , catalina.sh, web.xml和tomcat-users.xml进行备份，然后部署完新的tomcat</p>
<p>后，将这些配置文件覆盖过去。</p>
</li>
</ul>
<h3 id="隐藏版本信息"> 隐藏版本信息</h3>
<p>当tomcat出现404或其它错误时，就会显示当前版本信息，为避免针对某一版本的攻击，我们应该将其隐藏或伪装</p>
<p><img src="./images/883007-20170309115431516-1104120437.png" alt="image" /></p>
<p>版本信息的显示是由一个jar包控制的，该jar包存放在tomcat安装目录下的lib目录下，名称为catalina.jar.</p>
<ol>
<li>通过jar xf命令解压这个jar包会得到两个目录META-INF和org, 通过修改</li>
</ol>
<p><code>org/apache/catalina/util/ServerInfo.properties</code>文件中的<code>serverinfo</code>字段来实现更改tomcat版本信息：</p>
<div><pre><code>[root@localhost ~]# cat org/apache/catalina/util/SererInfo.properties | grep -v &#39;^$|#&#39;
server.info=Apache Tomcat/7.0.53
server.number=7.0.53.0
serer.built=Mar 25 2014 06:20:16
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="2">
<li>当然还有另外一种方法来隐藏或伪装版本信息，这两种方法本质是一样的：</li>
</ol>
<div><pre><code>[root@localhost ~]# cd /usr/local/apache-tomcat-7.0.53/lib
[root@localhost lib]# mkdir -p org/apache/catalina/util
[root@localhost lib]# cd org/apache/catalina/util
[root@localhost util]# vim ServerInfo.properties
server.info=nolinux        # 如果想修改成其它版本号，把这个地方的值改成其它值就行了
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>修改完成之后，重启tomcat即可看到效果！</p>
<h2 id="tomcat的配置优化"> tomcat的配置优化</h2>
<h3 id="优化web-xml"> 优化web.xml</h3>
<p>servlet与其它适用于整个Web应用程序设置的配置文件，必须符合servlet规范的标准格式。通过它可以配置你</p>
<p>web应用的相关选项，tomcat在启动的时候会读取这个文件，完成你开发的系统的一些初始化操作。</p>
<p>它可以做如下事情：</p>
<ul>
<li>提供基于servlet的相关配置</li>
<li>增加监听器，监控session或在tomcat启动时，加载一些你希望加载的资源。比如创建数据库连接池等</li>
<li>设置session过期时间，tomcat默认是30分钟</li>
<li>更改应用的默认页面，通常为index.html/index.jsp等</li>
<li>增加过滤器， 做一些你希望的过滤操作，比如敏感词汇的过滤</li>
<li>增加一些jstl（标准标签库）的定义，方便在jsp中直接include进来</li>
<li>struts, spring或hibernate的一些配置等</li>
</ul>
<p>由于在生产环境中，tomcat不会直接对公网提供服务，前端肯定有apache或nginx，因此，默认主页或自定义错</p>
<p>误页，我们都在前端的apache或nginx中完成；另外也有可能是由程序员在项目内的WEB-INF/web.xml中去做定</p>
<p>义。</p>
<p>在tomcat新版本中，默认已经禁止列目录功能。</p>
<p>下面是几种觉的功能，在web.xml中的表现形式：</p>
<p><strong>站点默认主页：</strong></p>
<p><img src="./images/883007-20170309115432875-139916481.png" alt="image" /></p>
<p><strong>自定义错误页：</strong></p>
<p><img src="./images/883007-20170309115433984-443260669.png" alt="image" /></p>
<p><strong>定义会话超时时间：</strong></p>
<p><img src="./images/883007-20170309115435516-1709051054.png" alt="image" /></p>
<p><strong>禁止列目录：</strong></p>
<p><img src="./images/883007-20170309115437047-1295899737.png" alt="image" /></p>
<h3 id="优化-tomcat-user-xml"> 优化 tomcat-user.xml</h3>
<p>该文件中包含用户名，角色及密码。 负责提供webapps下manager项目的登录认证管理。</p>
<p>在生产环境中，我们需要将该文件全部注释。</p>
<p><img src="./images/883007-20170309115438797-1710834528.png" alt="image" /></p>
<h3 id="优化server-xml"> 优化server.xml</h3>
<ul>
<li>
<p>maxThreads连接数限制：</p>
<p>maxThreads是tomcat所能接受的最大连接数。 一般设置不要超过8000， 如果你的网站访问量非常大可使用</p>
<p>多个tomcat实例的方法，即在一个服务器上启动多个tomcat，然后做负载均衡。</p>
</li>
<li>
<p>tomcat和php不同，php可以按照cpu和内存的情况去配置连接数，所以上万很正常。 但java还需要注意jvm</p>
</li>
<li>
<p>的参数配置。如果不注意就会因为jvm参数过小而崩溃。</p>
</li>
<li>
<p>不要多个虚拟主机：</p>
<p>强烈建议不要使用tomcat的虚拟主机功能，推荐一个tomcat实例启动一个站点。即，可以启动多个tomcat，而不是一个tomcat里包含多个虚拟主机。 因为tomcat是多线程，共享内存，任何一个虚拟主机中的应用崩溃，都会影响到所有的应用程序。</p>
</li>
<li>
<p>压缩传输：</p>
<p>tomcat也支持gzip压缩功能。 可以在server.xml配置文件中的Connector节点中配置如下参数，来实现对指定资源类型进行压缩。</p>
<div><pre><code>compression=&quot;on&quot;             # 打开压缩功能 
compressionMinSize=&quot;50&quot;      # 启用压缩的输出内容大小，默认为2KB 
noCompressionUserAgents=&quot;gozilla, traviata&quot;      # 对于以下的浏览器，不启用压缩 
compressableMimeType=&quot;text/html,text/xml,text/javascript,text/css,text/plain&quot;　# 哪些资源类型需要压缩
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>要注意的是，对于文本信息比如txt, html, css,javascript进行压缩，效果非常好。而对文件，图片，视频不要压缩。</p>
</li>
<li>
<p>Connector 连接器的配置</p>
<p>bio、nio 和 apr，三种方式性能差别很大，apr 的性能最优， bio 的性能最差。而 Tomcat 7 使用的 Connector 默认就启用的 Apr 协议，但需要系统安装 Apr 库，否则就会使用 bio 方式。</p>
</li>
</ul>
<p>配置文件样例，connector连接器设置为bio</p>
<div><pre><code>   &lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot;
        maxThreads=&quot;2000&quot; minSpareThreads=&quot;4&quot;/&gt;
        
    &lt;Connector executor=&quot;tomcatThreadPool&quot;
         port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; 
               connectionTimeout=&quot;20000&quot; 
               redirectPort=&quot;8443&quot;
         	   maxHeaderCount=&quot;64&quot;  
               maxParameterCount=&quot;64&quot;  
               maxHttpHeaderSize=&quot;8192&quot;  
               URIEncoding=&quot;UTF-8&quot;  
               useBodyEncodingForURI=&quot;false&quot;  
               maxThreads=&quot;2048&quot;  
               minSpareThreads=&quot;12&quot;  
               acceptCount=&quot;2048&quot;  
               connectionLinger=&quot;-1&quot;  
               keepAliveTimeout=&quot;60&quot;  
               maxKeepAliveRequests=&quot;32&quot;  
               maxConnections=&quot;1000&quot;  
               acceptorThreadCount=&quot;1&quot;  
               pollerThreadCount=&quot;2&quot;  
               selectorTimeout=&quot;1000&quot;  
               enableLookups=&quot;false&quot;
               useSendfile=&quot;true&quot;  
               selectorPool.maxSelectors=&quot;128&quot;  /&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="管理ajp端口"> 管理AJP端口</h3>
<p>AJP是为tomcat与HTTP服务器之间通信而定制的协议，能提供较高的通信速度和效率。如果前端是apache的话，</p>
<p>会使用到AJP这个连接器，如果是nginx，就用不上了，因此需要注销掉：</p>
<div><pre><code>&lt;!--
    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;
--&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="更改关闭tomcat实例的指令"> 更改关闭tomcat实例的指令</h3>
<p>server.xml中定义了可以直接关闭tomcat实例的管理端口。 我们通过 telnet连接上该端口之后，输入shutdown</p>
<p>即可关闭。值得注意的是，虽然实例关闭了，但是进程还是存在的。由于默认的端口和指令都很简单，默认端口是</p>
<p>8005， 指令为SHUTDOWN. 因此我们要改得复杂一点（当然，新版本的tomcat管理端口监听在127.0.0.1）：</p>
<div><pre><code>&lt;Server port=&quot;8005&quot; shutdown=&quot;9SDKJ29jksjf23sjf0LSDF92JKS9DKkjsd&quot;&gt;
</code></pre>
<div><span>1</span><br></div></div><h3 id="更改tomcat服务监听端口"> 更改tomcat服务监听端口</h3>
<div><pre><code>&lt;Connector port=&quot;8080&quot; address=&quot;172.16.100.1&quot; /&gt;
</code></pre>
<div><span>1</span><br></div></div><h3 id="关闭war自动部署"> 关闭war自动部署</h3>
<div><pre><code>&lt;Host name=&quot;localhost&quot;  appBase=&quot;&quot;
      unpackWARs=&quot;false&quot; autoDeploy=&quot;false&quot;&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="禁用tomcat管理页面"> 禁用tomcat管理页面</h3>
<p>删除webapps目录下的所有文件，还涉及到管理页面的2个配置文件host-manager.xml和manager.xml也要删</p>
<p>除，这两个文件在tomcat安装 目录下的conf/Catalina/localhost目录下。</p>
<h3 id="使用普通用户启动tomcat"> 使用普通用户启动tomcat</h3>
<p>在启动之前需要将tomcat安装目录下所有文件的属主和属组都设置为指定的用户。</p>
<h2 id="tomcat生产服务器性能优化"> tomcat生产服务器性能优化</h2>
<h3 id="tomcat内存优化"> tomcat内存优化</h3>
<p>tomcat内存优化主要是对tomcat启动参数优化，我们可以在tomcat启动脚本catalina.sh中设置JAVA——OPTS参</p>
<p>数。</p>
<div><pre><code>JAVA_OPTS=&#39;-server -Xms2048m -Xmx2048m -XX:PermSize=256M -XX:MaxNewSize=256m -XX:MaxPermSize=256m&#39;
</code></pre>
<div><span>1</span><br></div></div><p>参数说明：</p>
<div><pre><code>-server  启用jdk 的 server 版；  
-Xms    java虚拟机初始化时的最小内存；  
-Xmx   java虚拟机可使用的最大内存；  
-XX:PermSize    内存永久保留区域  
-XX:MaxPermSize   内存最大永久保留区域
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>-Xmx 默认为物理内存的1/4， 实际建议不大于4GB；一般建议设置-Xms = -Xmx</p>
<p>-server  一定要作为第一个参数，在多个cpu时性能 佳</p>
<p>-Xms  初始heap大小，使用的最小内存，cpu性能 高时可以设置的大一些</p>
<blockquote>
<p>参考链接:</p>
<p>https://www.cnblogs.com/huangxm/p/6524968.html</p>
<p>https://blog.csdn.net/ljj_9/article/details/79145324</p>
<p>https://blog.csdn.net/loyachen/article/details/47280237</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-08T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">tomcat简介</title>
    <id>https://clay-wangzhi.com/web/tomcat/</id>
    <link href="https://clay-wangzhi.com/web/tomcat/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tomcat简介"> tomcat简介</h1>
<h2 id="tomcat学习笔记-一"> Tomcat学习笔记（一）</h2>
<p>Hello everyone, let's learn tomcat together！</p>
<h3 id="tomcat的开幕式"> Tomcat的开幕式</h3>
<p>Tomcat以Java编写</p>
<h4 id="安装tomcat"> 安装Tomcat</h4>
<p>官网地址为：https://tomcat.apache.org</p>
<p>各个版本的下载地址为：https://archive.apache.org/dist/tomcat/</p>
<p>安装方式</p>
<p>二进制文件（文件为tar.gz）</p>
<div><pre><code>wget https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.23/bin/apache-tomcat-8.5.23.tar.gz
tar -xvf apache-tomcat-8.5.23.tar.gz
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>需提前配置好jdk的环境变量，jdk配置详见上一章节</p>
<h4 id="tomcat启动、停止、重启"> Tomcat启动、停止、重启</h4>
<p>主要用到的脚本有</p>
<p>catalina.sh、shutdown.sh、startup.sh、version.sh</p>
<p><img src="./images/tomcat1.png" alt="" /></p>
<p>catalina是tomcat的主要脚本，它会执行java命令以调用Tomcat的启动或停止等</p>
<p>shutdown是停止tomcat脚本</p>
<p>startup是启动tomcat脚本</p>
<p>version是查看tomcat的版本信息</p>
<ul>
<li>
<p>常用的catalina脚本启动参数</p>
<p>config [server.xml file]	  指定另一个server.xml配置文件。默认是使用驻留在$CATALINA_BASE/conf目录中的server.xml</p>
<p>help					输出命令行选项摘要表</p>
<p>ebug					以调试模式启动tomcat</p>
<p>tart					启动tomcat，并将标准输出与错误送至tomcat的日志文件</p>
<p>top					停止tomcat</p>
<p>ersion 					输出tomcat的版本信息</p>
</li>
</ul>
<h4 id="安装后的测试"> 安装后的测试</h4>
<p>当安装以及启动tomcat后，测试是否成功启动，可以访问网页进行测试，默认端口为8080</p>
<p><img src="./images/tomcat2.png" alt="" /></p>
<h3 id="配置tomcat"> 配置tomcat</h3>
<h4 id="从8080改变端口号"> 从8080改变端口号</h4>
<p>把机器上目的地为80端口的所有连接需重定向到8080端口的信息通知给内核。</p>
<div><pre><code>iptables -t nat -I PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080
iptables -t nat -I OUTPUT -p tcp --dport 80 -j REDIRECT --to-ports 8080
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-08T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">Tomcat 错误代号及状态码</title>
    <id>https://clay-wangzhi.com/web/tomcat/status/</id>
    <link href="https://clay-wangzhi.com/web/tomcat/status/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tomcat-错误代号及状态码"> Tomcat 错误代号及状态码</h1>
<p>状态代码  状态信息  含义</p>
<div><pre><code>100  Continue  初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）
 101  Switching Protocols  服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）
 200  OK  一切正常，对GET和POST请求的应答文档跟在后面。
 201  Created  服务器已经创建了文档，Location头给出了它的URL。
 202  Accepted  已经接受请求，但处理尚未完成。
 203  Non-Authoritative Information  文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1新）。
 204  No Content  没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。
 205  Reset Content  没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。
 206  Partial Content  客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。
 300  Multiple Choices  客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。
 301  Moved Permanently  客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。
 302  Found  类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。

出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。

注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求[http://host/~user](https://link.jianshu.com?t=http://host/~user)（缺少了后面的斜杠），有的服务器返回301，有的则返回302。

严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。
 303  See Other  类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。
 304  Not Modified  客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。
 305  Use Proxy  客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。
 307  Temporary Redirect  和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是 303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只 能跟随对GET请求的重定向。（HTTP 1.1新）
 400  Bad Request  请求出现语法错误。
 401  Unauthorized  客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。
 403  Forbidden  资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。
 404  Not Found  无法找到指定位置的资源。这也是一个常用的应答。
 405  Method Not Allowed  请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新）
 406  Not Acceptable  指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）。
 407  Proxy Authentication Required  类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新）
 408  Request Timeout  在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新）
 409  Conflict  通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新）
 410  Gone  所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。（HTTP 1.1新）
 411  Length Required  服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新）
 412  Precondition Failed  请求头中指定的一些前提条件失败（HTTP 1.1新）。
 413  Request Entity Too Large  目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。
 414  Request URI Too Long  URI太长（HTTP 1.1新）。
 416  Requested Range Not Satisfiable  服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新）
 500  Internal Server Error  服务器遇到了意料不到的情况，不能完成客户的请求。
 501  Not Implemented  服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。
 502  Bad Gateway  服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。
 503  Service Unavailable  服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头。
 504  Gateway Timeout  由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）
 505  HTTP Version Not Supported  服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><blockquote>
<p>转载链接：</p>
<p>https://www.jianshu.com/p/8ad1009f927d</p>
</blockquote>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="web中间件"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-08T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">4.5 Playbook之tags</title>
    <id>https://clay-wangzhi.com/automate/ansible/playbook-tags/</id>
    <link href="https://clay-wangzhi.com/automate/ansible/playbook-tags/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_4-5-playbook之tags"> 4.5 Playbook之tags</h1>
<h2 id="_1-简介"> 1 简介</h2>
<p>在大型项目当中，通常一个playbook会有非常多的task。而我们每次执行这个playbook时，都会将所有task运行一遍。而事实上，在实际使用过程中，我们可能只是想要执行其中的一部分任务而已，并不想把整个playbook完整跑一遍。这个时候就需要用到tags。</p>
<p>通过tags，我们可以给playbook中的某一些任务打上“标签”，而在执行playbook的时候，我们可以通过选定标签的方式指定只执行哪一些任务或者不执行哪一些任务。</p>
<h2 id="_2-为task打tag"> 2 为task打tag</h2>
<p>下面是一个安装httpd的简单示例：</p>
<div><pre><code><span># cat /etc/ansible/playbook/install_web.yml</span>
<span>-</span> <span>name</span><span>:</span> configure webservers 
  <span>hosts</span><span>:</span> all
  <span>remote_user</span><span>:</span> ansible
  
  <span>tasks</span><span>:</span>
    <span>-</span> <span>name</span><span>:</span> Install httpd
      <span>yum</span><span>:</span> 
        <span>name</span><span>:</span> httpd
        <span>state</span><span>:</span> present
      <span>tags</span><span>:</span> install_httpd
        
    <span>-</span> <span>name</span><span>:</span> Cofiguration httpd
      <span>copy</span><span>:</span> 
        <span>src</span><span>:</span> /root/httpd.conf 
        <span>dest</span><span>:</span> /etc/httpd/conf/httpd.conf
      <span>tags</span><span>:</span> conf_httpd   
      <span>notify</span><span>:</span>
        <span>-</span> restart httpd
        
    <span>-</span> <span>name</span><span>:</span> Start httpd
      <span>service</span><span>:</span> 
        <span>name</span><span>:</span> httpd 
        <span>state</span><span>:</span> started 
        <span>enabled</span><span>:</span> no
      <span>tags</span><span>:</span> start_httpd

  <span>handlers</span><span>:</span>
    <span>-</span> <span>name</span><span>:</span> restart httpd
      <span>service</span><span>:</span> name=httpd state=restart
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>在上面的示例中，我们为两个task定义了三个tags：<code>install_httpd</code>、<code>conf_httpd</code>以及<code>start_httpd</code>。</p>
<h2 id="_3-使用tag"> 3 使用tag</h2>
<h3 id="_3-1-执行指定tag的task"> 3.1 执行指定tag的task</h3>
<p>有了tags之后，我们就可以只运行playbook中指定标签的task了：</p>
<div><pre><code># ansible-playbook  install_web.yml --tags &quot;start_httpd&quot;

PLAY [configure webservers] *************************************************************************************************************************************************

TASK [Gathering Facts] ******************************************************************************************************************************************************
ok: [10.1.61.187]

TASK [Start httpd] **********************************************************************************************************************************************************
changed: [10.1.61.187]

PLAY RECAP ******************************************************************************************************************************************************************
10.1.61.187                : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>也可以一次指定多个tag执行：</p>
<div><pre><code># ansible-playbook install_web.yml     --tags &quot;conf_httpd,start_httpd&quot;

PLAY [configure webservers] *************************************************************************************************************************************************

TASK [Gathering Facts] ******************************************************************************************************************************************************
ok: [10.1.61.187]

TASK [Cofiguration httpd] ***************************************************************************************************************************************************
ok: [10.1.61.187]

TASK [Start httpd] **********************************************************************************************************************************************************
ok: [10.1.61.187]

PLAY RECAP ******************************************************************************************************************************************************************
10.1.61.187                : ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="_3-2-排除指定tag的task"> 3.2 排除指定tag的task</h3>
<p>通过下面的方式可以排除指定了tag的task，即除了指定tag的task不执行，其他task都执行：</p>
<div><pre><code># ansible-playbook --skip-tags=&quot;install_httpd&quot; install_web.yml                           

PLAY [configure webservers] *************************************************************************************************************************************************

TASK [Gathering Facts] ******************************************************************************************************************************************************
ok: [10.1.61.187]

TASK [Cofiguration httpd] ***************************************************************************************************************************************************
ok: [10.1.61.187]

TASK [Start httpd] **********************************************************************************************************************************************************
ok: [10.1.61.187]

PLAY RECAP ******************************************************************************************************************************************************************
10.1.61.187                : ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>执行效果跟上面一样。</p>
<h3 id="_3-3-查看playbook中的所有tag"> 3.3 查看playbook中的所有tag</h3>
<p>可以通过<code>--list-tags</code>参数列出指定的playbook中所有的tag</p>
<div><pre><code># ansible-playbook --list-tags install_web.yml                          

playbook: install_web.yml

  play #1 (all): configure webservers   TAGS: []
      TASK TAGS: [conf_httpd, install_httpd, start_httpd]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="_4-打tag的几种方式"> 4 打tag的几种方式</h2>
<ol>
<li>为一个任务指定一个标签</li>
</ol>
<p>这种方式就是上面示例中的方法：</p>
<div><pre><code><span>tags</span><span>:</span> conf_httpd
</code></pre>
<div><span>1</span><br></div></div><ol>
<li>为一个任务指定多个标签</li>
</ol>
<p>可以通过列表的方式为一个任务指定多个标签：</p>
<div><pre><code><span>tags</span><span>:</span>
  <span>-</span> install_httpd
  <span>-</span> install_web
  
<span>tags</span><span>:</span> <span>[</span><span>'install_httpd'</span><span>,</span><span>'install_web'</span><span>]</span>

<span>tags</span><span>:</span> install_httpd<span>,</span>install_web
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol>
<li>为一个play指定一组标签</li>
</ol>
<p>当为一个play指定一组标签后，该play下的所有task都会自动继承该标签，各task也可以自定义自己的标签。</p>
<div><pre><code>- name: configure webservers 
  hosts: all
  remote_user: ansible
  tags: 
    - httpd
  tasks:
    ...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在静态加载文件的指令上打标签，等价于为所加载文件中所有子任务打标签。</p>
<p>在动态加载文件的指令上打标签，不会为子任务打标签，而是为父任务自身打标签。</p>
<p>现在说结论：</p>
<p>(1).静态加载的指令有：roles、include、import_tasks、import_role</p>
<p>(2).动态加载的指令只有include_xxx，包括include_tasks、include_role</p>
<p>import_playbook和include_playbook因为本身就是play级别或高于play级别，所以不能为这两个指令打标签。</p>
<h2 id="_5-ansible内置tag"> 5 ansible内置tag</h2>
<p>除了用户自定义tag，ansible也内置了几个tag，这些tag都包含特殊含义：</p>
<ul>
<li>
<p>always：一旦某个task被打上了always的tag，则无论是playbook的完整执行，还是指定tag执行，不管你指定的tag是啥，该任务总是会被执行。除非明确指定&quot;--skip-tags=always&quot;选项，才不会执行该task。</p>
</li>
<li>
<p>never：该标签与always正好相反，总是不会执行，除非明确指定&quot;--tags=never&quot;选项。</p>
</li>
<li>
<p>tagged：在调用时使用</p>
<div><pre><code><span># 所有打了tag的任务都会被执行，包含never tag的除外，没有标签的不会被执行</span>
ansible-playbook --tags tagged install_web.yaml 

<span># 所有打了tag的任务都不会被执行，包括always tag也不会被执行</span>
ansible-playbook --skip-tags tagged install_web.yaml
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>untagged：在调用时使用</p>
<div><pre><code><span># 所有未打tag的任务都会被执行，打了always tag的也会被执行</span>
ansibl-playbook --tags untagged install_web.yaml

<span># 所有未打tag的任务都不会被执行</span>
ansibl-playbook --skip-tags untagged install_web.yaml
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>all：表示所有任务都会被执行，在默认情况下，不指定任何标签，则使用的就是该标签</p>
</li>
</ul>
]]></content>
    <author>
      <name>Clay</name>
    </author>
    <category term="自动化工具"/>
    <contributor>
      <name>Clay</name>
    </contributor>
    <published>2020-03-20T00:00:00.000Z</published>
    <rights>Copyright by Clay</rights>
  </entry>
  <entry>
    <title type="html">11.3 循环控制</title>
    <id>https://clay-wangzhi.com/code/shell/part3/11_3_loop_control/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/11_3_loop_control/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_11-3-循环控制"> 11.3 循环控制</h1>
<blockquote>
<p>Tournez cent tours, tournez mille tours,</p>
<p>Tournez souvent et tournez toujours . . .</p>
<p>——保尔·魏尔伦，《木马》</p>
</blockquote>
<p>本节介绍两个会影响循环行为的命令。</p>
<h3 id="break-continue"> break, continue</h3>
<p><code>break</code> 和 <code>continue</code> 命令<sup></sup>的作用和在其他编程语言中的作用一样。<code>break</code> 用来中止（跳出）循环，而 <code>continue</code> 则是略过未执行的循环部分，直接进行下一次循环。</p>
<p>样例 11-21. 循环中 <code>break</code> 与 <code>continue</code> 的作用</p>
<div><pre><code><span>#!/bin/bash</span>

<span>LIMIT</span><span>=</span><span>19</span>  <span># 循环上界</span>

<span>echo</span>
<span>echo</span> <span>"Printing Numbers 1 through 20 (but not 3 and 11)."</span>

<span>a</span><span>=</span><span>0</span>

<span>while</span> <span>[</span> <span>$a</span> -le <span>"<span>$LIMIT</span>"</span> <span>]</span>
<span>do</span>
 <span>a</span><span>=</span><span><span>$((</span>$a<span>+</span><span>1</span><span>))</span></span>
 
 <span>if</span> <span>[</span> <span>"<span>$a</span>"</span> -eq <span>3</span> <span>]</span> <span>||</span> <span>[</span> <span>"<span>$a</span>"</span> -eq <span>11</span> <span>]</span>  <span># 除了 3 和 11。</span>
 <span>then</span>
   <span>continue</span>      <span># 略过本次循环的剩余部分。</span>
 <span>fi</span>
 
 <span>echo</span> -n <span>"<span>$a</span> "</span>   <span># 当 a 等于 3 和 11 时，将不会执行这条语句。</span>
<span>done</span>

<span># 思考：</span>
<span># 为什么循环不会输出到20？</span>

<span>echo</span><span>;</span> <span>echo</span>

<span>echo</span> Printing Numbers <span>1</span> through <span>20</span>, but something happens after <span>2</span>.

<span>##################################################################</span>

<span># 用 'break' 代替了 'continue'。</span>

<span>a</span><span>=</span><span>0</span>

<span>while</span> <span>[</span> <span>"<span>$a</span>"</span> -le <span>"<span>$LIMIT</span>"</span> <span>]</span>
<span>do</span>
 <span>a</span><span>=</span><span><span>$((</span>$a<span>+</span><span>1</span><span>))</span></span>
 
 <span>if</span> <span>[</span> <span>"<span>$a</span>"</span> -gt <span>2</span> <span>]</span>
 <span>then</span>
   <span>break</span>  <span># 中止循环。</span>
 <span>fi</span>
 
 <span>echo</span> -n <span>"<span>$a</span>"</span>
<span>done</span>

<span>echo</span><span>;</span> <span>echo</span><span>;</span> <span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><p><code>break</code> 命令接受一个参数。普通的 <code>break</code> 命令仅仅跳出其所在的那层循环，而 <code>break N</code> 命令则可以跳出其上 N 层的循环。</p>
<p>样例 11-22. 跳出多层循环</p>
<div><pre><code><span>#!/bin/bash</span>
<span># break-levels.sh: 跳出循环.</span>

<span># "break N" 跳出 N 层循环。</span>

<span>for</span> <span>outerloop</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>
<span>do</span>
  <span>echo</span> -n <span>"Group <span>$outerloop</span>:   "</span>

  <span># ------------------------------------------</span>
  <span>for</span> <span>innerloop</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>
  <span>do</span>
    <span>echo</span> -n <span>"<span>$innerloop</span> "</span>
    
    <span>if</span> <span>[</span> <span>"<span>$innerloop</span>"</span> -eq <span>3</span> <span>]</span>
    <span>then</span>
      <span>break</span>  <span># 尝试一下 break 2 看看会发生什么。</span>
             <span># （它同时中止了内层和外层循环。）</span>
    <span>fi</span>
  <span>done</span>
  <span># ------------------------------------------</span>

  <span>echo</span>
<span>done</span>

<span>echo</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>与 <code>break</code> 类似，<code>continue</code> 也接受一个参数。普通的 <code>continue</code> 命令仅仅影响其所在的那层循环，而 <code>continue N</code> 命令则可以影响其上 N 层的循环。</p>
<p>样例 11-23. <code>continue</code> 影响外层循环</p>
<div><pre><code><span>#!/bin/bash</span>
<span># "continue N" 命令可以影响其上 N 层循环。</span>

<span>for</span> <span>outer</span> <span>in</span> I II III IV V           <span># 外层循环</span>
<span>do</span>
  <span>echo</span><span>;</span> <span>echo</span> -n <span>"Group <span>$outer</span>: "</span>
  
  <span># --------------------------------------------------------------------</span>
  <span>for</span> <span>inner</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span> <span>8</span> <span>9</span> <span>10</span>  <span># 内层循环</span>
  <span>do</span>
  
    <span>if</span> <span>[</span><span>[</span> <span>"<span>$inner</span>"</span> -eq <span>7</span> <span>&amp;&amp;</span> <span>"<span>$outer</span>"</span> <span>=</span> <span>"III"</span> <span>]</span><span>]</span>
    <span>then</span>
      <span>continue</span> <span>2</span>  <span># 影响两层循环，包括“外层循环”。</span>
                  <span># 将其替换为普通的 "continue"，那么只会影响内层循环。</span>
    <span>fi</span>
    
    <span>echo</span> -n <span>"<span>$inner</span> "</span>  <span># 7 8 9 10 将不会出现在 "Group III."中。</span>
  <span>done</span>
  <span># --------------------------------------------------------------------</span>

<span>done</span>

<span>echo</span><span>;</span> <span>echo</span>

<span># 思考：</span>
<span># 想一个 "continue N" 在脚本中的实际应用情况。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>样例 11-24. 真实环境中的 <code>continue N</code></p>
<div><pre><code><span># Albert Reiner 举出了一个如何使用 "continue N" 的例子：</span>
<span># ---------------------------------------------------</span>

<span>#  如果我有许多任务需要运行，并且运行所需要的数据都以文件的形</span>
<span>#+ 式存在文件夹中。现在有多台设备可以访问这个文件夹，我想将任</span>
<span>#+ 务分配给这些不同的设备来完成。</span>
<span>#  那么我通常会在每台设备上执行下面的代码：</span>

<span>while</span> true:
<span>do</span>
  <span>for</span> <span>n</span> <span>in</span> .iso.*
  <span>do</span>
    <span>[</span> <span>"<span>$n</span>"</span> <span>=</span> <span>".iso.opts"</span> <span>]</span> <span>&amp;&amp;</span> <span>continue</span>
    <span>beta</span><span>=</span><span>${n<span>#</span>.iso.}</span>
    <span>[</span> -r .Iso.<span>$beta</span> <span>]</span> <span>&amp;&amp;</span> <span>continue</span>
    <span>[</span> -r .lock.<span>$beta</span> <span>]</span> <span>&amp;&amp;</span> <span>sleep</span> <span>10</span> <span>&amp;&amp;</span> <span>continue</span>
    lockfile -r0 .lock.<span>$beta</span> <span>||</span> <span>continue</span>
    <span>echo</span> -n <span>"<span>$beta</span>: "</span> <span><span>`</span><span>date</span><span>`</span></span>
    run-isotherm <span>$beta</span>
    <span>date</span>
    <span>ls</span> -alF .Iso.<span>$beta</span>
    <span>[</span> -r .Iso.<span>$beta</span> <span>]</span> <span>&amp;&amp;</span> <span>rm</span> -rf .lock.<span>$beta</span>
    <span>continue</span> <span>2</span>
  <span>done</span>
  <span>break</span>
<span>done</span>

<span>exit</span> <span>0</span>

<span># 这个脚本中出现的 sleep N 只针对这个脚本，通常的形式是：</span>

<span>while</span> <span>true</span>
<span>do</span>
  <span>for</span> <span>job</span> <span>in</span> <span>{</span>pattern<span>}</span>
  <span>do</span>
    <span>{</span>job already <span>done</span> or running<span>}</span> <span>&amp;&amp;</span> <span>continue</span>
    <span>{</span>mark job as running, <span>do</span> job, mark job as done<span>}</span>
    <span>continue</span> <span>2</span>
  <span>done</span>
  <span>break</span>        <span># 或者使用类似 `sleep 600` 这样的语句来防止脚本结束。</span>
<span>done</span>

<span>#  这样做可以保证脚本只会在没有任务时（包括在运行过程中添加的任务）</span>
<span>#+ 才会停止。合理使用文件锁保证多台设备可以无重复的并行执行任务（这</span>
<span>#+ 在我的设备上通常会消耗好几个小时，所以我想避免重复计算）。并且，</span>
<span>#+ 因为每次总是从头开始搜索文件，因此可以通过文件名决定执行的先后</span>
<span>#+ 顺序。当然，你可以不使用 'continue 2' 来完成这些，但是你必须</span>
<span>#+ 添加代码去检测某项任务是否完成（以此判断是否可以执行下一项任务或</span>
<span>#+ 终止、休眠一段时间再执行下一项任务）。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/caution.gif" alt="caution" /> <code>continue N</code> 结构不易理解并且可能在一些情况下有歧义，因此不建议使用。</p>
</blockquote>
<hr>
<section>
<ol>
<li id="footnote1"><p>这两个命令是 <a href="http://tldp.org/LDP/abs/html/internal.html#BUILTINREF" target="_blank" rel="noopener noreferrer">内建命令</a>，而另外的循环命令，如 <a href="http://tldp.org/LDP/abs/html/loops1.html#WHILELOOPREF" target="_blank" rel="noopener noreferrer"><code>while</code></a> 和 <a href="http://tldp.org/LDP/abs/html/testbranch.html#CASEESAC1" target="_blank" rel="noopener noreferrer"><code>case</code></a> 则是 <a href="http://tldp.org/LDP/abs/html/internal.html#KEYWORDREF" target="_blank" rel="noopener noreferrer">关键词</a>。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
  <entry>
    <title type="html">11.4 测试与分支</title>
    <id>https://clay-wangzhi.com/code/shell/part3/11_4_testing_and_branching/</id>
    <link href="https://clay-wangzhi.com/code/shell/part3/11_4_testing_and_branching/"/>
    <updated>2021-05-11T03:54:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_11-4-测试与分支"> 11.4 测试与分支</h1>
<p><code>case</code> 和 <code>select</code> 结构并不属于循环结构，因为它们并没有反复执行代码块。但是和循环结构相似的是，它们会根据代码块顶部或尾部的条件控制程序流。</p>
<p>下面介绍两种在代码块中控制程序流的方法：</p>
<h3 id="case-in-esac"> <code>case (in)</code> / <code>esac</code></h3>
<p>在 shell 脚本中，<code>case</code> 模拟了 C/C++ 语言中的 <code>switch</code>，可以根据条件跳转到其中一个分支。其相当于简写版的 <code>if/then/else</code> 语句。很适合用来创建菜单选项哟！</p>
<div><pre><code><span>case</span> <span>"<span>$variable</span>"</span> <span>in</span>
  <span>"<span>$condition1</span>"</span> <span>)</span>
    command<span>..</span>.
  <span>;</span><span>;</span>
  <span>"<span>$condition2</span>"</span> <span>)</span>
    command<span>..</span>.
  <span>;</span><span>;</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p><img src="http://tldp.org/LDP/abs/images/note.gif" alt="note" /></p>
<ul>
<li>
<p>对变量进行引用不是必须的，因为在这里不会进行字符分割。</p>
</li>
<li>
<p>条件测试语句必须以右括号 ) 结束。<sup></sup></p>
</li>
<li>
<p>每一段代码块都必须以双分号 ;; 结束。</p>
</li>
<li>
<p>如果测试条件为真，其对应的代码块将被执行，而后整个 <code>case</code> 代码段结束执行。</p>
</li>
<li>
<p><code>case</code> 代码段必须以 <code>esac</code> 结束（倒着拼写case）。</p>
</li>
</ul>
</blockquote>
<p>样例 11-25. 如何使用 <code>case</code></p>
<div><pre><code><span>#!/bin/bash</span>
<span># 测试字符的种类。</span>

<span>echo</span><span>;</span> <span>echo</span> <span>"Hit a key, then hit return."</span>
<span>read</span> Keypress

<span>case</span> <span>"<span>$Keypress</span>"</span> <span>in</span>
  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span>   <span>)</span> <span>echo</span> <span>"Lowercase letter"</span><span>;</span><span>;</span>
  <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>   <span>)</span> <span>echo</span> <span>"Uppercase letter"</span><span>;</span><span>;</span>
  <span>[</span><span>0</span>-9<span>]</span>         <span>)</span> <span>echo</span> <span>"Digit"</span><span>;</span><span>;</span>
  *             <span>)</span> <span>echo</span> <span>"Punctuation, whitespace, or other"</span><span>;</span><span>;</span>
<span>esac</span>      <span>#  字符范围可以用[方括号]表示，也可以用 POSIX 形式的[[双方括号]]表示。</span>

<span># 在这个例子的第一个版本中，用来测试是小写还是大写字符使用的是 [a-z] 和 [A-Z]。</span>
<span># 这在一些特定的语言环境和 Linux 发行版中不起效。</span>
<span># POSIX 形式具有更好的兼容性。</span>
<span># 感谢 Frank Wang 指出这一点。</span>

<span># 练习：</span>
<span># -----</span>
<span># 这个脚本接受一个单字符然后结束。</span>
<span># 修改脚本，使得其可以循环接受输入，并且检测键入的每一个字符，直到键入 "X" 为止。</span>
<span># 提示：将所有东西包在 "while" 中。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>样例 11-26. 使用 <code>case</code> 创建菜单</p>
<div><pre><code><span>#!/bin/bash</span>

<span># 简易的通讯录数据库</span>

<span>clear</span> <span># 清屏。</span>

<span>echo</span> <span>"          Contact List"</span>
<span>echo</span> <span>"          ------- ----"</span>
<span>echo</span> <span>"Choose one of the following persons:"</span> 
<span>echo</span>
<span>echo</span> <span>"[E]vans, Roland"</span>
<span>echo</span> <span>"[J]ones, Mildred"</span>
<span>echo</span> <span>"[S]mith, Julie"</span>
<span>echo</span> <span>"[Z]ane, Morris"</span>
<span>echo</span>

<span>read</span> person

<span>case</span> <span>"<span>$person</span>"</span> <span>in</span>
<span># 注意变量是被引用的。</span>

  <span>"E"</span> <span>|</span> <span>"e"</span> <span>)</span>
  <span># 同时接受大小写的输入。</span>
  <span>echo</span>
  <span>echo</span> <span>"Roland Evans"</span>
  <span>echo</span> <span>"4321 Flash Dr."</span>
  <span>echo</span> <span>"Hardscrabble, CO 80753"</span>
  <span>echo</span> <span>"(303) 734-9874"</span>
  <span>echo</span> <span>"(303) 734-9892 fax"</span>
  <span>echo</span> <span>"revans@zzy.net"</span>
  <span>echo</span> <span>"Business partner &amp; old friend"</span>
  <span>;</span><span>;</span>
  <span># 注意用双分号结束这一个选项。</span>

  <span>"J"</span> <span>|</span> <span>"j"</span> <span>)</span>
  <span>echo</span>
  <span>echo</span> <span>"Mildred Jones"</span>
  <span>echo</span> <span>"249 E. 7th St., Apt. 19"</span>
  <span>echo</span> <span>"New York, NY 10009"</span>
  <span>echo</span> <span>"(212) 533-2814"</span>
  <span>echo</span> <span>"(212) 533-9972 fax"</span>
  <span>echo</span> <span>"milliej@loisaida.com"</span>
  <span>echo</span> <span>"Ex-girlfriend"</span>
  <span>echo</span> <span>"Birthday: Feb. 11"</span>
  <span>;</span><span>;</span>
  
  <span># Smith 和 Zane 的信息稍后添加。</span>

  *         <span>)</span>
  <span># 缺省设置。</span>
  <span># 空输入（直接键入回车）也是执行这一部分。</span>
  <span>echo</span>
  <span>echo</span> <span>"Not yet in database."</span>
  <span>;</span><span>;</span>
  
<span>esac</span>

<span>echo</span>

<span># 练习：</span>
<span># -----</span>
<span># 修改脚本，使得其可以循环接受多次输入而不是只显示一个地址后终止脚本。</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><p>你可以用 <code>case</code> 来检测命令行参数。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>case</span> <span>"<span>$1</span>"</span> <span>in</span>
  <span>""</span><span>)</span> <span>echo</span> <span>"Usage: <span>${0<span>##</span>*<span>/</span>}</span> &lt;filename>"</span><span>;</span> <span>exit</span> <span>$E_PARAM</span><span>;</span><span>;</span>
                      <span># 没有命令行参数，或者第一个参数为空。</span>
                      <span># 注意 ${0##*/} 是参数替换 ${var##pattern} 的一种形式。</span>
                      <span># 最后的结果是 $0.</span>
  
  -*<span>)</span> <span>FILENAME</span><span>=</span>./<span>$1</span><span>;</span><span>;</span> <span>#  如果传入的参数以短横线开头，那么将其替换为 ./$1</span>
                      <span>#+ 以避免后续的命令将其解释为一个选项。</span>
  
  * <span>)</span> <span>FILENAME</span><span>=</span><span>$1</span><span>;</span><span>;</span>   <span># 否则赋值为 $1。</span>
<span>esac</span>                  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>下面是一个更加直观的处理命令行参数的例子：</p>
<div><pre><code><span>#!/bin/bash</span>

<span>while</span> <span>[</span> <span>$#</span> -gt <span>0</span> <span>]</span><span>;</span> <span>do</span>    <span># 遍历完所有参数</span>
  <span>case</span> <span>"<span>$1</span>"</span> <span>in</span>
    -d<span>|</span>--debug<span>)</span>
              <span># 检测是否是 "-d" 或者 "--debug"。</span>
              <span>DEBUG</span><span>=</span><span>1</span>
              <span>;</span><span>;</span>
    -c<span>|</span>--conf<span>)</span>
              <span>CONFFILE</span><span>=</span><span>"<span>$2</span>"</span>
              <span>shift</span>
              <span>if</span> <span>[</span> <span>!</span> -f <span>$CONFFILE</span> <span>]</span><span>;</span> <span>then</span>
                <span>echo</span> <span>"Error: Supplied file doesn't exist!"</span>
                <span>exit</span> <span>$E_CONFFILE</span>     <span># 找不到文件。</span>
              <span>fi</span>
              <span>;</span><span>;</span>
  <span>esac</span>
  <span>shift</span>       <span># 检测下一个参数</span>
<span>done</span>

<span># 摘自 Stefano Falsetto 的 "Log2Rot" 脚本中 "rottlog" 包的一部分。</span>
<span># 已授权使用。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>样例 11-27. 使用命令替换生成 <code>case</code> 变量</p>
<div><pre><code><span>#!/bin/bash</span>
<span># case-cmd.sh: 使用命令替换生成 "case" 变量。</span>

<span>case</span> <span><span>$(</span> arch <span>)</span></span> <span>in</span>   <span># $( arch ) 返回设备架构。</span>
                    <span># 等价于 'uname -m"。</span>
  i386 <span>)</span> <span>echo</span> <span>"80386-based machine"</span><span>;</span><span>;</span>
  i486 <span>)</span> <span>echo</span> <span>"80486-based machine"</span><span>;</span><span>;</span>
  i586 <span>)</span> <span>echo</span> <span>"Pentium-based machine"</span><span>;</span><span>;</span>
  i686 <span>)</span> <span>echo</span> <span>"Pentium2+-based machine"</span><span>;</span><span>;</span>
  *    <span>)</span> <span>echo</span> <span>"Other type of machine"</span><span>;</span><span>;</span>
<span>esac</span>

<span>exit</span> <span>0</span>  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><code>case</code> 还可以用来做字符串模式匹配。</p>
<p>样例 11-28. 简单的字符串匹配</p>
<div><pre><code><span>#!/bin/bash</span>
<span># match-string.sh: 使用 'case' 结构进行简单的字符串匹配。</span>

<span>match_string</span> <span>(</span><span>)</span>
<span>{</span> <span># 字符串精确匹配。</span>
  <span>MATCH</span><span>=</span><span>0</span>
  <span>E_NOMATCH</span><span>=</span><span>90</span>
  <span>PARAMS</span><span>=</span><span>2</span>     <span># 需要2个参数。</span>
  <span>E_BAD_PARAMS</span><span>=</span><span>91</span>
  
  <span>[</span> <span>$#</span> -eq <span>$PARAMS</span> <span>]</span> <span>||</span> <span>return</span> <span>$E_BAD_PARAMS</span>
  
  <span>case</span> <span>"<span>$1</span>"</span> <span>in</span>
    <span>"<span>$2</span>"</span><span>)</span> <span>return</span> <span>$MATCH</span><span>;</span><span>;</span>
    *   <span>)</span> <span>return</span> <span>$E_NOMATCH</span><span>;</span><span>;</span>
  <span>esac</span>
  
<span>}</span>


<span>a</span><span>=</span>one
<span>b</span><span>=</span>two
<span>c</span><span>=</span>three
<span>d</span><span>=</span>two

match_string <span>$a</span>     <span># 参数个数不够</span>
<span>echo</span> <span>$?</span>             <span># 91</span>

match_string <span>$a</span> <span>$b</span>  <span># 匹配不到</span>
<span>echo</span> <span>$?</span>             <span># 90</span>

match_string <span>$a</span> <span>$d</span>  <span># 匹配成功</span>
<span>echo</span> <span>$?</span>             <span># 0</span>


<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>样例 11-29. 检查输入</p>
<div><pre><code><span>#!/bin/bash</span>
<span># isaplpha.sh: 使用 "case" 结构检查输入。</span>

<span>SUCCESS</span><span>=</span><span>0</span>
<span>FAILURE</span><span>=</span><span>1</span>   <span>#  以前是FAILURE=-1,</span>
            <span>#+ 但现在 Bash 不允许返回负值。</span>

isalpha <span>(</span><span>)</span>  <span># 测试字符串的第一个字符是否是字母。</span>
<span>{</span>
<span>if</span> <span>[</span> -z <span>"<span>$1</span>"</span> <span>]</span>                <span># 检测是否传入参数。</span>
<span>then</span>
  <span>return</span> <span>$FAILURE</span>
<span>fi</span>

<span>case</span> <span>"<span>$1</span>"</span> <span>in</span>
  <span>[</span>a-zA-Z<span>]</span>*<span>)</span> <span>return</span> <span>$SUCCESS</span><span>;</span><span>;</span>  <span># 是否以字母形式开始？</span>
  *        <span>)</span> <span>return</span> <span>$FAILURE</span><span>;</span><span>;</span>
<span>esac</span>
<span>}</span>             <span># 可以与 C 语言中的函数 "isalpha ()" 作比较。</span>


isalpha2 <span>(</span><span>)</span>   <span># 测试整个字符串是否都是字母。</span>
<span>{</span>
  <span>[</span> <span>$#</span> -eq <span>1</span> <span>]</span> <span>||</span> <span>return</span> <span>$FAILURE</span>
  
  <span>case</span> <span>$1</span> <span>in</span>
  *<span>[</span><span>!</span>a-zA-Z<span>]</span>*<span>|</span><span>""</span><span>)</span> <span>return</span> <span>$FAILURE</span><span>;</span><span>;</span>
               *<span>)</span> <span>return</span> <span>$SUCCESS</span><span>;</span><span>;</span>
  <span>esac</span>
<span>}</span>

isdigit <span>(</span><span>)</span>    <span># 测试整个字符串是否都是数字。</span>
<span>{</span>             <span># 换句话说，也就是测试是否是一个整型变量。</span>
  <span>[</span> <span>$#</span> -eq <span>1</span> <span>]</span> <span>||</span> <span>return</span> <span>$FAILURE</span>
  
  <span>case</span> <span>$1</span> <span>in</span>
    *<span>[</span><span>!</span><span>0</span>-9<span>]</span>*<span>|</span><span>""</span><span>)</span> <span>return</span> <span>$FAILURE</span><span>;</span><span>;</span>
              *<span>)</span> <span>return</span> <span>$SUCCESS</span><span>;</span><span>;</span>
  <span>esac</span>
<span>}</span>



check_var <span>(</span><span>)</span>  <span># 包装后的 isalpha ()。</span>
<span>{</span>
<span>if</span> isalpha <span>"<span>$@</span>"</span>
<span>then</span>
  <span>echo</span> <span>"<span title="\&quot;">\"</span><span>$*</span><span title="\&quot;">\"</span> begins with an alpha character."</span>
  <span>if</span> isalpha2 <span>"<span>$@</span>"</span>
  <span>then</span>        <span># 其实没必要检查第一个字符是不是字母。</span>
    <span>echo</span> <span>"<span title="\&quot;">\"</span><span>$*</span><span title="\&quot;">\"</span> contains only alpha characters."</span>
  <span>else</span>
    <span>echo</span> <span>"<span title="\&quot;">\"</span><span>$*</span><span title="\&quot;">\"</span> contains at least one non-alpha character."</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"<span title="\&quot;">\"</span><span>$*</span><span title="\&quot;">\"</span> begins with a non-alpha character."</span>
              <span># 如果没有传入参数同样同样返回“存在非字母”。</span>
<span>fi</span>
  
<span>echo</span>
  
<span>}</span>

digit_check <span>(</span><span>)</span>  <span># 包装后的 isdigit ()。</span>
<span>{</span>
<span>if</span> isdigit <span>"<span>$@</span>"</span>
<span>then</span>
  <span>echo</span> <span>"<span title="\&quot;">\"</span><span>$*</span><span title="\&quot;">\"</span> contains only digits [0 - 9]."</span>
<span>else</span>
  <span>echo</span> <span>"<span title="\&quot;">\"</span><span>$*</span><span title="\&quot;">\"</span> has at least one non-digit character."</span>
<span>fi</span>
  
<span>echo</span>
  
<span>}</span>


<span>a</span><span>=</span>23skidoo
<span>b</span><span>=</span>H3llo
<span>c</span><span>=</span>-What?
<span>d</span><span>=</span>What?
<span>e</span><span>=</span><span><span>$(</span><span>echo</span> $b<span>)</span></span>   <span># 命令替换。</span>
<span>f</span><span>=</span>AbcDef
<span>g</span><span>=</span><span>27234</span>
<span>h</span><span>=</span>27a34
<span>i</span><span>=</span><span>27.34</span>

check_var <span>$a</span>
check_var <span>$b</span>
check_var <span>$c</span>
check_var <span>$d</span>
check_var <span>$e</span>
check_var <span>$f</span>
check_var     <span># 如果不传入参数会发送什么？</span>
<span>#</span>
digit_check <span>$g</span>
digit_check <span>$h</span>
digit_check <span>$i</span>


<span>exit</span> <span>0</span>        <span># S.C. 改进了本脚本。</span>

<span># 练习：</span>
<span># -----</span>
<span># 写一个函数 'isfloat ()' 来检测输入值是否是浮点数。</span>
<span># 提示：可以参考函数 'isdigit ()'，在其中加入检测合法的小数点即可。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br></div></div><h3 id="select"> <code>select</code></h3>
<p><code>select</code> 结构是学习自 Korn Shell。其同样可以用来构建菜单。</p>
<div><pre><code><span>select</span> variable <span>[</span>in list<span>]</span>
<span>do</span>
 command<span>..</span>.
 <span>break</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>而效果则是终端会提示用户输入列表中的一个选项。注意，<code>select</code> 默认使用提示字串3（Prompt String 3，<code>$PS3</code>, 即#?），但同样可以被修改。</p>
<p>样例 11-30. 使用 <code>select</code> 创建菜单</p>
<div><pre><code><span>#!/bin/bash</span>

<span><span>PS3</span></span><span>=</span><span>'Choose your favorite vegetable: '</span> <span># 设置提示字串。</span>
                                       <span># 否则默认为 #?。</span>

<span>echo</span>

<span>select</span> <span>vegetable</span> <span>in</span> <span>"beans"</span> <span>"carrots"</span> <span>"potatoes"</span> <span>"onions"</span> <span>"rutabagas"</span>
<span>do</span>
  <span>echo</span>
  <span>echo</span> <span>"Your favorite veggie is <span>$vegetable</span>."</span>
  <span>echo</span> <span>"Yuck!"</span>
  <span>echo</span>
  <span>break</span>  <span># 如果没有 'break' 会发生什么？</span>
<span>done</span>

<span>exit</span>

<span># 练习:</span>
<span># -----</span>
<span># 修改脚本，使得其可以接受其他输入而不是 "select" 语句中所指定的。</span>
<span># 例如，如果用户输入 "peas,"，那么脚本会通知用户 "Sorry. That is not on the menu."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>如果 <em>in list</em> 被省略，那么 <code>select</code> 将会使用传入脚本的命令行参数（<code>$@</code>）或者传入函数的参数作为 <em>list</em>。</p>
<p>可以与 <code>for variable [in list]</code> 中 <em>in list</em> 被省略的情况做比较。</p>
<p>样例 11-31. 在函数中使用 <code>select</code> 创建菜单</p>
<div><pre><code><span>#!/bin/bash</span>

<span><span>PS3</span></span><span>=</span><span>'Choose your favorite vegetable: '</span>

<span>echo</span>

<span>choice_of</span><span>(</span><span>)</span>
<span>{</span>
<span>select</span> vegetable
<span># [in list] 被省略，因此 'select' 将会使用传入函数的参数作为 list。</span>
<span>do</span>
  <span>echo</span>
  <span>echo</span> <span>"Your favorite veggie is <span>$vegetable</span>."</span>
  <span>echo</span> <span>"Yuck!"</span>
  <span>echo</span>
  <span>break</span>
<span>done</span>
<span>}</span>

choice_of beans rice carrorts radishes rutabaga spinach
<span>#         $1    $2   $3      $4       $5       $6</span>
<span>#         传入了函数 choice_of()</span>

<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>还可以参照 <a href="http://tldp.org/LDP/abs/html/bashver2.html#RESISTOR" target="_blank" rel="noopener noreferrer">样例37-3</a>。</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>在写匹配行的时候，可以在左边加上左括号 (，使整个结构看起来更加优雅。<pre>case $( arch ) in   # $( arch ) 返回设备架构。<br>  ( i386 ) echo &quot;80386-based machine&quot;;;<br># ^      ^<br>  ( i486 ) echo &quot;80486-based machine&quot;;;<br>  ( i586 ) echo &quot;Pentium-based machine&quot;;;<br>  ( i686 ) echo &quot;Pentium2+-based machine&quot;;;<br>  (    * ) echo &quot;Other type of machine&quot;;;<br>esac</pre> </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>LinuxStory</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>LinuxStory</name>
    </contributor>
    <published>2021-05-11T03:54:51.000Z</published>
    <rights>Copyright by LinuxStory</rights>
  </entry>
</feed>