## 函数

数学定义

* y=f(x) ，y是x的函数，x是自变量。y=f(x0, x1, ..., xn)

Python函数

* 由若干语句组成的语句块、函数名称、参数列表构成，它是组织代码的最小单元
* 完成一定的功能

函数的作用

* 结构化编程对代码的最基本的封装，一般按照功能组织一段代码
* 封装的目的为了复用，减少冗余代码
* 代码更加简洁美观、可读易懂

函数的分类

* 内建函数，如max()、reversed()等
* 库函数，如math.ceil()等
* 自定义函数，使用def关键字定义

## 函数定义

```python
def 函数名(参数列表):
	函数体（代码块）
	[return 返回值]
```

* 函数名就是标识符，命名要求一样
* 语句块必须缩进，约定4个空格
* Python的函数若没有return语句，会隐式返回一个None值
* 定义中的参数列表称为形式参数，只是一种符号表达（标识符），简称形参

## 函数调用

* 函数定义，只是声明了一个函数，它不能被执行，需要调用执行
* 调用的方式，就是函数名后加上小括号，如有必要在括号内填写上参数
* 调用时写的参数是实际参数，是实实在在传入的值，简称实参

```python
def add(x, y): # 函数定义
	result = x + y # 函数体
	return result # 返回值

out = add(4,5) # 函数调用，可能有返回值，使用变量接收这个返回值
print(out) # print函数加上括号也是调用
```

上面代码解释：

* 定义一个函数add，及函数名是add，能接受2个参数
* 该函数计算的结果，通过返回值返回，需要return语句
* 调用时，通过函数名add后加2个参数，返回值可使用变量接收
* 函数名也是标识符
* 返回值也是值
* 定义需要在调用前，也就是说调用时，已经被定义过了，否则抛NameError异常
* 函数是可调用的对象，callable(add)返回True

## 函数参数

函数在定义是要定义好形式参数，调用时也提供足够的实际参数，一般来说，形参和实参个数要一致（可变参数除外）。

### 实参传参方式

1、位置传参

定义时def f(x, y, z)， 调用使用 f(1, 3, 5)，按照参数定义顺序传入实参

2、关键字传参

定义时def f(x, y, z)，调用使用 f(x=1, y=3, z=5)，使用形参的名字来传入实参的方式，如果使用了形参名字，那么传参顺序就可和定义顺序不同

要求位置参数必须在关键字参数之前传入，位置参数是按位置对应的

> 切记：传参指的是调用时传入实参，就2种方式。

下面讲的都是形参定义。

### 形参缺省值

缺省值也称为默认值，可以在函数定义时，为形参增加一个缺省值。其作用：

* 参数的默认值可以在未传入足够的实参的时候，对没有给定的参数赋值为默认值
* 参数非常多的时候，并不需要用户每次都输入所有的参数，简化函数调用

### 可变参数

需求：写一个函数，可以对多个数累加求和

```python
def sum(iterable):
	s = 0
	for x in iterable:
		s += x
	return s

print(sum([1,3,5]))
print(sum(range(4)))
```

上例，传入可迭代对象，并累加每一个元素。

也可以使用可变参数完成上面的函数。

```python
def sum(*nums):
	sum = 0
	for x in nums:
		sum += x
	return sum

print(sum(1, 3, 5))
print(sum(1, 2, 3))
```

1、可变位置参数

* 在形参前使用 * 表示该形参是可变位置参数，可以接受多个实参
* 它将收集来的实参组织到一个 tuple 中

2、可变关键字参数

* 在形参前使用 ** 表示该形参是可变关键字参数，可以接受多个关键字参数
* 它将收集来的实参的名称和值，组织到一个dict中

总结：

* 有可变位置参数和可变关键字参数
* 可变位置参数在形参前使用一个星号*
* 可变关键字参数在形参前使用两个星号**
* 可变位置参数和可变关键字参数都可以收集若干个实参，可变位置参数收集形成一个tuple，可变关键字参数收集形成一个dict
* 混合使用参数的时候，普通参数需要放到参数列表前面，可变参数要放到参数列表的后面，可变位置参数需要在可变关键字参数之前

### keyword-only参数

在Python3之后，新增了keyword-only参数。

keyword-only参数：在形参定义时，在一个*星号之后，或一个可变位置参数之后，出现的普通参数，就已经不是普通的参数了，称为keyword-only参数。

keyword-only参数，言下之意就是这个参数必须采用关键字传参。

### positional-only参数

Python 3.8 开始，增加了最后一种形参类型的定义：Positional-only参数。（2019年10月发布3.8.0）

```python
def fn(a, /):
	print(a, sep='\n')
fn(3)
fn(a=4) # 错误，仅位置参数，不可以使用关键字传参
```

### 参数规则

参数列表参数一般顺序是：positional-only参数、普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值）、可变关键字参数。
注意：

* 代码应该易读易懂，而不是为难别人
* 请按照书写习惯定义函数参数
* 定义最常用参数为普通参数，可不提供缺省值，必须由用户提供。注意这些参数的顺序，最常用的先定义
* 将必须使用名称的才能使用的参数，定义为keyword-only参数，要求必须使用关键字传参
* 如果函数有很多参数，无法逐一定义，可使用可变参数。如果需要知道这些参数的意义，则使用可变关键字参数收集

### 参数解构

参数解构：

* 在给函数提供实参的时候，可以在可迭代对象前使用 * 或者 ** 来进行结构的解构，提取出其中所有元素作为函数的实参
* 使用 * 解构成位置传参
* 使用 ** 解构成关键字传参
* 提取出来的元素数目要和参数的要求匹配

## 函数返回值

* Python 函数使用 return 语句返回“返回值”
* 所有函数都有返回值，如果没有return语句，隐式调用return None
* return 语句并不一定是函数的语句块的最后一条语句
* 一个函数可以存在多个return语句，但是只有一条可以被执行。如果没有一条return语句被执行到，隐式调用return None
* 如果有必要，可以显示调用return None，可以简写为return
* 如果函数执行了return语句，函数就会返回，当前被执行的return语句之后的其它语句就不会被执行了
* 返回值的作用：结束函数调用、返回“返回值”

* 函数不能同时返回多个值
* return 1, 3, 5 看似返回多个值，隐式的被python封装成了一个元组
* x, y, z = showlist() 使用解构提取返回值更为方便

## 作用域

一个标识符的可见范围，这就是标识符的作用域。一般常说的是变量的作用域

```python
def foo():
	x = 100
print(x) # 可以访问到吗
```

上例中x不可以访问到，会抛出异常（NameError: name 'x' is not defined），原因在于函数是一个封装，它会开辟一个作用域，x变量被限制在这个作用域中，所以在函数外部x变量不可见。

> 注意：每一个函数都会开辟一个作用域

## 作用域分类

* 全局作用域
  * 在整个程序运行环境中都可见
  * 全局作用域中的变量称为全局变量global
* 局部作用域
  * 在函数、类等内部可见
  * 局部作用域中的变量称为局部变量，其使用范围不能超过其所在局部作用域
  * 也称为本地作用域local

## 函数嵌套

在一个函数中定义了另外一个函数

```python
def outer():
	def inner():
		print("inner")
	inner()
	print("outer")
outer() # 可以吗？ 可以
inner() # 可以吗？ 不可以
```

内部函数inner不能在外部直接使用，会抛NameError异常，因为它在函数外部不可见。

其实，inner不过就是一个标识符，就是一个函数outer内部定义的变量而已。

**嵌套结构的作用域**

对比下面嵌套结构，代码执行的效果

```python
def outer1(): #
    o = 65
    def inner():
        print("inner {}".format(o))
        print(chr(o))

    inner()
    print("outer {}".format(o))

outer1() # 打印结果
#inner 65
#A
#outer 65

def outer2(): #
    o = 65
    def inner():
        o = 97
        print("inner {}".format(o))
        print(chr(o))

    inner()
    print("outer {}".format(o))

outer2() # 打印结果
#inner 97
#a
#outer 65
```

从执行的结果来看：

* 外层变量在内部作用域可见
* 内层作用域 inner 中，如果定义了 `o = 97` ，相当于在当前函数 inner 作用域中重新定义了一个新的变量o，但是，***这个 o 并不能覆盖掉外部作用域 outer2 中的变量 o***。只不过对于 inner 函数来说，其只能可见自己作用域中定义的变量 o 了

| 内建函数 | 函数签名 | 说明                        |
| -------- | -------- | --------------------------- |
| chr      | chr(i)   | 通过unicode编码返回对应字符 |
| ord      | ord(c)   | 获得字符对应的unicode       |

```python
print(ord('中'), hex(ord('中')), '中'.encode(), '中'.encode('gbk'))
print(chr(20013)) # '中'
print(chr(97))
```

**一个赋值语句的问题**

函数内，变量未定义，+= 1问题

略

## global 语句

```python
x = 5
def foo():
    global x # 全局变量
    x += 1
    print(x)
foo()
```

* 使用 global 关键字的变量，将 foo 内的 x 声明为使用外部的全局作用域中定义的 x
* 全局作用域中必须有 x 的定义
* 使用了global，foo中的x不再是局部变量了，它是全局变量。

**总结**

* `x+=1` 这种是特殊形式产生的错误的原因？先引用后赋值，而 python 动态语言是赋值才算定义，才能被引用。解决办法，在这条语句前增加 x=0 之类的赋值语句，或者使用global 告诉内部作用域，去全局作用域查找变量定义
* 内部作用域使用 `x = 10` 之类的赋值语句会重新定义局部作用域使用的变量x，但是，一旦这个作
  用域中使用 global 声明x为全局的，那么`x=10`相当于在为全局作用域的变量x赋值

**global使用原则**

* 外部作用域变量会在内部作用域可见，但也不要在这个内部的局部作用域中直接使用，因为函数的目的就是为了封装，尽量与外界隔离
* 如果函数需要使用外部全局变量，请尽量使用函数的形参定义，并在调用传实参解决
* 一句话：不用global。学习它就是为了深入理解变量作用域

## 闭包

**自由变量**：未在本地作用域中定义的变量。例如定义在内层函数外的外层函数的作用域中的变量

**闭包**：就是一个概念，出现在嵌套函数中，指的是**内层函数引用到了外层函数的自由变量**，就形成了闭包。很多语言都有这个概念，最熟悉就是JavaScript

```python
def counter():
    c = [0]
    def inc():
        c[0] += 1 # 报错吗？ 为什么 # line 4
        return c[0]
    return inc
foo = counter() # line 8
print(foo(), foo()) # line 9
c = 100
print(foo()) # line 11
```

代码分析

* 第8行会执行 counter 函数并返回 inc 对应的函数对象，注意这个函数对象并不释放，因为有 foo 记着
* 第4行会报错吗？为什么
  * 不会报错，c 已经在 counter 函数中定义过了。而且 inc 中的使用方式是为 c 的元素修改值，而不是重新定义 c 变量
* 第9行打印什么结果？
  * 打印 1 2
* 第11行打印什么结果？
  * 打印 3
  * 第9行的 c 和 counter 中的 c 不一样，而 inc 引用的是自由变量正是 counter 中的变量 c

这是 Python2 中实现闭包的方式，Python3 还可以使用 nonlocal 关键字

再看下面这段代码，会报错吗？使用 global 能解决吗？

```python
def counter():
    count = 0
    def inc():
        count += 1
        return count
    return inc

foo = counter()
print(foo(), foo())
```

上例一定出错，使用gobal可以解决

```python
def counter():
    global count
    count = 0
    def inc():
        global count
        count += 1
        return count
    return inc

foo = counter()
print(foo(), foo())
count = 100
print(foo()) # 打印几？ 101
```

上例使用 global 解决，这是全局变量的实现，而不是闭包了。

如果要对这个普通变量使用闭包，Python3中可以使用nonlocal关键字。

## nonlocal 语句

**nonlocal**：将变量标记为不在本地作用域定义，而是在**上级的某一级局部作用域**中定义，但**不能是全局**
**作用域中定义**。

```python
def counter():
    count = 0
    def inc():
        nonlocal count # 声明变量count不是本地变量
        count += 1
        return count
    return inc

foo = counter()
print(foo(), foo())
```

count 是外层函数的局部变量，被内部函数引用。

内部函数使用 nonlocal 关键字声明 count 变量在上级作用域而非本地作用域中定义。

代码中内层函数引用外部局部作用域中的自由变量，形成闭包。

```python
count = 10
def counter():
    nonlocal count
    count += 1
    return count

foo = counter()
print(foo(), foo())
```

上例是错误的，nonlocal 声明变量 a 不在当前作用域，但是往外就是全局作用域了，所以错误。

## 函数的销毁

定义一个函数就是生成一个函数对象，函数名指向的就是函数对象。

可以使用 del 语句删除函数，使其引用计数减1。

可以使用同名标识符覆盖原有定义，本质上也是使其引用计数减1。

Python 程序结束时，所有对象销毁。

函数也是对象，也不例外，是否销毁，还是看引用计数是否减为0。

## 变量名解析原则LEGB

* Local，本地作用域、局部作用域的 local 命名空间。函数调用时创建，调用结束消亡
* Enclosing，Python2.2 时引入了嵌套函数，实现了闭包，这个就是嵌套函数的外部函数的命名空间
* Global，全局作用域，即一个模块的命名空间。模块被 import 时创建，解释器退出时消亡
* Build-in，内置模块的命名空间，生命周期从 python 解释器启动时创建到解释器退出时消亡。例如print(open)，print 和 open 都是内置的变量

所以一个名词的查找顺序就是LEGB

![LEGB](https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/LEGB.png)

| 内建函数  | 函数签名                 | 说明                                                         |
| --------- | ------------------------ | ------------------------------------------------------------ |
| iter      | iter(iterable)           | 把一个可迭代对象包装成迭代器                                 |
| next      | next(iterable[,default]) | 取迭代器下一个元素<br/>如果已经取完，继续取抛StopIteration异常 |
| reversed  | reversed(seq)            | 返回一个翻转元素的迭代器                                     |
| enumerate | enumerate(seq, start=0)  | 迭代一个可迭代对象，返回一个迭代器<br/>每一个元素都是数字和元素构成的二元组 |

迭代器

* 特殊的对象，一定是可迭代对象，具备可迭代对象的特征
* 通过 iter 方法把一个可迭代对象封装成迭代器
* 通过 next 方法，迭代 迭代器对象
* 生成器对象，就是迭代器对象。但是迭代器对象未必是生成器对象

可迭代对象

* 能够通过迭代一次次返回不同的元素的对象
  * 所谓相同，不是指值是否相同，而是元素在容器中是否是同一个，例如列表中值可以重复的，['a', 'a']，虽然这个列表有2个元素，值一样，但是两个'a'是不同的元素
* 可以迭代，但是未必有序，未必可索引
* 可迭代对象有：list、tuple、string、bytes、bytearray、range、set、dict、生成器、迭代器等
* 可以使用成员操作符in、not in
  * 对于线性数据结构，in本质上是在遍历对象，时间复杂度为O(n)

```python
lst = [1, 3, 5, 7, 9]
it = iter(lst) # 返回一个迭代器对象
print(next(it)) # 1
print(next(it)) # 3
for i, x in enumerate(it, 2):
    print(i, x)
#2 5
#3 7
#4 9

# print(next(it)) # StopIteration
print()

for x in reversed(lst):
    print(x) # 9 7 5 3 1
```

