## 赋值
使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。
```
x = 1 // 命令变量的赋值
*p = true // 通过指针间接赋值
person.name = "bob" // 结构体字段赋值
count[x] = count[x] * scale // 数组、slice或map的元素赋值
```
## 元组赋值（多重赋值）
元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。
```
x, y = y, x
a[i], a[j] = a[j], a[i]
```
例题：计算两个整数值的的最大公约数（GCD）
```
func gcd(x, y int) int {
for y != 0 {
x, y = y, x%y
}
return x
}
```
例题：计算斐波纳契数列（Fibonacci）的第N个数：
```
func fib(n int) int {
x, y := 0, 1
for i := 0; i < n; i++ {
x, y = y, x+y
}
return x
}
```
有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右边一致。

如果`map查找`、`类型断言`或`通道接收`出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功：
```
v, ok = m[key] // map lookup
v, ok = x.(T) // type assertion
v, ok = <-ch // channel receive
```
译注：map查找）、类型断言或通道接收出现在赋值语句的右边时，并不一定是产生两个结果，也可能只产生一个结果。对于值产生一个结果的情形，map查找失败时会返回零值，类型断言失败时会发送运行时panic异常，通道接收失败时会返回零值（阻塞不算是失败）。例如下面的例子：
```
v = m[key] // map查找，失败时返回零值
v = x.(T) // type断言，失败时panic异常
v = <-ch // 管道接收，失败时返回零值（阻塞不算是失败）
_, ok = m[key] // map返回2个值
_, ok = mm[""], false // map返回1个值
_ = mm[""] // map返回1个值
```
和变量声明一样，我们可以用下划线空白标识符_来丢弃不需要的值。
```
_, err = io.Copy(dst, src) // 丢弃字节数
_, ok = x.(T) // 只检测类型，忽略具体值
```



