
Go操作redis文档<https://godoc.org/github.com/gomodule/redigo/redis>

连接数据库

Dial(network, address string)（conn,err）

执行数据库操作命令

Send(commandName string, args ...interface{}) error

Flush() error

Receive() (reply interface{}, err error)



Send函数发出指令，flush将连接的输出缓冲区刷新到服务器，Receive接收服务器返回的数据

例如：

c.Send("SET", "foo", "bar")

c.Send("GET", "foo")

c.Flush()//把缓冲区命令发到服务器

c.Receive() // 接收set请求返回的数据

v, err = c.Receive() // 接收get请求传输的数据



另外一种执行数据库操作命令

Do(commandName string, args ...interface{}) (reply interface{}, err error)

reply helper functions（回复助手函数）

Bool，Int，Bytes，map，String，Strings和Values函数将回复转换为特定类型的值。为了方便地包含对连接Do和Receive方法的调用，这些函数采用了类型为error的第二个参数。如果错误是非nil，则辅助函数返回错误。如果错误为nil，则该函数将回复转换为指定的类型：

exists, err := redis.Bool(c.Do("EXISTS", "foo"))

if err != nil {

//处理错误代码

}

reflect.TypeOf(exists)//打印exists类型



Scan函数

func Scan(src \[\] interface {},dest ... interface {})(\[\] interface {},error)

Scan函数从src复制到dest指向的值。

Dest参数的值必须是整数，浮点数，布尔值，字符串，\[\]byte，interface{}或这些类型的切片。Scan使用标准的strconv包将批量字符串转换为数字和布尔类型。

示例代码

var value1 int

var value2 string

reply, err := redis.Values(c.Do("MGET", "key1", "key2"))

if err != nil {

 //处理错误代码

}

 if \_, err := redis.Scan(reply, &value1, &value2); err != nil {

 // 处理错误代码

}
