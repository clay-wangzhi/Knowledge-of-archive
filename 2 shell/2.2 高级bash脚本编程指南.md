# 第一部分 初见shell

Shell是一种命令解释器，它不仅分离了用户层与操作系统内核，更是一门强大的编程语言。我们称为shell编写的程序为脚本（script）。脚本是一种易于使用的工具，它能够将系统调用、工具软件、实用程序（utility）和已编译的二进制文件联系在一起构建程序。实际上，shell脚本可以调用所有的UNIX命令、实用程序以及工具软件。如果你觉得这还不够，使用像`test`命令和循环结构这样的shell内建命令能够让脚本更加灵活强大。Shell脚本特别适合完成系统管理任务和那些不需要复杂结构性语言实现的重复工作。

## 1 为什么使用shell编程

> 没有任何一种程序设计语言是完美的，甚至没有一个最好的语言。只有在特定环境下适合的语言。
>
> —— Herbert Mayer

## 2 和Sha-Bang（#!）一起出发

一个最简单的脚本其实就是将一连串系统命令存储在一个文件中。最起码，它能帮你省下重复输入这一连串命令的功夫。

样例：清理`/var/log`目录下的日志文件

```bash
#!/bin/bash
# Cleanup, version 3

LOG_DIR=/var/log
ROOT_UID=0     # UID为0的用户才拥有root权限。
LINES=50       # 默认保存messages日志文件行数。
E_XCD=86       # 无法切换工作目录的错误码。
E_NOTROOT=87   # 非root权限用户执行的错误码。
E_WRONGARGS=85 # 非数值格式的错误吗。


# 请使用root权限运行。
if [ "$UID" -ne "$ROOT_UID" ];then
  echo "Must be root to run this script."
  exit $E_NOTROOT
fi

case "$1" in
  "") lines=$LINES ;;
  *[!0-9]*) echo "Usage: bash `basename $0` lines-to-cleanup"; exit $E_WRONGARGS ;;
  *) lines=$1 ;;
esac

cd $LOG_DIR || {
  echo "Cannot change to necessary directory." >&2
  exit $E_XCD
}

tail -n $lines messages > mesg.temp # 保存messages日志文件最后一部分
mv mesg.temp messages               # 替换系统日志文件以达到清理目的

cat /dev/null > wtmp  #  ': > wtmp' 与 '> wtmp' 有同样的效果
echo "Log files cleaned up."
#  注意在/var/log目录下的其他日志文件不会被这个脚本清除

exit 0
#  返回0表示脚本运行成功
```

脚本起始行*sha-bang*（#!）告诉系统这个脚本文件需要使用指定的命令解释器来执行。

### 2.1 调用一个脚本

写完一个脚本以后，你可以通过`sh scriptname`或`bash scriptname`来调用它（不推荐使用`sh <scriptname`调用脚本，因为这会禁用脚本从标准输入（stdin）读入数据）。更方便的方式是使用`chmod`命令使脚本可以被直接执行。

执行命令：

`chmod +x scriptname`（给予所有用户读取/执行的权限）

当脚本的权限被设置好后，你就可以直接使用`./scriptname`进行调用测试了。如果脚本文件以sha-bang开头，那么它将自动调用指定的命令解释器运行脚本。

完成调试与测试后，你可能会将脚本文件移至`/usr/local/bin`（使用root权限）中，使脚本可以被所有用户调用。这时你可以直接在命令行中输入`scriptname [ENTER]`执行脚本。

# 第二部分 shell基础

## 3 特殊字符

是什么让一个字符变得*特殊*呢？如果一个字符不仅具有*字面*意义，而且具有*元意（meta-meaning）*，我们就称它为特殊字符。特殊字符同命令和关键词（keywords）一样，是bash脚本的组成部分。

你在脚本或其他地方都能够找到特殊字符。

* \# 注释符

  * 如果一行脚本的开头是#（除了#!），那么代表这一行是注释，不会被执行。

    ```bash
    # 这是一行注释
    ```

  * 注释也可能会在一行命令结束之后出现。

    ```bash
    echo "A comment will follow." # 这儿可以写注释
    #                            ^ 注意在#之前有空格
    ```

  * 注释也可以出现在一行开头的空白符（whitespace）之后。

    ```bash
    	# 这个注释前面存在着一个制表符（tab）
    ```

  * 注释甚至可以嵌入到管道命令（pipe）之中。

    ```bash
    initial=( `cat "$startfile" | sed -e '/#/d' | tr -d '\n' |\
    # 删除所有带'#'注释符号的行
               sed -e 's/\./\. /g' -e 's/_/_ /g'` )
    # 摘录自脚本 life.sh
    ```

  * > ![notice](images/caution.gif)命令不能写在同一行注释之后。因为没有任何方法可以结束注释(仅支持单行注释)，为了让新命令正常执行，另起一行写吧。

    > ![extra](images/note.gif) 当然，在`echo`语句中被引用或被转义的#不会被认为是注释。同样，在某些参数替换式或常量表达式中的#也不会被认为是注释。

* ; 命令分割符[分号]

  * 允许在同一行内放置两条或更多的命令。

    ```bash
    echo hello; echo there
    
    if [ -x "$filename" ]; then    #  注意在分号以后有一个空格
    #+                   ^^
      echo "File $filename exists."; cp $filename $filename.bak
    else   #                       ^^
      echo "File $filename not found."; touch $filename
    fi; echo "File test complete."
    ```

    > 注意有时候";"需要被转义才能正常工作。

* ;; `case`条件语句终止符[双分号]。

  ```bash
  case "$variable" in
    abc)  echo "\$variable = abc" ;;
    xyz)  echo "\$variable = xyz" ;;
  esac
  ```

* ;;&, ;& `case`条件语句终止符（Bash4+ 版本）。

* . [句点]

  * 句点命令[句点]。等价于`source`命令（查看样例 15-22）。这是一个bash的内建命令。

  * 句点可以作为文件名的一部分。如果它在文件名开头，那说明此文件是隐藏文件。使用不带参数的`ls`命令不会显示隐藏文件。

    ```
    bash$ touch .hidden-file
    bash$ ls -l
    total 10
     -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
     -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
     -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook
    	
    	
    bash$ ls -al
    total 14
     drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
     drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
     -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
     -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
     -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
     -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file
    ```

  * 当句点出现在目录中时，单个句点代表当前工作目录，两个句点代表上级目录。

    ```
    bash$ pwd
    /home/bozo/projects
    
    bash$ cd .
    bash$ pwd
    /home/bozo/projects
    
    bash$ cd ..
    bash$ pwd
    /home/bozo/
    ```

  * 句点匹配符。在*正则表达式*中，点号意味着匹配任意单个字符。

* "  部分引用[双引号]。在字符串中保留大部分特殊字符。详细内容将在[第五章](05_quoting.md)介绍。

* ' 全引用[单引号]。在字符串中保留所有的特殊字符。是部分引用的强化版。详细内容将在[第五章](05_quoting.md)介绍。

* , [逗号]

  * 逗号运算符。逗号运算符将一系列的算术表达式串联在一起。算术表达式依次被执行，但只返回最后一个表达式的值。

    ```bash
    let "t2 = ((a = 9, 15 / 3))"
    # a被赋值为9，t2被赋值为15 / 3
    ```

  * 逗号运算符也可以用来连接字符串。

    ```bash
    for file in /{,usr/}bin/*calc
    #             ^    在 /bin 与 /usr/bin 目录中
    #+                 找到所有的以"calc"结尾的可执行文件
    do
            if [ -x "$file" ]
            then
              echo $file
            fi
    done
    
    # /bin/ipcalc
    # /usr/bin/kcalc
    # /usr/bin/oidcalc
    # /usr/bin/oocalc
    
    # 感谢Rory Winston提供的执行结果
    ```

* ,, , 在参数替换中进行小写字母转换（Bash4 新增）。

* \ 转义符[反斜杠]。转义某字符的标志。

  `\x`转义了字符x。双引号""内的X与单引号内的X具有同样的效果。
  转义符也可以用来转义"与'，使它们表达其字面含义。

  第五章将更加深入的解释转义字符。

* / [正斜杠]
  * 文件路径分隔符[正斜杠]。起分割路径的作用。（比如 `/home/bozo/projects/Makefile`）
  * 它也在算术运算中充当除法运算符。

* \`  命令替换符。`` `command` ``结构可以使得命令的输出结果赋值给一个变量。通常也被称作后引号（backquotes）或反引号（backticks）。

* : [冒号]

  * 空命令[冒号]。它在shell中等价于"NOP"（即no op，空操作）与shell内建命令true有同样的效果。它本身也是Bash的内建命令之一，返回值是true（0）。

    ```bash
    :
    echo $?   # 返回0
    ```

    在无限循环中的应用：

    ```bash
    while :
    do
       operation-1
       operation-2
       ...
       operation-n
    done
    
    # 等价于
    #    while true
    #    do
    #      ...
    #    done
    ```

  * 可在 `if/then` 中充当占位符：

    ```bash
    if condition
    then :   # 什么都不做，跳出判断执行下一条语句
    else
       take-some-action
    fi
    ```

  * 在二元操作中作占位符: 查看*样例 8-2*或*默认参数*部分。

    ```bash
    : ${username=`whoami`}
    # ${username=`whoami`}   如果没有:就会报错
    #                        除非 "username" 是系统命令或内建命令
    
    : ${1?"Usage: $0 ARGUMENT"}     # 摘自样例脚本 "usage-message.sh"
    ```

    查看*样例 19-10*了解空命令在here document中作为占位符的情况。

  * 使用参数替换为字符串变量赋值（查看*样例 10-7*）。

    ```bash
    : ${HOSTNAME?} ${USER?} ${MAIL?} #  如果其中一个或多个必要的环境变量没有被设置
    #  将会打印错误
    ```

    查看*变量扩展*或*字符串替换*章节了解空命令在其中的作用。

  * 与`>`重定向操作符结合，可以在不改变文件权限的情况下清空文件。如果文件不存在，那么将创建这个文件。

    ```bash
    : > data.xxx   # 文件 "data.xxx" 已被清空
    
    # 与 cat /dev/null >data.xxx 作用相同
    # 但是此操作不会产生一个新进程，因为 ":" 是shell内建命令。
    ```

    也可查看*样例 16-15*。

  * 与`>>`重定向操作符结合，将不会清空任何已存在的文件（`: >> target_file`）。如果文件不存在，将创建这个文件。

    > ![extra](images/note.gif) 以上操作仅适用于普通文件，不适用于管道、符号链接和特殊文件。

  * :也可以作为一个域分隔符，比如在`/etc/passwd`和 `$PATH` 变量中。

    ```
    bash$ echo $PATH
    /usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games
    ```

    

* ! [感叹号]
  * 取反（或否定）操作符[感叹号]。! 操作符反转已执行的命令的返回状态（查看*样例 6-2*）。它同时可以反转测试操作符的意义，例如可以将相等（=）反转成不等（!=）。它是一个Bash关键词。
  * 在一些特殊场景下，它也会出现在间接变量引用中。
  * 在另外一些特殊场景下，即在命令行下可以使用 ! 调用Bash的历史记录（*附录 L*）。需要注意的是，在脚本中，这个机制是被禁用的。

* \* [星号]

  * 通配符[星号]。在文件匹配（globbing）操作时扩展文件名。如果它独立出现，则匹配该目录下的所有文件。

    ```
    bash$ echo *
    abs-book.sgml add-drive.sh agram.sh alias.sh
    ```

  * 在*正则表达式*中表示匹配任意多个（包括0）前个字符。
  * 算术运算符。在进行算术运算时，表示乘法运算。
  * ** 双星号可以表示乘方运算或扩展文件匹配。

* ? [问号]

  * 测试操作符[问号]。在一些特定的语句中，? 表示一个条件测试。

    在一个双圆括号结构中，? 可以表示一个类似C语言风格的三元（trinary）运算符的一个组成部分。

    `condition?result-if-true:result-if-false`

    ```bash
    (( var0 = var1<98?9:21 ))
    #不要加空格，紧挨着写
    
    #等价于
    # if [ "$var1" -lt 98 ]
    # then
    #   var0=9
    # else
    #   var0=21
    # fi
    ```

    在参数替换表达式中，? 用来测试一个变量是否已经被赋值。

  * 通配符。它在进行文件匹配（globbing）时以单字符通配符扩展文件名。
    在*扩展正则表达式*中匹配一个单字符。

* $ [钱字符]

  * 取值符号[钱字符]，用来进行变量替换（即取出变量的内容）。

    ```bash
    var1=5
    var2=23skidoo
    
    echo $var1     # 5
    echo $var2     # 23skidoo
    ```

    如果在变量名前有 $，则表示此变量的值。

  * 行结束符[EOF]。

    在*正则表达式*中，$ 匹配行尾字符串。

* ${} 参数替换。

* $'...' 引用字符串扩展。这个结构将转义八进制或十六进制的值转换成ASCII或Unicode字符。

* $*, $@ 位置参数。

* $? 返回状态变量。此变量保存一个命令、一个函数或该脚本自身的返回状态。

* $$ 进程ID变量。此变量保存该运行脚本的进程ID。

* ()

  * 命令组。

    `(a=hello; echo $a)`

    > ![notice](images/important.gif) 通过括号执行一系列命令会产生一个子shell（subshell）。

    括号中的变量，即在子shell中的变量，在脚本的其他部分是不可见的。父进程脚本不能访问子进程（子shell）所创建的变量。

    ```bash
    a=123
    ( a=321; )
    
    echo "a = $a"   # a = 123
    # 在括号中的 "a" 就像个局部变量。
    ```

  * 数组初始化。

    ```bash
    Array=(element1 element2 element3)
    ```

* {xxx,yyy,zzz,...}  花括号扩展结构。

  ```bash
  echo \"{These,words,are,quoted}\"   # " 将作为单词的前缀和后缀
  # "These" "words" "are" "quoted"
  
  
  cat {file1,file2,file3} > combined_file
  # 将 file1, file2 与 file3 拼接在一起后写入 combined_file 中。
  
  cp file22.{txt,backup}
  # 将 "file22.txt" 拷贝为 "file22.backup"
  ```

  这个命令可以作用于花括号内由逗号分隔的文件描述列表。 文件名扩展（匹配）作用于大括号间的各个文件。

  > ![notice](images/caution.gif) 除非被引用或被转义，否则空白符不应在花括号中出现。

  ```bash
  echo {file1,file2}\ :{\ A," B",' C'}
  file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C
  ```

* {a..z} 扩展的花括号扩展结构。

  ```bash
  echo {a..z} #  a b c d e f g h i j k l m n o p q r s t u v w x y z
  # 输出 a 到 z 之间所有的字母。
  	
  echo {0..3} # 0 1 2 3
  # 输出 0 到 3 之间所有的数字。
  
  
  base64_charset=( {A..Z} {a..z} {0..9} + / = )
  # 使用扩展花括号初始化一个数组。
  # 摘自 vladz 编写的样例脚本 "base64.sh"。
  ```

  Bash第三版中引入了 {a..z} 扩展的花括号扩展结构。

* {}  [花括号]

  * 代码块[花括号]，又被称作内联组（inline group）。

    它实际上创建了一个匿名函数（anonymous function），即没有名字的函数。但是，不同于那些“标准”函数，代码块内的变量在脚本的其他部分仍旧是可见的。

    ```
    bash$ { local a;
                  a=123; }
    bash: local: can only be used in a
    function
    ```

    ```bash
    a=123
    { a=321; }
    echo "a = $a"   # a = 321   (代码块内赋值)
    
    # 感谢S.C.
    ```

    代码块可以经由I/O重定向进行输入或输出。

    **样例 3-1. 代码块及I/O重定向**

    ```bash
    #!/bin/bash
    # 读取文件 /etc/fstab
    
    File=/etc/fstab
    
    {
    read line1
    read line2
    } < $File
    
    echo "First line in $File is:"
    echo "$line1"
    echo
    echo "Second line in $File is:"
    echo "$line2"
    
    exit 0
    
    # 你知道如何解析剩下的行吗？
    # 提示：使用 awk 或...
    # Hans-Joerg Diers 建议：使用Bash的内建命令 set。
    ```

    **样例 3-2. 将代码块的输出保存至文件中**

    ```bash
    #!/bin/bash
    # rpm-check.sh
    
    # 查询一个rpm文件的文件描述、包含文件列表，以及是否可以被安装。
    # 将输出保存至文件。
    #
    # 这个脚本使用代码块来描述。
    
    SUCCESS=0
    E_NOARGS=65
    
    if [ -z "$1" ]
    then
      echo "Usage: `basename $0` rpm-file"
      exit $E_NOARGS
    fi  
    
    { # 代码块起始
      echo
      echo "Archive Description:"
      rpm -qpi $1       # 查询文件描述。
      echo
      echo "Archive Listing:"
      rpm -qpl $1       # 查询文件列表。
      echo
      rpm -i --test $1  # 查询是否可以被安装。
      if [ "$?" -eq $SUCCESS ]
      then
        echo "$1 can be installed."
      else
        echo "$1 cannot be installed."
      fi  
      echo              # 代码块结束。
    } > "$1.test"       # 输出重定向至文件。
    
    echo "Results of rpm test in file $1.test"
    
    # rpm各项参数的具体含义可查看man文档
    
    exit 0
    ```

    > ![extra](images/note.gif) 与由圆括号包裹起来的命令组不同，由花括号包裹起来的代码块不产生子进程。
    >
    > 也可以使用非标准的 for 循环语句来遍历代码块。

  * 文本占位符。在 `xargs -i` 后作为输出的占位符使用。

    ```bash
    ls . | xargs -i -t cp ./{} $1
    #            ^^         ^^
    
    # 摘自 "ex42.sh" (copydir.sh)
    ```

* {} \; 路径名。通常在 `find` 命令中使用，但这不是shell的内建命令。

  > 定义：路径名是包含完整路径的文件名，例如`/home/bozo/Notes/Thursday/schedule.txt`。我们通常又称之为绝对路径。
  >
  > ![extra](images/note.gif) 在执行`find -exec`时最后需要加上`;`，但是分号需要被转义以保证其不会被shell解释。

* [ ]

  * 测试。在 [ ] 之间填写测试表达式。值得注意的是，[ 是shell内建命令 `test` 的一个组成部分，而不是外部命令 `/usr/bin/test` 的链接。

  * 数组元素。在数组中，可以使用中括号的偏移量来用来访问数组中的每一个元素。

    ```bash
    Array[1]=slot_1
    echo ${Array[1]}
    ```

  * 字符集、字符范围。
    在*正则表达式*中，中括号用来匹配指定字符集或字符范围内的任意字符。

* [[ ]]  测试。

  在 [[ ]] 之间填写测试表达式。相比起单括号测试 （[ ]），它更加的灵活。它是一个shell的关键字。

  详情查看*关于 [[ ]] 结构的讨论*。

* $[ ... ]整数扩展符。在 $[ ] 中可以计算整数的算术表达式。

  ```bash
  a=3
  b=7
  
  echo $[$a+$b]   # 10
  echo $[$a*$b]   # 21
  ```

* (( )) 整数扩展符。在 (( )) 中可以计算整数的算术表达式。

  详情查看*关于 (( ... )) 结构的讨论*。

* \> &> >& >> < <>  重定向。

  `scriptname >filename` 将脚本 *scriptname* 的输出重定向到 *filename* 中。如果文件存在，那么覆盖掉文件内容。

  `command &>filename` 将命令 *command* 的标准输出(stdout) 和标准错误输出(stderr) 重定向到 *filename*。

  >  ![extra](images/note.gif) 重定向在用于清除测试条件的输出时特别有效。例如测试一个特定的命令是否存在。

  ```
  bash$ type bogus_command &>/dev/null
  bash$ echo $?
  1
  ```

  或写在脚本中：

  ```bash
  command_test () { type "$1" &>/dev/null; }
  #                                      ^
   
  cmd=rmdir            # 存在的命令。
  command_test $cmd; echo $?   # 返回0
  
  
  cmd=bogus_command    # 不存在的命令。
  command_test $cmd; echo $?   # 返回1
  ```

  `command >&2` 将命令的标准输出重定向至标准错误输出。

  `scriptname >>filename` 将脚本 *scriptname* 的输出追加到 *filename* 文件末尾。如果文件不存在，那么将创建这个文件。

  `[i]<>filename` 打开文件 *filename* 用来读写，并且分配一个文件描述符*i*指向它。如果文件不存在，那么将创建这个文件。

  进程替换：
  `(command)>`
  `<(command)`

  在某些情况下， "<" 与 ">" 将用作字符串比较。

  在另外一些情况下， "<" 与 ">" 将用作数字比较。详情查看*样例 16-9*。

* <<   在here document中进行重定向。

* <<<  在here string中进行重定向。

* <, >

  * ASCII码比较。

    ```bash
    veg1=carrots
    veg2=tomatoes
    
    if [[ "veg1" < "veg2" ]]
    then
      echo "Although $veg1 precede $veg2 in the dictionary,"
      echo -n "this does not necessarily imply anything "
      echo "about my culinary preferences."
    else
      echo "What kind of dictionary are you using, anyhow?"
    fi
    ```

  * *正则表达式*中的单词边界（word boundary）。

    ```
    bash$ grep '\<the\>' textfile
    ```

* |  管道（pipe）。管道可以将上一个命令的输出作为下一个命令的输入，或者直接输出到shell中。管道是一种可以将一系列命令连接在一起的绝妙方式。

  ```bash
  echo ls -l | sh
  #  将 "echo ls -l" 的结果输出到shell中，
  #  与直接输入 "ls -l" 的结果相同。
  
  
  cat *.lst | sort | uniq
  # 将所有后缀名为 lst 的文件合并后排序，接着删掉所有重复行。
  ```

  > 管道是一种在进程间通信的典型方法。它将一个进程的输出作为另一个进程的输入。举一个经典的例子，像 `cat` 或者 `echo` 这样的命令，可以通过管道将它们产生的数据流导入到过滤器（filter）中。过滤器是可以用来处理输入流的命令。
  >
  > `cat $filename1 $filename2 | grep $search_word`
  >
  > 查看[UNIX FAQ第三章](http://www.faqs.org/faqs/unix-faq/faq/part3/)获取更多关于使用UNIX管道的信息。

  命令的输出同样可以通过管道输入到脚本中。

  ```bash
  #!/bin/bash
  # uppercase.sh : 将所有输入变成大写
  
  tr 'a-z' 'A-Z'
  #  为了防止产生单字符文件名，
  #  必须使用单引号引用字符范围。
  
  exit 0
  ```

  现在，让我们将 `ls -l` 的输出通过管道导入到脚本中。

  ```
  bash$ ls -l | ./uppercase.sh
   -RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
   -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
   -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE
  ```

  > ![extra](images/note.gif) 在管道中，每一个进程的输出必须作为下个进程的输入被正确读入，如果不这样，数据流会被阻塞（block），管道就无法按照预期正常工作。

  ```bash
  cat file1 file2 | ls -l | sort
  # "cat file1 file2" 的输出会消失。
  ```

  管道是在一个子进程中运行的，因此它并不能修改父进程脚本中的变量。

  ```bash
  variable="initial_value"
  echo "new_value" | read variable
  echo "variable = $variable"     # variable = initial_value
  ```

  如果管道中的任意一个命令意外中止了，管道将会提前中断，我们称其为*管道破裂*(Broken Pipe)。出现这种情况，系统将发送一个 `SIGPIPE` 信号。

* \>|  强制重定向。即使在 `noclobber` 选项被设置的情况下，重定向也会覆盖已存在的文件。

* ||  或（OR）逻辑运算符。在测试结构中，任意一个测试条件为真，整个表达式为真。返回 0（成功标志位）。

* &  后台运行操作符。如果命令后带&，那么此命令将转至后台运行。

  ```
  bash$ sleep 10 &
  [1] 850
  [1]+  Done                    sleep 10
  ```

  在脚本中，命令甚至循环都可以在后台运行

  **样例 3-3. 在后台运行的循环**

  ```bash
  #!/bin/bash
  # background-loop.sh
  
  for i in 1 2 3 4 5 6 7 8 9 10            # 第一个循环
  do
    echo -n "$i "
  done & # 这个循环在后台运行。
         # 有时会在第二个循环结之后才执行此后台循环。
  
  echo   # 此'echo' 有时不显示
  
  for i in 11 12 13 14 15 16 17 18 19 20   # 第二个循环
  do
    echo -n "$i "
  done
  
  echo   # 此'echo' 有时不显示
  
  # ======================================================
  
  # 脚本期望输出结果：
  # 1 2 3 4 5 6 7 8 9 10
  # 11 12 13 14 15 16 17 18 19 20
  
  # 一些情况下可能会输出：
  # 11 12 13 14 15 16 17 18 19 20
  # 1 2 3 4 5 6 7 8 9 10 bozo $
  # 第二个 'echo' 没有被执行，为什么？
  
  # 另外一些情况下可能会输出：
  # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
  # 第一个 'echo' 没有被执行，为什么？
  
  # 非常罕见的情况下，可能会输出：
  # 11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20
  # 前台循环抢占（preempt）了后台循环。
  
  exit 0
  
  #  Nasimuddin Ansari 建议：在第6行和第14行的
  #  echo -n "$i " 后增加 sleep 1，
  #  会得到许多有趣的结果。
  ```

  > ![notice](images/caution.gif) 脚本在后台执行命令时可能因为等待键盘事件被挂起。幸运的是，有一套方案可以解决这个问题。

* &&  与（AND）逻辑操作符。在测试结构中，所有测试条件都为真，表达式才为真，返回 0（成功标志位）。

* \-  

  * 选项与前缀。它可以作为命令的选项标志，也可以作为一个操作符的前缀，也可以作为在参数代换中作为默认参数的前缀。

    `COMMAND -[Option1][Option2][..]`

    `ls -al`

    `sort -dfu $filename`

    ```bash
    if [ $file1 -ot $file2 ]
    then #      ^
      echo "File $file1 is older than $file2."
    fi
    
    if [ "$a" -eq "$b" ]
    then #    ^
      echo "$a is equal to $b."
    fi
    
    if [ "$c" -eq 24 -a "$d" -eq 47 ]
    then #    ^              ^
      echo "$c equals 24 and $d equals 47."
    fi
    
    
    param2=${param1:-$DEFAULTVAL}
    #               ^
    ```

  * 重定向输入输出[短横线]。

    ```
    bash$ cat -
    abc
    abc
    
    ...
    
    Ctl-D
    ```

    在这个例子中，`cat -` 输出由键盘读入的标准输入(stdin) 到 标准输出(stdout)。但是在真实应用的 I/O 重定向中是否有使用 '-'？

    ```bash
    (cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)
    
    # 将整个文件树从一个目录移动到另一个目录。
    # 感谢 Alan Cox <a.cox@swansea.ac.uk> 所作出的部分改动
    
    # 1) cd /source/directory
    #    工作目录定位到文件所属的源目录
    # 2) &&
    #    "与链"：如果 'cd' 命令操作成功，那么执行下一条命令
    # 3) tar cf - .
    #    'tar c' (create 创建) 创建一份新的档案
    #    'tar f -' (file 指定文件) 在 '-' 后指定一个目标文件作为输出
    #    '.' 代表当前目录
    # 4) |
    #    通过管道进行重定向
    # 5) ( ... )
    #    在建立的子进程中执行命令
    # 6) cd /dest/directory
    #    工作目录定位到目标目录
    # 7) &&
    #    与 2) 相同
    # 8) tar xpvf -
    #    'tar x' 解压档案
    #    'tar p' (preserve 保留) 保留档案内文件的所有权及文件权限
    #    'tar v' (verbose 冗余) 发送全部信息到标准输出
    #    'tar f -' (file 指定文件) 在 '-' 后指定一个目标文件作为输入
    #
    #    注意 'x' 是一个命令，而 'p', 'v', 'f' 是选项。
    
    # 干的漂亮！
    
    
    # 更加优雅的写法是:
    #   cd source/directory
    #   tar cf - . | (cd ../dest/directory; tar xpvf -)
    #
    # 同样可以写成:
    #   cp -a /source/directory/* /dest/directory
    # 或:
    #   cp -a /source/directory/* /source/directory/.[^.]* /dest/directory
    # 可以在源目录中有隐藏文件时使用
    ```

    ```bash
    bunzip2 -c linux-2.6.16.tar.bz2 | tar xvf -
    #  --未解压的 tar 文件--        | --将解压出的 tar 传递给 "tar"--
    #  如果不使用管道让 "tar" 处理 "bunzip2" 得到的文件，
    #  那么就需要使用单独的两步来完成。
    #  目的是为了解压 "bzipped" 压缩的内核源代码。
    ```

    下面的例子中，"-" 并不是一个Bash的操作符，它仅仅是 `tar`, `cat` 等一些特定UNIX命令中将结果输出到标准输出的选项。

    ```
    bash$ echo "whatever" | cat -
    whatever 
    ```

    当需要文件名的时候，- 可以用来代替某个文件而重定向到标准输出（通常出现在 `tar cf` 中）或从 *stdin* 中接受数据。这是一种在管道中使用面向文件（file-oriented）工具作为过滤器的方法。

    ```
    bash$ file
    Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...
    ```

    单独执行 `file` 命令，将会得到一条错误信息。

    在命令后增加一个 "-" 可以得到一个更加有用的结果。它会使得shell暂停等待用户输入。

    ```
    bash$ file -
    abc
    standard input:              ASCII text
    
    
    bash$ file -
    #!/bin/bash
    standard input:              Bourne-Again shell script text executable
    ```

    现在命令能够接受标准输入并且处理它们了。

    "-" 能够通过管道将标准输出重定向到其他命令中。这就可以做到像在某个文件前添加几行这样的事情。

    使用 `diff` 比较两个文件的部分内容：

    ```bash
    grep Linux file1 | diff file2 -
    ```

    最后介绍一个使用 - 的 `tar` 命令的实际案例。

    **样例 3-4. 备份最近一天修改过的所有文件**

    ```bash
    #!/bin/bash
    
    #  将当前目录下24小时之内修改过的所有文件备份成一个
    #  "tarball" (经 tar 打包`与 gzip 压缩) 文件
    
    BACKUPFILE=backup-$(date +%m-%d-%Y)
    #                 在备份文件中嵌入时间
    #                 感谢 Joshua Tschida 提供的建议
    
    archive=${1:-$BACKUPFILE}
    #  如果没有在命令行中特别制定备份格式，
    #  那么将会默认设置为 "backup-MM-DD-YYYY.tar.gz"。
    
    tar cvf - `find . -mtime -1 -type f -print` > $archive.tar
    gzip $archive.tar
    echo "Directory $PWD backed up in archive file \"$archive.tar.gz\"."
    
    #  Stephane Chazeles 指出如果目录中有非常多的文件，
    #  或文件名中包含空白符时，上面的代码会运行失败。
    
    # 他建议使用以下的任意一种方法：
    # -------------------------------------------------------------------
    #   find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$archive.tar"
    #   使用了 GNU 版本的 "find" 命令。
    
    
    #   find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;
    #   兼容其他的 UNIX 发行版，但是速度会比较慢
    # -------------------------------------------------------------------
    
    
    exit 0
    ```

    > ![notice](images/caution.gif) 以 "-" 开头的文件在和"-" 重定向操作符一起使用时可能会导致一些问题。因此合格的脚本必须首先检查这种情况。如果遇到，就需要给文件名加一个合适的前缀，比如 `./-FILENAME, $PWD/-FILENAME` 或者`$PATHNAME/-FILENAME` 。
    >
    > 如果变量的值以 '-' 开头，也可能会造成类似问题。

    ```bash
    var='-n'
    echo $var
    # 等同于 "echo -n"，不会输出任何东西。
    ```

  * 先前的工作目录。使用 `cd -` 命令可以返回先前的工作目录。它实际上是使用了 `$OLDPWD` 环境变量。

    > ![notice](images/caution.gif) 不要将这里的 "-" 与先前的 "-" 重定位操作符混淆。"-" 的具体含义需要根据上下文来解释。

  * 减号。算术运算符中的减法标志。

* --

  双横线一般作为命令长选项的前缀。

  `sort --ignore-leading-blanks`

  双横线与Bash内建命令一起使用时，意味着该命令选项的结束。

  > ![info](images/tip.gif) 下面提供了一种删除文件名以横线开头文件的简单方法。

  ```
  bash$ ls -l
  -rw-r--r-- 1 bozo bozo 0 Nov 25 12:29 -badname
  
  
  bash$ rm -- -badname
  
  bash$ ls -l
  total 0
  ```

  双横线通常也和 `set` 连用。

  `set -- $variable`（查看*样例 15-18*）。

* =  等号。赋值操作符。

  ```bash
  a=28
  echo $a   # 28
  ```

  在一些情况下，"=" 可以作为字符串比较操作符。

* \+ 加号。

  * 加法算术运算。

  * 在一些情况下，+ 是作为正则表达式中的一个操作符。

  * 选项操作符。作为一个命令或过滤器的选项标记。

    特定的一些指令和内建命令使用 + 启用特定的选项，使用 - 禁用特定的选项。在参数代换中，+ 是作为变量扩展的备用值（alternate value）的前缀。

* %

  * 取模。取模操作运算符。

    ```
    let "z = 5 % 3"
    echo $z  # 2
    ```

  * 在另外一些情况下，% 是一种模式匹配的操作符。

* ~

  主目录[波浪号]。它相当于内部变量 `$HOME`。`~bozo` 是 bozo 的主目录，执行 `ls ~bozo` 将会列出他的主目录中内容。`~/` 是当前用户的主目录，执行 `ls ~/` 将会列出其中所有的内容。

  ```
  bash$ echo ~bozo
  /home/bozo
  
  bash$ echo ~
  /home/bozo
  
  bash$ echo ~/
  /home/bozo/
  
  bash$ echo ~:
  /home/bozo:
  
  bash$ echo ~nonexistent-user
  ~nonexistent-user
  ```

* ~+  当前工作目录。它等同于内部变量 `$PWD`。

* ~-  先前的工作目录。它等同于内部变量 `$OLDPWD`。

* =~  *正则表达式*匹配。将在 *Bash version 3 *章节中介绍。

* ^  行起始符。在正则表达式中，"^" 代表一行文本的开始。

* ^, ^^   参数替换中的大写转换符（在Bash第4版新增）。

* 空白符

  作为命令或变量之间的分隔符。空白符包含空格、制表符、换行符或它们的任意组合。在一些地方，比如变量赋值时，空白符不应该出现，否则会造成语法错误。

  空白行在脚本中不会有任何实际作用，但是可以划分代码，使代码更具可读性。

  特殊变量 `$IFS` 是作为一些特定命令的输入域（field）分隔符，默认值为空白符。

  > 定义：域是字符串中离散的数据块。使用空白符或者指定的字符（通常由 `$IFS` 决定）来分隔临近域。在一些情况下，域也可以被称作记录（record）。

  如果想在字符串或者变量中保留空白符，请引用。

  UNIX 过滤器可以使用 POSIX 字符类 `[:space:]` 来寻找和操作空白符。

## 4 变量与参数

变量（variable）在编程语言中用来表示数据。它本身只是一个标记，指向数据在计算机内存中的一个或一组地址。

变量通常出现在算术运算，数量操作及字符串解析中。

### 4.1 变量替换($)

变量名是其所指向值的一个占位符（placeholder）。引用变量值的过程我们称之为变量替换（variable substitution）。

接下来我们仔细区分一下**变量名**与**变量值**。如果变量名是 `variable1`， 那么 `$variable1` 就是对变量值的引用。

```
bash$ variable1=23

bash$ echo variable1
variable1

bash$ echo $variable1
23
```

变量仅仅在声明时、赋值时、被删除时（`unset`）、被导出时（`export`），算术运算中使用双括号结构((...))时或在代表信号时（signal，查看样例 32-5）才不需要有 $ 前缀。赋值可以是使用 =（比如 `var1=27`），可以是在 `read` 语句中，也可以是在循环的头部（`for var2 in 1 2 3`）。

在双引号`""`字符串中可以使用变量替换。我们称之为部分引用，有时候也称弱引用。而使用单引号`''`引用时，变量只会作为字符串显示，变量替换不会发生。我们称之为全引用，有时也称强引用。更多细节将在第五章讲解。

实际上, `$variable` 这种写法是 `${variable}` 的简化形式。在某些特殊情况下，使用 `$variable` 写法会造成语法错误，使用完整形式会更好（查看章节 10.2）。

样例 4-1. 变量赋值与替换

```bash
#!/bin/bash
# ex9.sh

# 变量赋值与替换

a=375
hello=$a
#   ^ ^

#----------------------------------------------------
# 初始化变量时，赋值号 = 的两侧绝不允许有空格出现。
# 如果有空格会发生什么？

#   "VARIABLE =value"
#            ^
#% 脚本将会尝试运行带参数 "=value" 的 "VARIABLE " 命令。

#   "VARIABLE= value"
#             ^
#% 脚本将会尝试运行 "value" 命令，
#+ 同时设置环境变量 "VARIABLE" 为 ""。
#----------------------------------------------------


echo hello    # hello
# 没有引用变量，"hello" 只是一个字符串...

echo $hello   # 375
#    ^          这是变量引用。

echo ${hello} # 375
#               与上面的类似，变量引用。

# 字符串内引用变量
echo "$hello"    # 375
echo "${hello}"  # 375

echo

hello="A B  C   D"
echo $hello   # A B C D
echo "$hello" # A B  C   D
# 正如我们所见，echo $hello 与 echo "$hello" 的结果不同。
# ====================================
# 字符串内引用变量将会保留变量的空白符。
# ====================================

echo

echo '$hello'  # $hello
#    ^      ^
#  单引号会禁用掉（转义）变量引用，这导致 "$" 将以普通字符形式被解析。

# 注意单双引号字符串引用效果的不同。

hello=    # 将其设置为空值
echo "\$hello (null value) = $hello"      # $hello (null value) =
# 注意 
# 将一个变量设置为空与删除(unset)它不同，尽管它们的表现形式相同。

# -----------------------------------------------

# 使用空白符分隔，可以在一行内对多个变量进行赋值。
# 但是这会降低程序的可读性，并且可能会导致部分程序不兼容的问题。

var1=21  var2=22  var3=$V3
echo
echo "var1=$var1   var2=$var2   var3=$var3"

# 在一些老版本的 shell 中这样写可能会有问题。

# -----------------------------------------------

echo; echo

numbers="one two three"
#           ^   ^
other_numbers="1 2 3"
#               ^ ^
# 如果变量中有空白符号，那么必须用引号进行引用。
# other_numbers=1 2 3                  # 出错
echo "numbers = $numbers"
echo "other_numbers = $other_numbers"  # other_numbers = 1 2 3
# 也可以转义空白符。
mixed_bag=2\ ---\ Whatever
#           ^    ^ 使用 \ 转义空格

echo "$mixed_bag"         # 2 --- Whatever

echo; echo

echo "uninitialized_variable = $uninitialized_variable"
# 未初始化的变量是空值(null表示不含有任何值)。
uninitialized_variable=   # 只声明而不初始化，等同于设为空值。
echo "uninitialized_variable = $uninitialized_variable" # 仍旧为空

uninitialized_variable=23       # 设置变量
unset uninitialized_variable    # 删除变量
echo "uninitialized_variable = $uninitialized_variable"
                                # uninitialized_variable =
                                # 变量值为空
echo

exit 0
```

> ![notice](images/caution.gif) 一个未被赋值或未初始化的变量拥有空值（null value）。*注意：null值不等同于0*。

```bash
if [ -z "$unassigned" ]
then
  echo "\$unassigned is NULL."
fi     # $unassigned is NULL.
```

> 在赋值前使用变量可能会导致错误。但在算术运算中使用未赋值变量是可行的。

```bash
echo "$uninitialized"            # 空行
let "uninitialized += 5"         # 加5
echo "$uninitialized"            # 5
# 结论：
# 一个未初始化的变量不含值(null)，但在算术运算中会被作为0处理。
```

>  也可参考样例 15-23。

### 4.2 变量赋值(=)

赋值操作符（在其前后没有空白符）。

> ![noitce](images/caution.gif) 不要混淆 = 与 -eq，后者用来进行比较而非赋值。
>
> 同时也要注意 = 根据使用场景既可作赋值操作符，也可作比较操作符。

样例 4-2. 变量赋值

```bash
#!/bin/bash
# 非引用形式变量

echo

# 什么时候变量是非引用形式，即变量名前没有 '$' 符号的呢？
# 当变量在被赋值而不是被引用时。

# 赋值
a=879
echo "The value of \"a\" is $a."

# 使用 'let' 进行赋值
let a=16+5
echo "The value of \"a\" is now $a."

echo

# 在 'for' 循环中赋值（隐式赋值）
echo -n "Values of \"a\" in the loop are: "
for a in 7 8 9 11
do
  echo -n "$a "
done

echo
echo

# 在 'read' 表达式中（另一种赋值形式）
echo -n "Enter \"a\" "
read a
echo "The value of \"a\" is now $a."

echo

exit 0
```

样例 4-3. 奇妙的变量赋值

```bash
#!/bin/bash

a=23              # 简单形式
echo $a
b=$a
echo $b

# 来我们玩点炫的（命令替换）。

a=`echo Hello!`   # 将 'echo' 命令的结果赋值给 'a'
echo $a
#  注意在命令替换结构中包含感叹号(!)在命令行中使用将会失效，
#+ 因为它将会触发 Bash 的历史(history)机制。
#  在shell脚本内，Bash 的历史机制默认关闭。

a=`ls -l`         # 将 'ls -l' 命令的结果赋值给 'a'
echo $a           # 不带引号引用，将会移除所有的制表符与分行符
echo
echo "$a"         # 引号引用变量将会保留空白符
                  # 查看 "引用" 章节。
                  
exit 0
```

使用 `$(...)` 形式进行赋值（与反引号不同的新形式），与命令替换形式相似。

```bash
# 摘自 /etc/rc.d/rc.local
R=$(cat /etc/redhat-release)
arch=$(uname -m)
```

### 4.3 Bash变量是弱类型的

不同于许多其他编程语言，Bash 并不区分变量的类型。本质上说，*Bash 变量是字符串*，但在某些情况下，Bash 允许对变量进行算术运算和比较。决定因素则是变量值是否只含有数字。

样例 4-4. 整数还是字符串？

```bash
#!/bin/bash
# int-or-string.sh

a=2334                   # 整数。
let "a += 1"
echo "a = $a "           # a = 2335
echo                     # 依旧是整数。


b=${a/23/BB}             # 将 "23" 替换为 "BB"。
                         # $b 变成了字符串。
echo "b = $b"            # b = BB35
declare -i b             # 将其声明为整数并没有什么卵用。
echo "b = $b"            # b = BB35

let "b += 1"             # BB35 + 1
echo "b = $b"            # b = 1
echo                     # Bash 认为字符串的"整数值"为0。

c=BB34
echo "c = $c"            # c = BB34
d=${c/BB/23}             # 将 "BB" 替换为 "23"。
                         # $d 变为了一个整数。
echo "d = $d"            # d = 2334
let "d += 1"             # 2334 + 1
echo "d = $d"            # d = 2335
echo


# 如果是空值会怎样呢？
e=''                     # ...也可以是 e="" 或 e=
echo "e = $e"            # e =
let "e += 1"             # 空值是否允许进行算术运算？
echo "e = $e"            # e = 1
echo                     # 空值变为了一个整数。

# 如果时未声明的变量呢？
echo "f = $f"            # f =
let "f += 1"             # 是否允许进行算术运算？
echo "f = $f"            # f = 1
echo                     # 未声明变量变为了一个整数。
#
# 然而……
let "f /= $undecl_var"   # 可以除以0么？
#   let: f /= : syntax error: operand expected (error token is " ")
# 语法错误！在这里 $undecl_var 并没有被设置为0！
#
# 但是，仍旧……
let "f /= 0"
#   let: f /= 0: division by 0 (error token is "0")
# 预期之中。


# 在执行算术运算时，Bash 通常将其空值的整数值设为0。
# 但是不要做这种事情！
# 因为这可能会导致一些意外的后果。


# 结论：上面的结果都表明 Bash 中的变量是弱类型的。

exit $?
```

弱类型变量有利有弊。它可以使编程更加灵活、更加容易（给与你足够的想象空间）。但它也同样的容易造成一些小错误，容易养成粗心大意的编程习惯。

为了减轻脚本持续跟踪变量类型的负担，Bash *不允许*变量声明。

### 4.4 特殊的变量类型

#### 4.4.1 局部变量

仅在代码块或函数中才可见的变量（参考函数章节的局部变量部分）。

#### 4.4.2 环境变量

会影响用户及shell行为的变量。

> ![extra](images/note-1583300773483.gif) 一般情况下，每一个进程都有自己的“环境”（environment），也就是一组该进程可以访问到的变量。从这个意义上来说，shell表现出与其他进程一样的行为。
>
> 每当shell启动时，都会创建出与其环境对应的shell环境变量。改变或增加shell环境变量会使shell更新其自身的环境。*子进程*（由父进程执行产生）会继承*父进程*的环境变量。
>
> ![notice](images/caution.gif) 分配给环境变量的空间是有限的。创建过多环境变量或占用空间过大的环境变量有可能会造成问题。

```
bash$ eval "`seq 10000 | sed -e 's/.*/export var&=ZZZZZZZZZZZZZZ/'`"
>
bash$ du
bash: /usr/bin/du: Argument list too long
```

> 注意，上面的"错误"已经在Linux内核版本号为2.6.23的系统中修复了。
>
> （感谢 Stéphane Chazelas 对此问题的解释并提供了上面的例子。）

如果在脚本中设置了环境变量，那么这些环境变量需要被“导出”，也就是通知脚本所在的*环境*做出相应的更新。这个“导出”操作就是 `export` 命令。

> ![extra](images/note-1583300773483.gif) 脚本只能将变量导出到子进程，即在这个脚本中所调用的命令或程序。在命令行中调用的脚本不能够将变量回传给命令行环境，即*子进程不能将变量回传给父进程*。
>
> **定义：** 子进程（child process）是由另一个进程，即其父进程（parent process）所启动的子程序。

#### 4.4.3 位置参数

从命令行中传递给脚本的参数：`$0, $1, $2, $3 ...`
即**命令行参数**。

`$0` 代表脚本名称，`$1` 代表第一个参数，`$2` 代表第二个，`$3` 代表第三个，以此类推。在 `$9` 之后的参数必须被包含在大括号中，如 `${10}, ${11}, ${12}`。

特殊变量 `$*` 与 `$@` 代表所有位置参数。

样例 4-5. 位置参数

```bash
#!/bin/bash

# 调用脚本时使用至少10个参数，例如
# ./scriptname 1 2 3 4 5 6 7 8 9 10
MINPARAMS=10

echo

echo "The name of this script is \"$0\"."
# 附带 ./ 代表当前目录
echo "The name of this script is \"`basename $0`\"."
# 除去路径信息（查看 'basename'）

echo

if [ -n "$1" ]              # 测试变量是否存在
then
 echo "Parameter #1 is $1"  # 使用引号转义#
fi

if [ -n "$2" ]
then
 echo "Parameter #2 is $2"
fi

if [ -n "$3" ]
then
 echo "Parameter #3 is $3"
fi

# ...

if [ -n "${10}" ]  # 大于 $9 的参数必须被放在大括号中
then
 echo "Parameter #10 is ${10}"
fi

echo "-----------------------------------"
echo "All the command-line parameters are: "$*""

if [ $# -lt "$MINPARAMS" ]
then
  echo
  echo "This script needs at least $MINPARAMS command-line arguments!"
fi

echo

exit 0
```

在位置参数中使用大括号助记符提供了一种非常简单的方式来访问传入脚本的最后一个参数。在其中会使用到间接引用。

```bash
args=$#           # 传入参数的个数
lastarg=${!args}
# 这是 $args 的一种间接引用方式

# 也可以使用:       lastarg=${!#}             (感谢 Chris Monson.)
# 这是 $# 的一种间接引用方式。
# 注意 lastarg=${!$#} 是无效的。
```

一些脚本能够根据调用时文件名的不同来执行不同的操作。要达到这样的效果，脚本需要检测 `$0`，也就是调用时的文件名。同时，也必须存在指向这个脚本所有别名的符号链接文件（symbolic links）。详情查看样例 16-2。

> ![info](images/tip-1583300773492.gif) 如果一个脚本需要一个命令行参数但是在调用的时候却没有传入，那么这将会造成一个空变量赋值。这通常不是我们想要的。一种避免的方法是，在使用期望的位置参数时候，在赋值语句两侧添加一个额外的字符。

```bash
variable1_=$1_  # 而不是 variable1=$1
# 使用这种方法可以在没有位置参数的情况下避免产生错误。

critical_argument01=$variable1_

# 多余的字符可以被去掉，就像下面这样：
variable1=${variable1_/_/}
# 仅仅当 $variable1_ 是以下划线开头时候才会有一些副作用。
# 这里使用了我们稍后会介绍的参数替换模板中的一种。
# （将替换模式设为空等价于删除。）

# 更直接的处理方法就是先检测预期的位置参数是否被传入。
if [ -z $1 ]
then
  exit $E_MISSING_POS_PARAM
fi


#  但是，正如 Fabin Kreutz 指出的，
#+ 上面的方法会有一些意想不到的副作用。
#  更好的方法是使用参数替换：
#         ${1:-$DefaultVal}
#  详情查看第十章“操作变量”的第二节“变量替换”。
```

样例 4-6. *wh*, *whois* 域名查询

```bash
#!/bin/bash
# ex18.sh

# 在下面三个可选的服务器中进行 whois 域名查询：
# ripe.net, cw.net, radb.net

# 将这个脚本重命名为 'wh' 后放在 /usr/local/bin 目录下

# 这个脚本需要进行符号链接：
# ln -s /usr/local/bin/wh /usr/local/bin/wh-ripe
# ln -s /usr/local/bin/wh /usr/local/bin/wh-apnic
# ln -s /usr/local/bin/wh /usr/local/bin/wh-tucows

E_NOARGS=75


if [ -z "$1" ]
then
  echo "Usage: `basename $0` [domain-name]"
  exit $E_NOARGS
fi

# 检查脚本名，访问对应服务器进行查询。
case `basename $0` in    # 也可以写:    case ${0##*/} in
    "wh"       ) whois $1@whois.tucows.com;;
    "wh-ripe"  ) whois $1@whois.ripe.net;;
    "wh-apnic" ) whois $1@whois.apnic.net;;
    "wh-cw"    ) whois $1@whois.cw.net;;
    *          ) echo "Usage: `basename $0` [domain-name]";;
esac

exit $?
```

使用 `shift` 命令可以将全体位置参数向左移一位, 重新赋值。

`$1 <--- $2`, `$2 <--- $3`, `$3 <--- $4`，以此类推。

原先的 `$1` 将会消失，而 `$0`（脚本名称）不会有任何改变。如果你在脚本中使用了大量的位置参数，`shift` 可以让你不使用{大括号}助记法也可以访问超过10个的位置参数。

样例 4-7. 使用 `shift` 命令

```bash
#!/bin/bash
# shft.sh: 使用 `shift` 命令步进访问所有的位置参数。

# 将这个脚本命名为 shft.sh，然后在调用时跟上一些参数。
# 例如：
#    sh shft.sh a b c def 83 barndoor

until [ -z "$1" ]  # 直到访问完所有的参数
do
  echo -n "$1 "
  shift
done

echo               # 换行。

# 那些被访问完的参数又会怎样呢？
echo "$2"
# 什么都不会被打印出来。
# 当 $2 被移动到 $1 且没有 $3 时，$2 将会保持空。
# 因此 shift 是移动参数而非复制参数。

exit

#  可以参考 echo-params.sh 脚本，在不使用 shift 命令的情况下，
#+ 步进访问所有位置参数。
```

`shift` 命令也可以带一个参数来指明一次移动多少位。

```bash
#!/bin/bash
# shift-past.sh

shift 3    # 移动3位。
# 与 n=3; shift $n 效果相同。

echo "$1"

exit 0

# ======================== #


$ sh shift-past.sh 1 2 3 4 5
4

#  但是就像 Eleni Fragkiadaki 指出的那样，
#  如果尝试将位置参数（$#）传给 'shift'，
#  将会导致脚本错误的结束，同时位置参数也不会发送改变。
#  这也许是因为陷入了一个死循环...
#  比如：
#      until [ -z "$1" ]
#      do
#         echo -n "$1 "
#         shift 20    #  如果少于20个位置参数，
#      done           #+ 那么循环将永远不会结束。
#
#  当你不确定是否有这么多的参数时，你可以加入一个测试：
#      shift 20 || break
#               ^^^^^^^^
```

> ![extra](images/note-1583300773483.gif) 使用 `shift` 命令同给函数传参相类似。详情查看样例 36-18。

## 5 引用

引用就是将一个字符串用引号括起来。这样做是为了保护Shell/Shell脚本中被重新解释过或带扩展功能的[特殊字符](http://tldp.org/LDP/abs/html/special-chars.html)（如果一个字符带有其特殊意义而不仅仅是字面量的话，这个字符就能称为“特殊字符”。比如星号“*”就能表示[正则表达式](http://tldp.org/LDP/abs/html/regexp.html#REGEXREF)中的一个[通配符](http://tldp.org/LDP/abs/html/globbingref.html)）。

```
bash$ ls -l [Vv]*
-rw-rw-r--    1 bozo  bozo       324 Apr  2 15:05 VIEWDATA.BAT
-rw-rw-r--    1 bozo  bozo       507 May  4 14:25 vartrace.sh
-rw-rw-r--    1 bozo  bozo       539 Apr 14 17:11 viewdata.sh

bash$ ls -l '[Vv]*'
ls: [Vv]*: No such file or directory
```

> 可以看到，提示不存在该文件。这里的`'[Vv]*`被当成了文件名。
> 在日常沟通和写作中，当我们引用一个短语的时候，我们会将它单独隔开并赋予它特殊的意义，而在bash脚本中，当我们*引用*一个字符串，意味着保留它的*字面量*。

很多程序和公用代码会展开被引用字符串中的特殊字符。引用的一个重用用途是保护Shell中的命令行参数，但仍然允许调用的程序扩展它。

```	
bash$ grep '[Ff]irst' *.txt
file1.txt:This is the first line of file1.txt.
file2.txt:This is the First line of file2.txt.
```

> 在所有.txt文件中找出包含first或者First字符串的行

注意，不加引号的 `grep [Ff]irst *.txt` 在Bash下也同样有效。

引用也可以控制[echo](http://tldp.org/LDP/abs/html/internal.html#ECHOREF)命令的断行符。

```
bash$ echo $(ls -l)
total 8 -rw-rw-r-- 1 bo bo 13 Aug 21 12:57 t.sh -rw-rw-r-- 1 bo bo 78 Aug 21 12:57 u.sh


bash$ echo "$(ls -l)"
total 8
 -rw-rw-r--  1 bo bo  13 Aug 21 12:57 t.sh
 -rw-rw-r--  1 bo bo  78 Aug 21 12:57 u.sh
```

### 5.1 引用变量

引用变量时，通常建议将变量包含在双引号中。因为这样可以防止除 `$`，`` ` ``（反引号）和`\`（转义符）之外的其他特殊字符被重新解释。在双引号中仍然可以使用`$`引用变量（`"$variable"`），也就是将变量名替换为变量值（详情查看样例 4-1）。

使用双引号可以防止字符串被分割。即使参数中拥有很多空白分隔符，被包在双引号中后依旧是算作单一字符。

```bash
List="one two three"

for a in $List     # 空白符将变量分成几个部分。
do
  echo "$a"
done
# one
# two
# three

echo "---"

for a in "$List"   # 在单一变量中保留所有空格。
do #     ^     ^
  echo "$a"
done
# one two three
```

下面是一个更加复杂的例子：

```bash
variable1="a variable containing five words"
COMMAND This is $variable1    # 带上7个参数执行COMMAND命令：
# "This" "is" "a" "variable" "containing" "five" "words"

COMMAND "This is $variable1"  # 带上1个参数执行COMMAND命令：
# "This is a variable containing five words"


variable2=""    # 空值。

COMMAND  $variable2 $variable2 $variable2
                # 不带参数执行COMMAND命令。
COMMAND "$variable2" "$variable2" "$variable2"
                # 带上3个参数执行COMMAND命令。
COMMAND "$variable2 $variable2 $variable2"
                # 带上1个参数执行COMMAND命令（2空格）。

# 感谢 Stéphane Chazelas。
```

> ![info](images/tip-1583302483997.gif) 当字符分割或者保留空白符出现问题时，才需要在`echo`语句中用双引号包住参数。

样例 5-1. 输出一些奇怪的变量

```bash
#!/bin/bash
# weirdvars.sh: 输出一些奇怪的变量

echo

var="'(]\\{}\$\""
echo $var        # '(]\{}$"
echo "$var"      # '(]\{}$"     没有任何区别。

echo

IFS='\'
echo $var        # '(] {}$"     \ 被转换成了空格，为什么？
echo "$var"      # '(]\{}$"

# 上面的例子由 Stephane Chazelas 提供。

echo

var2="\\\\\""
echo $var2       #   "
echo "$var2"     # \\"
echo
# 但是...var2="\\\\"" 不是合法的语句，为什么？
var3='\\\\'
echo "$var3"     # \\\\
# 强引用是可以的。


# ************************************************************ #
# 就像第一个例子展示的那样，嵌套引用是允许的。

echo "$(echo '"')"           # "
#    ^           ^


# 在有些时候这种方法非常有用。

var1="Two bits"
echo "\$var1 = "$var1""      # $var1 = Two bits
#    ^                ^

# 或者，可以像 Chris Hiestand 指出的那样：

if [[ "$(du "$My_File1")" -gt "$(du "$My_File2")" ]]
#     ^     ^         ^ ^     ^     ^         ^ ^
then
  ...
fi
# ************************************************************ #
```

单引号（' '）与双引号类似，但是在单引号中不能引用变量，因为 `$` 不再具有特殊含义。在单引号中，除`'`之外的所有特殊字符都将会被直接按照字面意思解释。可以认为单引号（“全引用”）是双引号（“部分引用”）的一种更严格的形式。

> ![extra](images/note-1583302483968.gif) 因为在单引号中转义符（\）都已经按照字面意思解释了，因此尝试在单引号中包含单引号将不会产生你所预期的结果。

```bash
echo "Why can't I write 's between single quotes"
>
echo
>
# 可以采取迂回的方式。
echo 'Why can'\''t I write '"'"'s between single quotes'
#    |-------|  |----------|   |-----------------------|
# 由三个单引号引用的字符串，再加上转义以及双引号包住的单引号组成。
>
# 感谢 Stéphane Chazelas 提供的例子。
```

### 5.2 转义

转义是一种引用单字符的方法。通过在特殊字符前加上转义符 `\` 来告诉shell按照字面意思去解释这个字符。

> ![notice](images/caution.gif) 需要注意的是，在一些特定的命令和工具，比如 `echo` 和 `sed` 中，转义字符通常会起到相反的效果，即可能会使得那些字符产生特殊含义。

在 `echo` 与 `sed` 命令中，转义字符的特殊含义

* \n     换行（line feed）。

* \r     回车（carriage return）。

* \t     水平制表符。

* \v    垂直制表符。

* \b    退格。

* \a    警报、响铃或闪烁。

* \0xx

ASCII码的八进制形式，等价于 `0nn`，其中 `nn` 是数字。

> ![important](images/important-1583303464458.gif) 在 `$' ... '` 字符串扩展结构中可以通过转义八进制或十六进制的ASCII码形式给变量赋值，比如 `quote=$'\042'`。

样例 5-2. 转义字符

```bash
#!/bin/bash
# escaped.sh: 转义字符

##############################################
### 首先让我们先看一下转义字符的基本用法。 ###
##############################################

# 转义新的一行。
# ------------

echo ""

echo "This will print
as two lines."
# This will print
# as two lines.

echo "This will print \
as one line."
# This will print as one line.

echo; echo

echo "============="


echo "\v\v\v\v"      # 按字面意思打印 \v\v\v\v
# 使用 echo 命令的 -e 选项来打印转义字符。
echo "============="
echo "VERTICAL TABS"
echo -e "\v\v\v\v"   # 打印四个垂直制表符。
echo "=============="

echo "QUOTATION MARK"
echo -e "\042"       # 打印 " （引号，八进制ASCII码为42）。
echo "=============="



# 使用 $'\X' 这样的形式后可以不需要加 -e 选项。

echo; echo "NEWLINE and (maybe) BEEP"
echo $'\n'           # 新的一行。
echo $'\a'           # 警报（响铃）。
                     # 根据不同的终端版本，也可能是闪屏。

# 我们之前介绍了 $'\nnn' 字符串扩展，而现在我们要看到的是...

# ============================================ #
# 自 Bash 第二个版本开始的 $'\nnn' 字符串扩展结构。
# ============================================ #

echo "Introducing the \$\' ... \' string-expansion construct . . . "
echo ". . . featuring more quotation marks."

echo $'\t \042 \t'   # 在制表符之间的引号。
# 需要注意的是 '\nnn' 是一个八进制的值。

# 字符串扩展同样适用于十六进制的值，格式是 $'\xhhh'。
echo $'\t \x22 \t'  # 在制表符之间的引号。
# 感谢 Greg Keraunen 指出这些。
# 在早期的 Bash 版本中允许使用 '\x022' 这样的形式。

echo


# 将 ASCII 码字符赋值给变量。
# -----------------------
quote=$'\042'        # 将 " 赋值给变量。
echo "$quote Quoted string $quote and this lies outside the quotes."

echo

# 连接多个 ASCII 码字符给变量。
triple_underline=$'\137\137\137'  # 137是 '_' ASCII码的八进制形式
echo "$triple_underline UNDERLINE $triple_underline"

echo

ABC=$'\101\102\103\010'           # 101，102，103是 A, B, C 
                                  # ASCII码的八进制形式。
echo $ABC

echo

escape=$'\033'                    # 033 是 ESC 的八进制形式
echo "\"escape\" echoes an $escape"
                                  # 没有可见输出

echo

exit 0
```

下面是一个更加复杂的例子：

样例 5-3. 检测键盘输入

```bash
#!/bin/bash
# 作者：Sigurd Solaas，作于2011年4月20日
# 授权在《高级Bash脚本编程指南》中使用。
# 需要 Bash 版本高于4.2。

key="no value yet"
while true; do
  clear
  echo "Bash Extra Keys Demo. Keys to try:"
  echo
  echo "* Insert, Delete, Home, End, Page_Up and Page_Down"
  echo "* The four arrow keys"
  echo "* Tab, enter, escape, and space key"
  echo "* The letter and number keys, etc."
  echo
  echo "    d = show date/time"
  echo "    q = quit"
  echo "================================"
  echo
  
  # 将独立的Home键值转换为数字7上的Home键值：
  if [ "$key" = $'\x1b\x4f\x48' ]; then
   key=$'\x1b\x5b\x31\x7e'
   #   引用字符扩展结构。
  fi
  
  # 将独立的End键值转换为数字1上的End键值：
  if [ "$key" = $'\x1b\x4f\x46' ]; then
   key=$'\x1b\x5b\x34\x7e'
  fi
  
  case "$key" in
   $'\x1b\x5b\x32\x7e')  # 插入
    echo Insert Key
   ;;
   $'\x1b\x5b\x33\x7e')  # 删除
    echo Delete Key
   ;;
   $'\x1b\x5b\x31\x7e')  # 数字7上的Home键
    echo Home Key
   ;;
   $'\x1b\x5b\x34\x7e')  # 数字1上的End键
    echo End Key
   ;;
   $'\x1b\x5b\x35\x7e')  # 上翻页
    echo Page_Up
   ;;
   $'\x1b\x5b\x36\x7e')  # 下翻页
    echo Page_Down
   ;;
   $'\x1b\x5b\x41')  # 上箭头
    echo Up arrow
   ;;
   $'\x1b\x5b\x42')  # 下箭头
    echo Down arrow
   ;;
   $'\x1b\x5b\x43')  # 右箭头
    echo Right arrow
   ;;
   $'\x1b\x5b\x44')  # 左箭头
    echo Left arrow
   ;;
   $'\x09')  # 制表符
    echo Tab Key
   ;;
   $'\x0a')  # 回车
    echo Enter Key
   ;;
   $'\x1b')  # ESC
    echo Escape Key
   ;;
   $'\x20')  # 空格
    echo Space Key
   ;;
   d)
    date
   ;;
   q)
    echo Time to quit...
    echo
    exit 0
   ;;
   *)
    echo Your pressed: \'"$key"\'
   ;;
  esac
  
  echo
  echo "================================"
  
  unset K1 K2 K3
  read -s -N1 -p "Press a key: "
  K1="$REPLY"
  read -s -N2 -t 0.001
  K2="$REPLY"
  read -s -N1 -t 0.001
  K3="$REPLY"
  key="$K1$K2$K3"
  
done

exit $?
```

还可以查看样例 37-1。

**\\"**

转义引号，指代自身。

```bash
echo "Hello"                     # Hello
echo "\"Hello\" ... he said."    # "Hello" ... he said.
```

**\\$**

转义美元符号（跟在 `\\$` 后的变量名将不会被引用）。

```bash
echo "\$variable01"           # $variable01
echo "The book cost \$7.98."  # The book cost $7.98.
```

**\\\\**

转义反斜杠，指代自身。

```bash
echo "\\"  # 结果是 \

# 然而...

echo "\"   # 在命令行中会出现第二行并提示输入。
           # 在脚本中会出错。
           
# 但是...

echo '\'   # 结果是 \
```

> ![extra](images/note-1583303464459.gif) 根据转义符所在的上下文（强引用、弱引用，命令替换或者在 here document）的不同，它的行为也会有所不同。

```bash
                      #  简单转义与引用
echo \z               #  z
echo \\z              # \z
echo '\z'             # \z
ehco '\\z'            # \\z
echo "\z"             # \z
echo "\\z"            # \z
>
                      #  命令替换
echo `echo \z`        #  z
echo `echo \\z`       #  z
echo `echo \\\z`      # \z
echo `echo \\\\z`     # \z
echo `echo \\\\\\z`   # \z
echo `echo \\\\\\\z`  # \\z
echo `echo "\z"`      # \z
echo `echo "\\z"`     # \z
>
                      # Here Document
cat <<EOF
\z
EOF                   # \z
>
cat <<EOF
\\z
EOF                   # \z
>
# 以上例子由 Stéphane Chazelas 提供。 
```

> 含有转义字符的字符串可以赋值给变量，但是仅仅将单一的转义符赋值给变量是不可行的。

```bash
variable=\
echo "$variable"
# 这样做会报如下错误：
# tesh.sh: : command not found
# 单独的转义符不能够赋值给变量。
# 
#  事实上，"\" 转义了换行，实际效果是：
#+ variable=echo "$variable"
#+ 这是一个非法的赋值方式。
>
variable=\
23skidoo
echo "$variable"        # 23skidoo
                        # 因为第二行是一个合法的赋值，因此不会报错。
>
variable=\ 
#        \^    转义符后有一个空格
echo "$variable"        # 空格
>
variable=\\
echo "$variable"        # \
>
variable=\\\
echo "$variable"
# 这样做会报如下错误：
# tesh.sh: \: command not found
#
#  第一个转义符转转义了第二个，但是第三个转义符仍旧转义的是换行，
#+ 跟开始的那个例子一样，因此会报错。
>
variable=\\\\
echo "$variable"        # \\
                        # 第二个和第四个转义符被转义了，因此可行。
```

转义空格能够避免在命令参数列表中的字符分割问题。

```bash
file_list="/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7"
# 将一系列文件作为命令的参数。

# 增加两个文件到列表中，并且列出整个表。
ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list

echo "-------------------------------------------------------------------------"

# 如果我们转义了这些空格会怎样？
ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list
# 错误：因为转义了两个空格，因此前三个文件被连接成了一个参数传递给了 'ls -l'
```

转义符也提供一种可以撰写多行命令的方式。通常，每一行是一个命令，但是转义换行后命令就可以在下一行继续撰写。

```bash
(cd /source/directory && tar cf - . ) | \
(cd /dest/directory && tar xpvf -)
# 回顾 Alan Cox 的目录树拷贝命令，但是把它拆成了两行。

# 或者你也可以：
tar cf - -C /source/directory . |
tar xpvf - -C /dest/directory
# 可以看下方的注释。
# （感谢 Stéphane Chazelas。）
```

> ![extra](http://tldp.org/LDP/abs/images/note.gif) 在脚本中，如果以 "|" 管道作为一行的结束字符，那么不需要加转义符 \ 也可以写多行命令。但是一个好的编程习惯就是在写多行命令的事后，无论什么情况都要在行尾加上转义符 \。

```bash
echo "foo
bar"
#foo
#bar

echo

echo 'foo
bar'    # 没有区别。
#foo
#bar

echo

echo foo\
bar     # 转义换行。
#foobar

echo

echo "foo\
bar"     # 没有区别，在弱引用中，\ 转义符仍旧转义了换行。
#foobar

echo

echo 'foo\
bar'     # 在强引用中，\ 就按照字面意思来解释了。
#foo\
#bar

# 由 Stéphane Chazelas 提供的例子。
```

## 6 退出与退出状态

> Bourne shell里存在不明确之处，但人们也会使用它们。
>
> —— Chat Ramey

跟C程序类似，`exit` 命令被用来结束脚本。同时，它也会返回一个值，返回值可以被交给父进程。

每个命令都会返回一个退出状态（exit status），有时也叫做返回状态（return status）或退出码（exit code）。命令执行成功返回0，如果返回一个非0值，通常情况下会被认为是一个错误代码。一个运行状态良好的UNIX命令、程序和工具在正常执行退出后都会返回一个0的退出码，当然也有例外。

同样地，脚本中的函数和脚本本身也会返回一个退出状态。在脚本或者脚本函数中执行的最后的命令会决定它们的退出状态。在脚本中，`exit nnn` 命令将会把nnn退出状态码传递给shell（nnn 必须是 0-255 之间的整型数）。

> ![note](images/note-1583304140613.gif) 当一个脚本以不带参数的 `exit` 来结束时，脚本的退出状态由脚本最后执行命令决定（`exit` 命令之前）。

```bash
#!/bin/bash

COMMAND_1

...

COMMAND_LAST

# 将以最后的命令来决定退出状态

exit
```

> `exit`，`exit $?` 以及省略 `exit` 效果等同。

```bash
#!/bin/bash 

COMMAND_1

...

COMMAND_LAST

#将以最后的命令来决定退出状态

exit $?
```

```bash
#!/bin/bash

COMMAND_1

...

COMMAND_LAST

#将以最后的命令来决定退出状态
```

`$?` 读取上一个执行命令的退出状态。在一个函数返回后，`$?` 给出函数最后执行的那条命令的退出状态。这就是Bash函数的"返回值"。

在[管道](http://tldp.org/LDP/abs/html/special-chars.html#PIPEREF)执行后，`$?` 给出最后执行的那条命令的退出状态。

在脚本终止后，命令行下键入`$?`会给出脚本的退出状态，即在脚本中最后一条命令执行后的退出状态。一般情况下，0为成功，1-255为失败。

样例 6-1. 退出与退出状态

```bash
#!/bin/bash

echo hello
echo $?    # 返回值为0，因为执行成功。

lskdf      # 不认识的命令。
echo $?    # 返回非0值，因为失败了。

echo

exit 113   # 将返回113给shell
           # 为了验证这些，在脚本结束的地方使用“echo $?”

#  按照惯例，'exit 0' 意味着执行成功，
#+ 非0意味着错误或者异常情况。
#  查看附录章节“退出码的特殊含义”
```

`$?` 对于测试脚本中的命令的执行结果特别有用（查看样例 16-35和样例 16-20）。

> ![note](http://tldp.org/LDP/abs/images/note.gif) 逻辑非操作符 [!](http://tldp.org/LDP/abs/html/special-chars.html#NOTREF) 将会反转测试或命令的结果，并且这将会影响退出状态。

样例 6-2. 否定一个条件使用!

```bash
true    # true 是 shell 内建命令。
echo "exit status of \"true\" = $?"     # 0

! true
echo "exit status of \"! true\" = $?"   # 1
# 注意在命令之间的 "!" 需要一个空格。
# !true 将导致一个"command not found"错误。
#
# 如果一个命令以'!'开头，那么将调用 Bash 的历史机制，显示这个命令被使用的历史。

true
!true
# 这次就没有错误了，但是同样也没有反转。
# 它不过是重复之前的命令（true）。


# ============================================================ #
# 在 _pipe_ 前使用 ! 将改变返回的退出状态。
ls | bogus_command      #bash: bogus_command: command not found
echo $?                 #127
>
! ls | bogus_command    #bash: bogus_command:command not found
echo $?                 #0
# 注意 ! 不会改变管道的执行。
# 只改变退出状态。
#============================================================  #
>
# 感谢 Stéphane Chazelas 和 Kristopher Newsome。
```

> ![caution](images/caution-1583304140626.gif) 某些特定的退出码具有一些特定的[保留含义](http://tldp.org/LDP/abs/html/exitcodes.html#EXITCODESREF)，用户不应该在自己的脚本中重新定义它们。

## 7 测试

每一个完备的程序设计语言都可以对一个条件进行判断，然后根据判断结果执行相应的指令。Bash 拥有 [`test`](http://tldp.org/LDP/abs/html/testconstructs.html#TTESTREF) 命令，[双方括号](http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS)、[双圆括号](http://tldp.org/LDP/abs/html/testconstructs.html#DBLPARENSTST) 测试操作符以及 `if/then` 测试结构。

### 7.1 测试结构

- `if/then` 结构是用来检测一系列命令的 [退出状态](http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF) 是否为0（按 UNIX 惯例,退出码 0 表示命令执行成功），如果为0，则执行接下来的一个或多个命令。

- 测试结构会使用一个特殊的命令 `[`（参看特殊字符章节 [左方括号](http://tldp.org/LDP/abs/html/special-chars.html#LEFTBRACKET)）。等同于 `test` 命令，它是一个[内建命令](http://tldp.org/LDP/abs/html/internal.html#BUILTINREF)，写法更加简洁高效。该命令将其参数视为比较表达式或文件测试，以比较结果作为其退出状态码返回（0 为真，1 为假）。

- Bash 在 2.02 版本中引入了扩展测试命令 [`[[...]]`]，它提供了一种与其他语言语法更为相似的方式进行比较操作。注意， `[[` 是一个 [关键字](http://tldp.org/LDP/abs/html/internal.html#KEYWORDREF) 而非一个命令。

  Bash 将 `[[ $a -lt $b ]]` 视为一整条语句，执行并返回退出状态。

- 结构 [`(( ... ))`](http://tldp.org/LDP/abs/html/dblparens.html) 和 [`let ...`](http://tldp.org/LDP/abs/html/internal.html#LETREF) 根据其执行的算术表达式的结果决定退出状态码。这样的 [算术扩展](http://tldp.org/LDP/abs/html/arithexp.html#ARITHEXPREF) 结构可以用来进行 [数值比较](http://tldp.org/LDP/abs/html/comparison-ops.html#ICOMPARISON1)。

```bash
(( 0 && 1 ))                 # 逻辑与
echo $?     # 1     ***
# 然后 ...
let "num = (( 0 && 1 ))"
echo $num   # 0
# 然而 ...
let "num = (( 0 && 1 ))"
echo $?     # 1     ***


(( 200 || 11 ))              # 逻辑或
echo $?     # 0     ***
# ...
let "num = (( 200 || 11 ))"
echo $num   # 1
let "num = (( 200 || 11 ))"
echo $?     # 0     ***


(( 200 | 11 ))               # 按位或
echo $?                      # 0     ***
# ...
let "num = (( 200 | 11 ))"
echo $num                    # 203
let "num = (( 200 | 11 ))"
echo $?                      # 0     ***

# "let" 结构的退出状态与双括号算术扩展的退出状态是相同的。
```

![caution](images/caution-1583304562255.gif) 注意，双括号算术扩展表达式的退出状态码不是一个错误的值。算术表达式为0，返回1；算术表达式不为0，返回0。

```bash
var=-2 && (( var+=2 ))
echo $?                   # 1

var=-2 && (( var+=2 )) && echo $var
                          # 并不会输出 $var, 因为((var+=2))的状态码为1
```

- `if` 不仅可以用来测试括号内的条件表达式，还可以用来测试其他任何命令。

```bash
if cmp a b &> /dev/null  # 消去输出结果
then echo "Files a and b are identical."
else echo "Files a and b differ."
fi

# 下面介绍一个非常实用的 “if-grep" 结构：
# -----------------------------------
if grep -q Bash file
  then echo "File contains at least one occurrence of Bash."
fi
    
word=Linux
letter_sequence=inu
if echo "$word" | grep -q "$letter_sequence"
# 使用 -q 选项消去 grep 的输出结果
then
  echo "$letter_sequence found in "$word"
else
  echo "$letter_sequence not found in $word"
fi


if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED
  then echo "Command succeed."
  else echo "Command failed."
fi
```

- 感谢 Stéphane Chazelas 提供了后两个例子。

样例 7-1. 什么才是真？

```bash
#!/bin/bash

# 提示：
# 如果你不确定某个表达式的布尔值，可以用 if 结构进行测试。

echo

echo "Testing \"0\""
if [ 0 ]
then
  echo "0 is true."
else
  echo "0 is false."
fi            # 0 为真。

echo

echo "Testing \"1\""
if [ 1 ]
then
  echo "1 is true."
else
  echo "1 is false."
fi            # 1 为真。

echo

echo "Testing \"-1\""
if [ -1 ]
then
  echo "-1 is true."
else
  echo "-1 is false."
fi            # -1 为真。

echo

echo "Testing \"NULL\""
if [ ]        # NULL, 空
then
  echo "NULL is true."
else
  echo "NULL is false."
fi            # NULL 为假。

echo

echo "Testing \"xyz\""
if [ xyz ]    # 字符串
then
  echo "Random string is true."
else
  echo "Random string is false."
fi            # 随机字符串为真。

echo

echo "Testing \"$xyz\""
if [ $xyz ]   # 原意是测试 $xyz 是否为空，但是
              # 现在 $xyz 只是一个没有初始化的变量。
then
  echo "Uninitialized variable is true."
else
  echo "Uninitialized variable is flase."
fi            # 未初始化变量含有null空值，为假。

echo

echo "Testing \"-n \$xyz\""
if [ -n "$xyz" ]            # 更加准确的写法。
then
  echo "Uninitialized variable is true."
else
  echo "Uninitialized variable is false."
fi            # 未初始化变量为假。

echo


xyz=          # 初始化为空。

echo "Testing \"-n \$xyz\""
if [ -n "$xyz" ]
then
  echo "Null variable is true."
else
  echo "Null variable is false."
fi            # 空变量为假。

echo

# 什么时候 "false" 为真？

echo "Testing \"false\""
if [ "false" ]              #  看起来 "false" 只是一个字符串
then
  echo "\"false\" is true." #+ 测试结果为真。
else
  echo "\"false\" is false."
fi            # "false" 为真。

echo

echo "Testing \"\$false\""  # 未初始化的变量。
if [ "$false" ]
then
  echo "\"\$false\" is true."
else
  echo "\"\$false\" is false."
fi            # "$false" 为假。
              # 得到了我们想要的结果。

# 如果测试空变量 "$true" 会有什么样的结果？

echo

exit 0
```

练习：理解 [样例 7-1](http://tldp.org/LDP/abs/html/testconstructs.html#EX10)

```bash
if [ condition-true ]
then
   command 1
   command 2
   ...
else  # 如果测试条件为假，则执行 else 后面的代码段
   command 3
   command 4
   ...
fi
```

![note](images/note-1583304562259.gif) 如果把 `if` 和 `then` 写在同一行时，则必须在 `if` 语句后加上一个分号来结束语句。因为 `if` 和 `then` 都是 [关键字](http://tldp.org/LDP/abs/html/internal.html#KEYWORDREF)。以关键字（或者命令）开头的语句，必须先结束该语句(分号;)，才能执行下一条语句。

```bash
if [ -x "$filename" ]; then
```

#### 7.1.1 Else if 与 elif

elif

`elif` 是 `else if` 的缩写。可以把多个 `if/then` 语句连到外边去，更加简洁明了。

```bash
if [ condition1 ]
then
   command1
   command2
   command3
elif [condition2 ]
# 等价于 else if
then
   command4
   command5
else
   default-command
fi
```

`if test condition-true` 完全等价于 `if [ condition-true ]`。当语句开始执行时，左括号 `[` 是作为调用 `test` 命令的标记，而右括号则不严格要求，但在新版本的 Bash 里，右括号必须补上。

![note](images/note-1583304562259.gif) `test` 命令是 Bash 的 [内建命令](http://tldp.org/LDP/abs/html/internal.html#BUILTINREF)，可以用来检测文件类型和比较字符串。在 Bash 脚本中，`test` 不调用 `sh-utils` 包下的文件 `/usr/bin/test`。同样，`[` 也不会调用链接到 `/usr/bin/test` 的 `/usr/bin/[` 文件。

```
bash$ type test
test is a shell builtin
bash$ type '['
[ is a shell builtin
bash$ type '[['
[[ is a shell keyword
bash$ type ']]'
]] is a shell keyword
bash$ type ']'
bash: type: ]: not found
```

如果你想在 Bash 脚本中使用 `/usr/bin/test`，那你必须把路径写全。

样例 7-2. `test`，`/usr/bin/test`，`[]` 和 `/usr/bin/[` 的等价性

```bash
#!/bin/bash

echo

if test -z "$1"
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo

if /usr/bin/test -z "$1"      # 等价于内建命令 "test"
#  ^^^^^^^^^^^^^              # 指定全路径
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo

if [ -z "$1" ]                # 功能和上面的代码相同。
#   if [ -z "$1"                理论上可行，但是 Bash 会提示缺失右括号
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo


if /usr/bin/[ -z "$1" ]       # 功能和上面的代码相同。
# if /usr/bin/[ -z "$1"       # 理论上可行，但是会报错
#                             # 已经在 Bash 3.x 版本被修复了
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo

exit 0
```

在 Bash 里，``[[ ]]`` 是比 `[ ]` 更加通用的写法。其作为扩展`test` 命令从 ksh88 中被继承了过来。


在 ``[[`` 和 ``]]`` 中不会进行文件名扩展或字符串分割，但是可以进行参数扩展和命令替换。

```bash
file=/etc/passwd

if [[ -e $file ]]
then
  echo "Password file exists."
fi
```

使用 ``[[...]]`` 代替 ``[...]``可以避免很多逻辑错误。比如可以在 ``[[]]`` 中使用 ``&&``，``||``，`<` 和 `>` 运算符，而在 `[]` 中使用会报错。

在 ``[[]]`` 中会自动执行八进制和十六进制的进制转换操作。

```bash
# [[ 八进制和十六进制进制转换 ]]
# 感谢 Moritz Gronbach 提出。


decimal=15
octal=017   # = 15 (十进制)
hex=0x0f    # = 15 (十进制)

if [ "$decimal" -eq "$octal" ]
then
  echo "$decimal equals $octal"
else
  echo "$decimal is not equal to $octal"       # 15 不等于 017
fi      # 在单括号 [ ] 之间不会进行进制转换。


if [[ "$decimal" -eq "$octal" ]]
then
  echo "$decimal equals $octal"                # 15 等于 017
else
  echo "$decimal is not equal to $octal"
fi      # 在双括号 [[ ]] 之间会进行进制转换。

if [[ "$decimal" -eq "$hex" ]]
then
  echo "$decimal equals $hex"                  # 15 等于 0x0f
else
  echo "$decimal is not equal to $hex"
fi      # 十六进制也可以进行转换。
```

![note](http://tldp.org/LDP/abs/images/note.gif) 语法上并不严格要求在 `if` 之后一定要写 `test` 命令或者测试结构（`[]` 或 `[[]]`）。

```bash
dir=/home/bozo

if cd "$dir" 2>/dev/null; then   # "2>/dev/null" 重定向消去错误输出。
  echo "Now in $dir."
else
  echo "Can't change to $dir."
fi
```

`if COMMAND` 的退出状态就是`COMMAND` 的退出状态。

同样的，测试括号也不一定需要与 `if` 一起使用。其可以同 [列表结构](http://tldp.org/LDP/abs/html/list-cons.html#LISTCONSREF) 结合而不需要 `if`。

```bash
var1=20
var2=22
[ "$var1" -ne "$var2" ] && echo "$var1 is not equal to $var2"

home=/home/bozo
[ -d "$home" ] || echo "$home directory does not exist."
```

[`(( ))` 结构](http://tldp.org/LDP/abs/html/dblparens.html) 扩展和执行算术表达式。如果执行结果为0，其返回的 [退出状态码](http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF) 为1（假）。非0表达式返回的退出状态为0（真）。这与上述所使用的 `test` 和 `[ ]` 结构形成鲜明的对比。

样例 7-3. 使用 `(( ))` 进行算术测试

```bash
#!/bin/bash
# arith-tests.sh
# 算术测试。

# (( ... )) 结构执行并测试算术表达式。
# 与 [ ... ] 结构的退出状态正好相反。

(( 0 ))
echo "Exit status of \"(( 0 ))\" is $?."         # 1

(( 1 ))
echo "Exit status of \"(( 1 ))\" is $?."         # 0

(( 5 > 4 ))                                      # 真
echo "Exit status of \"(( 5 > 4 ))\" is $?."     # 0

(( 5 > 9 ))                                      # 假
echo "Exit status of \"(( 5 > 9 ))\" is $?."     # 1

(( 5 == 5 ))                                     # 真
echo "Exit status of \"(( 5 == 5 ))\" is $?."    # 0
# (( 5 = 5 )) 会报错。

(( 5 - 5 ))                                      # 0
echo "Exit status of \"(( 5 - 5 ))\" is $?."     # 1

(( 5 / 4 ))                                      # 合法
echo "Exit status of \"(( 5 / 4 ))\" is $?."     # 0 

(( 1 / 2 ))                                      # 结果小于1
echo "Exit status of \"(( 1 / 2 ))\" is $?."     # 舍入至0。
                                                 # 1

(( 1 / 0 )) 2>/dev/null                          # 除0，非法
#           ^^^^^^^^^^^
echo "Exit status of \"(( 1 / 0 ))\" is $?."     # 1

# "2>/dev/null" 的作用是什么？
# 如果将其移除会发生什么？
# 尝试移除这条语句并重新执行脚本。

# ======================================= #

# (( ... )) 在 if-then 中也非常有用

var1=5
var2=4

if (( var1 > var2 ))
then #^      ^      注意不是 $var1 和 $var2，为什么？
  echo "$var1 is greater then $var2"
fi     # 5 大于 4

exit 0
```

### 7.2 文件测试操作

下列每一个运算符在满足其下条件时，返回的结果为真。

**-e**

检测文件是否存在

**-a**

检测文件是否存在

等价于 `-e`。不推荐使用，已被弃用。

**-f**

文件是常规文件(regular file)，而非目录或 [设备文件](http://tldp.org/LDP/abs/html/devref1.html#DEVFILEREF)

**-s**

文件大小不为0

**-d**

文件是一个目录

**-b**

文件是一个 [块设备](http://tldp.org/LDP/abs/html/devref1.html#BLOCKDEVREF)

**-c**

文件是一个 [字符设备](http://tldp.org/LDP/abs/html/devref1.html#CHARDEVREF)

```bash
device0="/dev/sda2"    # /   (根目录)
if [ -b "$device0" ]
then
  echo "$device0 is a block device."
fi

# /dev/sda2 是一个块设备。



device1="/dev/ttyS1"   # PCMCIA 调制解调卡
if [ -c "$device1" ]
then
  echo "$device1 is a character device."
fi

# /dev/ttyS1 是一个字符设备。
```

**-p**

文件是一个 [管道设备](http://tldp.org/LDP/abs/html/special-chars.html#PIPEREF)

```bash
function show_input_type()
{
   [ -p /dev/fd/0 ] && echo PIPE || echo STDIN
}

show_input_type "Input"                           # STDIN
echo "Input" | show_input_type                    # PIPE

# 这个例子由 Carl Anderson 提供。
```

**-h**

文件是一个 [符号链接](http://tldp.org/LDP/abs/html/basic.html#SYMLINKREF)

**-L**

文件是一个符号链接

**-S**

文件是一个 [套接字](http://tldp.org/LDP/abs/html/devref1.html#SOCKETREF)

**-t**

文件（[文件描述符](http://tldp.org/LDP/abs/html/io-redirection.html#FDREF)）与终端设备关联

该选项通常被用于 [测试](http://tldp.org/LDP/abs/html/intandnonint.html#II2TEST) 脚本中的 `stdin [ -t 0 ]` 或 `stdout [ -t 1 ]` 是否为终端设备。

**-r**

该文件对执行测试的用户可读

**-w**

该文件对执行测试的用户可写

**-x**

该文件可被执行测试的用户所执行

**-g**

文件或目录设置了 set-group-id `sgid` 标志

如果一个目录设置了 `sgid` 标志，那么在该目录中所有的新建文件的权限组都归属于该目录的权限组，而非文件创建者的权限组。该标志对共享文件夹很有用。

**-u**

文件设置了 set-user-id `suid` 标志。

一个属于 root 的可执行文件设置了 `suid` 标志后，即使是一个普通用户执行也拥有 root 权限[^2]。对需要访问硬件设备的可执行文件（例如 `pppd` 和 `cdrecord`）很有用。如果没有 `suid` 标志，这些可执行文件就不能被非 root 用户所调用了。

```
-rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd
```

设置了 `suid` 标志后，在权限中会显示 `s`。

**-k**

设置了粘滞位(sticky bit)。

标志粘滞位是一种特殊的文件权限。如果文件设置了粘滞位，那么该文件将会被存储在高速缓存中以便快速访问[^3]。如果目录设置了该标记，那么它将会对目录的写权限进行限制，目录中只有文件的拥有者可以修改或删除文件。设置标记后你可以在权限中看到 `t`。

```
drwxrwxrwt    7 root         1024 May 19 21:26 tmp/
```

如果一个用户不是设置了粘滞位目录的拥有者，但对该目录有写权限，那么他仅仅可以删除目录中他所拥有的文件。这可以防止用户不经意间删除或修改其他人的文件，例如 `/tmp` 文件夹。（当然目录的所有者可以删除或修改该目录下的所有文件）

**-O**

执行用户是文件的拥有者

**-G**

文件的组与执行用户的组相同

**-N**

文件在在上次访问后被修改过了

**f1 -nt f2**

文件 f1 比文件 f2 新

**f1 -ot f2**

文件 f1 比文件 f2 旧

**f1 -ef f2**

文件 f1 和文件 f2 硬链接到同一个文件

**!**

取反——对测试结果取反(如果条件缺失则返回真)。

样例 7-4. 检测链接是否损坏

```bash
#!/bin/bash
# broken-link.sh
# Lee bigelow <ligelowbee@yahoo.com> 编写。
# ABS Guide 经许可可以使用。

#  该脚本用来发现输出损坏的链接。输出的结果是被引用的，
#+ 所以可以直接导到 xargs 中进行处理 ：）
#  例如：sh broken-link.sh /somedir /someotherdir|xargs rm
#
#  更加优雅的方式：
#
#  find "somedir" -type 1 -print0|\
#  xargs -r0 file|\
#  grep "broken symbolic"|
#  sed -e 's/^\|: *broken symbolic.*$/"/g'
#
#  但是这种方法不是纯 Bash 写法。
#  警告：小心 /proc 文件下的文件和任意循环链接！
############################################


#  如果不给脚本传任何参数，那么 directories-to-search 设置为当前目录
#+ 否则设置为传进的参数
#####################

[ $# -eq 0 ] && directory=`pwd` || directory=$@


#  函数 linkchk 是用来检测传入的文件夹中是否包含损坏的链接文件，
#+ 并引用输出他们。
#  如果文件夹中包含子文件夹，那么将子文件夹继续传给 linkchk 函数进行检测。
#################

linkchk () {
    for element in $1/*; do
      [ -h "$element" -a ! -e "$element" ] && echo \"$element\"
      [ -d "$element" ] && linkchk $element
    # -h 用来检测是否是链接，-d 用来检测是否是文件夹。
    done
}

#  检测传递给 linkchk() 函数的参数是否是一个存在的文件夹，
#+ 如果不是则报错。
################
for directory in $direcotrys; do
    if [ -d $directory ]
        then linkchk $directory
        else
            echo "$directory is not a directory"
            echo "Usage $0 dir1 dir2 ..."
    fi
done

exit $?
```

### 7.3 其他比较操作

二元比较操作比较变量或者数量。注意整数和字符串比较使用的是两套运算符。

#### 7.3.1 整数比较

* -eq	等于

  `if [ "$a" -eq "$b" ]`

* -ne     不等于

  `if [ "$a" -ne "$b" ]`

* -gt    大于

  `if [ "$a" -gt "$b" ]`

* -ge    大于等于

  `if [ "$a" -ge "$b" ]`

* -lt    小于

  `if [ "$a" -lt "$b" ]`

* -le    小于等于

  `if [ "$a" -le "$b" ]`

* <    小于（使用 [双圆括号](http://tldp.org/LDP/abs/html/dblparens.html)）

  `(("$a" < "$b"))`

* <=    小于等于（使用双圆括号）

  `(("$a" <= "$b"))`

* \>    大于（使用双圆括号）

  `(("$a" > "$b"))`

* \>=    大于等于（使用双圆括号）

  `(("$a" >= "$b"))`

#### 7.3.2 字符串比较

* =    等于

  `if [ "$a" = "$b" ]`

  >  ![caution](images/caution.gif) 注意在`=`前后要加上[空格](http://tldp.org/LDP/abs/images/caution.gif)

  `	if [ "$a"="$b" ]` 和上面不等价。

* ==     等于

  `if [ "$a" == "$b" ]`

  和 `=` 同义

  > ![note](images/note.gif) `==` 运算符在 [双方括号](http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS) 和单方括号里表现不同。

  ```bash
  [[ $a == z* ]]   # $a 以 "z" 开头时为真（模式匹配）
  [[ $a == "z*" ]] # $a 等于 z* 时为真（字符匹配）
  
  [ $a == z* ]     # 发生文件匹配和字符分割。
  [ "$a" == "z*" ] # $a 等于 z* 时为真（字符匹配）
  
  # 感谢 Stéphane Chazelas
  ```

* !=    不等于

  `if [ "$a" != "$b" ]`

  在 [`[[ ... ]]`]结构中会进行模式匹配。

* <    小于，按照 [ASCII码](http://tldp.org/LDP/abs/html/special-chars.html#ASCIIDEF) 排序。

  `if [[ "$a" < "$b" ]]`

  `if [ "$a" \< "$b" ]`

  > 注意在 `[]` 结构里 `<` 需要被 [转义](http://tldp.org/LDP/abs/html/escapingsection.html#ESCP)。

* \>    大于，按照 ASCII 码排序。

  `if [[ "$a" > "$b" ]]`

  `if [ "$a" \> "$b" ]`

  >  注意在 `[]` 结构里 `>` 需要被转义。

  [样例 27-11](http://tldp.org/LDP/abs/html/arrays.html#BUBBLE) 包含了比较运算符。

* -z    字符串为空，即字符串长度为0。

  ```bash
  String=''   # 长度为0的字符串变量。
  
  if [ -z "$String" ]
  then
    echo "\$String is null."
  else
    echo "\$String is NOT null."
  fi     # $String is null.
  ```

* -n    字符串非空（`null`）。

  > ![caution](images/caution.gif) 使用 `-n` 时字符串必须是在括号中且被引用的。使用 `! -z` 判断未引用的字符串或者直接判断（[样例 7-6](http://tldp.org/LDP/abs/html/comparison-ops.html#STRTEST)）通常可行，但是非常危险。判断字符串时一定要引用[^1]。

样例 7-5. 算术比较和字符串比较

```bash
#!/bin/bash

a=4
b=5

# 这里的 "a" 和 "b" 可以是整数也可以是字符串。
# 因为 Bash 的变量是弱类型的，因此字符串和整数比较有很多相同之处。

# 在 Bash 中可以用处理整数的方式来处理全是数字的字符串。
# 但是谨慎使用。

echo

if [ "$a" -ne "$b" ]
then
  echo "$a is not equal to $b"
  echo "(arithmetic comparison)"
fi

echo

if [ "$a" != "$b" ]
then
  echo "$a is not equal to $b."
  echo "(string comparison)"
  #     "4"  != "5"
  # ASCII 52 != ASCIII 53
fi

# 在这个例子里 "-ne" 和 "!=" 都可以。

echo

exit 0
```

样例 7-6. 测试字符串是否为空（`null`）

```bash
#!/bin/bash
# str-test.sh: 测试是否为空字符串或是未引用的字符串。

# 使用 if [ ... ] 结构

# 如果字符串未被初始化，则其值是未定义的。
# 这种状态就是空 "null"（并不是 0）。

if [ -n $string1 ]    # 并未声明或是初始化 string1。
then
  echo "String \"string1\" is not null."
else
  echo "String \"string1\" is null."
fi
# 尽管没有初始化 string1，但是结果显示其非空。

echo

# 再试一次。

if [ -n "$string1" ]   # 这次引用了 $string1。
then
  echo "String \"string1\" is not null."
else
  echo "String \"string1\" is null."
fi                    # 在测试括号内引用字符串得到了正确的结果。

echo

if [ $string1 ]       # 这次只有一个 $string1。
then
  echo "String \"string1\" is not null."
else
  echo "String \"string1\" is null."
fi                    # 结果正确。
# 独立的 [ ... ] 测试运算符可以用来检测字符串是否为空。
# 但是最好将字符串进行引用（if [ "$string1" ]）。
#
# Stephane Chazelas 指出：
#    if [ $string1 ]    只有一个参数 "]"
#    if [ "$string1" ]  则有两个参数，空的 "$string1" 和 "]"


echo


string1=initialized

if [ $string1 ]       # $string1 这次仍然没有被引用。
then
  echo "String \"string1\" is not null."
else
  echo "String \"string1\" is null."
fi                    # 这次的结果仍然是正确的。
# 最好将字符串引用（"$string1"）


string1="a = b"

if [ $string1 ]       # $string1 这次仍然没有被引用。
then
  echo "String \"string1\" is not null."
else
  echo "String \"string1\" is null."
fi                    # 这次没有引用就错了。

exit 0   # 同时感谢 Florian Wisser 的提示。
```

样例 7-7. `zmore`

```bash
#!/bin/bash
# zmore

# 使用筛选器 'more' 查看 gzipped 文件。

E_NOARGS=85
E_NOTFOUND=86
E_NOTGZIP=87

if [ $# -eq 0 ] # 作用和 if [ -z "$1" ] 相同。
# $1 可以为空： zmore "" arg2 arg3
then
  echo "Usage: `basename $0` filename" >&2
  # 将错误信息通过标准错误 stderr 进行输出。
  exit $E_NOARGS
  # 脚本的退出状态为 85.
fi

filename=$1

if [ ! -f "$filename" ]   # 引用字符串以防字符串中带有空格。
then
  echo "File $filename not found!" >&2   # 通过标准错误 stderr 进行输出。
  exit $E_NOTFOUND
fi

if [ ${filename##*.} != "gz" ]
# 在括号内使用变量代换。
then
  echo "File $1 is not a gzipped file!"
  exit $E_NOTGZIP
fi

zcat $1 | more

# 使用筛选器 'more'
# 也可以用 'less' 替代

exit $?   # 脚本的退出状态由管道 pipe 的退出状态决定。
#  实际上 "exit $?" 不一定要写出来，
#+ 因为无论如何脚本都会返回最后执行命令的退出状态。
```

#### 7.3.4 复合比较

* -a    逻辑与

  `exp1 -a exp2` 返回真当且仅当 `exp1` 和 `exp2` 均为真。

* -o    逻辑或

  如果 `exp1` 或 `exp2` 为真，则 `exp1 -o exp2` 返回真。

以上两个操作和 [双方括号](http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS) 结构中的 Bash 比较运算符号 `&&` 和 `||` 类似。

```bash
[[ condition1 && condition2 ]]
```

测试操作 `-o` 和 `-a` 可以在 [`test`](http://tldp.org/LDP/abs/html/testconstructs.html#TTESTREF) 命令或在测试括号中进行。

```bash
if [ "$expr1" -a "$expr2" ]
then
  echo "Both expr1 and expr2 are true."
else
  echo "Either expr1 or expr2 is false."
fi
```

![caution](images/caution.gif) rihad 指出：

```bash
[ 1 -eq 1 ] && [ -n "`echo true 1>&2`" ]   # 真
[ 1 -eq 2 ] && [ -n "`echo true 1>&2`" ]   # 没有输出
# ^^^^^^^ 条件为假。到这里为止，一切都按预期执行。

# 但是
[ 1 -eq 2 -a -n "`echo true 1>&2`" ]       # 真
# ^^^^^^^ 条件为假。但是为什么结果为真？

# 是因为括号内的两个条件子句都执行了么？
[[ 1 -eq 2 && -n "`echo true 1>&2`" ]]     # 没有输出
# 并不是。

#  所以显然 && 和 || 具备“短路”机制，
#+ 例如对于 &&，若第一个表达式为假，则不执行第二个表达式直接返回假，
#+ 而 -a 和 -o 则不是。
```

复合比较操作的例子可以参考 [样例 8-3](http://tldp.org/LDP/abs/html/ops.html#ANDOR)，[样例 27-17](http://tldp.org/LDP/abs/html/arrays.html#TWODIM) 和 [样例 A-29](http://tldp.org/LDP/abs/html/contributed-scripts.html#WHX)。

### 7.4 嵌套 if/then 条件测试

可以嵌套 `if/then` 条件测试结构。嵌套的结果等价于使用 [`&&`](http://tldp.org/LDP/abs/html/ops.html#LOGOPS1) 复合比较运算符。

```bash
a=3

if [ "$a" -gt 0 ]
then
  if [ "$a" -lt 5 ]
  then
    echo "The value of \"a\" lies somewhere between 0 and 5."
  fi
fi

# 和下面的结果相同

if [ "$a" -gt 0 ] && [ "$a" -lt 5 ]
then
  echo "The value of \"a\" lies somewhere between 0 and 5."
fi
```

在 [样例 37-4](http://tldp.org/LDP/abs/html/bashver2.html#CARDS) 和 [样例 17-11](http://tldp.org/LDP/abs/html/system.html#BACKLIGHT) 中展示了嵌套 `if/then` 条件测试结构。

## 8 运算符相关话题

# 第三部分 shell进阶

## 9 换个角度看变量

在脚本中恰当的使用变量可以增强脚本并提高适应性。因此就需要了解变量的微妙之处和细微差异。

### 9.1 内部变量

#### 9.1.1 内建变量

影响 Bash 脚本行为的变量。

**$BASH**

Bash程序的路径。

```bash
bash$ echo $BASH
/bin/bash
```

**$BASH_ENV**

这个环境变量会指向一个 Bash 启动文件，该文件在脚本被调用时会被读取。

**$BASH_SUBSHELL**

该变量用于提示所处的 subshell 层级。这是在 Bash version 3 中被引入的新特性。

具体用法可以参考 [样例21-1](http://tldp.org/LDP/abs/html/subshells.html#SUBSHELL)。

**$BASHPID**

当前 Bash 进程实例的进程ID号。虽然与 `$$` 变量不一样，但是通常它们会给出相同的结果。

```bash
bash4$ echo $$
11015


bash4$ echo $BASHPID
11015


bash4$ ps ax | grep bash4
11015 pts/2    R      0:00 bash4
```

然而...

```bash
#!/bin/bash4

echo "\$\$ outside of subshell = $$"                              # 9602
echo "\$BASH_SUBSHELL  outside of subshell = $BASH_SUBSHELL"      # 0
echo "\$BASHPID outside of subshell = $BASHPID"                   # 9602

echo

( echo "\$\$ inside of subshell = $$"                             # 9602
  echo "\$BASH_SUBSHELL inside of subshell = $BASH_SUBSHELL"      # 1
  echo "\$BASHPID inside of subshell = $BASHPID" )                # 9603
  #  注意 $$ 总是返回父进程的 PID。
```

**$BASH_VERSINFO[n]**

这是一个6个元素的数组，其中包含了已经安装的 Bash 的版本信息。该变量与变量 `$BASH_VERSION` 类似，但是更加详细。

```bash
# Bash 版本信息：

for n in 0 1 2 3 4 5
do
  echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
done

# BASH_VERSINFO[0] = 3                      # 主版本号
# BASH_VERSINFO[1] = 00                     # 次版本号
# BASH_VERSINFO[2] = 14                     # 补丁号
# BASH_VERSINFO[3] = 1                      # 构建版本号
# BASH_VERSINFO[4] = release                # 发行状态
# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # 架构
                                            # (与 $MACHTYPE 相同)
```

**$BASH_VERSION**

已经安装的 Bash 的版本信息。

```bash
bash$ echo $BASH_VERSION
3.2.25(1)-release
```

```bash
tcsh% echo $BASH_VERSION
BASH_VERSION: Undefined variable.
```

利用 `$BASH_VERSION` 来判断运行的是哪个 shell 是一个不错的方法，因为变量 `$SHELL` 并不总是能够给出正确的答案。

**$CDPATH**

变量指定 `cd` 命令可以搜索的路径，路径之间用冒号进行分隔。该变量的功能类似于指定可执行文件搜索路径的变量 `$PATH`。可以在本地文件 `~/.bashrc` 中设置该变量。

```bash
bash$ cd bash-doc
bash: cd : bash-doc: No such file or directory


bash$ CDPATH=/usr/share/doc
bash$ cd bash-doc
/usr/share/doc/bash-doc


bash$ echo $PWD
/usr/share/doc/bash-doc
```

**$DIRSTACK**

指代目录栈中顶部的值，目录栈由命令 `pushd` 和 `popd` 控制。

该变量相当于命令 `dirs`，但是 `dirs` 命令会显示整个目录栈。

**$EDITOR**

脚本所调用的默认编辑器，通常是 `vi` 或是 `emcas`。

**$EUID**

有效用户ID。

有效用户ID（EUID）是指当前用户正在使用的用户ID，可以通过 `su` 命令修改。

{% hint style="warning" %}

`$EUID` 与 `$UID` 并不总是相同的。

{% endhint %}

**$FUNCNAME**

当前运行函数的函数名。

``` bash
xyz23 ()
{
  echo "$FUNCNAME now executing."  # xyz2 now executing.
}

xyz23

echo "FUNCNAME = $FUNCNAME"        # FUNCNAME =
                                   # 如果在函数外则为空值。 
```

可以参考 [样例 A-50]()。

**$GLOBIGNORE**

在[文件匹配](../part5/18_2_globbing.md)时所忽略的文件名模式列表。

**$GROUPS**

当前用户所属的用户组。

该变量存储了当前用户所归属的用户组ID列表，是一个数组。内容与记录在文件 `/etc/passwd` 和文件 `/etc/group` 中的一致。

```bash
root# echo $GROUPS
0


root# echo ${GROUPS[1]}
1


root# echo ${GROUPS[5]}
6
```

**$HOME**

当前用户的主目录，其值通常为 `/home/username` （参考 [样例 10-7]()）。

**$HOMENAME**

系统启动的初始化脚本通过命令 `hostname` 给系统分配主机名。而函数 `gethostname()` 则是给 Bash 的内部变量 `$HOSTNAME` 赋值。可以参考 [样例 10-7]()。

**$HOSTTYPE**

主机类型。

类似变量 [`$MACHTYPE`]()，用于识别系统硬件信息。

```bash
bash$ echo $HOSTTYPE
i686
```

**$IFS**

内部字段分隔符。

该变量决定了 Bash 在解析字符串时如何去识别 [字段]() 或单词边界。

`$IFS` 的缺省值是空白符（空格，制表符以及换行符），但其可以被修改。例如你在处理逗号分隔的文件时可以将其设置为逗号。需要注意 [`$*`]() 使用保存在 `$IFS` 中的第一个字符。可以参考 [样例 5-1]()。

```bash
bash$ echo "$IFS"

(当 $IFS 设置为缺省值时，显示空行。)


bash$ echo "$IFS" | cat -vte
 ^I$
 $
(显示空白符：首先是一个空格，然后是 ^I [水平制表符]，
 然后是换行符，最后在末尾显示 "$"。)


bash$ bash -c 'set w x y z; IFS=":-;"; echo "$*"'
w:x:y:z
(从字符串中解析命令，然后将命令参数分配给位置参数。)
```

通过设置 `$IFS` 来忽略文件路径名中空格带来的影响。

```bash
IFS="$(printf '\n\t')"   # 按 David Wheeler 所述。
```

{% hint style="warning" %}

相比于其他字符，变量 `$IFS` 在处理空白符时有所不同。

样例 9-1. $IFS 与空白符

```bash
#!/bin/bash
# ifs.sh


var1="a+b+c"
var2="d-e-f"
var3="g,h,i"

IFS=+
# 加号会被解析成分隔符。
echo $var1     # a b c
echo $var2     # d-e-f
echo $var3     # g,h,i

echo

IFS="-"
# 恢复对加号的默认解析。
# 现在减号会被解析成分隔符。
echo $var1     # a+b+c
echo $var2     # d e f
echo $var3     # g,h,i

echo

IFS=","
# 现在逗号会被解析成分隔符。
# 恢复对减号的默认解析。
echo $var1     # a+b+c
echo $var2     # d-e-f
echo $var3     # g h i

echo

IFS=" "
# 现在空格会被解析成分隔符。
# 逗号恢复成默认解析。
echo $var1     # a+b+c
echo $var2     # d-e-f
echo $var3     # g,h,i

# ======================================================== #

# 然而...
# $IFS 处理空白符的方式不同其他字符。

output_args_one_per_line()
{
  for arg
  do
    echo "[$arg]"
  done #  ^    ^   为了获得更好的视觉体验，把参数放到了括号里。
}

echo; echo "IFS=\"  \""
echo "-------"

IFS=" "
var=" a  b c   "
#    ^ ^^   ^^^
output_args_one_per_line $var  # output_args_one_per_line `echo " a  b c   "`
# [a]
# [b]
# [c]


echo; echo "IFS=:"
echo "-----"

IFS=:
var=":a::b:c:::"               # 与上面一样的模式，
#    ^ ^^   ^^^                #+ 仅仅是将 " " 替换成了 ":" ...
output_args_one_per_line $var
# []
# [a]
# []
# [b]
# [c]
# []
# []

# 注意那些“空的”括号。
# 同样的情况也会出现在 awk 命令所使用的 "FS" 字段分隔符中。


echo

exit
```

{% endhint %}

（非常感谢 Stéphane Chazelas 提供了上面的样例并做出的详细说明。）

也可以参考 [样例 16-41]()，[样例 11-8]() 和 [样例19-14]()，获取更多使用 `$IFS` 的技巧。

**$IGNOREEOF**

忽略 EOF：用于指示 Shell 在注销前需要忽略多少个文件结束符(EOF，contrl-D)。

**$LC_COLLATE**

经常会在文件 [`.bashrc`]() 或是文件 `/etc/profile` 中被设置。该变量控制文件名扩展和模式匹配中的排序顺序。如果设置不得当，`LC_COLLATE` 将会导致 [文件名匹配]() 中出现非预期结果。


{% hint style="info" %}

在 Bash 2.05 版本之后，文件名匹配在不再区分中括号中字母的大小写。例如 `ls [A-M]*` 将会同时匹配 `File1.txt` 和 `file1.txt` 两个文件。如果想要恢复成之前的模式，则需要在文件 `/etc/profile` 或文件 `~/.bashrc` 中通过语句 `export LC_COLLATE=C` 设置 `LC_COLLATE` 的值为 `C`。

{% endhint %}

**$LC_CTYPE**

这个内部变量控制在 [文件匹配]() 和模式匹配中的字符解析行为。

**$LINENO**

该变量记录了其在脚本中被使用时所处行的行号。该变量只有在被使用时才有意义，在调试过程中非常有用。

```bash
# *** 调试部分起始 ***
last_cmd_arg=$_  # 保存最后的命令。

echo "At line number $LINENO, variable \"v1\" = $v1"
echo "Last command argument processed = $last_cmd_arg"
# *** 调试部分终止 ***
```

**$MACHTYPE**

设备类型。

识别系统硬件。

```bash
bash$ echo $MACHTYPE
i686
```

**$OLDPWD**

上一个工作目录(OLD-Print-Working-Directory)，也就是之前所在的目录。

**$OSTYPE**

操作系统类型。

```bash
bash$ echo $OSTYPE
linux
```

**$PATH**

可执行文件搜索路径，其值通常包含 `/usr/bin`，`/usr/X11R6/bin/`，`/usr/local/bin` 等路径。

给定一个命令，shell就会自动从搜索路径包含的目录中利用哈希表搜索该可执行命令。而搜索路径就保存在 [环境变量]() `$PATH` 中，其中包含的一系列目录则通过冒号进行分隔。通常情况下，`$PATH` 会定义在文件 `/etc/profile` 或文件 [`~/.bashrc`]() 中（参考 [附录 H]()）。

```bash
bash$ echo $PATH
/bin:/usr/bin:/usr/local/bin/:/usr/X11R6/bin:/sbin:/usr/sbin
```

`PATH=${PATH}:/opt/bin` 表示添加目录 `/opt/bin` 到当前的搜索路径中。在脚本中可以通过这种方式临时添加目录到搜索路径。而当脚本结束时，`$PATH` 就会恢复到原始值（类似于脚本这样的子进程所作出的修改，不会影响到例如 shell 这样的父进程的环境）。

{% hint style="info" %}

基于安全考虑，通常在 `$PATH` 中会省略当前工作目录 `./`。

{% endhint %}

**$PIPESTATUS**

该 [数组]() 变量保存了最后运行的前台 [管道]() 的 [退出状态(es)]()。

```bash
bash$ echo $PIPESTATUS
0

bash$ ls -al | bogus_command
bash: bogus_command: command not found
bash$ echo ${PIPESTATUS[1]}
127

bash$ ls -al | bogus_command
bash: bogus_command: command not found
bash$ echo $?
127
```

`$PIPESTATUS` 数组中的每一个元素都代表了该管道中相对应命令的退出状态。`$PIPESTATUS[0]` 表示管道中第一个命令的退出状态，`$PIPESTATUS[1]` 表示第二个命令的退出状态，以此类推。

{% hint style="warning" %}

在Bash 3.0 以下版本的登录shell中，变量 `$PIPESTATUS` 可能会包含一个不正确的 0 值。

```bash
tcsh% bash

bash$ who | grep nobody | sort
bash$ echo ${PIPESTATUS[*]}
0
```

如果脚本包含了上述代码，应该得到期望的输出是 0 1 0。

感谢 Wayne Pollock 指出了这个问题并提供了上述的样例。

{% endhint %}

{% hint style="info" %}

在某些场景下，`$PIPESTATUS` 变量将会产生非预期结果。

```bash
bash$ echo $BASH_VERSION
3.00.14(1)-release

bash$ ls | bogus_command | wc
bash: bogus_command: command not found
 0       0       0

bash$ echo ${PIPESTATUS[@]}
141 127 0
```

Chet Ramey 把上述非预期结果的原因归咎于 [`ls`]() 命令的行为。如果 `ls` 将结果输出到没有被读取的管道上，产生的 SIGPIPE 信号将会终止 `ls` 命令，同时其 [退出状态]() 从期望的 0 变为 141。而同样的情况也会发生在命令 `tr` 中。

{% endhint %}

{% hint style="info" %}

`$PIPESTATUS` 是一个易失的变量。该变量需要在目标管道执行完成后，且其他任何命令执行之前去捕获。

```bash
bash$ ls | bogus_command | wc
bash: bogus_command: command not found
 0       0                0

bash$ echo ${PIPESTATUS[@]}
0 127 0

bash$ echo ${PIPESTATUS[@]}
0
```

{% endhint %}

{% hint style="info" %}

在 `$PIPESTATUS` 不能给出所期望的信息的情况下，使用 [pipeline 选项]() 可能会有帮助。

{% endhint %}

**$PPID**

一个进程的 `$PPID` 即该进程的父进程的进程ID(pid)。[^2]

可以与命令 [`pidof`]() 进行比较。

**$PROMPT_COMMAND**

该变量存储在主提示符 `$PS1` 显示之前所需要执行的命令。

**$PS1**

主提示符，即在命令行中显示的提示符。

**$PS2**

次要提示符，当需要额外输入时出现的提示符。默认显示为 `>`。

**$PS3**

三级提示符，显示在 `select` 循环中（参考 [样例 11-30]()）。

**$PS4**

四级提示符，当使用 `-x [verbose trace]` [选项]() 调用脚本时显示的提示符。默认显示为 `+`。

其可以作为调试的辅助手段，把一些诊断信息显示在 `$PS4` 中可能会有帮助。

```bash
P4='$(read time junk < /proc/$$/schedstat; echo "@@@ $time @@@ " )'
# 根据 Erik Brandsberg 提供的建议。
set -x
# 可以在后面写各种命令...
```

**$PWD**

工作目录（你当前所在的目录）。

该变量是内建命令 [`pwd`]() 的翻版。

```bash
#!/bin/bash

E_WRONG_DIRECTORY=85

clear # 清空屏幕。

TargetDirectory=/home/bozo/projects/GreatAmericanNovel

cd $TargetDirectory
echo "Deleting stale files in $TargetDirectory."

if [ "$PWD" != "$TargetDirectory" ]
then    # 小心不要偶然清空了错误的目录。
  echo "Wrong directory!"
  echo "In $PWD, rather than $TargetDirectory!"
  echo "Bailing out!"
  exit $E_WRONG_DIRECTORY
fi

rm -rf *
rm .[A-Za-z0-9]*    # 删除隐藏文件。
# rm -f .[^.]* ..?*   删除那些以多个点开头的文件。
# (shopt -s dotglob; rm -f *)   这样写也可以。
# 感谢 S.C. 提出这点。

#  文件名可以包含ASCII码中范围为 0-255 的所有字符，
#+ 除了字符 "/"。
#  删除以一些特殊字符开头的文件，例如 -
#+ 留作练习。（提示： rm ./-weirdname 或者 rm -- -weirdname）
result=$?   # 删除操作的结果。如果删除成功，值为0。

echo
ls -al              # 是不是还有剩余没有删除的文件？
echo "Done."
echo "Old files deleted in $TargetDirectory."
echo

# 如果有其他需要，在这里完成。

exit $result
```

**$REPLY**

当没有给 [`read`]() 命令提供接收参数时的默认接收参数。该变量同样适用于 [`select`]() 菜单接收用户输入值的场景，需要注意的是，用户只需要输入菜单项的编号，而不需要输入完整的菜单项内容。

```bash
#!/bin/bash
# reply.sh

# REPLY 是 'read' 命令的默认接收参数。

echo
echo -n "What is your favorite vegetable? "
read

echo "Your favorite vegetable is $REPLY."
#  当且仅当 'read' 命令没有接收参数的时候，
#+ REPLY 才能保存最近一次 'read' 命令接收的值。

echo
echo -n "What is your favorite fruit? "
read fruit
echo "Your favorite fruit is $fruit."
echo "but..."
echo "Value of \$REPLY is still $REPLY."
#  因为变量 $fruit 接收了新一次 "read" 命令所读入的值，
#+ 所以 $REPLY 仍旧存储的是上一次接收的值。

echo

exit 0
```

**$SECONDS**

该变量记录到目前为止脚本执行的时间，单位为秒。

```bash
#!/bin/bash

TIME_LIMIT=10
INTERVAL=1

echo
echo "Hit Control-C to exit before $TIME_LIMIT seconds."
echo

while [ "$SECONDS" -le "$TIME_LIMIT" ]
do   #   $SECONDS 是一个 shell 的内部变量。
  if [ "$SECONDS" -eq 1 ]
  then
    units=second
  else
    units=seconds
  fi
  
  echo "This script has been running $SECONDS $units."
  #  在一台性能较差或负载过重的设备上，
  #+ 这个脚本可能会偶尔跳过几个计数。
  sleep $INTERVAL
done

echo -e "\a"  # 发出蜂鸣声！

exit 0
```

**$SHELLOPTS**

该只读变量记录了 shell 中已启用的 [选项]() 列表。

```bash
bash$ echo $SHELLOPTS
braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs
```

**$SHLVL**

当前 shell 的层级，即嵌套了多少层 Bash [^3]。如果命令行的层级 `$SHLVL` 为 1，那么在其中执行的脚本层级则增加到 2。

{% hint style="info" %}

该变量 [不受 subshell 影响]()。当你需要指出嵌套了多少层 subshell 时，需要使用变量 [`$BASH_SUBSHELL`](#$BASH_SUBSHELL)。

{% endhint %}

**$TMOUT**

如果 `$TMOUT` 被设为非 0 值 `time`，那么 shell 会在 `$time` 秒后超时，然后导致 shell 登出。

在 Bash 2.05b 版本之后，可以在脚本中将 `read` 命令与 `$TMOUT` 变量进行结合。

```bash
# 只能在 Bash 2.05b 及之后的版本中成功执行。

TMOUT=3    # 提示会在 3 秒后超时。

echo "What is your favorite song?"
echo "Quickly now, you only have $TMOUT seconds to answer!"
read song

if [ -z "$song" ]
then
  song="(no answer)"
  # 默认值。
fi

echo "Your favorite song is $song."
```

在脚本中，同样也存在其他一些实现超时功能的更复杂的方法。其中一个方法是设置一个循环的计时器，当脚本超时的时候，计时器会给脚本发送一个信号。同时，也需要一个处理信号的程序来 [捕获]()（参考 [样例 32-5]()）由循环计时器产生的中断。

样例 9-2. 限时输入

```bash
#!/bin/bash
# timed-input.sh

# TMOUT=3    在新版本的 Bash 中起效。

TIMER_INTERRUPT=14
TIMELIMIT=3  # 在该实例中设置为 3 秒。
             # 同样可以设置成其他值。
             
PrintAnswer()
{
  if [ "$answer" = TIMEOUT ]
  then
    echo $answer
  else       # 不要混淆了这两个实例。
    echo "Your favorite veggie is $answer"
    kill $!  #  终止在后台运行的
             #+ 不再被需要的 TimerOn 函数。
             #  $! 代表最后一个在后台运行的作业的进程ID。
  fi

}
                
                
TimerOn()
{
  sleep $TIMELIMIT && kill -s 14 $$ &
  # 等待 3 秒，然后给脚本发送一个信号。
}


Int14Vector()
{
  answer="TIMEOUT"
  PrintAnswer
  exit $TIMER_INTERRUPT
}

trap Int14Vector $TIMER_INTERRUPT
# 我们的目的就是通过时间中断 (14) 终止程序。

echo "What is your favorite vegetable "
TimerOn
read answer
PrintAnswer


#  必须承认，这个实现限时输入的方法并不优雅。
#  但利用 "read" 命令的 "-t" 选项可以简化这个操作。
#  参考脚本 "t-out.sh"。
#  思考一下，如果不是对用户的单次输入时间进行限制，
#+ 而是对整个脚本的运行时间进行限制，应该怎么做？

#  如果你需要更优雅的写法 ...
#+ 可以考虑用 C 或者 C++ 来编写应用，
#+ 并使用其中包含的类似 'alarm' 或是 ‘setitimer' 等合适的库函数来实现计时。

exit 0
```

还有一种方法是使用 [`stty`]()。

样例 9-3. 再来一次，限时输入

```bash
#!/bin/bash
# timeout.sh

#  该脚本由 Stephane Chazelas 编写，
#+ 并由本书作者修改。

INTERVAL=5                # 超时所需的时间间隔

timedout_read() {
  timeout=$1
  varname=$2
  old_tty_settings=`stty -g`
  stty -icanon min 0 time ${timeout}0
  eval read $varname      # 或者直接写成 read $varname
  stty "$old_tty_settings"
  # 参考 "stty" 的帮助页面 (man)。
}

echo; echo -n "What's your name? Quick! "
timedout_read $INTERVAL your_name

#  该脚本也许并不能在所有类型的终端上正常运行。
#  最大的超时时间间隔依赖于终端。
#+ （通常是 25.5 秒）。

echo

if [ ! -z "$your_name" ]  # 如果在超时前输入了姓名 ...
then
  echo "Your name is $your_name."
else
  echo "Timed out."
fi

echo

# 该脚本的计时行为与 "timed-input.sh" 中的计时行为有所不同，
# 该脚本的计时器会在每次按键后被重置。

exit 0
```

可能最简单的方法就是利用 [`read`]() 命令的 `-t` 选项。

样例 9-4. 限时 read

```bash
#!/bin/bash
# t-out.sh [time-out]
# 从 "syngin seven" 的建议中所汲取的灵感，谢谢你们。


TIMELIMIT=4         # 4 秒

read -t $TIMELIMIT variable <&1
#                           ^^^
#  在这个实例中，只有 Bash 1.x 或 Bash 2.x 版本需要 "<&1"，
#  而在 Bash 3 及更高版本则不需要。

echo

if [ -z "$variable" ]  # 判断是否为空。
then
  echo "Timed out, variable still unset."
else
  echo "variable = $variable"
fi

exit 0
```

**$UID**

用户 ID。

记录在文件 [`/etc/passwd`]() 中当前用户的用户标识号。

该 ID 表示的是当前用户的真实 ID，即使用户通过 `su` 命令临时切换至另一个用户，这个 ID 也不会改变。`$UID` 是一个只读变量，不能够被命令行或是脚本中的命令所修改，并与内建命令 [`id`]() 相对应。

样例 9-5. 我是 root 用户吗？

```bash
#!/bin/bash
# am-i-root.sh:   我是否是 root 用户？

ROOT_UID=0   # Root 用户的 $UID 为 0。

if [ "$UID" -eq "$ROOT_UID" ]  # 只有真正的 "root" 用户才能经受得住考研。
then
  echo "You are root."
else
  echo "You are just an ordinary user (but mom loves you just the same)."
fi

exit 0


# ============================================================= #
# 下面的代码将不会被执行，因为脚本已经退出了。

# 另外一种判断是否是 root 用户的方法：

ROOTUSER_NAME=root

username=`id -nu`              # 或是...  username=`whoami`
if [ "$username" = "$ROOTUSER_NAME" ]
then
  echo "Rooty, toot, toot. You are root."
else
  echo "You are just a regular fella."
fi
```

还可以参考 [样例2-3]()。

{% hint style="info" %}

变量 `$ENV`，`$LOGNAME`，`$MAIL`，`$TERM`，`$USER` 以及 `$USERNAME` 并不是 Bash 的 [内建变量]()，而是在 [`Bash`]() 或系统的某个启动文件中，被设置而成的 [环境变量]()。代表当前用户登录 shell 名称的变量 `$SHELL` 是在文件 `/etc/password` 或是某个初始化脚本中被设定的，它也不是一个 Bash 的内建变量。

```bash
tcsh% echo $LOGNAME
bozo
tcsh% echo $SHELL
/bin/tcsh
tcsh% echo $TERM
rxvt

bash$ echo $LOGNAME
bozo
bash$ echo $SHELL
/bin/tcsh
bash$ echo $TERM
rxvt
```

{% endhint %}

#### 9.1.2 位置参数

**\$0, \$1, \$2 等**

位置参数。出现在从命令行传递给脚本、函数或是通过内建命令 [`set`]() 设置变量时（参考 [样例 4-5]() 或是 [样例 15-16]()）。

**$&#35;** 

命令行参数或是位置参数的个数（参考 [样例 36-2]()）。

**$***

将所有的位置参数整合，视作一个单词。

{% hint style="info" %}

该参数必须是被引用的状态，`"$*"`。

{% endhint %}

**$@**

该参数等同于 `$*`，但其中每个参数都是独立的被引用的字符串。也就是说，所有的参数都是被原封不动的进行传递，并没有被解析或是扩展。这意味着，参数列表中的每一个参数都被独立视为一个单词。

{% hint style="info" %}

同样，该参数必须是被引用的状态，`"$@"`。

{% endhint %}

样例 9-6. 参数列表：利用 \$* 和 \$@ 列出参数

```bash
#!/bin/bash
# arglist.sh
# 在调用该脚本时需要跟上一些参数，例如 "one two three" ...

E_BADARGS=85

if [ ! -n "$1" ]
then
  echo "Usage: `basename $0` argument1 argument2 etc."
  exit $E_BADARGS
fi

echo

index=1          # 初始化计数器。

echo "Listing args with \"\$*\":"
for arg in "$*"  # 如果这里没有引用 "$*"，脚本将不会正常运行。
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # $* 将所有参数视作一个单词。
echo "Entire arg list seen as single word."

echo

index=1          # 重置计数器。
                 # 如果忘了这一步将会发生什么？
                 
echo "Listing args with \"\$@\":"
for arg in "$@"
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # $@ 将所有参数视作独立的单词。
echo "Arg list seen as separate words."

echo

index=1          # 重置计数器。

echo "Listing args with \$* (unquoted):"
for arg in $*
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # 未被引用的 $* 将所有参数视作独立的单词。
echo "Arg list seen as separate words."

exit 0
```

在 `shift` 命令执行后，`$@` 将会保留除了 `$1` 之外的剩余的命令行参数，而 `$1` 则会被丢弃。

```bash
#!/bin/bash
# 使用 ./scriptname 1 2 3 4 5 调用脚本

echo "$@"    # 1 2 3 4 5
shift
echo "$@"    # 2 3 4 5
shift
echo "$@"    # 3 4 5

# 每一次 "shift" 都会丢弃参数 $1。
# "$@" 则包含了剩余的所有参数。
```

参数 `$@` 也可被用作过滤 shell 脚本输入的工具。结构 `cat "$@"` 可以接受来自标准输入 `stdin` 的输入，也可以接受传递给脚本的参数中的文件中的输入。参考 [样例 16-24]() 和 [样例 16-25]()。

{% hint style="warning" %}

根据分隔符 [`$IFS`]() 设置的不同，`$*` 和 `$@` 有时会出现不一致或非预期行为。

{% endhint %}

样例 9-7. \$* 和 \$@ 的不一致行为

```bash
#!/bin/bash

#  Bash 的内部变量 "$*" 和 "$@" 拥有不稳定的行为，
#+ 这些行为是否出现通常依赖于它们是否是被引用的状态。
#  下面的代码会演示在分词和换行时，这些变量所会出现的一些不一致的处理方式。


set -- "First one" "second" "third:one" "" "Fifth: :one"
# 设置脚本参数，$1, $2, $3 等等。

echo 

echo 'IFS unchanged, using "$*"'
c=0
for i in "$*"               # 被引用状态。
do echo "$((c+=1)): [$i]"   # 这一行在下面所有的例子中都保持不变。
                            # 输出参数。
done
echo ---

echo 'IFS unchanged, using $*'
c=0
for i in $*                 # 未被引用状态。
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS unchanged, using "$@"'
c=0
for i in "$@"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS unchanged, using $@'
c=0
for i in $@
do echo "$((c+=1)): [$i]"
done
echo ---

IFS=:
echo 'IFS=":", using "$*"'
c=0
for i in "$*"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $*'
c=0
for i in $*
do echo "$((c+=1)): [$i]"
done
echo ---

var=$*
echo 'IFS=":", using "$var" (var=$*)'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $var (var=$*)'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

var="$*"
echo 'IFS=":", using $var (var="$*")'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$var" (var="$*")'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$@"'
c=0
for i in "$@"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $@'
c=0
for i in $@
do echo "$((c+=1)): [$i]"
done
echo ---

var=$@
echo 'IFS=":", using $var (var=$@)'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$var" (var=$@)'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

var="$@"
echo 'IFS=":", using "$var" (var="$@")'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $var (var="$@")'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done

echo

# 尝试在 ksh 或是 zsh -y 下执行这个脚本。

exit 0

#  这个样例是由 Stephane Chazelas 所编写，
#+ 由本书作者轻微改动。
```

{% hint style="info" %}

`$@` 和 `$*` 仅在被双引号引用时才会表现出不同。

{% endhint %}

样例 9-8. 当 $IFS 为空时 \$* 和 \$@ 的表现

```bash
#!/bin/bash

#  如果 $IFS 被设置为空，
#+ 那么 "$*" 和 "$@" 将不会像期望的那样输出位置参数。

mecho ()       # 输出位置参数。
{
echo "$1,$2,$3";
}


IFS=""         # 设置为空。
set a b c      # 位置参数。

mecho "$*"     # abc,,
#                   ^^
mecho $*       # a,b,c

mecho $@       # a,b,c
mecho "$@"     # a,b,c

#  当 $IFS 为空时 $* 和 $@ 的行为
#+ 依赖于 Bash 或是 sh 所运行的版本。
#  因此不宜在脚本中使用这个“特性”。


# 感谢 Stephane Chazelas。

exit
```

#### 9.1.3 其他特殊参数

**$-**

使用 [`set`]() 命令设置的脚本标记。参考 [样例 15-16]()。

{% hint style="warning" %}

这个参数最开始是从 ksh 引入到 Bash中的。但很遗憾的是，该参数在 Bash 脚本中并不能可靠地运行。该参数可能的一个用法是用于 [自检脚本是否可交互]()。

{% endhint %}

**$!**

运行在后台的最后一个任务的 [进程ID]()。

```bash
LOG=$0.log

COMMAND1="sleep 100"

echo "Logging PIDs background commands for script: $0" >> "$LOG"
# 这样就可以监控命令，并在必要的时候终止它们。
echo >> "$LOG"

# 记录命令。

echo -n "PID of \"$COMMAND1\":  " >> "$LOG"
${COMMAND1} &
echo $! >> "$LOG"
# "sleep 100" 的 PID 是 1506

# 感谢 Jacques Lederer 提出的该建议。
```

将 `$!` 用于控制任务：

```bash
possibly_hanging_job & { sleep ${TIMEOUT}; eval 'kill -9 $!' &> /dev/null; }
# 强制终止一个出错的程序。
# 非常有用，例如可以用在启动脚本中。

# 感谢 Sylvain Fourmanoit 提出的这个利用变量 "$!" 的创造性用法。
```

也可以这么使用：

```bash
# 该样例由 Matthew Sage 编写。
# 本书经授权后使用。

TIMEOUT=30   # 以秒为单位的超时时间值。
count=0

possibly_hanging_job & {
        while ((count < TIMEOUT )); do
                eval '[ ! -d "/proc/$!" ] && ((count = TIMEOUT))'
                # 当前运行进程的详细信息都可以在 /proc 中找到。
                # "-d" 用于测试进程是否存在（即在 /proc 文件夹下该进程的文件夹是否存在）。
                # 我们在等待出问题的任务出现。
                ((count++))
                sleep 1
        done
        eval '[ -d "/proc/$!" ] && kill -15 $!'
        # 如果被挂起的任务正在运行就终止它。
}

#  -------------------------------------------------------------- #

#  然而，如果另外一个进程在 "hanging_job" 之后开始运行
#+ 该函数可能不能正常运行 ...
#  在那种情况下，一个非我们预期的任务会被终止。
#  Ariel Meragelman 提出了如下的解决方案。

TIMEOUT=30
count=0

possibly_hanging_job & {
    while ((count < TIMEOUT )); do
            eval '[ !-d "/proc/$lastjob" ] && ((count = TIMEOUT))'
            lastjob=$!
            ((count++))
            sleep 1
    done
    eval '[ -d "/proc/$lastjob" ] && kill -15 $lastjob'
}

exit
```

**$_**

该变量被设置为上一个执行的命令的最后一个参数。

样例 9-9. 下划线变量

```bash
#!/bin/bash

echo $_              #  /bin/bash
                     #  仅通过调用 /bin/bash 执行该脚本。
                     #  注意这个结果会根据脚本如何被调用
                     #+ 而有所不同。

du >/dev/null        #  这样命令就不会在命令行上有任何输出。
echo $_              #  du

ls -al >/dev/null    #  这样命令就不会在命令行上有任何输出。
echo $_              #  -al (最后一个参数)

:
echo $_              #  :
```

**$?**

命令、[函数]() 或是脚本自身的 [退出状态]()。参考 [样例 24-7]()。

**$$**

脚本自身的进程 ID[^5]。该变量 `$$` 通常在脚本构建独有的临时文件时被使用（参考 [样例 32-6]()，[样例 16-31]()，以及 [样例 15-27]()）。该方法通常比调用 [`mktemp`]() 命令更简单。

**注记**

{% hint style="info" %}
栈寄存器是一段连续的内存空间，在该空间中，存入（压栈）的值是以倒序的方式取出（出栈）的。最后一个存入的值被最先取出。其通常又被称为后进先出(LIFO)或是下堆栈。
{% endhint %}

{% hint style="info" %}
当前运行脚本的进程 ID 就是 `$$`。
{% endhint %}

{% hint style="info" %}
类似于 [递归]()。在本文中，嵌套是指代一种模式被嵌入在一种更大的模式中。在 1913 年出版的韦伯斯特大辞典中用一种更加优雅的方式解释了什么是嵌套：“一组按体积大小排列的盒子、箱子或是类似的东西，它们中的每一个都被放入到另一个更大的箱子中。(A collection of boxes, cases, or the like, of graduated size, each put within the one next larger.)”。
{% endhint %}

{% hint style="info" %}
术语“变量(argument)”和“参数(parameter)”通常情况下是可以互相交换使用的。在本书中，它们具有相同的含义：传入脚本或函数的变量。
{% endhint %}

{% hint style="info" %}
在 subshell 中运行的脚本，`$$` [返回脚本的进程 ID]() 而非 subshell 的。
{% endhint %}

### 9.2 变量类型标注：`declare` 与 `typeset`

[内建命令]() `declare` 和 `typeset` 是完全相同的命令，其被用于修改变量的属性。相比起一部分编程语言来说，这种修改属于非常弱的类型标注方式。`declare` 命令只有在 Bash version 2 及更高版本才能使用，而 `typeset` 命令可以在 ksh 脚本中运行。

#### 9.2.1 `declare`/`typeset` 命令选项

**-r 只读（readonly）**

（`declare -r var1` 与 `readonly var1` 的作用相同）

该选项约等于 C 语言中的类型限定符 `const`。任何尝试修改只读变量的行为都会导致脚本出错。

```bash
declare -r var1=1
echo "var1 = $var1"   # var1 = 1

(( var1++ ))          # x.sh: line 4: var1: readonly variable
```

**-i 整型（integer）**

```bash
declare -i number
# 脚本会将之后所有出现的 "number" 变量的类型都视作整型。

number=3
echo "Number = $number"     # Number = 3

number=three
echo "Number = $number"     # Number = 0
# 脚本试图将字符串 "three" 视为整型。
```

被视为整型的变量无需命令 [`expr`]() 或是 [`let`]() 即可进行数学运算。

```bash
n=6/3
echo "n = $n"       # n = 6/3

declare -i n
n=6/3
echo "n = $n"       # n = 2
```

**-a 数组（array）**

```bash
declare -a indices
```

变量 `indices` 会被视作 [数组]()。

**-f 函数（function）**

```bash
declare -f
```

如果没有在 `declare -f` 后带上任何参数，该语句将会列出在脚本中已经定义的所有函数。

```bash
declare -f function_name
```

而 `declare -f function_name` 则仅仅列出名为 `function_name` 的函数。

**-x 导出（export）**

```bash
declare -x var3
```

该语句声明了变量 `var3` 可以导出到该变量所属脚本之外的 shell 环境中。

**-x var=$value**

```bash
declare -x var3=373
```

`declare` 命令允许在设置变量属性的同时给变量赋值。

样例9-10. 使用 `declare` 命令标注变量类型

```bash
#!/bin/bash

func1 ()
{
  echo This is a function.
}

declare -f        # 显示上面的所有函数。

echo

declare -i var1   # var1 是一个整型变量。
var1=2367
echo "var1 declared as $var1"
var1=var1+1       # 整型变量的运算可以省略 let 命令。
echo "var1 incremented by 1 is $var1."
# 尝试修改整型变量。
echo "Attempting to change var1 to floating point value, 2367.1."
var1=2367.1       # 报错，并且 var1 的值并没有被修改。
echo "var1 is still $var1"

echo

declare -r var2=13.36         # 'declare' 允许在设置变量属性时，
                              #+ 同时给变量赋值。
echo "var2 declared as $var2" # 尝试修改只读变量。
var2=13.37                    # 报错，然后脚本异常结束。

echo "var2 is still $var2"    # 这行语句将不会被执行。

exit 0                        # 脚本也不会从这里结束。
```

{% hint style="warning" %}

使用内建命令 `declare` 还可以限制变量的 [作用域]()。

```bash
foo ()
{
FOO="bar"
}

bar ()
{
foo
echo $FOO
}

bar   # 输出 bar。
```

但是...

```bash
foo(){
declare FOO="bar"
}

bar ()
{
foo
echo $FOO
}

bar  # 什么都不会输出。


# 感谢 Michael Iatrou 指出这点。
```

{% endhint %}

**注记**

{% hint style="info" %}
在本书中，变量类型标注（typing）是指指定变量类型并限制其属性。例如一个变量被 `declared` 或是 `typed` 命令声明为整型，则该变量不再适用于各种 [字符串操作]()。

```bash
declare -i intvar

intvar=23
echo "$intvar"   # 23
intvar=stringval
echo "$intvar"   # 0
```

{% endhint %}

#### 9.2.2 `declare` 的另类用法

`declare` 命令可以帮助用户识别变量、[环境变量]() 或是其他信息，与 [数组]() 搭配效果更佳。

```bash
bash$ declare | grep HOME
HOME=/home/bozo


bash$ zzy=68
bash$ declare | grep zzy
zzy=68


bash$ Colors=([0]="purple" [1]="reddish-orange" [2]="light green")
bash$ echo ${Colors[@]}
purple reddish-orange light green
bash$ declare | grep Colors
Colors=([0]="purple" [1]="reddish-orange" [2]="light green")
```

### 9.3 `$RANDOM`：生成随机数

> 任何试图通过确定性方法生成随机数的行为都是在犯罪。
>
> —— 约翰·冯·诺伊曼

`$RANDOM` 是 Bash 中用来生成 0 至 32767 之间随机整数的一个内置 [函数]()（而非常量）。其**不应**被用于生成密钥。

样例 9-11. 生成随机数

```bash
#!/bin/bash

# $RANDOM 每一次调用都会返回一个随机的不同的整数。
# 随机数的标称范围为 0 - 32767（16位有符号整型）。

MAXCOUNT=10
count=1

echo
echo "$MAXCOUNT random numbers:"
echo "-----------------"
while [ "$count" -le $MAXCOUNT ]      # 生成 10 ($MAXCOUNT) 个随机整数。
do
  number=$RANDOM
  echo $number
  let "count += 1"  # 增加计数。
done
echo "-----------------"

# 如果你需要一个小于指定上界的随机数，可以使用 'modulo' 操作符。
# 该操作符可以返回除法后的余数。

RANGE=500

echo

number=$RANDOM
let "number %= $RANGE"
#           ^^
echo "Random number less than $RANGE --- $number"

echo



#  如果你需要生成的随机数大于一个指定的下界，
#+ 可以增加一步判断，判别并丢弃所有小于下界的数。

FLOOR=200

number=0   # 初始化
while [ "$number" -le $FLOOR ]
do
  number=$RANDOM
done
echo "Random number greater than $FLOOR --- $number"
echo

   # 现在来看一种可以代替上面循环的更简单的方式，也就是
   #       let "number = $RANDOM + $FLOOR"
   # 该方式可以不使用 while 循环，效率更高。
   # 但是，该方法可能会产生一些问题，是什么呢？



# 通过结合上面的两种方法，可以获得一个特定范围内的随机数。
number=0   # 初始化
while [ "$number" -le $FLOOR ]
do
  number=$RANDOM
  let "number %= $RANGE"  # 将 $number 缩小至 $RANGE 的范围内。
done
echo "Random number between $FLOOR and $RANGE --- $number"
echo



# 生成二元选择值，即真(true)或假(false)。
BINARY=2
T=1
number=$RANDOM

let "number %= $BINARY"
#  如果使用    let "number >>= 14"    可以获得更优的随机分布
#+ （除了最低位，其余二进制位都右移）。
if [ "$number" -eq $T ]
then
  echo "TRUE"
else
  echo "FALSE"
fi

echo


# 扔一个骰子。
SPOTS=6   # 模 6 的余数范围为 0 - 5。
          # 然后加 1 就可以得到期望的范围 1 - 6。
          # 感谢 Paulo Marcel Coelho Aragao 简化了代码。
die1=0
die2=0
# 如果设置 SPOTS=7 就可以不用加 1 得到值。这是不是一种更好的方法，为什么？

# 为了保证公平，独立的投每一个骰子。

    let "die1 = $RANDOM % $SPOTS + 1" # 投第一个骰子。
    let "die2 = $RANDOM % $SPOTS + 1" # 投第二个骰子。
    #  哪一种运算符有更高的优先级，
    #+ 取余(%)还是加法(+)？


let "throw = $die1 + $die2"
echo "Throw of the dice = $throw"
echo


exit 0
```

样例 9-12. 从牌组中随机选牌

```bash
#!/bin/bash
# pick-card.sh

# 该样例演示了如何从数组中随机选择元素。


# 随机选择任意一张牌。

Suites="Clubs
Diamonds
Hearts
Spades"

Denominations="2
3
4
5
6
7
8
9
10
Jack
Queen
King
Ace"

# 注意一个变量占了多行。


suite=($Suites)                # 读入数组变量。
denomination=($Denominations)

num_suites=${#suite[*]}        # 数组中的元素数量。
num_denominations=${#denomination[*]}

echo -n "${denomination[$((RANDOM%num_denominations))]} of "
echo ${suite[$((RANDOM%num_suites))]}


# $bozo sh pick-cards.sh
# Jack of Clubs


# 感谢 jipe 指出可以用 $RANDOM 随机选牌。
exit 0
```

Example 9-13. 模拟布朗运动

```bash
#!/bin/bash
# brownian.sh
# 作者：Mendel Cooper
# 发布日期：10/26/07
# 开源协议：GPL3

#  ----------------------------------------------------------------
#  该脚本模拟了布朗运动。
#+ 布朗运动是指微小粒子受到流体粒子随机碰撞，
#+ 而在流体中做的无规则随机运动。
#+ 也就是俗称的“醉汉走路”。

#  布朗运动也可以被视作是一个简化的高尔顿板。
#+ 高尔顿板是一个有着交错排列的钉子的倾斜板子，
#+ 每次可以从中向下滚动一堆石子。
#+ 在板子底端是一排槽位，
#+ 石子最后会落在槽位中。
#  把它想象成一个简单的弹珠游戏就可以了。
#  当运行这个脚本之后，
#+ 你就会发现大部分的石子都聚集在中间的槽位里。
#+ 这与预期的二项分布相符。
#  作为模拟高尔顿板的程序，
#+ 脚本忽略了许多参数，
#+ 例如板子的倾斜角度、石子滚动的摩擦系数、
#+ 冲击角度以及钉子的弹性系数等等。
#  忽略的这些参数能够在多大程度上影响模拟的精度？
#  -------------------------------------------------------------

PASSES=500            #  粒子作用数 / 石子数。
ROWS=10               #  碰撞数 / 每一排钉子的数量。
RANGE=3               #  $RANDOM 的输出范围为 0 - 2。
POS=0                 #  滚落左侧或是右侧。
RANDOM=$$             #  将脚本的进程 ID 作为
                      #+ 生成随机数的种子。

declare -a Slots      # 用于储存落入每一个槽位的石子数量。
NUMSLOTS=21           # 底部槽位的数量。


Initialize_Slots () { # 初始化数组。
for i in $( seq $NUMSLOTS )
do
  Slots[$i]=0
done

echo                  # 在正式模拟开始之前先输出空行。
  }


Show_Slots () {
echo; echo
echo -n " "
for i in $( seq $NUMSLOTS )   # 更精致地输出数组中的所有元素。
do
  printf "%3d" ${Slots[$i]}   # 每个结果都占三个字符的宽度。
done

echo # 槽位：
echo " |__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|"
echo "                                ||"
echo #  需要注意的是，如果任意一个槽位中石子的数量超过 99，
     #+ 将会打乱整个程序的显示效果。
     #  如果只运行 500 次通常可以避免这个问题。
  }


Move () {              # 将一个单位左移、右移或保持原地不动。
  Move=$RANDOM         # $RANDOM 到底有多随机？让我们看看...
  let "Move %= RANGE"  # 标准化至范围 0 - 2。
  case "$Move" in
    0 ) ;;                   # 什么也不做，也就是原地不动。
    1 ) ((POS--));;          # 左移。
    2 ) ((POS++));;          # 右移。
    * ) echo -n "Error ";;   # 出现异常！（应该永远不会发生）
  esac
  }


Play () {                    # 模拟单次运行（内部循环）。
i=0
while [ "$i" -lt "$ROWS" ]   # 每一排钉子经过且仅经过一次石子。
do
  Move
  ((i++));
done

SHIFT=11                     # 为什么是 11 而不是 10？
let "POS += $SHIFT"          # 将原点移到中间。
(( Slots[$POS]++ ))          # 调试：echo $POS

# echo -n "$POS "

  }


Run () {                     # 外部循环。
p=0
while [ "$p" -lt "$PASSES ]
do
  Play
  (( p++ ))
  POS=0                      # 重置为 0。为什么要这么做？
done
  }


# --------------
# main ()
Initialize_Slots
Run
Show_Slots
# --------------

exit $?

#  练习：
#  ---------
#  1) 将结果显示为一张直方图，
#+    或者是一张散点图。
#  2) 修改脚本，使用 /dev/urandom 提到 $RANDOM。
#     这会使脚本更加的随机化么？
#  3) 当每一个石子落下的时候，
#+    尝试添加一些动画效果。
```

Jipe 提供了一些生成指定范围内随机数的方法。

```bash
#  生成范围为 6 到 30 的随机数。
   rnumber=$((RANDOM%25+6))

#  生成范围为 6 到 30 的随机数，
#+ 并且该随机数能被 3 整除。
   rnumber=$(((RANDOM%30/3+1)*3))

#  需要注意这种方法并不是在所有情况下都能起效。
#  会在 $RANDOM%30 为 0 时失效。

#  Frank Wang 建议可以换用下面的方法：
   rnumber=$(( RANDOM%27/3*3+6 ))
```

Bill Gradwohl 提出了一种改良后的仅适用于正数的公式。

```bash
rnumber=$(((RANDOM%(max-min+divisibleBy))/divisibleBy*divisibleBy+min))
```

Bill 在这还给出了一个生成指定范围内随机数的通用函数。

样例 9-14. 指定范围随机数

```bash
#!/bin/bash
# random-between.sh
# 生成指定范围内的随机数。
# 本书作者在 Bill Gradwhol 所提供的脚本的基础上作了些细微修改。
# Anthony Le Clezio 修正了 187 行和 189 行。
# 本书被授权使用该脚本。


randomBetween() {
   #  生成一个范围在 $min 和 $max 之间，
   #+ 并且能被 $divisibleBy 整除的
   #+ 随机正数或负数。
   #  返回的随机数遵循合理的随机分布。
   
   #  Bill Gradwohl - Oct 1, 2003
   
   syntax() {
   # 嵌套函数。
      echo
      echo    "Syntax: randomBetween [min] [max] [multiple]"
      echo
      echo -n "Expects up to 3 passed parameters, "
      echo    "but all are completely optional."
      echo    "min is the minimum value"
      echo    "max is the maximum value"
      echo -n "multiple specifies that the answer must be "
      echo     "a multiple of this value."
      echo    "    i.e. answer must be evenly divisible by this number."
      echo
      echo    "If any value is missing, defaults area supplied as: 0 32767 1"
      echo -n "Successful completion returns 0, "
      echo      "unsuccessful completion returns"
      echo    "function syntax and 1."
      echo -n "The answer is returned in the global variable "
      echo    "randomBetweenAnswer"
      echo -n "Negative values for any passed parameter are "
      echo    "handled correctly."
   }
   
   local min=${1:-0}
   local max=${2:-32767}
   local divisibleBy=${3:-1}
   # 考虑到没有给函数传参的情况，给变量设置默认值。
   
   local x
   local spread
   
   # 确保 divisibleBy 的值为正数。
   [ ${divisibleBy} -lt 0 ] && divisibleBy=$((0-divisibleBy))
   
   # 合规校验。
   if [ $# -gt 3 -o ${divisibleBy} -eq 0 -o  ${min} -eq ${max} ]; then
      syntax
      return 1
   fi
   
   # 检查 min 和 max 的值是否颠倒。
   if [ ${min} -gt ${max} ]; then
      # 交换它们。
      x=${min}
      min=${max}
      max=${x}
   fi
   
   #  如果 min 值本身不能被 $divisibleBy 整除，
   #+ 则将其修正到范围内。
   if [ $((min/divisibleBy*divisibleBy)) -ne ${min} ]; then
      if [ ${min} -lt 0 ]; then
         min=$((min/divisibleBy*divisibleBy))
      else
         min=$((((min/divisibleBy)+1)*divisibleBy))
      fi
   fi
   
   #  如果 max 值本身不能被 $divisibleBy 整除，
   #+ 则将其修正到范围内。
   if [ $((max/divisibleBy*divisibleBy)) -ne ${max} ]; then
      if [ ${max} -lt 0 ]; then
         max=$((((max/divisibleBy)-1)*divisibleBy))
      else
         max=$((max/divisibleBy*divisibleBy))
      fi
   fi

   #  ---------------------------------------------------------------------
   #  接下来开始真正的内容。
   
   #  需要注意的是，为了得到端点间合理的随机分布，
   #+ 随机数的取值范围应是 0 至 abs(max-min)+divisibleBy，
   #+ 而不是简单的 abs(max-min)+1。
   
   #  少量的增长将会带来端点间
   #+ 合理的随机分布。
   
   #  将公式修改为使用 abs(max-min)+1 仍然可以得到正确的答案，
   #+ 但是获得的这些随机数的随机性是有缺陷的，
   #+ 因为这种情况下返回的端点值 ($min 和 $max) 的次数远少于
   #+ 使用正确公式时所返回的次数。
   #  ---------------------------------------------------------------------

   spread=$((max-min))
   #  Omair Eshkenazi 指出在这里没有必要进行校验，
   #+ 因为 max 和 min 的值已经被交换了。
   [ ${spread} -lt 0 ] && spread=$((0-spread))
   let spread+=divisibleBy
   randomBetweenAnswer=$(((RANDOM%spread)/divisibleBy*divisibleBy+min))
   
   return 0
   
   #  但是 Paulo Marcel Coelho Aragao 指出
   #+ 当 $max 和 $min 不能被 $divisibleBy 整除时，
   #+ 该公式就会失效。
   #
   #  他建议替换为下面的公式：
   #    rnumber = $(((RANDOM%(max-min+1)+min)/divisibleBy*divisibleBy))
   
}

# 接下来测试函数。
min=-14
max=20
divisibleBy=3


#  循环执行足够多次数的函数，生成包含这些随机数的数组，
#+ 然后校验数组中是否包含了端点范围内的每一个数字。

declare -a answer
minimum=${min}
maximum=${max}
   if [ $((minimum/divisibleBy*divisibleBy)) -ne ${minimum} ]; then
      if [ ${minimum} -lt 0 ]; then
         minimum=$((minimum/divisibleBy*divisibleBy))
      else
         minimum=$((((minimum/divisibleBy)+1)*divisibleBy))
      fi
   fi
   
   
   #  如果 max 值本身不能被 $divisibleBy 整除，
   #+ 则将其修正到范围内。
   
   if [ $((maximum/divisibleBy*divisibleBy)) -ne ${maximum} ]; then
      if [ ${maximum} -lt 0 ]; then
         maximum=$((((maximum/divisibleBy)-1)*divisibleBy))
      else
         maximum=$((maximum/divisibleBy*divisibleBy))
      fi
   fi


#  需要保证数组的下标只能为正数，
#+ 因此这里需要通过位移来保证
#+ 结果为正。

disp=$((0-minimum))
for ((i=${minimum}; i<=${maximum}; i+=divisibleBy)); do
   answer[i+disp]=0
done


# 现在开始循环执行函数以获得大量的随机数。
loopIt=1000   #  脚本的作者建议使用 100000，
              #+ 但是这会花费大量的时间。
              
for ((i=0; i<${loopIt}; i++)); do

   #  注意，我们在这里颠倒了 min 和 max 的值，
   #+ 为的是校验函数在这种情况下是否能正常执行。
   
   randomBetween ${max} ${min} ${divisibleBy}
   
   # 如果获得了非预期的答案，则报错。
   [ ${randomBetweenAnswer} -lt ${min} -o ${randomBetweenAnswer} -gt ${max} ] \
   && echo MIN or MAX error - ${randomBetweenAnswer}!
   [ $((randomBetweenAnswer%${divisibleBy})) -ne 0 ] \
   && echo DIVISIBLE BY error - ${randomBetweenAnswer}!
   
   # 保存统计结果。
   answer[randomBetweenAnswer+disp]=$((answer[randomBetweenAnswer+disp]+1))
done



# 校验最终结果。

for ((i=${minimum}; i<=${maximum}; i+=divisibleBy)); do
   [ ${answer[i+disp]} -eq 0 ] \
   && echo "We never got an answer of $i." \
   || echo "${i} occurred ${answer[i+disp]} times."
done

exit 0
```

那么 `$RANDOM` 到底有多随机？最好的测试方法就是写一个脚本跟踪由 `$RANDOM` 生成的随机数的分布。接下来让我们多投几次由 `$RANDOM` 做的骰子...

样例 9-15. 用 `RANDOM` 投骰子

```bash
#!/bin/bash
# RANDOM 有多随机？

RANDOM=$$       # 用脚本的进程 ID 重置随机数生成器种子。

PIPS=6          # 骰子有 6 个点。
MAXTHORWS=600   # 如果你没有更好消磨时间的办法，就增加这个值。
                # 投骰子的次数。

ones=0          #  必须初始化计数器的值为 0，
twos=0          #+ 因为未初始化的变量的值为 null 而非 0。
threes=0
fours=0
fives=0
sixes=0

print_result ()
{
echo
echo "ones =   $ones"
echo "twos =   $twos"
echo "threes = $threes"
echo "fours =  $fours"
echo "fives =  $fives"
echo "sixes =  $sixes"
echo
}

update_count()
{
case "$1" in
  0) ((ones++));;   # 因为骰子没有 0 点，所以这个其实对应的是 1 点。
  1) ((twos++));;   # 这个对应 2 点。
  2) ((threes++));; # 以此类推。
  3) ((fours++));;
  4) ((fives++));;
  5) ((sixes++));;
esac
}

echo


while [ "$throw" -lt "$MAXTHROWS" ]
do
  let "die1 = RANDOM % $PIPS"
  update_count $die1
  let "throw += 1"
done

print_result

exit $?

#  假设 RANDOM 是真随机，那么计数结果应该均匀分布。
#  当 $MAXTHROWS 的值为 600 时，每一个计数器的值都应该在 100 左右，
#+ 上下浮动大约 20。
#
#  记住 RANDOM 是一个 ***伪随机*** 生成器，
#+ 并且也不是其中最优秀的那一个。

#  随机化是一个很深奥且复杂的话题。
#  足够长的“随机”序列可能会出现一些
#+ 混乱或其他非随机化的表现。

# 练习（简单）：
# ---------------
# 重写脚本，修改为投掷硬币 1000 次。
# 显示为正面 "HEADS" 和背面 "TAILS"。
```

从上一个样例中我们可以发现，在每次调用 `RANDOM` 生成器时，最好利用重置生成器种子。在 `RANDOM` 生成器中使用相同的种子会生成相同序列的随机数。[^2]（与 C 语言中的 `random()` 函数的行为一致）

样例 9-16. 重置 `RANDOM` 种子

```bash
#!/bin/bash
# seeding-random.sh: 设置 RANDOM 变量的种子。
# 版本号 1.1, 发布日期 09 Feb 2013

MAXCOUNT=25       # 生成随机数的个数。
SEED=

random_numbers ()
{
local count=0
local number

while [ "$count" -lt "$MAXCOUNT" ]
do
  number=$RANDOM
  echo -n "$number "
  let "count++"
done
}

echo; echo

SEED=1
RANDOM=$SEED      # 设置变量 RANDOM 会为随机数生成器设置种子。
echo "Random seed = $SEED"
random_numbers

RANDOM=$SEED      # 同样的种子 ...
echo; echo "Again, with same random seed ..."
echo "Random seed = $SEED"
random_numbers    # ... 生成了同样的数字序列。
                  #
                  # 在什么情况下重复一个随机化序列会有用？
                  
echo; echo

SEED=2
RANDOM=$SEED      # 用不同的种子再试一次 ...
echo "Random seed = $SEED"
random_numbers    # ... 生成了不同的数字序列。

echo; echo

# RANDOM=$$  利用脚本的进程 ID 设置 RANDOM 的种子。
# 同样也可以利用 'time' 或是 'date' 命令设置 RANDOM 的种子。

# 更花哨一点的 ...
SEED=$(head -1 /dev/urandom | od -N 1 | awk '{ print $2 }'| sed s/^0*//)
#  从 /dev/urandom （系统的伪随机设备文件）中
#+ 获取伪随机输出，
#+ 然后通过 "od" 转换为可打印八进制字符行，
#+ 然后 "awk" 命令会检索出一个数字作为种子，
#+ 最后用 "sed" 命令删除数字前面所有的前置 0。
RANDOM=$SEED
echo "Random seed = $SEED"
random_numbers

echo; echo

exit 0
```

{% hint style="info" %}

伪设备文件 `/dev/urandom` 提供了比 `$RANDOM` 变量更随机化的伪随机数。命令 `dd if=/dev/urandom of=targetfile bs=1 count=XXX` 将会创建一个包含均匀分布的伪随机数的文件。但是想要在脚本中将这些随机数赋值给变量需要做一些变通，比如使用命令 [`od`]() 进行过滤（参照上面的样例以及 [样例 16-14]() 和 [样例 A-36]()）或者使用管道导入命令 [md5sum]() 中（参照 [样例 36-16]()）。

当然也有其他在脚本中生成伪随机数的方法。比如 `Awk` 命令就提供了这样一种非常简易的方法。

样例 9-17. 使用 [`awk`]() 命令生成伪随机数

```bash
#!/bin/bash
#  random2.sh: 返回大小在 0 - 1 内，
#+ 精度为小数点后 6 位的伪随机数。例如：0.822725
#  使用 awk rand() 函数。

AWKSCRIPT=' { srand(); print rand() } '
#           传递给 awk 的命令或参数
# 注意 srand() 重置了 awk 的随机数生成种子。


echo -n "Random number between 0 and 1 = "

echo | awk "$AWKSCRIPT"
# 如果省略 'echo' 将会发生什么？

exit 0


# 练习：
# ---------

# 1) 使用循环结构，输出 10 个不同的随机数。
#      （提示：你必须在每次循环中使用 srand() 函数重置种子以获得不同的随机数种子。
#+       如果你省略了这一步会发生什么？）

# 2) 利用整型乘数作为随机数的缩放因子，
#+   生成大小在 10 到 100 之间的随机数。

# 3) 内容与练习 #2 相同，只是这次生成随机整数。
```

同样，命令 [`date`]() 可以用于 [生成整型随机数序列]()。

{% endhint %}

**注记**

{% hint style="info" %}
真正的“随机性”，就其存在而言，只存在于一些类似放射性衰变这样还未被完全理解的自然现象中。计算机只能模拟这样的随机性，因此计算机生成的“随机数”序列被称作伪随机数。
{% endhint %}

{% hint style="info" %}
计算机用于生成伪随机数的种子可以被视作一个标识标签。例如，你可以将用种子 23 生成的随机数序列视作第23号序列。

伪随机数序列的一个属性是该序列在开始重复之前的周期长度。一个好的伪随机数生成器能够生成周期非常长的序列。
{% endhint %}

## 10 变量处理

### 10.1 字符串处理

Bash 支持的字符串操作数量达到了一个惊人的数目。但可惜的是，这些操作工具缺乏一个统一的核心。他们中的一些是[参数代换](http://tldp.org/LDP/abs/html/parameter-substitution.html#PARAMSUBREF)的子集，另外一些则是 UNIX 下 [`expr`](http://tldp.org/LDP/abs/html/moreadv.html#EXPRREF) 函数的子集。这将会导致语法前后不一致或者功能上出现重叠，更不用说那些可能导致的混乱了。

#### 10.1.1 字符串长度

`${#string}`

`expr length $string`

上面两个表达式等价于C语言中的 `strlen()` 函数。

`expr "$string" : '.*'`

```bash
stringZ=abcABC123ABCabc

echo ${#stringZ}                 # 15
echo `expr length $stringz`      # 15
echo `expr "$stringZ" : '.*'`    # 15
```

样例 10-1. 在文本的段落之间插入空行

```bash
#!/bin/bash
# paragraph-space.sh
# 版本 2.1，发布日期 2012年7月29日

# 在无空行的文本文件的段落之间插入空行。
# 像这样使用: $0 <FILENAME

MINLEN=60        # 可以试试修改这个值。它用来做判断。
#  假设一行的字符数小于 $MINLEN，并且以句点结束段落。
#+ 结尾部分有练习！

while read line  # 当文件有许多行的时候
do
  echo "$line"   # 输出行本身。
  
  len=${#line}
  if [[ "$len" -lt "$MINLEN" && "$line" =~ [*{\.}]$ ]]
# if [[ "$len" -lt "$MINLEN" && "$line" =~ \[*\.\] ]]
# 新版Bash将不能正常运行前一个版本的脚本。Ouch！
# 感谢 Halim Srama 指出这点，并且给出了修正版本。
    then echo    #  在该行以句点结束时，
  fi             #+ 增加一行空行。
done

exit

# 练习：
# -----
#  1) 该脚本通常会在文件的最后插入一个空行。
#+    尝试解决这个问题。
#  2) 在第17行仅仅考虑到了以句点作为句子终止的情况。
#+    修改以满足其他的终止符，例如 ?, ! 和 "。
```

#### 10.1.2 起始部分字符串匹配长度

`expr match "$string" '$substring'`

其中，`$substring` 是一个[正则表达式](http://tldp.org/LDP/abs/html/regexp.html#REGEXREF)。

`expr "$string" : '$substring'`

其中，`$substring` 是一个正则表达式。

```bash
stringZ=abcABC123ABCabc
#       |------|
#       12345678

echo `expr match "$stringZ" 'abc[A-Z]*.2'`   # 8
echo `expr "$stringZ" : 'abc[A-Z]*.2'`       # 8
```

#### 10.1.3 索引

`expr index $string $substring`

返回在 `$string` 中第一个出现的 `$substring` 字符所在的位置。

```bash
stringZ=abcABC123ABCabc
#       123456 ...
echo `expr index "$stringZ" C12`             # 6
                                             # C 的位置。
echo `expr index "$stringZ" 1c`              # 3
# 'c' (第三号位) 较 '1' 出现的更早。
```

几乎等价于C语言中的 `strchr()`。

#### 10.1.4 截取字符串（字符串分片）

`${string:position}`

在 `$string` 中截取自 `$position` 起的字符串。

如果参数 `$string` 是 "*" 或者 "@"，那么将会截取自 `$position` 起的[位置参数](http://tldp.org/LDP/abs/html/internalvariables.html#POSPARAMREF)。

`${string:position:length}`

在 `$string` 中截取自 `$position` 起，长度为 `$length` 的字符串。

```bash
stringZ=abcABC123ABCabc
#       0123456789.....
#       索引位置从0开始。

echo ${stringZ:0}                            # abcABC123ABCabc
echo ${stringZ:1}                            # bcABC123ABCabc
echo ${stringZ:7}                            # 23ABCabc

echo ${stringz:7:3}                          # 23A
                                             # 三个字符的子字符串。
                                             
                                             

# 从右至左进行截取可行么？

echo ${stringZ:-4}                           # abcABC123ABCabc
# ${parameter:-default} 将会得到整个字符串。
# 但是……

echo ${stringZ:(-4)}                         # Cabc
echo ${stringZ: -4}                          # Cabc
# 现在可以了。
# 括号或者增加空格都可以"转义"位置参数。

# 感谢 Dan Jacobson 指出这些。
```

其中，参数 `position` 与 `length` 可以传入一个变量而不一定需要传入常量。

样例 10-2. 产生一个8个字符的随机字符串

```bash
#!/bin/bash
# rand-string.sh
# 产生一个8个字符的随机字符串。

if [ -n "$1" ]  #  如果在命令行中已经传入了参数，
then            #+ 那么就以它作为起始字符串。
  str0="$1"
else            #  否则，就将脚本的进程标识符PID作为起始字符串。
  str0="$$"
fi

POS=2  # 从字符串的第二位开始。
LEN=8  # 截取八个字符。

str1=$( echo "$str0" | md5sum | md5sum )
#                      ^^^^^^   ^^^^^^
# 将字符串通过管道计算两次 md5 来进行两次混淆。

randstring="${str1:$POS:$LEN}"
#                  ^^^^ ^^^^
# 允许传入参数

echo "$randstring"

exit $?

# bozo$ ./rand-string.sh my-password
# 1bdd88c4

# 不过不建议将其作为一种能够抵抗黑客的生成密码的方法。
```

如果参数 `$string` 是 "*" 或者 "@"，那么将会截取自 `$position` 起，最大个数为 `$length` 的位置参数。

```bash
echo ${*:2}          # 输出第二个及之后的所有位置参数。
echo ${@:2}          # 同上。

echo ${*:2:3}        # 从第二个位置参数起，输出三个位置参数。 
```

`expr substr $string $position $length`

在 `$string` 中截取自 `$position` 起，长度为 `$length` 的字符串。

```bash
stringZ=abcABC123ABCabc
#       123456789......
#       索引位置从1开始。

echo `expr substr $stringZ 1 2`              # ab
echo `expr substr $stringZ 4 3`              # ABC
```

`expr match "$string" '\($substring\)'`

在 `$string` 中截取自 `$position` 起的字符串，其中 `$substring` 是[正则表达式](http://tldp.org/LDP/abs/html/regexp.html#REGEXREF)。

`expr "$string" : '\($substring\)'`

在 `$string` 中截取自 `$position` 起的字符串，其中 `$substring` 是正则表达式。

```bash
stringZ=abcABC123ABCabc
#       =======

echo `expr match "$stringZ" '\(.[b-c]*[A-Z]..[0-9]\)'`   # abcABC1
echo `expr "$stringZ" : '\(.[b-c]*[A-Z]..[0-9]\)'`       # abcABC1
echo `expr "$stringZ" : '\(.......\)'`                   # abcABC1
# 上面所有的形式都给出了相同的结果。
```

`expr match "$string" '.*\($substring\)'`

从 `$string` 结尾部分截取 `$substring` 字符串，其中 `$substring` 是正则表达式。

`expr "$string" : '.*\($substring\)'`

从 `$string` 结尾部分截取 `$substring` 字符串，其中 `$substring` 是正则表达式。

```bash
stringZ=abcABC123ABCabc
#                ======

echo `expr match "$stringZ" '.*\([A-C][A-C][A-C][a-c]*\)'`    # ABCabc
echo `expr "$stringZ" : '.*\(......\)'`                       # ABCabc
```

#### 10.1.5 删除子串

`${string#substring}`

删除从 `$string` 起始部分起，匹配到的最短的 `$substring`。

`${string##substring}`

删除从 `$string` 起始部分起，匹配到的最长的 `$substring`。

```bash
stringZ=abcABC123ABCabc
#       |----|          最长
#       |----------|    最短

echo ${stringZ#a*C}      # 123ABCabc
# 删除 'a' 与 'c' 之间最短的匹配。

echo ${stringZ##a*C}     # abc
# 删除 'a' 与 'c' 之间最长的匹配。



# 你可以使用变量代替 substring。

X='a*C'

echo ${stringZ#$X}      # 123ABCabc
echo ${stringZ##$X}     # abc
                        # 同上。
```

`${string%substring}`

删除从 `$string` 结尾部分起，匹配到的最短的 `$substring`。

例如：

```bash
# 将当前目录下所有后缀名为 "TXT" 的文件改为 "txt" 后缀。
# 例如 "file1.TXT" 改为 "file1.txt"。

SUFF=TXT
suff=txt

for i in $(ls *.$SUFF)
do
  mv -f $i $(i%.$SUFF).$suff
  #  除了从变量 $i 右侧匹配到的最短的字符串之外，
  #+ 其他一切都保持不变。
done ### 如果需要，循环可以压缩成一行的形式。

# 感谢 Rory Winston。
```

`${string%%substring}`

删除从 `$string` 结尾部分起，匹配到的最长的 `$substring`。

```bash
stringZ=abcABC123ABCabc
#                    ||     最短
#        |------------|     最长

echo ${stringZ%b*c}      # abcABC123ABCa
# 从结尾处删除 'b' 与 'c' 之间最短的匹配。

echo ${stringZ%%b*c}     # a
# 从结尾处删除 'b' 与 'c' 之间最长的匹配。
```

这个操作对生成文件名非常有帮助。

样例 10-3. 改变图像文件的格式及文件名

```bash
#!/bin/bash
#  cvt.sh:
#  将目录下所有的 MacPaint 文件转换为 "pbm" 格式。

#  使用由 Brian Henderson (bryanh@giraffe-data.com) 维护的
#+ "netpbm" 包下的 "macptobpm" 二进制工具。
#  Netpbm 是大多数 Linux 发行版的标准组成部分。

OPERATION=macptopbm
SUFFIX=pbm          # 新的文件名后缀。

if [ -n "$1" ]
then
  directory=$1      # 如果已经通过脚本参数传入了目录名的情况……
else
  directory=$PWD    # 否则就使用当前工作目录。
fi

#  假设目标目录下的所有 MacPaint 图像文件都拥有
#+ ".mac" 的文件后缀名。

for file in $directory/*    # 文件名匹配。
do
  filename=${file%.*c}      #  从文件名中删除 ".mac" 后缀
                            #+ ('.*c' 匹配 '.' 与 'c' 之间的
                            #  所有字符，包括其本身)。
  $OPERATION $file > "$filename.$SUFFIX"
                            # 将转换结果重定向到新的文件。
  rm -f $file               # 在转换后删除原文件。
  echo "$filename.$SUFFIX"  # 将记录输出到 stdout 中。
done

exit 0

# 练习：
# -----
# 这个脚本会将当前工作目录下的所有文件进行转换。
# 修改脚本，使得它仅转换 ".mac" 后缀的文件。



# *** 还可以使用另外一种方法。 *** #

#!/bin/bash
# 将图像批处理转换成不同的格式。
# 假设已经安装了 imagemagick。（在大部分 Linux 发行版中都有）

INFMT=png   # 可以是 tif, jpg, gif 等等。
OUTFMT=pdf  # 可以是 tif, jpg, gif, pdf 等等。

for pic in *"$INFMT"
do
  p2=$(ls "$pic" | sed -e s/\.$INFMT//)
  # echo $p2
  convert "$pic" $p2.$OUTFMT
done

exit $?
```

样例 10-4. 将流音频格式转换成 ogg 格式

```bash
#!/bin/bash
# ra2ogg.sh: 将流音频文件 (*.ra) 转换成 ogg 格式。

# 使用 "mplayer" 媒体播放器程序：
#      http://www.mplayerhq.hu/homepage
# 使用 "ogg" 库与 "oggenc"：
#      http://www.xiph.org/
#
# 脚本同时需要安装一些解码器，例如 sipr.so 等等一些。
# 这些解码器可以在 compat-libstdc++ 包中找到。


OFILEPREF=${1%%ra}      # 删除 "ra" 后缀。
OFILESUFF=wav           # wav 文件后缀。
OUTFILE="$OFILEPREF""$OFILESUFF"
E_NOARGS=85

if [ -z "$1" ]          # 必须指定一个文件进行转换。
then
  echo "Usage: `basename $0` [filename]"
  exit $E_NOAGRS
fi


######################################################
mplayer "$1" -ao pcm:file=$OUTFILE
oggenc "$OUTFILE"  # 由 oggenc 自动加上正确的文件后缀名。
######################################################

rm "$OUTFILE"      # 立即删除 *.wav 文件。
                   # 如果你仍需保留原文件，注释掉上面这一行即可。
                   
exit $?

#  注意：
#  -----
#  在网站上，点击一个 *.ram 的流媒体音频文件
#+ 通常只会下载到 *.ra 音频文件的 URL。
#  你可以使用 "wget" 或者类似的工具下载 *.ra 文件本身。


#  练习：
#  -----
#  这个脚本仅仅转换 *.ra 文件。
#  修改脚本增加适应性，使其可以转换 *.ram 或其他文件格式。
#
#  如果你非常有热情，你可以扩展这个脚本使其
#+ 可以自动下载并且转换流媒体音频文件。
#  给定一个 URL，自动下载流媒体音频文件 (使用 "wget")，
#+ 然后转换它。
```

下面是使用字符串截取结构对 [`getopt`](http://tldp.org/LDP/abs/html/extmisc.html#GETOPTY) 的一个简单模拟。

样例 10-5. 模拟 `getopt`

```bash
#!/bin/bash
# getopt-simple.sh
# 作者: Chris Morgan
# 允许在高级脚本编程指南中使用。


getopt_simple()
{
    echo "getopt_simple()"
    echo "Parameters are '$*'"
    until [ -z "$1" ]
    do
      echo "Processing parameter of: '$1'"
      if [ ${1:0:1} = '/' ]
      then
          tmp=${1:1}               # 删除开头的 '/'
          parameter=${tmp%%=*}     # 取出名称。
          value=${tmp##*=}         # 取出值。
          echo "Parameter: '$parameter', value: '$value'"
          eval $parameter=$value
      fi
      shift
    done
}

# 将所有参数传递给 getopt_simple()。
getopt_simple $*

echo "test is '$test'"
echo "test2 is '$test2'"

exit 0  # 可以查看该脚本的修改版 UseGetOpt.sh。

---

sh getopt_example.sh /test=value1 /test2=value2

Parameters are '/test=value1 /test2=value2'
Processing parameter of: '/test=value1'
Parameter: 'test', value: 'value1'
Processing parameter of: '/test2=value2'
Parameter: 'test2', value: 'value2'
test is 'value1'
test2 is 'value2'
```

#### 10.1.6 子串替换

`${string/substring/replacement}`

替换匹配到的第一个 `$substring` 为 `$replacement`。

`${string//substring/replacement}`

替换匹配到的所有 `$substring` 为 `$replacement`。

```bash
stringZ=abcABC123ABCabc

echo ${stringZ/abc/xyz}       # xyzABC123ABCabc
                              # 将匹配到的第一个 'abc' 替换为 'xyz'。
                              
echo ${stringZ//abc/xyz}      # xyzABC123ABCxyz
                              # 将匹配到的所有 'abc' 替换为 'xyz'。
                              
echo  ---------------
echo "$stringZ"               # abcABC123ABCabc
echo  ---------------
                              # 字符串本身并不会被修改！
                              
# 匹配以及替换的字符串可以是参数么？
match=abc
repl=000
echo ${stringZ/$match/$repl}  # 000ABC123ABCabc
#              ^      ^         ^^^
echo ${stringZ//$match/$repl} # 000ABC123ABC000
# Yes!          ^      ^        ^^^         ^^^

echo

# 如果没有给定 $replacement 字符串会怎样？
echo ${stringZ/abc}           # ABC123ABCabc
echo ${stringZ//abc}          # ABC123ABC
# 仅仅是将其删除而已。
```

`${string/#substring/replacement}`

替换 `$string` 中最前端匹配到的 `$substring` 为 `$replacement`。

`${string/%substring/replacement}`

替换 `$string` 中最末端匹配到的 `$substring` 为 `$replacement`。

```bash
stringZ=abcABC123ABCabc

echo ${stringZ/#abc/XYZ}          # XYZABC123ABCabc
                                  # 将前端的 'abc' 替换为 'XYZ'
                                  
echo ${stringZ/%abc/XYZ}          # abcABC123ABCXYZ
                                  # 将末端的 'abc' 替换为 'XYZ'
```

####  10.1.7 使用 `awk` 处理字符串

在 Bash 脚本中可以调用字符串处理工具 `awk` 来替换内置的字符串处理操作。

样例 10-6. 使用另一种方式来截取和定位子字符串

```bash
#!/bin/bash
# substring-extraction.sh

String=23skidoo1
#      012345678    Bash
#      123456789    awk
# 注意不同字符串索引系统：
# Bash 中第一个字符的位置为0。
# Awk 中第一个字符的位置为1。

echo ${String:2:4} # 从第3位开始（0-1-2），4个字符的长度
                                         # skid

# Awk 中与 ${string:pos:length} 等价的是 substr(string,pos,length)。
echo | awk '
{ print substr("'"${String}"'",3,4)      # skid
}
'
#  将空的 "echo" 通过管道传递给 awk 作为一个模拟输入，
#+ 这样就不需要提供一个文件名来操作 awk 了。

echo "----"

# 同样的：

echo | awk '
{ print index("'"${String}"'", "skid")      # 3
}                                           # （skid 从第3位开始）
'   # 这里使用 awk 等价于 "expr index"。

exit 0
```

### 10.2 参数替换

参数替换用来处理或扩展变量。

`${parameter}`

等同于 `$parameter`，是变量 parameter 的值。在一些特定的环境下，只允许使用不易混淆的 `${parameter}` 形式。

可以用于连接变量与字符串。

```bash
your_id=${USER}-on-${HOSTNAME}
echo "$your_id"
# 
echo "Old \$PATH = $PATH"
PATH=${PATH}:/opt/bin  # 在脚本执行过程中临时在 $PATH 中加入 /opt/bin。
echo "New \$PATH = $PATH"
```

`${parameter-default}, ${parameter:-default}`

在没有设置变量的情况下使用缺省值。

```bash
var1=1
var2=2
# 没有设置 var3。

echo ${var1-$var2}   # 1
echo ${var3-$var2}   # 2
#           ^          注意前面的 $ 前缀。



echo ${username-`whoami`}
# 如果变量 $username 没有被设置，输出 `whoami` 的结果。
```

> ![note](images/note-1583310494799.gif) `${parameter-default}` 与 `${parameter:-default}` 的作用几乎相同，唯一不同的情况就是当变量 parameter 已经被声明但值为空时。

```bash
#!/bin/bash
# param-sub.sh

# 无论变量的值是否为空，其是否已被声明决定了缺省设置的触发。

username0=
echo "username0 has been declared, but is set to null."
echo "username0 = ${username0-`whoami`}"
# 将不会输出 `whoami` 的结果。

echo

echo username1 has not been declared.
echo "username1 = ${username1-`whoami`}"
# 将会输出 `whoami` 的结果。

username2=
echo "username2 has been declared, but is set to null."
echo "username2 = ${username2:-`whoami`}"
#                            ^
# 因为这里是 :- 而不是 -，所以将会输出 `whoami` 的结果。
# 与上面的 username0 比较。


# 

# 再来一次：

variable=
# 变量已被声明，但其值为空。

echo "${varibale-0}"    # 没有输出。
echo "${variable:-1}"   # 1
#               ^

unser variable

echo "${variable-2}"    # 2
echo "${variable:-3}"   # 3

exit 0
```

当传入的命令行参数的数量不足时，可以使用这种缺省参数结构。

```bash
DEFAULT_FILENAME=generic.data
filename=${1:-$DEFAULT_FILENAME}
# 如果没有其他特殊情况，下面的代码块将会操作文件 "generic.data"。
# 代码块开始
# ...
# ...
# ...
# 代码块结束



# 摘自样例 "hanoi2.bash"：
DISKS=${1:-E_NOPARAM}   # 必须指定碟子的个数。
#  将 $DISKS 设置为传入的第一个命令行参数，
#+ 如果没有传入第一个参数，则设置为 $E_NOPARAM。
```

可以查看 [样例 3-4](http://tldp.org/LDP/abs/html/special-chars.html#EX58)，[样例 31-2](http://tldp.org/LDP/abs/html/zeros.html#EX73) 和 [样例 A-6](http://tldp.org/LDP/abs/html/contributed-scripts.html#COLLATZ)。

可以同 [使用与链设置缺省命令行参数](http://tldp.org/LDP/abs/html/list-cons.html#ANDDEFAULT) 做比较。

`${parameter=default}, ${parameter:=default}`

在没有设置变量的情况下，将其设置为缺省值。

两种形式的作用几乎相同，唯一不同的情况与上面类似，就是当变量 parameter 已经被声明但值为空时。[^1]

```bash
echo ${var=abc}   # abc
echo ${vat=xyz}   # abc
# $var 已经在第一条语句中被赋值为 abc，因此第二条语句将不会改变它的值。
```

`${parameter+alt_value}, ${parameter:+alt_value}`

如果变量已被设置，使用 alt_value，否则使用空值。

两种形式的作用几乎相同，唯一不同的情况就是当变量 parameter 已经被声明但值为空时，看下面的例子。

```bash
echo "###### \${parameter+alt_value} ########"
echo

a=${param1+xyz}
echo "a = $a"      # a =

param2=
a=${param2+xyz}
echo "a = $a"      # a = xyz

param3=123
a=${param3+xyz}
echo "a = $a"      # a = xyz

echo
echo "###### \${parameter:+alt_value} ########"
echo

a=${param4:+xyz}
echo "a = $a"      # a =

param5=
a=${param5:+xyz}
echo "a = $a"      # a =
# 不同于 a=${param5+xyz}

param6=123
a=${param6:+xyz}
echo "a = $a"      # a = xyz
```

`${parameter?err_msg}, ${parameter:?err_msg}`

如果变量已被设置，那么使用原值，否则输出 err_msg 并且终止脚本，返回 [错误码](http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF) 1。

两种形式的作用几乎相同，唯一不同的情况与上面类似，就是当变量 parameter 已经被声明但值为空时。

样例 10-7. 如何使用变量替换和错误信息

```bash
#!/bin/bash

# 检查系统环境变量。
# 这是一种良好的预防性维护措施。
# 如果控制台用户的名称 $USER 没有被设置，那么主机将不能够识别用户。

: ${HOSTNAME?} ${USER?} ${HOME?} ${MAIL?}
  echo
  echo "Name of the machine is $HOSTNAME."
  echo "You are $USER."
  echo "Your home directory is $HOME."
  echo "Your mail INBOX is located in $MAIL."
  echo
  echo "If you are reading this message,"
  echo "critcial environmental variables have been set."
  echo
  echo
  
# ------------------------------------------------------

# ${variablename?} 结构统一可以检查脚本中的变量是否被设置。

ThisVariable=Value-of-ThisVariable
# 顺带一提，这个字符串的值可以被设置成名称中不可以使用的禁用字符。
: ${ThisVariable?}
echo "Value of ThisVariable is $ThisVariable."

echo; echo


: ${ZZXy23AB?"ZZXy23AB has not been set."}
# 因为 ZZXy23AB 没有被设置，所以脚本会终止同时显示错误消息。

# 你可以指定错误消息。
# : ${variablename?"ERROR MESSAGE"}


# 与这些结果相同:  dummy_variable=${ZZXy23AB?}
#                 dummy_variable=${ZZXy23AB?"ZZXy23AB has not been set."}
#
#                 echo ${ZZXy23AB?} >/dev/null

# 将上面这些检查变量是否被设置的方法同 "set -u" 作比较。



echo "You will not see this message, because script already terminated."

HERE=0
exit $HERE   # 将不会从这里退出。

#  事实上，这个脚本将会返回退出码（echo $?）1。
```

样例 10-8. 参数替换与 "usage" 消息

```bash
#!/bin/bash
# usage-message.sh

: ${1?"Usage: $0 ARGUMENT"}
# 如果命令行参数缺失，脚本将会在这里结束，并且返回下面的错误信息。
#    usage-message.sh: 1: Usage: usage-message.sh ARGUMENT

echo "These two lines echo only if command-line parameter given."
echo "command-line parameter = \"$1\""

exit 0  # 仅当命令行参数存在是才会从这里退出。

# 在传入和未传入命令行参数的情况下查看退出状态。
# 如果传入了命令行参数，那么 "$?" 的结果是0。
# 如果没有，那么 "$?" 的结果是1。
```

参数替换用来处理或扩展变量。下面的表达式是对 `expr` 处理字符串的操作的补足（查看样例 16-9）。这些特殊的表达式通常养来解析文件的路径名。

#### 10.2.1 变量长度 / 删除子串

`${#var}`

字符串的长度（`$var` 中字符的个数）。对任意 [数组](http://tldp.org/LDP/abs/html/arrays.html#ARRAYREF) array，`${#array}` 返回数组中第一个元素的长度。

> ![note](http://tldp.org/LDP/abs/images/note.gif) 以下情况例外：
>
> * `${#*}` 和 `${#@}` 返回位置参数的个数。
> * 任意数组 array，`${#array[*]}` 和 `${#array[@]}` 返回数组中元素的个数。

样例 10-9. 变量长度

```bash
#!/bin/bash
# length.sh

E_NO_ARGS=65

if [ $# -eq 0 ]  # 脚本必须传入参数。
then
  echo "Please invoke this script with one or more command-line arguments."
  exit $E_NO_ARGS
fi

var01=abcdEFGH28ij
echo "var01 = ${var01}"
echo "Length of var01 = ${#var01}"
# 现在我们尝试加入空格。
var02="abcd EFGH28ij"
echo "var02 = ${var02}"
echo "Length of var02 = ${#var02}"

echo "Number of command-line arguments passed to script = ${#@}"
echo "Number of command-line arguments passed to script = ${#*}"

exit 0
```

`${var#Pattern}, ${var##Pattern}`

`${var#Pattern}` 删除 `$var` 前缀部分匹配到的最短长度的 `$Pattern`。

`${var##Pattern}` 删除 `$var` 前缀部分匹配到的最长长度的 `$Pattern`。

摘自 [样例 A-7](http://tldp.org/LDP/abs/html/contributed-scripts.html#DAYSBETWEEN) 的例子：

```bash
# 函数摘自样例 "day-between.sh"。
# 删除传入的参数中的前缀0。

strip_leading_zero () #  删除传入参数中可能存在的
{                     #+ 前缀0。
  return=${1#0}       #  "1" 代表 "$1"，即传入的参数。
}                     #  从 "$1" 中删除 "0"。
```

下面是由 Manfred Schwarb 提供的上述函数的改进版本：

```bash
strip_leading_zero2 () # 删除前缀0，
{                      # 否则 Bash 会将其解释为8进制数。
  shopt -s extglob     # 启用扩展通配特性。
  local val=${1##+(0)} # 使用本地变量，匹配前缀中所有的0。
  shopt -u extglob     # 禁用扩展通配特性。
  _strip_leading_zero2=${var:-0}
                       # 如果输入的为0，那么返回 0 而不是 ""。
```

另外一个样例：

```bash
echo `basename $PWD`        # 当前工作目录的目录名。
echo "${PWD##*/}"           # 当前工作目录的目录名。
echo
echo `basename $0`          # 脚本名。
echo $0                     # 脚本名。
echo "${0##*/}"             # 脚本名。
echo
filename=test.data
echo "${filename##*.}"      # data
                            # 文件扩展名。
```

`${var%Pattern}, ${var%%Pattern}`

`${var%Pattern}` 删除 `$var` 后缀部分匹配到的最短长度的 `$Pattern`。

`${var%%Pattern}` 删除 `$var` 后缀部分匹配到的最长长度的 `$Pattern`。

在 Bash 的 [第二个版本](http://tldp.org/LDP/abs/html/bashver2.html#BASH2REF) 中增加了一些额外的选择。

样例 10-10. 参数替换中的模式匹配

```bash
#!/bin/bash
# patt-matching.sh

# 使用 # ## % %% 参数替换操作符进行模式匹配

var1=abcd12345abc6789
pattern1=a*c  # 通配符 * 可以匹配 a 与 c 之间的任意字符

echo
echo "var1 = $var1"           # abcd12345abc6789
echo "var1 = ${var1}"         # abcd12345abc6789
                              # （另一种形式）
echo "Number of characters in ${var1} = ${#var1}"
echo

echo "pattern1 = $pattern1"   # a*c  (匹配 'a' 与 'c' 之间的一切)
echo "--------------"
echo '${var1#$pattern1}  =' "${var1#$pattern1}"    #         d12345abc6789
# 匹配到首部最短的3个字符                                   abcd12345abc6789
#             ^                                           |-|
echo '${var1##$pattern1} =' "${var1##$pattern1}"   #                  6789
# 匹配到首部最长的12个字符                                  abcd12345abc6789
#             ^                                           |----------|

echo; echo; echo

pattern2=b*9            # 匹配 'b' 与 '9' 之间的任意字符
echo "var1 = $var1"     # 仍旧是 abcd12345abc6789
echo
echo "pattern2 = $pattern2"
echo "--------------"
echo '${var1%pattern2}  =' "${var1%$pattern2}"     #     abcd12345a
# 匹配到尾部最短的6个字符                                  abcd12345abc6789
#             ^                                                    |----|
echo '${var1%%pattern2} =' "${var1%%$pattern2}"    #     a
# 匹配到尾部最长的12个字符                                 abcd12345abc6789
#             ^                                           |-------------|

# 牢记 # 与 ## 是从字符串左侧开始，
#      % 与 %% 是从右侧开始。

echo

exit 0
```

样例 10-11. 更改文件扩展名：

```bash
#!/bin/bash
# rfe.sh: 更改文件扩展名。
#
#         rfe old_extension new_extension
#
# 如：
# 将当前目录下所有 *.gif 文件重命名为 *.jpg，
#         rfe gif jpg


E_BADARGS=65

case $# in
  0|1)             # 竖线 | 在这里表示逻辑或关系。
  echo "Usage: `basename $0` old_file_suffix new_file_suffix"
  exit $E_BADARGS  # 如果只有0个或1个参数，那么退出脚本。
  ;;
esac


for filename in *.$1
# 遍历以第一个参数作为后缀名的文件列表。
do
  mv $filename ${filename%$1}$2
  # 删除文件后缀名，增加第二个参数作为后缀名。
done

exit 0
```

#### 10.2.2 变量扩展 / 替换子串

下面这些结构采用自 ksh。

`${var:pos}`

扩展为从偏移量 pos 处截取的变量 var。

`${var:pos:len}`

扩展为从偏移量 pos 处截取变量 var 最大长度为 len 的字符串。

`${var/Pattern/Replacement}`

替换 var 中第一个匹配到的 Pattern 为 Replacement。

如果 Replacement 被省略，那么匹配到的第一个 Pattern 将被替换为空，即删除。

`${var//Pattern/Replacement}`

全局替换。替换 var 中所有匹配到的 Pattern 为 Replacement。

跟上面一样，如果 Replacement 被省略，那么匹配到的所有 Pattern 将被替换为空，即删除。

样例 10-12. 使用模式匹配解析任意字符串

```bash
#!/bin/bash

var1=abcd-1234-defg
echo "var1 = $var1"

t=${var1#*-*}
echo "var1 (with everything, up to and including first - stripped out) = $t"
#  t=${var1#*-} 效果相同，
#+ 因为 # 只匹配最短的字符串，
#+ 并且 * 可以任意匹配，其中也包括空字符串。
# （感谢 Stephane Chazelas 指出这一点。）

t=${var##*-*}
echo "If var1 contains a \"-\", returns empty string...   var1 = $t"


t=${var1%*-*}
echo "var1 (with everything from the last - on stripped out) = $t"

echo

# -------------------------------------------
path_name=/home/bozo/ideas/thoughts/for.today
# -------------------------------------------
echo "path_name = $path_name"
t=${path_name##/*/}
echo "path_name, stripped of prefixes = $t"
# 在这里与 t=`basename $path_name` 效果相同。
#  t=${path_name%/}; t=${t##*/}  是更加通用的方法，
#+ 但有时仍旧也会出现问题。
#  如果 $path_name 以换行结束，那么 `basename $path_name` 将会失效，
#+ 但是上面这种表达式却可以。
# （感谢 S.C.）

t=${path_name%/*.*}
# 同 t=`dirname $path_name` 效果相同。
echo "path_name, stripped of suffixes = $t"
# 在一些情况下会失效，比如 "../", "/foo////", # "foo/", "/"。
#  在删除后缀时，尤其是当文件名没有后缀，目录名却有后缀时，
#+ 事情会变的非常复杂。
# （感谢 S.C.）

echo

t=${path_name:11}
echo "$path_name, with first 11 chars stripped off = $t"
t=${path_name:11:5}
echo "$path_name, with first 11 chars stripped off, length 5 = $t"

echo

t=${path_name/bozo/clown}
echo "$path_name with \"bozo\" replaced by \"clown\" = $t"
t=${path_name/today/}
echo "$path_name with \"today\" deleted = $t"
t=${path_name//o/O}
echo "$path_name with all o's capitalized = $t"
t=${path_name//o/}
echo "$path_name with all o's deleted = $t"

exit 0
```

`${var/#Pattern/Replacement}`

替换 var 前缀部分匹配到的 Pattern 为 Replacement。

`${var/%Pattern/Replacement}`

替换 var 后缀部分匹配到的 Pattern 为 Replacement。

样例 10-13. 在字符串首部或尾部进行模式匹配

```bash
#!/bin/bash
# var-match.sh:
# 演示在字符串首部或尾部进行模式替换。

v0=abc1234zip1234abc    # 初始值。
echo "v0 = $v0"         # abc1234zip1234abc
echo

# 在字符串首部进行匹配
v1=${v0/#abc/ABCDEF}    # abc1234zip123abc
                        # |-|
echo "v1 = $v1"         # ABCDEF1234zip1234abc
                        # |----|
                        
# 在字符串尾部进行匹配
v2=${v0/%abc/ABCDEF}    # abc1234zip123abc
                        #              |-|
echo "v2 = $v2"         # abc1234zip1234ABCDEF
                        #               |----|
                        
echo

#  --------------------------------------------
#  必须在字符串的最开始或者最末尾的地方进行匹配，
#+ 否则将不会发生替换。
#  --------------------------------------------
v3=${v0/#123/000}       # 虽然匹配到了，但是不在最开始的地方。
echo "v3 = $v3"         # abc1234zip1234abc
                        # 没有替换。
v4=${v0/%123/000}       # 虽然匹配到了，但是不在最末尾的地方。
echo "v4 = $v4"         # abc1234zip1234abc
                        # 没有替换。

exit 0
```

`${!varprefix*}, ${!varprefix@}`

匹配先前声明过所有以 varprefix 作为变量名前缀的变量。

```bash
# 这是带 * 或 @ 的间接引用的一种变换形式。
# 在 Bash 2.04 版本中加入了这个特性。

xyz23=whatever
xyz23=

a=${!xyz*}         #  扩展为声明变量中以 "xyz"
# ^ ^   ^           + 开头变量名。
echo "a = $a"      #  a = xyz23 xyz24
a=${!xyz@}         #  同上。
echo "a = $a"      #  a = xyz23 xyz24

echo "---"

abc23=something_else
b=${!abc*}
echo "b = $b"      #  b = abc23
c=${!b}            #  这是我们熟悉的间接引用的形式。
echo $c            #  something_else
```
