

```bash
#!/bin/bash
# ex9.sh

# 变量赋值与替换

a=375
hello=$a
#   ^ ^

#----------------------------------------------------
# 初始化变量时，赋值号 = 的两侧绝不允许有空格出现。
# 如果有空格会发生什么？

#   "VARIABLE =value"
#            ^
#% 脚本将会尝试运行带参数 "=value" 的 "VARIABLE " 命令。

#   "VARIABLE= value"
#             ^
#% 脚本将会尝试运行 "value" 命令，
#+ 同时设置环境变量 "VARIABLE" 为 ""。
#----------------------------------------------------


echo hello    # hello
# 没有引用变量，"hello" 只是一个字符串...

echo $hello   # 375
#    ^          这是变量引用。

echo ${hello} # 375
#               与上面的类似，变量引用。

# 字符串内引用变量
echo "$hello"    # 375
echo "${hello}"  # 375

echo

hello="A B  C   D"
echo $hello   # A B C D
echo "$hello" # A B  C   D
# 正如我们所见，echo $hello 与 echo "$hello" 的结果不同。
# ====================================
# 字符串内引用变量将会保留变量的空白符。
# ====================================

echo

echo '$hello'  # $hello
#    ^      ^
#  单引号会禁用掉（转义）变量引用，这导致 "$" 将以普通字符形式被解析。

# 注意单双引号字符串引用效果的不同。

hello=    # 将其设置为空值
echo "\$hello (null value) = $hello"      # $hello (null value) =
# 注意 
# 将一个变量设置为空与删除(unset)它不同，尽管它们的表现形式相同。

# -----------------------------------------------

# 使用空白符分隔，可以在一行内对多个变量进行赋值。
# 但是这会降低程序的可读性，并且可能会导致部分程序不兼容的问题。

var1=21  var2=22  var3=$V3
echo
echo "var1=$var1   var2=$var2   var3=$var3"

# 在一些老版本的 shell 中这样写可能会有问题。

# -----------------------------------------------

echo; echo

numbers="one two three"
#           ^   ^
other_numbers="1 2 3"
#               ^ ^
# 如果变量中有空白符号，那么必须用引号进行引用。
# other_numbers=1 2 3                  # 出错
echo "numbers = $numbers"
echo "other_numbers = $other_numbers"  # other_numbers = 1 2 3
# 也可以转义空白符。
mixed_bag=2\ ---\ Whatever
#           ^    ^ 使用 \ 转义空格

echo "$mixed_bag"         # 2 --- Whatever

echo; echo

echo "uninitialized_variable = $uninitialized_variable"
# 未初始化的变量是空值(null表示不含有任何值)。
uninitialized_variable=   # 只声明而不初始化，等同于设为空值。
echo "uninitialized_variable = $uninitialized_variable" # 仍旧为空

uninitialized_variable=23       # 设置变量
unset uninitialized_variable    # 删除变量
echo "uninitialized_variable = $uninitialized_variable"
                                # uninitialized_variable =
                                # 变量值为空
echo

exit 0
```

> ![notice](images/caution.gif) 一个未被赋值或未初始化的变量拥有空值（null value）。*注意：null值不等同于0*。

```bash
if [ -z "$unassigned" ]
then
  echo "\$unassigned is NULL."
fi     # $unassigned is NULL.
```

> 在赋值前使用变量可能会导致错误。但在算术运算中使用未赋值变量是可行的。

```bash
echo "$uninitialized"            # 空行
let "uninitialized += 5"         # 加5
echo "$uninitialized"            # 5
# 结论：
# 一个未初始化的变量不含值(null)，但在算术运算中会被作为0处理。
```

>  也可参考样例 15-23。

### 4.2 变量赋值(=)

赋值操作符（在其前后没有空白符）。

> ![noitce](images/caution.gif) 不要混淆 = 与 -eq，后者用来进行比较而非赋值。
>
> 同时也要注意 = 根据使用场景既可作赋值操作符，也可作比较操作符。

样例 4-2. 变量赋值

```bash
#!/bin/bash
# 非引用形式变量

echo

# 什么时候变量是非引用形式，即变量名前没有 '$' 符号的呢？
# 当变量在被赋值而不是被引用时。

# 赋值
a=879
echo "The value of \"a\" is $a."

# 使用 'let' 进行赋值
let a=16+5
echo "The value of \"a\" is now $a."

echo

# 在 'for' 循环中赋值（隐式赋值）
echo -n "Values of \"a\" in the loop are: "
for a in 7 8 9 11
do
  echo -n "$a "
done

echo
echo

# 在 'read' 表达式中（另一种赋值形式）
echo -n "Enter \"a\" "
read a
echo "The value of \"a\" is now $a."

echo

exit 0
```

样例 4-3. 奇妙的变量赋值

```bash
#!/bin/bash

a=23              # 简单形式
echo $a
b=$a
echo $b

# 来我们玩点炫的（命令替换）。

a=`echo Hello!`   # 将 'echo' 命令的结果赋值给 'a'
echo $a
#  注意在命令替换结构中包含感叹号(!)在命令行中使用将会失效，
#+ 因为它将会触发 Bash 的历史(history)机制。
#  在shell脚本内，Bash 的历史机制默认关闭。

a=`ls -l`         # 将 'ls -l' 命令的结果赋值给 'a'
echo $a           # 不带引号引用，将会移除所有的制表符与分行符
echo
echo "$a"         # 引号引用变量将会保留空白符
                  # 查看 "引用" 章节。
                  
exit 0
```

使用 `$(...)` 形式进行赋值（与反引号不同的新形式），与命令替换形式相似。

```bash
# 摘自 /etc/rc.d/rc.local
R=$(cat /etc/redhat-release)
arch=$(uname -m)
```

### 4.3 Bash变量是弱类型的

不同于许多其他编程语言，Bash 并不区分变量的类型。本质上说，*Bash 变量是字符串*，但在某些情况下，Bash 允许对变量进行算术运算和比较。决定因素则是变量值是否只含有数字。

样例 4-4. 整数还是字符串？

```bash
#!/bin/bash
# int-or-string.sh

a=2334                   # 整数。
let "a += 1"
echo "a = $a "           # a = 2335
echo                     # 依旧是整数。


b=${a/23/BB}             # 将 "23" 替换为 "BB"。
                         # $b 变成了字符串。
echo "b = $b"            # b = BB35
declare -i b             # 将其声明为整数并没有什么卵用。
echo "b = $b"            # b = BB35

let "b += 1"             # BB35 + 1
echo "b = $b"            # b = 1
echo                     # Bash 认为字符串的"整数值"为0。

c=BB34
echo "c = $c"            # c = BB34
d=${c/BB/23}             # 将 "BB" 替换为 "23"。
                         # $d 变为了一个整数。
echo "d = $d"            # d = 2334
let "d += 1"             # 2334 + 1
echo "d = $d"            # d = 2335
echo


# 如果是空值会怎样呢？
e=''                     # ...也可以是 e="" 或 e=
echo "e = $e"            # e =
let "e += 1"             # 空值是否允许进行算术运算？
echo "e = $e"            # e = 1
echo                     # 空值变为了一个整数。

# 如果时未声明的变量呢？
echo "f = $f"            # f =
let "f += 1"             # 是否允许进行算术运算？
echo "f = $f"            # f = 1
echo                     # 未声明变量变为了一个整数。
#
# 然而……
let "f /= $undecl_var"   # 可以除以0么？
#   let: f /= : syntax error: operand expected (error token is " ")
# 语法错误！在这里 $undecl_var 并没有被设置为0！
#
# 但是，仍旧……
let "f /= 0"
#   let: f /= 0: division by 0 (error token is "0")
# 预期之中。


# 在执行算术运算时，Bash 通常将其空值的整数值设为0。
# 但是不要做这种事情！
# 因为这可能会导致一些意外的后果。


# 结论：上面的结果都表明 Bash 中的变量是弱类型的。

exit $?
```

弱类型变量有利有弊。它可以使编程更加灵活、更加容易（给与你足够的想象空间）。但它也同样的容易造成一些小错误，容易养成粗心大意的编程习惯。

为了减轻脚本持续跟踪变量类型的负担，Bash *不允许*变量声明。

### 4.4 特殊的变量类型

#### 4.4.1 局部变量

仅在代码块或函数中才可见的变量（参考函数章节的局部变量部分）。

#### 4.4.2 环境变量

会影响用户及shell行为的变量。

> ![extra](images/note-1583300773483.gif) 一般情况下，每一个进程都有自己的“环境”（environment），也就是一组该进程可以访问到的变量。从这个意义上来说，shell表现出与其他进程一样的行为。
>
> 每当shell启动时，都会创建出与其环境对应的shell环境变量。改变或增加shell环境变量会使shell更新其自身的环境。*子进程*（由父进程执行产生）会继承*父进程*的环境变量。
>
> ![notice](images/caution.gif) 分配给环境变量的空间是有限的。创建过多环境变量或占用空间过大的环境变量有可能会造成问题。

```
bash$ eval "`seq 10000 | sed -e 's/.*/export var&=ZZZZZZZZZZZZZZ/'`"
>
bash$ du
bash: /usr/bin/du: Argument list too long
```

> 注意，上面的"错误"已经在Linux内核版本号为2.6.23的系统中修复了。
>
> （感谢 Stéphane Chazelas 对此问题的解释并提供了上面的例子。）

如果在脚本中设置了环境变量，那么这些环境变量需要被“导出”，也就是通知脚本所在的*环境*做出相应的更新。这个“导出”操作就是 `export` 命令。

> ![extra](images/note-1583300773483.gif) 脚本只能将变量导出到子进程，即在这个脚本中所调用的命令或程序。在命令行中调用的脚本不能够将变量回传给命令行环境，即*子进程不能将变量回传给父进程*。
>
> **定义：** 子进程（child process）是由另一个进程，即其父进程（parent process）所启动的子程序。

#### 4.4.3 位置参数

从命令行中传递给脚本的参数：`$0, $1, $2, $3 ...`
即**命令行参数**。

`$0` 代表脚本名称，`$1` 代表第一个参数，`$2` 代表第二个，`$3` 代表第三个，以此类推。在 `$9` 之后的参数必须被包含在大括号中，如 `${10}, ${11}, ${12}`。

特殊变量 `$*` 与 `$@` 代表所有位置参数。

样例 4-5. 位置参数

```bash
#!/bin/bash

# 调用脚本时使用至少10个参数，例如
# ./scriptname 1 2 3 4 5 6 7 8 9 10
MINPARAMS=10

echo

echo "The name of this script is \"$0\"."
# 附带 ./ 代表当前目录
echo "The name of this script is \"`basename $0`\"."
# 除去路径信息（查看 'basename'）

echo

if [ -n "$1" ]              # 测试变量是否存在
then
 echo "Parameter #1 is $1"  # 使用引号转义#
fi

if [ -n "$2" ]
then
 echo "Parameter #2 is $2"
fi

if [ -n "$3" ]
then
 echo "Parameter #3 is $3"
fi

# ...

if [ -n "${10}" ]  # 大于 $9 的参数必须被放在大括号中
then
 echo "Parameter #10 is ${10}"
fi

echo "-----------------------------------"
echo "All the command-line parameters are: "$*""

if [ $# -lt "$MINPARAMS" ]
then
  echo
  echo "This script needs at least $MINPARAMS command-line arguments!"
fi

echo

exit 0
```

在位置参数中使用大括号助记符提供了一种非常简单的方式来访问传入脚本的最后一个参数。在其中会使用到间接引用。

```bash
args=$#           # 传入参数的个数
lastarg=${!args}
# 这是 $args 的一种间接引用方式

# 也可以使用:       lastarg=${!#}             (感谢 Chris Monson.)
# 这是 $# 的一种间接引用方式。
# 注意 lastarg=${!$#} 是无效的。
```

一些脚本能够根据调用时文件名的不同来执行不同的操作。要达到这样的效果，脚本需要检测 `$0`，也就是调用时的文件名。同时，也必须存在指向这个脚本所有别名的符号链接文件（symbolic links）。详情查看样例 16-2。

> ![info](images/tip-1583300773492.gif) 如果一个脚本需要一个命令行参数但是在调用的时候却没有传入，那么这将会造成一个空变量赋值。这通常不是我们想要的。一种避免的方法是，在使用期望的位置参数时候，在赋值语句两侧添加一个额外的字符。

```bash
variable1_=$1_  # 而不是 variable1=$1
# 使用这种方法可以在没有位置参数的情况下避免产生错误。

critical_argument01=$variable1_

# 多余的字符可以被去掉，就像下面这样：
variable1=${variable1_/_/}
# 仅仅当 $variable1_ 是以下划线开头时候才会有一些副作用。
# 这里使用了我们稍后会介绍的参数替换模板中的一种。
# （将替换模式设为空等价于删除。）

# 更直接的处理方法就是先检测预期的位置参数是否被传入。
if [ -z $1 ]
then
  exit $E_MISSING_POS_PARAM
fi


#  但是，正如 Fabin Kreutz 指出的，
#+ 上面的方法会有一些意想不到的副作用。
#  更好的方法是使用参数替换：
#         ${1:-$DefaultVal}
#  详情查看第十章“操作变量”的第二节“变量替换”。
```

样例 4-6. *wh*, *whois* 域名查询

```bash
#!/bin/bash
# ex18.sh

# 在下面三个可选的服务器中进行 whois 域名查询：
# ripe.net, cw.net, radb.net

# 将这个脚本重命名为 'wh' 后放在 /usr/local/bin 目录下

# 这个脚本需要进行符号链接：
# ln -s /usr/local/bin/wh /usr/local/bin/wh-ripe
# ln -s /usr/local/bin/wh /usr/local/bin/wh-apnic
# ln -s /usr/local/bin/wh /usr/local/bin/wh-tucows

E_NOARGS=75


if [ -z "$1" ]
then
  echo "Usage: `basename $0` [domain-name]"
  exit $E_NOARGS
fi

# 检查脚本名，访问对应服务器进行查询。
case `basename $0` in    # 也可以写:    case ${0##*/} in
    "wh"       ) whois $1@whois.tucows.com;;
    "wh-ripe"  ) whois $1@whois.ripe.net;;
    "wh-apnic" ) whois $1@whois.apnic.net;;
    "wh-cw"    ) whois $1@whois.cw.net;;
    *          ) echo "Usage: `basename $0` [domain-name]";;
esac

exit $?
```

使用 `shift` 命令可以将全体位置参数向左移一位, 重新赋值。

`$1 <--- $2`, `$2 <--- $3`, `$3 <--- $4`，以此类推。

原先的 `$1` 将会消失，而 `$0`（脚本名称）不会有任何改变。如果你在脚本中使用了大量的位置参数，`shift` 可以让你不使用{大括号}助记法也可以访问超过10个的位置参数。

样例 4-7. 使用 `shift` 命令

```bash
#!/bin/bash
# shft.sh: 使用 `shift` 命令步进访问所有的位置参数。

# 将这个脚本命名为 shft.sh，然后在调用时跟上一些参数。
# 例如：
#    sh shft.sh a b c def 83 barndoor

until [ -z "$1" ]  # 直到访问完所有的参数
do
  echo -n "$1 "
  shift
done

echo               # 换行。

# 那些被访问完的参数又会怎样呢？
echo "$2"
# 什么都不会被打印出来。
# 当 $2 被移动到 $1 且没有 $3 时，$2 将会保持空。
# 因此 shift 是移动参数而非复制参数。

exit

#  可以参考 echo-params.sh 脚本，在不使用 shift 命令的情况下，
#+ 步进访问所有位置参数。
```

`shift` 命令也可以带一个参数来指明一次移动多少位。

```bash
#!/bin/bash
# shift-past.sh

shift 3    # 移动3位。
# 与 n=3; shift $n 效果相同。

echo "$1"

exit 0

# ======================== #


$ sh shift-past.sh 1 2 3 4 5
4

#  但是就像 Eleni Fragkiadaki 指出的那样，
#  如果尝试将位置参数（$#）传给 'shift'，
#  将会导致脚本错误的结束，同时位置参数也不会发送改变。
#  这也许是因为陷入了一个死循环...
#  比如：
#      until [ -z "$1" ]
#      do
#         echo -n "$1 "
#         shift 20    #  如果少于20个位置参数，
#      done           #+ 那么循环将永远不会结束。
#
#  当你不确定是否有这么多的参数时，你可以加入一个测试：
#      shift 20 || break
#               ^^^^^^^^
```

> ![extra](images/note-1583300773483.gif) 使用 `shift` 命令同给函数传参相类似。详情查看样例 36-18。

## 5 引用

引用就是将一个字符串用引号括起来。这样做是为了保护Shell/Shell脚本中被重新解释过或带扩展功能的[特殊字符](http://tldp.org/LDP/abs/html/special-chars.html)（如果一个字符带有其特殊意义而不仅仅是字面量的话，这个字符就能称为“特殊字符”。比如星号“*”就能表示[正则表达式](http://tldp.org/LDP/abs/html/regexp.html#REGEXREF)中的一个[通配符](http://tldp.org/LDP/abs/html/globbingref.html)）。

```
bash$ ls -l [Vv]*
-rw-rw-r--    1 bozo  bozo       324 Apr  2 15:05 VIEWDATA.BAT
-rw-rw-r--    1 bozo  bozo       507 May  4 14:25 vartrace.sh
-rw-rw-r--    1 bozo  bozo       539 Apr 14 17:11 viewdata.sh

bash$ ls -l '[Vv]*'
ls: [Vv]*: No such file or directory
```

> 可以看到，提示不存在该文件。这里的`'[Vv]*`被当成了文件名。
> 在日常沟通和写作中，当我们引用一个短语的时候，我们会将它单独隔开并赋予它特殊的意义，而在bash脚本中，当我们*引用*一个字符串，意味着保留它的*字面量*。

很多程序和公用代码会展开被引用字符串中的特殊字符。引用的一个重用用途是保护Shell中的命令行参数，但仍然允许调用的程序扩展它。

```	
bash$ grep '[Ff]irst' *.txt
file1.txt:This is the first line of file1.txt.
file2.txt:This is the First line of file2.txt.
```

> 在所有.txt文件中找出包含first或者First字符串的行

注意，不加引号的 `grep [Ff]irst *.txt` 在Bash下也同样有效。

引用也可以控制[echo](http://tldp.org/LDP/abs/html/internal.html#ECHOREF)命令的断行符。

```
bash$ echo $(ls -l)
total 8 -rw-rw-r-- 1 bo bo 13 Aug 21 12:57 t.sh -rw-rw-r-- 1 bo bo 78 Aug 21 12:57 u.sh


bash$ echo "$(ls -l)"
total 8
 -rw-rw-r--  1 bo bo  13 Aug 21 12:57 t.sh
 -rw-rw-r--  1 bo bo  78 Aug 21 12:57 u.sh
```

### 5.1 引用变量

引用变量时，通常建议将变量包含在双引号中。因为这样可以防止除 `$`，`` ` ``（反引号）和`\`（转义符）之外的其他特殊字符被重新解释。在双引号中仍然可以使用`$`引用变量（`"$variable"`），也就是将变量名替换为变量值（详情查看样例 4-1）。

使用双引号可以防止字符串被分割。即使参数中拥有很多空白分隔符，被包在双引号中后依旧是算作单一字符。

```bash
List="one two three"

for a in $List     # 空白符将变量分成几个部分。
do
  echo "$a"
done
# one
# two
# three

echo "---"

for a in "$List"   # 在单一变量中保留所有空格。
do #     ^     ^
  echo "$a"
done
# one two three
```

下面是一个更加复杂的例子：

```bash
variable1="a variable containing five words"
COMMAND This is $variable1    # 带上7个参数执行COMMAND命令：
# "This" "is" "a" "variable" "containing" "five" "words"

COMMAND "This is $variable1"  # 带上1个参数执行COMMAND命令：
# "This is a variable containing five words"


variable2=""    # 空值。

COMMAND  $variable2 $variable2 $variable2
                # 不带参数执行COMMAND命令。
COMMAND "$variable2" "$variable2" "$variable2"
                # 带上3个参数执行COMMAND命令。
COMMAND "$variable2 $variable2 $variable2"
                # 带上1个参数执行COMMAND命令（2空格）。

# 感谢 Stéphane Chazelas。
```

> ![info](images/tip-1583302483997.gif) 当字符分割或者保留空白符出现问题时，才需要在`echo`语句中用双引号包住参数。

样例 5-1. 输出一些奇怪的变量

```bash
#!/bin/bash
# weirdvars.sh: 输出一些奇怪的变量

echo

var="'(]\\{}\$\""
echo $var        # '(]\{}$"
echo "$var"      # '(]\{}$"     没有任何区别。

echo

IFS='\'
echo $var        # '(] {}$"     \ 被转换成了空格，为什么？
echo "$var"      # '(]\{}$"

# 上面的例子由 Stephane Chazelas 提供。

echo

var2="\\\\\""
echo $var2       #   "
echo "$var2"     # \\"
echo
# 但是...var2="\\\\"" 不是合法的语句，为什么？
var3='\\\\'
echo "$var3"     # \\\\
# 强引用是可以的。


# ************************************************************ #
# 就像第一个例子展示的那样，嵌套引用是允许的。

echo "$(echo '"')"           # "
#    ^           ^


# 在有些时候这种方法非常有用。

var1="Two bits"
echo "\$var1 = "$var1""      # $var1 = Two bits
#    ^                ^

# 或者，可以像 Chris Hiestand 指出的那样：

if [[ "$(du "$My_File1")" -gt "$(du "$My_File2")" ]]
#     ^     ^         ^ ^     ^     ^         ^ ^
then
  ...
fi
# ************************************************************ #
```

单引号（' '）与双引号类似，但是在单引号中不能引用变量，因为 `$` 不再具有特殊含义。在单引号中，除`'`之外的所有特殊字符都将会被直接按照字面意思解释。可以认为单引号（“全引用”）是双引号（“部分引用”）的一种更严格的形式。

> ![extra](images/note-1583302483968.gif) 因为在单引号中转义符（\）都已经按照字面意思解释了，因此尝试在单引号中包含单引号将不会产生你所预期的结果。

```bash
echo "Why can't I write 's between single quotes"
>
echo
>
# 可以采取迂回的方式。
echo 'Why can'\''t I write '"'"'s between single quotes'
#    |-------|  |----------|   |-----------------------|
# 由三个单引号引用的字符串，再加上转义以及双引号包住的单引号组成。
>
# 感谢 Stéphane Chazelas 提供的例子。
```

### 5.2 转义

转义是一种引用单字符的方法。通过在特殊字符前加上转义符 `\` 来告诉shell按照字面意思去解释这个字符。

> ![notice](images/caution.gif) 需要注意的是，在一些特定的命令和工具，比如 `echo` 和 `sed` 中，转义字符通常会起到相反的效果，即可能会使得那些字符产生特殊含义。

在 `echo` 与 `sed` 命令中，转义字符的特殊含义

* \n     换行（line feed）。

* \r     回车（carriage return）。

* \t     水平制表符。

* \v    垂直制表符。

* \b    退格。

* \a    警报、响铃或闪烁。

* \0xx

ASCII码的八进制形式，等价于 `0nn`，其中 `nn` 是数字。

> ![important](images/important-1583303464458.gif) 在 `$' ... '` 字符串扩展结构中可以通过转义八进制或十六进制的ASCII码形式给变量赋值，比如 `quote=$'\042'`。

样例 5-2. 转义字符

```bash
#!/bin/bash
# escaped.sh: 转义字符

##############################################
### 首先让我们先看一下转义字符的基本用法。 ###
##############################################

# 转义新的一行。
# ------------

echo ""

echo "This will print
as two lines."
# This will print
# as two lines.

echo "This will print \
as one line."
# This will print as one line.

echo; echo

echo "============="


echo "\v\v\v\v"      # 按字面意思打印 \v\v\v\v
# 使用 echo 命令的 -e 选项来打印转义字符。
echo "============="
echo "VERTICAL TABS"
echo -e "\v\v\v\v"   # 打印四个垂直制表符。
echo "=============="

echo "QUOTATION MARK"
echo -e "\042"       # 打印 " （引号，八进制ASCII码为42）。
echo "=============="



# 使用 $'\X' 这样的形式后可以不需要加 -e 选项。

echo; echo "NEWLINE and (maybe) BEEP"
echo $'\n'           # 新的一行。
echo $'\a'           # 警报（响铃）。
                     # 根据不同的终端版本，也可能是闪屏。

# 我们之前介绍了 $'\nnn' 字符串扩展，而现在我们要看到的是...

# ============================================ #
# 自 Bash 第二个版本开始的 $'\nnn' 字符串扩展结构。
# ============================================ #

echo "Introducing the \$\' ... \' string-expansion construct . . . "
echo ". . . featuring more quotation marks."

echo $'\t \042 \t'   # 在制表符之间的引号。
# 需要注意的是 '\nnn' 是一个八进制的值。

# 字符串扩展同样适用于十六进制的值，格式是 $'\xhhh'。
echo $'\t \x22 \t'  # 在制表符之间的引号。
# 感谢 Greg Keraunen 指出这些。
# 在早期的 Bash 版本中允许使用 '\x022' 这样的形式。

echo


# 将 ASCII 码字符赋值给变量。
# -----------------------
quote=$'\042'        # 将 " 赋值给变量。
echo "$quote Quoted string $quote and this lies outside the quotes."

echo

# 连接多个 ASCII 码字符给变量。
triple_underline=$'\137\137\137'  # 137是 '_' ASCII码的八进制形式
echo "$triple_underline UNDERLINE $triple_underline"

echo

ABC=$'\101\102\103\010'           # 101，102，103是 A, B, C 
                                  # ASCII码的八进制形式。
echo $ABC

echo

escape=$'\033'                    # 033 是 ESC 的八进制形式
echo "\"escape\" echoes an $escape"
                                  # 没有可见输出

echo

exit 0
```

下面是一个更加复杂的例子：

样例 5-3. 检测键盘输入

```bash
#!/bin/bash
# 作者：Sigurd Solaas，作于2011年4月20日
# 授权在《高级Bash脚本编程指南》中使用。
# 需要 Bash 版本高于4.2。

key="no value yet"
while true; do
  clear
  echo "Bash Extra Keys Demo. Keys to try:"
  echo
  echo "* Insert, Delete, Home, End, Page_Up and Page_Down"
  echo "* The four arrow keys"
  echo "* Tab, enter, escape, and space key"
  echo "* The letter and number keys, etc."
  echo
  echo "    d = show date/time"
  echo "    q = quit"
  echo "================================"
  echo
  
  # 将独立的Home键值转换为数字7上的Home键值：
  if [ "$key" = $'\x1b\x4f\x48' ]; then
   key=$'\x1b\x5b\x31\x7e'
   #   引用字符扩展结构。
  fi
  
  # 将独立的End键值转换为数字1上的End键值：
  if [ "$key" = $'\x1b\x4f\x46' ]; then
   key=$'\x1b\x5b\x34\x7e'
  fi
  
  case "$key" in
   $'\x1b\x5b\x32\x7e')  # 插入
    echo Insert Key
   ;;
   $'\x1b\x5b\x33\x7e')  # 删除
    echo Delete Key
   ;;
   $'\x1b\x5b\x31\x7e')  # 数字7上的Home键
    echo Home Key
   ;;
   $'\x1b\x5b\x34\x7e')  # 数字1上的End键
    echo End Key
   ;;
   $'\x1b\x5b\x35\x7e')  # 上翻页
    echo Page_Up
   ;;
   $'\x1b\x5b\x36\x7e')  # 下翻页
    echo Page_Down
   ;;
   $'\x1b\x5b\x41')  # 上箭头
    echo Up arrow
   ;;
   $'\x1b\x5b\x42')  # 下箭头
    echo Down arrow
   ;;
   $'\x1b\x5b\x43')  # 右箭头
    echo Right arrow
   ;;
   $'\x1b\x5b\x44')  # 左箭头
    echo Left arrow
   ;;
   $'\x09')  # 制表符
    echo Tab Key
   ;;
   $'\x0a')  # 回车
    echo Enter Key
   ;;
   $'\x1b')  # ESC
    echo Escape Key
   ;;
   $'\x20')  # 空格
    echo Space Key
   ;;
   d)
    date
   ;;
   q)
    echo Time to quit...
    echo
    exit 0
   ;;
   *)
    echo Your pressed: \'"$key"\'
   ;;
  esac
  
  echo
  echo "================================"
  
  unset K1 K2 K3
  read -s -N1 -p "Press a key: "
  K1="$REPLY"
  read -s -N2 -t 0.001
  K2="$REPLY"
  read -s -N1 -t 0.001
  K3="$REPLY"
  key="$K1$K2$K3"
  
done

exit $?
```

还可以查看样例 37-1。

**\\"**

转义引号，指代自身。

```bash
echo "Hello"                     # Hello
echo "\"Hello\" ... he said."    # "Hello" ... he said.
```

**\\$**

转义美元符号（跟在 `\\$` 后的变量名将不会被引用）。

```bash
echo "\$variable01"           # $variable01
echo "The book cost \$7.98."  # The book cost $7.98.
```

**\\\\**

转义反斜杠，指代自身。

```bash
echo "\\"  # 结果是 \

# 然而...

echo "\"   # 在命令行中会出现第二行并提示输入。
           # 在脚本中会出错。
           
# 但是...

echo '\'   # 结果是 \
```

> ![extra](images/note-1583303464459.gif) 根据转义符所在的上下文（强引用、弱引用，命令替换或者在 here document）的不同，它的行为也会有所不同。

```bash
                      #  简单转义与引用
echo \z               #  z
echo \\z              # \z
echo '\z'             # \z
ehco '\\z'            # \\z
echo "\z"             # \z
echo "\\z"            # \z
>
                      #  命令替换
echo `echo \z`        #  z
echo `echo \\z`       #  z
echo `echo \\\z`      # \z
echo `echo \\\\z`     # \z
echo `echo \\\\\\z`   # \z
echo `echo \\\\\\\z`  # \\z
echo `echo "\z"`      # \z
echo `echo "\\z"`     # \z
>
                      # Here Document
cat <<EOF
\z
EOF                   # \z
>
cat <<EOF
\\z
EOF                   # \z
>
# 以上例子由 Stéphane Chazelas 提供。 
```

> 含有转义字符的字符串可以赋值给变量，但是仅仅将单一的转义符赋值给变量是不可行的。

```bash
variable=\
echo "$variable"
# 这样做会报如下错误：
# tesh.sh: : command not found
# 单独的转义符不能够赋值给变量。
# 
#  事实上，"\" 转义了换行，实际效果是：
#+ variable=echo "$variable"
#+ 这是一个非法的赋值方式。
>
variable=\
23skidoo
echo "$variable"        # 23skidoo
                        # 因为第二行是一个合法的赋值，因此不会报错。
>
variable=\ 
#        \^    转义符后有一个空格
echo "$variable"        # 空格
>
variable=\\
echo "$variable"        # \
>
variable=\\\
echo "$variable"
# 这样做会报如下错误：
# tesh.sh: \: command not found
#
#  第一个转义符转转义了第二个，但是第三个转义符仍旧转义的是换行，
#+ 跟开始的那个例子一样，因此会报错。
>
variable=\\\\
echo "$variable"        # \\
                        # 第二个和第四个转义符被转义了，因此可行。
```

转义空格能够避免在命令参数列表中的字符分割问题。

```bash
file_list="/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7"
# 将一系列文件作为命令的参数。

# 增加两个文件到列表中，并且列出整个表。
ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list

echo "-------------------------------------------------------------------------"

# 如果我们转义了这些空格会怎样？
ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list
# 错误：因为转义了两个空格，因此前三个文件被连接成了一个参数传递给了 'ls -l'
```

转义符也提供一种可以撰写多行命令的方式。通常，每一行是一个命令，但是转义换行后命令就可以在下一行继续撰写。

```bash
(cd /source/directory && tar cf - . ) | \
(cd /dest/directory && tar xpvf -)
# 回顾 Alan Cox 的目录树拷贝命令，但是把它拆成了两行。

# 或者你也可以：
tar cf - -C /source/directory . |
tar xpvf - -C /dest/directory
# 可以看下方的注释。
# （感谢 Stéphane Chazelas。）
```

> ![extra](http://tldp.org/LDP/abs/images/note.gif) 在脚本中，如果以 "|" 管道作为一行的结束字符，那么不需要加转义符 \ 也可以写多行命令。但是一个好的编程习惯就是在写多行命令的事后，无论什么情况都要在行尾加上转义符 \。

```bash
echo "foo
bar"
#foo
#bar

echo

echo 'foo
bar'    # 没有区别。
#foo
#bar

echo

echo foo\
bar     # 转义换行。
#foobar

echo

echo "foo\
bar"     # 没有区别，在弱引用中，\ 转义符仍旧转义了换行。
#foobar

echo

echo 'foo\
bar'     # 在强引用中，\ 就按照字面意思来解释了。
#foo\
#bar

# 由 Stéphane Chazelas 提供的例子。
```

## 6 退出与退出状态

> Bourne shell里存在不明确之处，但人们也会使用它们。
>
> —— Chat Ramey

跟C程序类似，`exit` 命令被用来结束脚本。同时，它也会返回一个值，返回值可以被交给父进程。

每个命令都会返回一个退出状态（exit status），有时也叫做返回状态（return status）或退出码（exit code）。命令执行成功返回0，如果返回一个非0值，通常情况下会被认为是一个错误代码。一个运行状态良好的UNIX命令、程序和工具在正常执行退出后都会返回一个0的退出码，当然也有例外。

同样地，脚本中的函数和脚本本身也会返回一个退出状态。在脚本或者脚本函数中执行的最后的命令会决定它们的退出状态。在脚本中，`exit nnn` 命令将会把nnn退出状态码传递给shell（nnn 必须是 0-255 之间的整型数）。

> ![note](images/note-1583304140613.gif) 当一个脚本以不带参数的 `exit` 来结束时，脚本的退出状态由脚本最后执行命令决定（`exit` 命令之前）。

```bash
#!/bin/bash

COMMAND_1

...

COMMAND_LAST

# 将以最后的命令来决定退出状态

exit
```

> `exit`，`exit $?` 以及省略 `exit` 效果等同。

```bash
#!/bin/bash 

COMMAND_1

...

COMMAND_LAST

#将以最后的命令来决定退出状态

exit $?
```

```bash
#!/bin/bash

COMMAND_1

...

COMMAND_LAST

#将以最后的命令来决定退出状态
```

`$?` 读取上一个执行命令的退出状态。在一个函数返回后，`$?` 给出函数最后执行的那条命令的退出状态。这就是Bash函数的"返回值"。

在[管道](http://tldp.org/LDP/abs/html/special-chars.html#PIPEREF)执行后，`$?` 给出最后执行的那条命令的退出状态。

在脚本终止后，命令行下键入`$?`会给出脚本的退出状态，即在脚本中最后一条命令执行后的退出状态。一般情况下，0为成功，1-255为失败。

样例 6-1. 退出与退出状态

```bash
#!/bin/bash

echo hello
echo $?    # 返回值为0，因为执行成功。

lskdf      # 不认识的命令。
echo $?    # 返回非0值，因为失败了。

echo

exit 113   # 将返回113给shell
           # 为了验证这些，在脚本结束的地方使用“echo $?”

#  按照惯例，'exit 0' 意味着执行成功，
#+ 非0意味着错误或者异常情况。
#  查看附录章节“退出码的特殊含义”
```

`$?` 对于测试脚本中的命令的执行结果特别有用（查看样例 16-35和样例 16-20）。

> ![note](http://tldp.org/LDP/abs/images/note.gif) 逻辑非操作符 [!](http://tldp.org/LDP/abs/html/special-chars.html#NOTREF) 将会反转测试或命令的结果，并且这将会影响退出状态。

样例 6-2. 否定一个条件使用!

```bash
true    # true 是 shell 内建命令。
echo "exit status of \"true\" = $?"     # 0

! true
echo "exit status of \"! true\" = $?"   # 1
# 注意在命令之间的 "!" 需要一个空格。
# !true 将导致一个"command not found"错误。
#
# 如果一个命令以'!'开头，那么将调用 Bash 的历史机制，显示这个命令被使用的历史。

true
!true
# 这次就没有错误了，但是同样也没有反转。
# 它不过是重复之前的命令（true）。


# ============================================================ #
# 在 _pipe_ 前使用 ! 将改变返回的退出状态。
ls | bogus_command      #bash: bogus_command: command not found
echo $?                 #127
>
! ls | bogus_command    #bash: bogus_command:command not found
echo $?                 #0
# 注意 ! 不会改变管道的执行。
# 只改变退出状态。
#============================================================  #
>
# 感谢 Stéphane Chazelas 和 Kristopher Newsome。
```

> ![caution](images/caution-1583304140626.gif) 某些特定的退出码具有一些特定的[保留含义](http://tldp.org/LDP/abs/html/exitcodes.html#EXITCODESREF)，用户不应该在自己的脚本中重新定义它们。

## 7 测试

每一个完备的程序设计语言都可以对一个条件进行判断，然后根据判断结果执行相应的指令。Bash 拥有 [`test`](http://tldp.org/LDP/abs/html/testconstructs.html#TTESTREF) 命令，[双方括号](http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS)、[双圆括号](http://tldp.org/LDP/abs/html/testconstructs.html#DBLPARENSTST) 测试操作符以及 `if/then` 测试结构。

### 7.1 测试结构

- `if/then` 结构是用来检测一系列命令的 [退出状态](http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF) 是否为0（按 UNIX 惯例,退出码 0 表示命令执行成功），如果为0，则执行接下来的一个或多个命令。

- 测试结构会使用一个特殊的命令 `[`（参看特殊字符章节 [左方括号](http://tldp.org/LDP/abs/html/special-chars.html#LEFTBRACKET)）。等同于 `test` 命令，它是一个[内建命令](http://tldp.org/LDP/abs/html/internal.html#BUILTINREF)，写法更加简洁高效。该命令将其参数视为比较表达式或文件测试，以比较结果作为其退出状态码返回（0 为真，1 为假）。

- Bash 在 2.02 版本中引入了扩展测试命令 [`[[...]]`]，它提供了一种与其他语言语法更为相似的方式进行比较操作。注意， `[[` 是一个 [关键字](http://tldp.org/LDP/abs/html/internal.html#KEYWORDREF) 而非一个命令。

  Bash 将 `[[ $a -lt $b ]]` 视为一整条语句，执行并返回退出状态。

- 结构 [`(( ... ))`](http://tldp.org/LDP/abs/html/dblparens.html) 和 [`let ...`](http://tldp.org/LDP/abs/html/internal.html#LETREF) 根据其执行的算术表达式的结果决定退出状态码。这样的 [算术扩展](http://tldp.org/LDP/abs/html/arithexp.html#ARITHEXPREF) 结构可以用来进行 [数值比较](http://tldp.org/LDP/abs/html/comparison-ops.html#ICOMPARISON1)。

```bash
(( 0 && 1 ))                 # 逻辑与
echo $?     # 1     ***
# 然后 ...
let "num = (( 0 && 1 ))"
echo $num   # 0
# 然而 ...
let "num = (( 0 && 1 ))"
echo $?     # 1     ***


(( 200 || 11 ))              # 逻辑或
echo $?     # 0     ***
# ...
let "num = (( 200 || 11 ))"
echo $num   # 1
let "num = (( 200 || 11 ))"
echo $?     # 0     ***


(( 200 | 11 ))               # 按位或
echo $?                      # 0     ***
# ...
let "num = (( 200 | 11 ))"
echo $num                    # 203
let "num = (( 200 | 11 ))"
echo $?                      # 0     ***

# "let" 结构的退出状态与双括号算术扩展的退出状态是相同的。
```

![caution](images/caution-1583304562255.gif) 注意，双括号算术扩展表达式的退出状态码不是一个错误的值。算术表达式为0，返回1；算术表达式不为0，返回0。

```bash
var=-2 && (( var+=2 ))
echo $?                   # 1

var=-2 && (( var+=2 )) && echo $var
                          # 并不会输出 $var, 因为((var+=2))的状态码为1
```

- `if` 不仅可以用来测试括号内的条件表达式，还可以用来测试其他任何命令。

```bash
if cmp a b &> /dev/null  # 消去输出结果
then echo "Files a and b are identical."
else echo "Files a and b differ."
fi

# 下面介绍一个非常实用的 “if-grep" 结构：
# -----------------------------------
if grep -q Bash file
  then echo "File contains at least one occurrence of Bash."
fi
    
word=Linux
letter_sequence=inu
if echo "$word" | grep -q "$letter_sequence"
# 使用 -q 选项消去 grep 的输出结果
then
  echo "$letter_sequence found in "$word"
else
  echo "$letter_sequence not found in $word"
fi


if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED
  then echo "Command succeed."
  else echo "Command failed."
fi
```

- 感谢 Stéphane Chazelas 提供了后两个例子。

样例 7-1. 什么才是真？

```bash
#!/bin/bash

# 提示：
# 如果你不确定某个表达式的布尔值，可以用 if 结构进行测试。

echo

echo "Testing \"0\""
if [ 0 ]
then
  echo "0 is true."
else
  echo "0 is false."
fi            # 0 为真。

echo

echo "Testing \"1\""
if [ 1 ]
then
  echo "1 is true."
else
  echo "1 is false."
fi            # 1 为真。

echo

echo "Testing \"-1\""
if [ -1 ]
then
  echo "-1 is true."
else
  echo "-1 is false."
fi            # -1 为真。

echo

echo "Testing \"NULL\""
if [ ]        # NULL, 空
then
  echo "NULL is true."
else
  echo "NULL is false."
fi            # NULL 为假。

echo

echo "Testing \"xyz\""
if [ xyz ]    # 字符串
then
  echo "Random string is true."
else
  echo "Random string is false."
fi            # 随机字符串为真。

echo

echo "Testing \"$xyz\""
if [ $xyz ]   # 原意是测试 $xyz 是否为空，但是
              # 现在 $xyz 只是一个没有初始化的变量。
then
  echo "Uninitialized variable is true."
else
  echo "Uninitialized variable is flase."
fi            # 未初始化变量含有null空值，为假。

echo

echo "Testing \"-n \$xyz\""
if [ -n "$xyz" ]            # 更加准确的写法。
then
  echo "Uninitialized variable is true."
else
  echo "Uninitialized variable is false."
fi            # 未初始化变量为假。

echo


xyz=          # 初始化为空。

echo "Testing \"-n \$xyz\""
if [ -n "$xyz" ]
then
  echo "Null variable is true."
else
  echo "Null variable is false."
fi            # 空变量为假。

echo

# 什么时候 "false" 为真？

echo "Testing \"false\""
if [ "false" ]              #  看起来 "false" 只是一个字符串
then
  echo "\"false\" is true." #+ 测试结果为真。
else
  echo "\"false\" is false."
fi            # "false" 为真。

echo

echo "Testing \"\$false\""  # 未初始化的变量。
if [ "$false" ]
then
  echo "\"\$false\" is true."
else
  echo "\"\$false\" is false."
fi            # "$false" 为假。
              # 得到了我们想要的结果。

# 如果测试空变量 "$true" 会有什么样的结果？

echo

exit 0
```

练习：理解 [样例 7-1](http://tldp.org/LDP/abs/html/testconstructs.html#EX10)

```bash
if [ condition-true ]
then
   command 1
   command 2
   ...
else  # 如果测试条件为假，则执行 else 后面的代码段
   command 3
   command 4
   ...
fi
```

![note](images/note-1583304562259.gif) 如果把 `if` 和 `then` 写在同一行时，则必须在 `if` 语句后加上一个分号来结束语句。因为 `if` 和 `then` 都是 [关键字](http://tldp.org/LDP/abs/html/internal.html#KEYWORDREF)。以关键字（或者命令）开头的语句，必须先结束该语句(分号;)，才能执行下一条语句。

```bash
if [ -x "$filename" ]; then
```

#### 7.1.1 Else if 与 elif

elif

`elif` 是 `else if` 的缩写。可以把多个 `if/then` 语句连到外边去，更加简洁明了。

```bash
if [ condition1 ]
then
   command1
   command2
   command3
elif [condition2 ]
# 等价于 else if
then
   command4
   command5
else
   default-command
fi
```

`if test condition-true` 完全等价于 `if [ condition-true ]`。当语句开始执行时，左括号 `[` 是作为调用 `test` 命令的标记，而右括号则不严格要求，但在新版本的 Bash 里，右括号必须补上。

![note](images/note-1583304562259.gif) `test` 命令是 Bash 的 [内建命令](http://tldp.org/LDP/abs/html/internal.html#BUILTINREF)，可以用来检测文件类型和比较字符串。在 Bash 脚本中，`test` 不调用 `sh-utils` 包下的文件 `/usr/bin/test`。同样，`[` 也不会调用链接到 `/usr/bin/test` 的 `/usr/bin/[` 文件。

```
bash$ type test
test is a shell builtin
bash$ type '['
[ is a shell builtin
bash$ type '[['
[[ is a shell keyword
bash$ type ']]'
]] is a shell keyword
bash$ type ']'
bash: type: ]: not found
```

如果你想在 Bash 脚本中使用 `/usr/bin/test`，那你必须把路径写全。

样例 7-2. `test`，`/usr/bin/test`，`[]` 和 `/usr/bin/[` 的等价性

```bash
#!/bin/bash

echo

if test -z "$1"
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo

if /usr/bin/test -z "$1"      # 等价于内建命令 "test"
#  ^^^^^^^^^^^^^              # 指定全路径
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo

if [ -z "$1" ]                # 功能和上面的代码相同。
#   if [ -z "$1"                理论上可行，但是 Bash 会提示缺失右括号
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo


if /usr/bin/[ -z "$1" ]       # 功能和上面的代码相同。
# if /usr/bin/[ -z "$1"       # 理论上可行，但是会报错
#                             # 已经在 Bash 3.x 版本被修复了
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo

exit 0
```

在 Bash 里，``[[ ]]`` 是比 `[ ]` 更加通用的写法。其作为扩展`test` 命令从 ksh88 中被继承了过来。


在 ``[[`` 和 ``]]`` 中不会进行文件名扩展或字符串分割，但是可以进行参数扩展和命令替换。

```bash
file=/etc/passwd

if [[ -e $file ]]
then
  echo "Password file exists."
fi
```

使用 ``[[...]]`` 代替 ``[...]``可以避免很多逻辑错误。比如可以在 ``[[]]`` 中使用 ``&&``，``||``，`<` 和 `>` 运算符，而在 `[]` 中使用会报错。

在 ``[[]]`` 中会自动执行八进制和十六进制的进制转换操作。

```bash
# [[ 八进制和十六进制进制转换 ]]
# 感谢 Moritz Gronbach 提出。


decimal=15
octal=017   # = 15 (十进制)
hex=0x0f    # = 15 (十进制)

if [ "$decimal" -eq "$octal" ]
then
  echo "$decimal equals $octal"
else
  echo "$decimal is not equal to $octal"       # 15 不等于 017
fi      # 在单括号 [ ] 之间不会进行进制转换。


if [[ "$decimal" -eq "$octal" ]]
then
  echo "$decimal equals $octal"                # 15 等于 017
else
  echo "$decimal is not equal to $octal"
fi      # 在双括号 [[ ]] 之间会进行进制转换。

if [[ "$decimal" -eq "$hex" ]]
then
  echo "$decimal equals $hex"                  # 15 等于 0x0f
else
  echo "$decimal is not equal to $hex"
fi      # 十六进制也可以进行转换。
```

![note](http://tldp.org/LDP/abs/images/note.gif) 语法上并不严格要求在 `if` 之后一定要写 `test` 命令或者测试结构（`[]` 或 `[[]]`）。

```bash
dir=/home/bozo

if cd "$dir" 2>/dev/null; then   # "2>/dev/null" 重定向消去错误输出。
  echo "Now in $dir."
else
  echo "Can't change to $dir."
fi
```

`if COMMAND` 的退出状态就是`COMMAND` 的退出状态。

同样的，测试括号也不一定需要与 `if` 一起使用。其可以同 [列表结构](http://tldp.org/LDP/abs/html/list-cons.html#LISTCONSREF) 结合而不需要 `if`。

```bash
var1=20
var2=22
[ "$var1" -ne "$var2" ] && echo "$var1 is not equal to $var2"

home=/home/bozo
[ -d "$home" ] || echo "$home directory does not exist."
```

[`(( ))` 结构](http://tldp.org/LDP/abs/html/dblparens.html) 扩展和执行算术表达式。如果执行结果为0，其返回的 [退出状态码](http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF) 为1（假）。非0表达式返回的退出状态为0（真）。这与上述所使用的 `test` 和 `[ ]` 结构形成鲜明的对比。

样例 7-3. 使用 `(( ))` 进行算术测试

```bash
#!/bin/bash
# arith-tests.sh
# 算术测试。

# (( ... )) 结构执行并测试算术表达式。
# 与 [ ... ] 结构的退出状态正好相反。

(( 0 ))
echo "Exit status of \"(( 0 ))\" is $?."         # 1

(( 1 ))
echo "Exit status of \"(( 1 ))\" is $?."         # 0

(( 5 > 4 ))                                      # 真
echo "Exit status of \"(( 5 > 4 ))\" is $?."     # 0

(( 5 > 9 ))                                      # 假
echo "Exit status of \"(( 5 > 9 ))\" is $?."     # 1

(( 5 == 5 ))                                     # 真
echo "Exit status of \"(( 5 == 5 ))\" is $?."    # 0
# (( 5 = 5 )) 会报错。

(( 5 - 5 ))                                      # 0
echo "Exit status of \"(( 5 - 5 ))\" is $?."     # 1

(( 5 / 4 ))                                      # 合法
echo "Exit status of \"(( 5 / 4 ))\" is $?."     # 0 

(( 1 / 2 ))                                      # 结果小于1
echo "Exit status of \"(( 1 / 2 ))\" is $?."     # 舍入至0。
                                                 # 1

(( 1 / 0 )) 2>/dev/null                          # 除0，非法
#           ^^^^^^^^^^^
echo "Exit status of \"(( 1 / 0 ))\" is $?."     # 1

# "2>/dev/null" 的作用是什么？
# 如果将其移除会发生什么？
# 尝试移除这条语句并重新执行脚本。

# ======================================= #

# (( ... )) 在 if-then 中也非常有用

var1=5
var2=4

if (( var1 > var2 ))
then #^      ^      注意不是 $var1 和 $var2，为什么？
  echo "$var1 is greater then $var2"
fi     # 5 大于 4

exit 0
```

### 7.2 文件测试操作

下列每一个运算符在满足其下条件时，返回的结果为真。

**-e**

检测文件是否存在

**-a**

检测文件是否存在

等价于 `-e`。不推荐使用，已被弃用。

**-f**

文件是常规文件(regular file)，而非目录或 [设备文件](http://tldp.org/LDP/abs/html/devref1.html#DEVFILEREF)

**-s**

文件大小不为0

**-d**

文件是一个目录

**-b**

文件是一个 [块设备](http://tldp.org/LDP/abs/html/devref1.html#BLOCKDEVREF)

**-c**

文件是一个 [字符设备](http://tldp.org/LDP/abs/html/devref1.html#CHARDEVREF)

```bash
device0="/dev/sda2"    # /   (根目录)
if [ -b "$device0" ]
then
  echo "$device0 is a block device."
fi

# /dev/sda2 是一个块设备。



device1="/dev/ttyS1"   # PCMCIA 调制解调卡
if [ -c "$device1" ]
then
  echo "$device1 is a character device."
fi

# /dev/ttyS1 是一个字符设备。
```

**-p**

文件是一个 [管道设备](http://tldp.org/LDP/abs/html/special-chars.html#PIPEREF)

```bash
function show_input_type()
{
   [ -p /dev/fd/0 ] && echo PIPE || echo STDIN
}

show_input_type "Input"                           # STDIN
echo "Input" | show_input_type                    # PIPE

# 这个例子由 Carl Anderson 提供。
```

**-h**

文件是一个 [符号链接](http://tldp.org/LDP/abs/html/basic.html#SYMLINKREF)

**-L**

文件是一个符号链接

**-S**

文件是一个 [套接字](http://tldp.org/LDP/abs/html/devref1.html#SOCKETREF)

**-t**

文件（[文件描述符](http://tldp.org/LDP/abs/html/io-redirection.html#FDREF)）与终端设备关联

该选项通常被用于 [测试](http://tldp.org/LDP/abs/html/intandnonint.html#II2TEST) 脚本中的 `stdin [ -t 0 ]` 或 `stdout [ -t 1 ]` 是否为终端设备。

**-r**

该文件对执行测试的用户可读

**-w**

该文件对执行测试的用户可写

**-x**

该文件可被执行测试的用户所执行

**-g**

文件或目录设置了 set-group-id `sgid` 标志

如果一个目录设置了 `sgid` 标志，那么在该目录中所有的新建文件的权限组都归属于该目录的权限组，而非文件创建者的权限组。该标志对共享文件夹很有用。

**-u**

文件设置了 set-user-id `suid` 标志。

一个属于 root 的可执行文件设置了 `suid` 标志后，即使是一个普通用户执行也拥有 root 权限[^2]。对需要访问硬件设备的可执行文件（例如 `pppd` 和 `cdrecord`）很有用。如果没有 `suid` 标志，这些可执行文件就不能被非 root 用户所调用了。

```
-rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd
```

设置了 `suid` 标志后，在权限中会显示 `s`。

**-k**

设置了粘滞位(sticky bit)。

标志粘滞位是一种特殊的文件权限。如果文件设置了粘滞位，那么该文件将会被存储在高速缓存中以便快速访问[^3]。如果目录设置了该标记，那么它将会对目录的写权限进行限制，目录中只有文件的拥有者可以修改或删除文件。设置标记后你可以在权限中看到 `t`。

```
drwxrwxrwt    7 root         1024 May 19 21:26 tmp/
```

如果一个用户不是设置了粘滞位目录的拥有者，但对该目录有写权限，那么他仅仅可以删除目录中他所拥有的文件。这可以防止用户不经意间删除或修改其他人的文件，例如 `/tmp` 文件夹。（当然目录的所有者可以删除或修改该目录下的所有文件）

**-O**

执行用户是文件的拥有者

**-G**

文件的组与执行用户的组相同

**-N**

文件在在上次访问后被修改过了

**f1 -nt f2**

文件 f1 比文件 f2 新

**f1 -ot f2**

文件 f1 比文件 f2 旧

**f1 -ef f2**

文件 f1 和文件 f2 硬链接到同一个文件

**!**

取反——对测试结果取反(如果条件缺失则返回真)。

样例 7-4. 检测链接是否损坏

```bash
#!/bin/bash
# broken-link.sh
# Lee bigelow <ligelowbee@yahoo.com> 编写。
# ABS Guide 经许可可以使用。

#  该脚本用来发现输出损坏的链接。输出的结果是被引用的，
#+ 所以可以直接导到 xargs 中进行处理 ：）
#  例如：sh broken-link.sh /somedir /someotherdir|xargs rm
#
#  更加优雅的方式：
#
#  find "somedir" -type 1 -print0|\
#  xargs -r0 file|\
#  grep "broken symbolic"|
#  sed -e 's/^\|: *broken symbolic.*$/"/g'
#
#  但是这种方法不是纯 Bash 写法。
#  警告：小心 /proc 文件下的文件和任意循环链接！
############################################


#  如果不给脚本传任何参数，那么 directories-to-search 设置为当前目录
#+ 否则设置为传进的参数
#####################

[ $# -eq 0 ] && directory=`pwd` || directory=$@


#  函数 linkchk 是用来检测传入的文件夹中是否包含损坏的链接文件，
#+ 并引用输出他们。
#  如果文件夹中包含子文件夹，那么将子文件夹继续传给 linkchk 函数进行检测。
#################

linkchk () {
    for element in $1/*; do
      [ -h "$element" -a ! -e "$element" ] && echo \"$element\"
      [ -d "$element" ] && linkchk $element
    # -h 用来检测是否是链接，-d 用来检测是否是文件夹。
    done
}

#  检测传递给 linkchk() 函数的参数是否是一个存在的文件夹，
#+ 如果不是则报错。
################
for directory in $direcotrys; do
    if [ -d $directory ]
        then linkchk $directory
        else
            echo "$directory is not a directory"
            echo "Usage $0 dir1 dir2 ..."
    fi
done

exit $?
```

### 7.3 其他比较操作

二元比较操作比较变量或者数量。注意整数和字符串比较使用的是两套运算符。

#### 7.3.1 整数比较

* -eq	等于

  `if [ "$a" -eq "$b" ]`

* -ne     不等于

  `if [ "$a" -ne "$b" ]`

* -gt    大于

  `if [ "$a" -gt "$b" ]`

* -ge    大于等于

  `if [ "$a" -ge "$b" ]`

* -lt    小于

  `if [ "$a" -lt "$b" ]`

* -le    小于等于

  `if [ "$a" -le "$b" ]`

* <    小于（使用 [双圆括号](http://tldp.org/LDP/abs/html/dblparens.html)）

  `(("$a" < "$b"))`

* <=    小于等于（使用双圆括号）

  `(("$a" <= "$b"))`

* \>    大于（使用双圆括号）

  `(("$a" > "$b"))`

* \>=    大于等于（使用双圆括号）

  `(("$a" >= "$b"))`

#### 7.3.2 字符串比较

* =    等于

  `if [ "$a" = "$b" ]`

  >  ![caution](images/caution.gif) 注意在`=`前后要加上[空格](http://tldp.org/LDP/abs/images/caution.gif)

  `	if [ "$a"="$b" ]` 和上面不等价。

* ==     等于

  `if [ "$a" == "$b" ]`

  和 `=` 同义

  > ![note](images/note.gif) `==` 运算符在 [双方括号](http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS) 和单方括号里表现不同。

  ```bash
  [[ $a == z* ]]   # $a 以 "z" 开头时为真（模式匹配）
  [[ $a == "z*" ]] # $a 等于 z* 时为真（字符匹配）
  
  [ $a == z* ]     # 发生文件匹配和字符分割。
  [ "$a" == "z*" ] # $a 等于 z* 时为真（字符匹配）
  
  # 感谢 Stéphane Chazelas
  ```

* !=    不等于

  `if [ "$a" != "$b" ]`

  在 [`[[ ... ]]`]结构中会进行模式匹配。

* <    小于，按照 [ASCII码](http://tldp.org/LDP/abs/html/special-chars.html#ASCIIDEF) 排序。

  `if [[ "$a" < "$b" ]]`

  `if [ "$a" \< "$b" ]`

  > 注意在 `[]` 结构里 `<` 需要被 [转义](http://tldp.org/LDP/abs/html/escapingsection.html#ESCP)。

* \>    大于，按照 ASCII 码排序。

  `if [[ "$a" > "$b" ]]`

  `if [ "$a" \> "$b" ]`

  >  注意在 `[]` 结构里 `>` 需要被转义。

  [样例 27-11](http://tldp.org/LDP/abs/html/arrays.html#BUBBLE) 包含了比较运算符。

* -z    字符串为空，即字符串长度为0。

  ```bash
  String=''   # 长度为0的字符串变量。
  
  if [ -z "$String" ]
  then
    echo "\$String is null."
  else
    echo "\$String is NOT null."
  fi     # $String is null.
  ```

* -n    字符串非空（`null`）。

  > ![caution](images/caution.gif) 使用 `-n` 时字符串必须是在括号中且被引用的。使用 `! -z` 判断未引用的字符串或者直接判断（[样例 7-6](http://tldp.org/LDP/abs/html/comparison-ops.html#STRTEST)）通常可行，但是非常危险。判断字符串时一定要引用[^1]。

样例 7-5. 算术比较和字符串比较

```bash
#!/bin/bash

a=4
b=5

# 这里的 "a" 和 "b" 可以是整数也可以是字符串。
# 因为 Bash 的变量是弱类型的，因此字符串和整数比较有很多相同之处。

# 在 Bash 中可以用处理整数的方式来处理全是数字的字符串。
# 但是谨慎使用。

echo

if [ "$a" -ne "$b" ]
then
  echo "$a is not equal to $b"
  echo "(arithmetic comparison)"
fi

echo

if [ "$a" != "$b" ]
then
  echo "$a is not equal to $b."
  echo "(string comparison)"
  #     "4"  != "5"
  # ASCII 52 != ASCIII 53
fi

# 在这个例子里 "-ne" 和 "!=" 都可以。

echo

exit 0
```

样例 7-6. 测试字符串是否为空（`null`）

```bash
#!/bin/bash
# str-test.sh: 测试是否为空字符串或是未引用的字符串。

# 使用 if [ ... ] 结构

# 如果字符串未被初始化，则其值是未定义的。
# 这种状态就是空 "null"（并不是 0）。

if [ -n $string1 ]    # 并未声明或是初始化 string1。
then
  echo "String \"string1\" is not null."
else
  echo "String \"string1\" is null."
fi
# 尽管没有初始化 string1，但是结果显示其非空。

echo

# 再试一次。

if [ -n "$string1" ]   # 这次引用了 $string1。
then
  echo "String \"string1\" is not null."
else
  echo "String \"string1\" is null."
fi                    # 在测试括号内引用字符串得到了正确的结果。

echo

if [ $string1 ]       # 这次只有一个 $string1。
then
  echo "String \"string1\" is not null."
else
  echo "String \"string1\" is null."
fi                    # 结果正确。
# 独立的 [ ... ] 测试运算符可以用来检测字符串是否为空。
# 但是最好将字符串进行引用（if [ "$string1" ]）。
#
# Stephane Chazelas 指出：
#    if [ $string1 ]    只有一个参数 "]"
#    if [ "$string1" ]  则有两个参数，空的 "$string1" 和 "]"


echo


string1=initialized

if [ $string1 ]       # $string1 这次仍然没有被引用。
then
  echo "String \"string1\" is not null."
else
  echo "String \"string1\" is null."
fi                    # 这次的结果仍然是正确的。
# 最好将字符串引用（"$string1"）


string1="a = b"

if [ $string1 ]       # $string1 这次仍然没有被引用。
then
  echo "String \"string1\" is not null."
else
  echo "String \"string1\" is null."
fi                    # 这次没有引用就错了。

exit 0   # 同时感谢 Florian Wisser 的提示。
```

样例 7-7. `zmore`

```bash
#!/bin/bash
# zmore

# 使用筛选器 'more' 查看 gzipped 文件。

E_NOARGS=85
E_NOTFOUND=86
E_NOTGZIP=87

if [ $# -eq 0 ] # 作用和 if [ -z "$1" ] 相同。
# $1 可以为空： zmore "" arg2 arg3
then
  echo "Usage: `basename $0` filename" >&2
  # 将错误信息通过标准错误 stderr 进行输出。
  exit $E_NOARGS
  # 脚本的退出状态为 85.
fi

filename=$1

if [ ! -f "$filename" ]   # 引用字符串以防字符串中带有空格。
then
  echo "File $filename not found!" >&2   # 通过标准错误 stderr 进行输出。
  exit $E_NOTFOUND
fi

if [ ${filename##*.} != "gz" ]
# 在括号内使用变量代换。
then
  echo "File $1 is not a gzipped file!"
  exit $E_NOTGZIP
fi

zcat $1 | more

# 使用筛选器 'more'
# 也可以用 'less' 替代

exit $?   # 脚本的退出状态由管道 pipe 的退出状态决定。
#  实际上 "exit $?" 不一定要写出来，
#+ 因为无论如何脚本都会返回最后执行命令的退出状态。
```

#### 7.3.4 复合比较

* -a    逻辑与

  `exp1 -a exp2` 返回真当且仅当 `exp1` 和 `exp2` 均为真。

* -o    逻辑或

  如果 `exp1` 或 `exp2` 为真，则 `exp1 -o exp2` 返回真。

以上两个操作和 [双方括号](http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS) 结构中的 Bash 比较运算符号 `&&` 和 `||` 类似。

```bash
[[ condition1 && condition2 ]]
```

测试操作 `-o` 和 `-a` 可以在 [`test`](http://tldp.org/LDP/abs/html/testconstructs.html#TTESTREF) 命令或在测试括号中进行。

```bash
if [ "$expr1" -a "$expr2" ]
then
  echo "Both expr1 and expr2 are true."
else
  echo "Either expr1 or expr2 is false."
fi
```

![caution](images/caution.gif) rihad 指出：

```bash
[ 1 -eq 1 ] && [ -n "`echo true 1>&2`" ]   # 真
[ 1 -eq 2 ] && [ -n "`echo true 1>&2`" ]   # 没有输出
# ^^^^^^^ 条件为假。到这里为止，一切都按预期执行。

# 但是
[ 1 -eq 2 -a -n "`echo true 1>&2`" ]       # 真
# ^^^^^^^ 条件为假。但是为什么结果为真？

# 是因为括号内的两个条件子句都执行了么？
[[ 1 -eq 2 && -n "`echo true 1>&2`" ]]     # 没有输出
# 并不是。

#  所以显然 && 和 || 具备“短路”机制，
#+ 例如对于 &&，若第一个表达式为假，则不执行第二个表达式直接返回假，
#+ 而 -a 和 -o 则不是。
```

复合比较操作的例子可以参考 [样例 8-3](http://tldp.org/LDP/abs/html/ops.html#ANDOR)，[样例 27-17](http://tldp.org/LDP/abs/html/arrays.html#TWODIM) 和 [样例 A-29](http://tldp.org/LDP/abs/html/contributed-scripts.html#WHX)。

### 7.4 嵌套 if/then 条件测试

可以嵌套 `if/then` 条件测试结构。嵌套的结果等价于使用 [`&&`](http://tldp.org/LDP/abs/html/ops.html#LOGOPS1) 复合比较运算符。

```bash
a=3

if [ "$a" -gt 0 ]
then
  if [ "$a" -lt 5 ]
  then
    echo "The value of \"a\" lies somewhere between 0 and 5."
  fi
fi

# 和下面的结果相同

if [ "$a" -gt 0 ] && [ "$a" -lt 5 ]
then
  echo "The value of \"a\" lies somewhere between 0 and 5."
fi
```

在 [样例 37-4](http://tldp.org/LDP/abs/html/bashver2.html#CARDS) 和 [样例 17-11](http://tldp.org/LDP/abs/html/system.html#BACKLIGHT) 中展示了嵌套 `if/then` 条件测试结构。

## 8 运算符相关话题

# 第三部分 shell进阶

## 9 换个角度看变量

在脚本中恰当的使用变量可以增强脚本并提高适应性。因此就需要了解变量的微妙之处和细微差异。

### 9.1 内部变量

#### 9.1.1 内建变量

影响 Bash 脚本行为的变量。

**$BASH**

Bash程序的路径。

```bash
bash$ echo $BASH
/bin/bash
```

**$BASH_ENV**

这个环境变量会指向一个 Bash 启动文件，该文件在脚本被调用时会被读取。

**$BASH_SUBSHELL**

该变量用于提示所处的 subshell 层级。这是在 Bash version 3 中被引入的新特性。

具体用法可以参考 [样例21-1](http://tldp.org/LDP/abs/html/subshells.html#SUBSHELL)。

**$BASHPID**

当前 Bash 进程实例的进程ID号。虽然与 `$$` 变量不一样，但是通常它们会给出相同的结果。

```bash
bash4$ echo $$
11015


bash4$ echo $BASHPID
11015


bash4$ ps ax | grep bash4
11015 pts/2    R      0:00 bash4
```

然而...

```bash
#!/bin/bash4

echo "\$\$ outside of subshell = $$"                              # 9602
echo "\$BASH_SUBSHELL  outside of subshell = $BASH_SUBSHELL"      # 0
echo "\$BASHPID outside of subshell = $BASHPID"                   # 9602

echo

( echo "\$\$ inside of subshell = $$"                             # 9602
  echo "\$BASH_SUBSHELL inside of subshell = $BASH_SUBSHELL"      # 1
  echo "\$BASHPID inside of subshell = $BASHPID" )                # 9603
  #  注意 $$ 总是返回父进程的 PID。
```

**$BASH_VERSINFO[n]**

这是一个6个元素的数组，其中包含了已经安装的 Bash 的版本信息。该变量与变量 `$BASH_VERSION` 类似，但是更加详细。

```bash
# Bash 版本信息：

for n in 0 1 2 3 4 5
do
  echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
done

# BASH_VERSINFO[0] = 3                      # 主版本号
# BASH_VERSINFO[1] = 00                     # 次版本号
# BASH_VERSINFO[2] = 14                     # 补丁号
# BASH_VERSINFO[3] = 1                      # 构建版本号
# BASH_VERSINFO[4] = release                # 发行状态
# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # 架构
                                            # (与 $MACHTYPE 相同)
```

**$BASH_VERSION**

已经安装的 Bash 的版本信息。

```bash
bash$ echo $BASH_VERSION
3.2.25(1)-release
```

```bash
tcsh% echo $BASH_VERSION
BASH_VERSION: Undefined variable.
```

利用 `$BASH_VERSION` 来判断运行的是哪个 shell 是一个不错的方法，因为变量 `$SHELL` 并不总是能够给出正确的答案。

**$CDPATH**

变量指定 `cd` 命令可以搜索的路径，路径之间用冒号进行分隔。该变量的功能类似于指定可执行文件搜索路径的变量 `$PATH`。可以在本地文件 `~/.bashrc` 中设置该变量。

```bash
bash$ cd bash-doc
bash: cd : bash-doc: No such file or directory


bash$ CDPATH=/usr/share/doc
bash$ cd bash-doc
/usr/share/doc/bash-doc


bash$ echo $PWD
/usr/share/doc/bash-doc
```

**$DIRSTACK**

指代目录栈中顶部的值，目录栈由命令 `pushd` 和 `popd` 控制。

该变量相当于命令 `dirs`，但是 `dirs` 命令会显示整个目录栈。

**$EDITOR**

脚本所调用的默认编辑器，通常是 `vi` 或是 `emcas`。

**$EUID**

有效用户ID。

有效用户ID（EUID）是指当前用户正在使用的用户ID，可以通过 `su` 命令修改。

{% hint style="warning" %}

`$EUID` 与 `$UID` 并不总是相同的。

{% endhint %}

**$FUNCNAME**

当前运行函数的函数名。

``` bash
xyz23 ()
{
  echo "$FUNCNAME now executing."  # xyz2 now executing.
}

xyz23

echo "FUNCNAME = $FUNCNAME"        # FUNCNAME =
                                   # 如果在函数外则为空值。 
```

可以参考 [样例 A-50]()。

**$GLOBIGNORE**

在[文件匹配](../part5/18_2_globbing.md)时所忽略的文件名模式列表。

**$GROUPS**

当前用户所属的用户组。

该变量存储了当前用户所归属的用户组ID列表，是一个数组。内容与记录在文件 `/etc/passwd` 和文件 `/etc/group` 中的一致。

```bash
root# echo $GROUPS
0


root# echo ${GROUPS[1]}
1


root# echo ${GROUPS[5]}
6
```

**$HOME**

当前用户的主目录，其值通常为 `/home/username` （参考 [样例 10-7]()）。

**$HOMENAME**

系统启动的初始化脚本通过命令 `hostname` 给系统分配主机名。而函数 `gethostname()` 则是给 Bash 的内部变量 `$HOSTNAME` 赋值。可以参考 [样例 10-7]()。

**$HOSTTYPE**

主机类型。

类似变量 [`$MACHTYPE`]()，用于识别系统硬件信息。

```bash
bash$ echo $HOSTTYPE
i686
```

**$IFS**

内部字段分隔符。

该变量决定了 Bash 在解析字符串时如何去识别 [字段]() 或单词边界。

`$IFS` 的缺省值是空白符（空格，制表符以及换行符），但其可以被修改。例如你在处理逗号分隔的文件时可以将其设置为逗号。需要注意 [`$*`]() 使用保存在 `$IFS` 中的第一个字符。可以参考 [样例 5-1]()。

```bash
bash$ echo "$IFS"

(当 $IFS 设置为缺省值时，显示空行。)


bash$ echo "$IFS" | cat -vte
 ^I$
 $
(显示空白符：首先是一个空格，然后是 ^I [水平制表符]，
 然后是换行符，最后在末尾显示 "$"。)


bash$ bash -c 'set w x y z; IFS=":-;"; echo "$*"'
w:x:y:z
(从字符串中解析命令，然后将命令参数分配给位置参数。)
```

通过设置 `$IFS` 来忽略文件路径名中空格带来的影响。

```bash
IFS="$(printf '\n\t')"   # 按 David Wheeler 所述。
```

{% hint style="warning" %}

相比于其他字符，变量 `$IFS` 在处理空白符时有所不同。

样例 9-1. $IFS 与空白符

```bash
#!/bin/bash
# ifs.sh


var1="a+b+c"
var2="d-e-f"
var3="g,h,i"

IFS=+
# 加号会被解析成分隔符。
echo $var1     # a b c
echo $var2     # d-e-f
echo $var3     # g,h,i

echo

IFS="-"
# 恢复对加号的默认解析。
# 现在减号会被解析成分隔符。
echo $var1     # a+b+c
echo $var2     # d e f
echo $var3     # g,h,i

echo

IFS=","
# 现在逗号会被解析成分隔符。
# 恢复对减号的默认解析。
echo $var1     # a+b+c
echo $var2     # d-e-f
echo $var3     # g h i

echo

IFS=" "
# 现在空格会被解析成分隔符。
# 逗号恢复成默认解析。
echo $var1     # a+b+c
echo $var2     # d-e-f
echo $var3     # g,h,i

# ======================================================== #

# 然而...
# $IFS 处理空白符的方式不同其他字符。

output_args_one_per_line()
{
  for arg
  do
    echo "[$arg]"
  done #  ^    ^   为了获得更好的视觉体验，把参数放到了括号里。
}

echo; echo "IFS=\"  \""
echo "-------"

IFS=" "
var=" a  b c   "
#    ^ ^^   ^^^
output_args_one_per_line $var  # output_args_one_per_line `echo " a  b c   "`
# [a]
# [b]
# [c]


echo; echo "IFS=:"
echo "-----"

IFS=:
var=":a::b:c:::"               # 与上面一样的模式，
#    ^ ^^   ^^^                #+ 仅仅是将 " " 替换成了 ":" ...
output_args_one_per_line $var
# []
# [a]
# []
# [b]
# [c]
# []
# []

# 注意那些“空的”括号。
# 同样的情况也会出现在 awk 命令所使用的 "FS" 字段分隔符中。


echo

exit
```

{% endhint %}

（非常感谢 Stéphane Chazelas 提供了上面的样例并做出的详细说明。）

也可以参考 [样例 16-41]()，[样例 11-8]() 和 [样例19-14]()，获取更多使用 `$IFS` 的技巧。

**$IGNOREEOF**

忽略 EOF：用于指示 Shell 在注销前需要忽略多少个文件结束符(EOF，contrl-D)。

**$LC_COLLATE**

经常会在文件 [`.bashrc`]() 或是文件 `/etc/profile` 中被设置。该变量控制文件名扩展和模式匹配中的排序顺序。如果设置不得当，`LC_COLLATE` 将会导致 [文件名匹配]() 中出现非预期结果。


{% hint style="info" %}

在 Bash 2.05 版本之后，文件名匹配在不再区分中括号中字母的大小写。例如 `ls [A-M]*` 将会同时匹配 `File1.txt` 和 `file1.txt` 两个文件。如果想要恢复成之前的模式，则需要在文件 `/etc/profile` 或文件 `~/.bashrc` 中通过语句 `export LC_COLLATE=C` 设置 `LC_COLLATE` 的值为 `C`。

{% endhint %}

**$LC_CTYPE**

这个内部变量控制在 [文件匹配]() 和模式匹配中的字符解析行为。

**$LINENO**

该变量记录了其在脚本中被使用时所处行的行号。该变量只有在被使用时才有意义，在调试过程中非常有用。

```bash
# *** 调试部分起始 ***
last_cmd_arg=$_  # 保存最后的命令。

echo "At line number $LINENO, variable \"v1\" = $v1"
echo "Last command argument processed = $last_cmd_arg"
# *** 调试部分终止 ***
```

**$MACHTYPE**

设备类型。

识别系统硬件。

```bash
bash$ echo $MACHTYPE
i686
```

**$OLDPWD**

上一个工作目录(OLD-Print-Working-Directory)，也就是之前所在的目录。

**$OSTYPE**

操作系统类型。

```bash
bash$ echo $OSTYPE
linux
```

**$PATH**

可执行文件搜索路径，其值通常包含 `/usr/bin`，`/usr/X11R6/bin/`，`/usr/local/bin` 等路径。

给定一个命令，shell就会自动从搜索路径包含的目录中利用哈希表搜索该可执行命令。而搜索路径就保存在 [环境变量]() `$PATH` 中，其中包含的一系列目录则通过冒号进行分隔。通常情况下，`$PATH` 会定义在文件 `/etc/profile` 或文件 [`~/.bashrc`]() 中（参考 [附录 H]()）。

```bash
bash$ echo $PATH
/bin:/usr/bin:/usr/local/bin/:/usr/X11R6/bin:/sbin:/usr/sbin
```

`PATH=${PATH}:/opt/bin` 表示添加目录 `/opt/bin` 到当前的搜索路径中。在脚本中可以通过这种方式临时添加目录到搜索路径。而当脚本结束时，`$PATH` 就会恢复到原始值（类似于脚本这样的子进程所作出的修改，不会影响到例如 shell 这样的父进程的环境）。

{% hint style="info" %}

基于安全考虑，通常在 `$PATH` 中会省略当前工作目录 `./`。

{% endhint %}

**$PIPESTATUS**

该 [数组]() 变量保存了最后运行的前台 [管道]() 的 [退出状态(es)]()。

```bash
bash$ echo $PIPESTATUS
0

bash$ ls -al | bogus_command
bash: bogus_command: command not found
bash$ echo ${PIPESTATUS[1]}
127

bash$ ls -al | bogus_command
bash: bogus_command: command not found
bash$ echo $?
127
```

`$PIPESTATUS` 数组中的每一个元素都代表了该管道中相对应命令的退出状态。`$PIPESTATUS[0]` 表示管道中第一个命令的退出状态，`$PIPESTATUS[1]` 表示第二个命令的退出状态，以此类推。

{% hint style="warning" %}

在Bash 3.0 以下版本的登录shell中，变量 `$PIPESTATUS` 可能会包含一个不正确的 0 值。

```bash
tcsh% bash

bash$ who | grep nobody | sort
bash$ echo ${PIPESTATUS[*]}
0
```

如果脚本包含了上述代码，应该得到期望的输出是 0 1 0。

感谢 Wayne Pollock 指出了这个问题并提供了上述的样例。

{% endhint %}

{% hint style="info" %}

在某些场景下，`$PIPESTATUS` 变量将会产生非预期结果。

```bash
bash$ echo $BASH_VERSION
3.00.14(1)-release

bash$ ls | bogus_command | wc
bash: bogus_command: command not found
 0       0       0

bash$ echo ${PIPESTATUS[@]}
141 127 0
```

Chet Ramey 把上述非预期结果的原因归咎于 [`ls`]() 命令的行为。如果 `ls` 将结果输出到没有被读取的管道上，产生的 SIGPIPE 信号将会终止 `ls` 命令，同时其 [退出状态]() 从期望的 0 变为 141。而同样的情况也会发生在命令 `tr` 中。

{% endhint %}

{% hint style="info" %}

`$PIPESTATUS` 是一个易失的变量。该变量需要在目标管道执行完成后，且其他任何命令执行之前去捕获。

```bash
bash$ ls | bogus_command | wc
bash: bogus_command: command not found
 0       0                0

bash$ echo ${PIPESTATUS[@]}
0 127 0

bash$ echo ${PIPESTATUS[@]}
0
```

{% endhint %}

{% hint style="info" %}

在 `$PIPESTATUS` 不能给出所期望的信息的情况下，使用 [pipeline 选项]() 可能会有帮助。

{% endhint %}

**$PPID**

一个进程的 `$PPID` 即该进程的父进程的进程ID(pid)。[^2]

可以与命令 [`pidof`]() 进行比较。

**$PROMPT_COMMAND**

该变量存储在主提示符 `$PS1` 显示之前所需要执行的命令。

**$PS1**

主提示符，即在命令行中显示的提示符。

**$PS2**

次要提示符，当需要额外输入时出现的提示符。默认显示为 `>`。

**$PS3**

三级提示符，显示在 `select` 循环中（参考 [样例 11-30]()）。

**$PS4**

四级提示符，当使用 `-x [verbose trace]` [选项]() 调用脚本时显示的提示符。默认显示为 `+`。

其可以作为调试的辅助手段，把一些诊断信息显示在 `$PS4` 中可能会有帮助。

```bash
P4='$(read time junk < /proc/$$/schedstat; echo "@@@ $time @@@ " )'
# 根据 Erik Brandsberg 提供的建议。
set -x
# 可以在后面写各种命令...
```

**$PWD**

工作目录（你当前所在的目录）。

该变量是内建命令 [`pwd`]() 的翻版。

```bash
#!/bin/bash

E_WRONG_DIRECTORY=85

clear # 清空屏幕。

TargetDirectory=/home/bozo/projects/GreatAmericanNovel

cd $TargetDirectory
echo "Deleting stale files in $TargetDirectory."

if [ "$PWD" != "$TargetDirectory" ]
then    # 小心不要偶然清空了错误的目录。
  echo "Wrong directory!"
  echo "In $PWD, rather than $TargetDirectory!"
  echo "Bailing out!"
  exit $E_WRONG_DIRECTORY
fi

rm -rf *
rm .[A-Za-z0-9]*    # 删除隐藏文件。
# rm -f .[^.]* ..?*   删除那些以多个点开头的文件。
# (shopt -s dotglob; rm -f *)   这样写也可以。
# 感谢 S.C. 提出这点。

#  文件名可以包含ASCII码中范围为 0-255 的所有字符，
#+ 除了字符 "/"。
#  删除以一些特殊字符开头的文件，例如 -
#+ 留作练习。（提示： rm ./-weirdname 或者 rm -- -weirdname）
result=$?   # 删除操作的结果。如果删除成功，值为0。

echo
ls -al              # 是不是还有剩余没有删除的文件？
echo "Done."
echo "Old files deleted in $TargetDirectory."
echo

# 如果有其他需要，在这里完成。

exit $result
```

**$REPLY**

当没有给 [`read`]() 命令提供接收参数时的默认接收参数。该变量同样适用于 [`select`]() 菜单接收用户输入值的场景，需要注意的是，用户只需要输入菜单项的编号，而不需要输入完整的菜单项内容。

```bash
#!/bin/bash
# reply.sh

# REPLY 是 'read' 命令的默认接收参数。

echo
echo -n "What is your favorite vegetable? "
read

echo "Your favorite vegetable is $REPLY."
#  当且仅当 'read' 命令没有接收参数的时候，
#+ REPLY 才能保存最近一次 'read' 命令接收的值。

echo
echo -n "What is your favorite fruit? "
read fruit
echo "Your favorite fruit is $fruit."
echo "but..."
echo "Value of \$REPLY is still $REPLY."
#  因为变量 $fruit 接收了新一次 "read" 命令所读入的值，
#+ 所以 $REPLY 仍旧存储的是上一次接收的值。

echo

exit 0
```

**$SECONDS**

该变量记录到目前为止脚本执行的时间，单位为秒。

```bash
#!/bin/bash

TIME_LIMIT=10
INTERVAL=1

echo
echo "Hit Control-C to exit before $TIME_LIMIT seconds."
echo

while [ "$SECONDS" -le "$TIME_LIMIT" ]
do   #   $SECONDS 是一个 shell 的内部变量。
  if [ "$SECONDS" -eq 1 ]
  then
    units=second
  else
    units=seconds
  fi
  
  echo "This script has been running $SECONDS $units."
  #  在一台性能较差或负载过重的设备上，
  #+ 这个脚本可能会偶尔跳过几个计数。
  sleep $INTERVAL
done

echo -e "\a"  # 发出蜂鸣声！

exit 0
```

**$SHELLOPTS**

该只读变量记录了 shell 中已启用的 [选项]() 列表。

```bash
bash$ echo $SHELLOPTS
braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs
```

**$SHLVL**

当前 shell 的层级，即嵌套了多少层 Bash [^3]。如果命令行的层级 `$SHLVL` 为 1，那么在其中执行的脚本层级则增加到 2。

{% hint style="info" %}

该变量 [不受 subshell 影响]()。当你需要指出嵌套了多少层 subshell 时，需要使用变量 [`$BASH_SUBSHELL`](#$BASH_SUBSHELL)。

{% endhint %}

**$TMOUT**

如果 `$TMOUT` 被设为非 0 值 `time`，那么 shell 会在 `$time` 秒后超时，然后导致 shell 登出。

在 Bash 2.05b 版本之后，可以在脚本中将 `read` 命令与 `$TMOUT` 变量进行结合。

```bash
# 只能在 Bash 2.05b 及之后的版本中成功执行。

TMOUT=3    # 提示会在 3 秒后超时。

echo "What is your favorite song?"
echo "Quickly now, you only have $TMOUT seconds to answer!"
read song

if [ -z "$song" ]
then
  song="(no answer)"
  # 默认值。
fi

echo "Your favorite song is $song."
```

在脚本中，同样也存在其他一些实现超时功能的更复杂的方法。其中一个方法是设置一个循环的计时器，当脚本超时的时候，计时器会给脚本发送一个信号。同时，也需要一个处理信号的程序来 [捕获]()（参考 [样例 32-5]()）由循环计时器产生的中断。

样例 9-2. 限时输入

```bash
#!/bin/bash
# timed-input.sh

# TMOUT=3    在新版本的 Bash 中起效。

TIMER_INTERRUPT=14
TIMELIMIT=3  # 在该实例中设置为 3 秒。
             # 同样可以设置成其他值。
             
PrintAnswer()
{
  if [ "$answer" = TIMEOUT ]
  then
    echo $answer
  else       # 不要混淆了这两个实例。
    echo "Your favorite veggie is $answer"
    kill $!  #  终止在后台运行的
             #+ 不再被需要的 TimerOn 函数。
             #  $! 代表最后一个在后台运行的作业的进程ID。
  fi

}
                
                
TimerOn()
{
  sleep $TIMELIMIT && kill -s 14 $$ &
  # 等待 3 秒，然后给脚本发送一个信号。
}


Int14Vector()
{
  answer="TIMEOUT"
  PrintAnswer
  exit $TIMER_INTERRUPT
}

trap Int14Vector $TIMER_INTERRUPT
# 我们的目的就是通过时间中断 (14) 终止程序。

echo "What is your favorite vegetable "
TimerOn
read answer
PrintAnswer


#  必须承认，这个实现限时输入的方法并不优雅。
#  但利用 "read" 命令的 "-t" 选项可以简化这个操作。
#  参考脚本 "t-out.sh"。
#  思考一下，如果不是对用户的单次输入时间进行限制，
#+ 而是对整个脚本的运行时间进行限制，应该怎么做？

#  如果你需要更优雅的写法 ...
#+ 可以考虑用 C 或者 C++ 来编写应用，
#+ 并使用其中包含的类似 'alarm' 或是 ‘setitimer' 等合适的库函数来实现计时。

exit 0
```

还有一种方法是使用 [`stty`]()。

样例 9-3. 再来一次，限时输入

```bash
#!/bin/bash
# timeout.sh

#  该脚本由 Stephane Chazelas 编写，
#+ 并由本书作者修改。

INTERVAL=5                # 超时所需的时间间隔

timedout_read() {
  timeout=$1
  varname=$2
  old_tty_settings=`stty -g`
  stty -icanon min 0 time ${timeout}0
  eval read $varname      # 或者直接写成 read $varname
  stty "$old_tty_settings"
  # 参考 "stty" 的帮助页面 (man)。
}

echo; echo -n "What's your name? Quick! "
timedout_read $INTERVAL your_name

#  该脚本也许并不能在所有类型的终端上正常运行。
#  最大的超时时间间隔依赖于终端。
#+ （通常是 25.5 秒）。

echo

if [ ! -z "$your_name" ]  # 如果在超时前输入了姓名 ...
then
  echo "Your name is $your_name."
else
  echo "Timed out."
fi

echo

# 该脚本的计时行为与 "timed-input.sh" 中的计时行为有所不同，
# 该脚本的计时器会在每次按键后被重置。

exit 0
```

可能最简单的方法就是利用 [`read`]() 命令的 `-t` 选项。

样例 9-4. 限时 read

```bash
#!/bin/bash
# t-out.sh [time-out]
# 从 "syngin seven" 的建议中所汲取的灵感，谢谢你们。


TIMELIMIT=4         # 4 秒

read -t $TIMELIMIT variable <&1
#                           ^^^
#  在这个实例中，只有 Bash 1.x 或 Bash 2.x 版本需要 "<&1"，
#  而在 Bash 3 及更高版本则不需要。

echo

if [ -z "$variable" ]  # 判断是否为空。
then
  echo "Timed out, variable still unset."
else
  echo "variable = $variable"
fi

exit 0
```

**$UID**

用户 ID。

记录在文件 [`/etc/passwd`]() 中当前用户的用户标识号。

该 ID 表示的是当前用户的真实 ID，即使用户通过 `su` 命令临时切换至另一个用户，这个 ID 也不会改变。`$UID` 是一个只读变量，不能够被命令行或是脚本中的命令所修改，并与内建命令 [`id`]() 相对应。

样例 9-5. 我是 root 用户吗？

```bash
#!/bin/bash
# am-i-root.sh:   我是否是 root 用户？

ROOT_UID=0   # Root 用户的 $UID 为 0。

if [ "$UID" -eq "$ROOT_UID" ]  # 只有真正的 "root" 用户才能经受得住考研。
then
  echo "You are root."
else
  echo "You are just an ordinary user (but mom loves you just the same)."
fi

exit 0


# ============================================================= #
# 下面的代码将不会被执行，因为脚本已经退出了。

# 另外一种判断是否是 root 用户的方法：

ROOTUSER_NAME=root

username=`id -nu`              # 或是...  username=`whoami`
if [ "$username" = "$ROOTUSER_NAME" ]
then
  echo "Rooty, toot, toot. You are root."
else
  echo "You are just a regular fella."
fi
```

还可以参考 [样例2-3]()。

{% hint style="info" %}

变量 `$ENV`，`$LOGNAME`，`$MAIL`，`$TERM`，`$USER` 以及 `$USERNAME` 并不是 Bash 的 [内建变量]()，而是在 [`Bash`]() 或系统的某个启动文件中，被设置而成的 [环境变量]()。代表当前用户登录 shell 名称的变量 `$SHELL` 是在文件 `/etc/password` 或是某个初始化脚本中被设定的，它也不是一个 Bash 的内建变量。

```bash
tcsh% echo $LOGNAME
bozo
tcsh% echo $SHELL
/bin/tcsh
tcsh% echo $TERM
rxvt

bash$ echo $LOGNAME
bozo
bash$ echo $SHELL
/bin/tcsh
bash$ echo $TERM
rxvt
```

{% endhint %}

#### 9.1.2 位置参数

**\$0, \$1, \$2 等**

位置参数。出现在从命令行传递给脚本、函数或是通过内建命令 [`set`]() 设置变量时（参考 [样例 4-5]() 或是 [样例 15-16]()）。

**$&#35;** 

命令行参数或是位置参数的个数（参考 [样例 36-2]()）。

**$***

将所有的位置参数整合，视作一个单词。

{% hint style="info" %}

该参数必须是被引用的状态，`"$*"`。

{% endhint %}

**$@**

该参数等同于 `$*`，但其中每个参数都是独立的被引用的字符串。也就是说，所有的参数都是被原封不动的进行传递，并没有被解析或是扩展。这意味着，参数列表中的每一个参数都被独立视为一个单词。

{% hint style="info" %}

同样，该参数必须是被引用的状态，`"$@"`。

{% endhint %}

样例 9-6. 参数列表：利用 \$* 和 \$@ 列出参数

```bash
#!/bin/bash
# arglist.sh
# 在调用该脚本时需要跟上一些参数，例如 "one two three" ...

E_BADARGS=85

if [ ! -n "$1" ]
then
  echo "Usage: `basename $0` argument1 argument2 etc."
  exit $E_BADARGS
fi

echo

index=1          # 初始化计数器。

echo "Listing args with \"\$*\":"
for arg in "$*"  # 如果这里没有引用 "$*"，脚本将不会正常运行。
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # $* 将所有参数视作一个单词。
echo "Entire arg list seen as single word."

echo

index=1          # 重置计数器。
                 # 如果忘了这一步将会发生什么？
                 
echo "Listing args with \"\$@\":"
for arg in "$@"
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # $@ 将所有参数视作独立的单词。
echo "Arg list seen as separate words."

echo

index=1          # 重置计数器。

echo "Listing args with \$* (unquoted):"
for arg in $*
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # 未被引用的 $* 将所有参数视作独立的单词。
echo "Arg list seen as separate words."

exit 0
```

在 `shift` 命令执行后，`$@` 将会保留除了 `$1` 之外的剩余的命令行参数，而 `$1` 则会被丢弃。

```bash
#!/bin/bash
# 使用 ./scriptname 1 2 3 4 5 调用脚本

echo "$@"    # 1 2 3 4 5
shift
echo "$@"    # 2 3 4 5
shift
echo "$@"    # 3 4 5

# 每一次 "shift" 都会丢弃参数 $1。
# "$@" 则包含了剩余的所有参数。
```

参数 `$@` 也可被用作过滤 shell 脚本输入的工具。结构 `cat "$@"` 可以接受来自标准输入 `stdin` 的输入，也可以接受传递给脚本的参数中的文件中的输入。参考 [样例 16-24]() 和 [样例 16-25]()。

{% hint style="warning" %}

根据分隔符 [`$IFS`]() 设置的不同，`$*` 和 `$@` 有时会出现不一致或非预期行为。

{% endhint %}

样例 9-7. \$* 和 \$@ 的不一致行为

```bash
#!/bin/bash

#  Bash 的内部变量 "$*" 和 "$@" 拥有不稳定的行为，
#+ 这些行为是否出现通常依赖于它们是否是被引用的状态。
#  下面的代码会演示在分词和换行时，这些变量所会出现的一些不一致的处理方式。


set -- "First one" "second" "third:one" "" "Fifth: :one"
# 设置脚本参数，$1, $2, $3 等等。

echo 

echo 'IFS unchanged, using "$*"'
c=0
for i in "$*"               # 被引用状态。
do echo "$((c+=1)): [$i]"   # 这一行在下面所有的例子中都保持不变。
                            # 输出参数。
done
echo ---

echo 'IFS unchanged, using $*'
c=0
for i in $*                 # 未被引用状态。
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS unchanged, using "$@"'
c=0
for i in "$@"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS unchanged, using $@'
c=0
for i in $@
do echo "$((c+=1)): [$i]"
done
echo ---

IFS=:
echo 'IFS=":", using "$*"'
c=0
for i in "$*"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $*'
c=0
for i in $*
do echo "$((c+=1)): [$i]"
done
echo ---

var=$*
echo 'IFS=":", using "$var" (var=$*)'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $var (var=$*)'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

var="$*"
echo 'IFS=":", using $var (var="$*")'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$var" (var="$*")'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$@"'
c=0
for i in "$@"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $@'
c=0
for i in $@
do echo "$((c+=1)): [$i]"
done
echo ---

var=$@
echo 'IFS=":", using $var (var=$@)'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$var" (var=$@)'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

var="$@"
echo 'IFS=":", using "$var" (var="$@")'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $var (var="$@")'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done

echo

# 尝试在 ksh 或是 zsh -y 下执行这个脚本。

exit 0

#  这个样例是由 Stephane Chazelas 所编写，
#+ 由本书作者轻微改动。
```

{% hint style="info" %}

`$@` 和 `$*` 仅在被双引号引用时才会表现出不同。

{% endhint %}

样例 9-8. 当 $IFS 为空时 \$* 和 \$@ 的表现

```bash
#!/bin/bash

#  如果 $IFS 被设置为空，
#+ 那么 "$*" 和 "$@" 将不会像期望的那样输出位置参数。

mecho ()       # 输出位置参数。
{
echo "$1,$2,$3";
}


IFS=""         # 设置为空。
set a b c      # 位置参数。

mecho "$*"     # abc,,
#                   ^^
mecho $*       # a,b,c

mecho $@       # a,b,c
mecho "$@"     # a,b,c

#  当 $IFS 为空时 $* 和 $@ 的行为
#+ 依赖于 Bash 或是 sh 所运行的版本。
#  因此不宜在脚本中使用这个“特性”。


# 感谢 Stephane Chazelas。

exit
```

#### 9.1.3 其他特殊参数

**$-**

使用 [`set`]() 命令设置的脚本标记。参考 [样例 15-16]()。

{% hint style="warning" %}

这个参数最开始是从 ksh 引入到 Bash中的。但很遗憾的是，该参数在 Bash 脚本中并不能可靠地运行。该参数可能的一个用法是用于 [自检脚本是否可交互]()。

{% endhint %}

**$!**

运行在后台的最后一个任务的 [进程ID]()。

```bash
LOG=$0.log

COMMAND1="sleep 100"

echo "Logging PIDs background commands for script: $0" >> "$LOG"
# 这样就可以监控命令，并在必要的时候终止它们。
echo >> "$LOG"

# 记录命令。

echo -n "PID of \"$COMMAND1\":  " >> "$LOG"
${COMMAND1} &
echo $! >> "$LOG"
# "sleep 100" 的 PID 是 1506

# 感谢 Jacques Lederer 提出的该建议。
```

将 `$!` 用于控制任务：

```bash
possibly_hanging_job & { sleep ${TIMEOUT}; eval 'kill -9 $!' &> /dev/null; }
# 强制终止一个出错的程序。
# 非常有用，例如可以用在启动脚本中。

# 感谢 Sylvain Fourmanoit 提出的这个利用变量 "$!" 的创造性用法。
```

也可以这么使用：

```bash
# 该样例由 Matthew Sage 编写。
# 本书经授权后使用。

TIMEOUT=30   # 以秒为单位的超时时间值。
count=0

possibly_hanging_job & {
        while ((count < TIMEOUT )); do
                eval '[ ! -d "/proc/$!" ] && ((count = TIMEOUT))'
                # 当前运行进程的详细信息都可以在 /proc 中找到。
                # "-d" 用于测试进程是否存在（即在 /proc 文件夹下该进程的文件夹是否存在）。
                # 我们在等待出问题的任务出现。
                ((count++))
                sleep 1
        done
        eval '[ -d "/proc/$!" ] && kill -15 $!'
        # 如果被挂起的任务正在运行就终止它。
}

#  -------------------------------------------------------------- #

#  然而，如果另外一个进程在 "hanging_job" 之后开始运行
#+ 该函数可能不能正常运行 ...
#  在那种情况下，一个非我们预期的任务会被终止。
#  Ariel Meragelman 提出了如下的解决方案。

TIMEOUT=30
count=0

possibly_hanging_job & {
    while ((count < TIMEOUT )); do
            eval '[ !-d "/proc/$lastjob" ] && ((count = TIMEOUT))'
            lastjob=$!
            ((count++))
            sleep 1
    done
    eval '[ -d "/proc/$lastjob" ] && kill -15 $lastjob'
}

exit
```

**$_**

该变量被设置为上一个执行的命令的最后一个参数。

样例 9-9. 下划线变量

```bash
#!/bin/bash

echo $_              #  /bin/bash
                     #  仅通过调用 /bin/bash 执行该脚本。
                     #  注意这个结果会根据脚本如何被调用
                     #+ 而有所不同。

du >/dev/null        #  这样命令就不会在命令行上有任何输出。
echo $_              #  du

ls -al >/dev/null    #  这样命令就不会在命令行上有任何输出。
echo $_              #  -al (最后一个参数)

:
echo $_              #  :
```

**$?**

命令、[函数]() 或是脚本自身的 [退出状态]()。参考 [样例 24-7]()。

**$$**

脚本自身的进程 ID[^5]。该变量 `$$` 通常在脚本构建独有的临时文件时被使用（参考 [样例 32-6]()，[样例 16-31]()，以及 [样例 15-27]()）。该方法通常比调用 [`mktemp`]() 命令更简单。

**注记**

{% hint style="info" %}
栈寄存器是一段连续的内存空间，在该空间中，存入（压栈）的值是以倒序的方式取出（出栈）的。最后一个存入的值被最先取出。其通常又被称为后进先出(LIFO)或是下堆栈。
{% endhint %}

{% hint style="info" %}
当前运行脚本的进程 ID 就是 `$$`。
{% endhint %}

{% hint style="info" %}
类似于 [递归]()。在本文中，嵌套是指代一种模式被嵌入在一种更大的模式中。在 1913 年出版的韦伯斯特大辞典中用一种更加优雅的方式解释了什么是嵌套：“一组按体积大小排列的盒子、箱子或是类似的东西，它们中的每一个都被放入到另一个更大的箱子中。(A collection of boxes, cases, or the like, of graduated size, each put within the one next larger.)”。
{% endhint %}

{% hint style="info" %}
术语“变量(argument)”和“参数(parameter)”通常情况下是可以互相交换使用的。在本书中，它们具有相同的含义：传入脚本或函数的变量。
{% endhint %}

{% hint style="info" %}
在 subshell 中运行的脚本，`$$` [返回脚本的进程 ID]() 而非 subshell 的。
{% endhint %}

### 9.2 变量类型标注：`declare` 与 `typeset`

[内建命令]() `declare` 和 `typeset` 是完全相同的命令，其被用于修改变量的属性。相比起一部分编程语言来说，这种修改属于非常弱的类型标注方式。`declare` 命令只有在 Bash version 2 及更高版本才能使用，而 `typeset` 命令可以在 ksh 脚本中运行。

#### 9.2.1 `declare`/`typeset` 命令选项

**-r 只读（readonly）**

（`declare -r var1` 与 `readonly var1` 的作用相同）

该选项约等于 C 语言中的类型限定符 `const`。任何尝试修改只读变量的行为都会导致脚本出错。

```bash
declare -r var1=1
echo "var1 = $var1"   # var1 = 1

(( var1++ ))          # x.sh: line 4: var1: readonly variable
```

**-i 整型（integer）**

```bash
declare -i number
# 脚本会将之后所有出现的 "number" 变量的类型都视作整型。

number=3
echo "Number = $number"     # Number = 3

number=three
echo "Number = $number"     # Number = 0
# 脚本试图将字符串 "three" 视为整型。
```

被视为整型的变量无需命令 [`expr`]() 或是 [`let`]() 即可进行数学运算。

```bash
n=6/3
echo "n = $n"       # n = 6/3

declare -i n
n=6/3
echo "n = $n"       # n = 2
```

**-a 数组（array）**

```bash
declare -a indices
```

变量 `indices` 会被视作 [数组]()。

**-f 函数（function）**

```bash
declare -f
```

如果没有在 `declare -f` 后带上任何参数，该语句将会列出在脚本中已经定义的所有函数。

```bash
declare -f function_name
```

而 `declare -f function_name` 则仅仅列出名为 `function_name` 的函数。

**-x 导出（export）**

```bash
declare -x var3
```

该语句声明了变量 `var3` 可以导出到该变量所属脚本之外的 shell 环境中。

**-x var=$value**

```bash
declare -x var3=373
```

`declare` 命令允许在设置变量属性的同时给变量赋值。

样例9-10. 使用 `declare` 命令标注变量类型

```bash
#!/bin/bash

func1 ()
{
  echo This is a function.
}

declare -f        # 显示上面的所有函数。

echo

declare -i var1   # var1 是一个整型变量。
var1=2367
echo "var1 declared as $var1"
var1=var1+1       # 整型变量的运算可以省略 let 命令。
echo "var1 incremented by 1 is $var1."
# 尝试修改整型变量。
echo "Attempting to change var1 to floating point value, 2367.1."
var1=2367.1       # 报错，并且 var1 的值并没有被修改。
echo "var1 is still $var1"

echo

declare -r var2=13.36         # 'declare' 允许在设置变量属性时，
                              #+ 同时给变量赋值。
echo "var2 declared as $var2" # 尝试修改只读变量。
var2=13.37                    # 报错，然后脚本异常结束。

echo "var2 is still $var2"    # 这行语句将不会被执行。

exit 0                        # 脚本也不会从这里结束。
```

{% hint style="warning" %}

使用内建命令 `declare` 还可以限制变量的 [作用域]()。

```bash
foo ()
{
FOO="bar"
}

bar ()
{
foo
echo $FOO
}

bar   # 输出 bar。
```

但是...

```bash
foo(){
declare FOO="bar"
}

bar ()
{
foo
echo $FOO
}

bar  # 什么都不会输出。


# 感谢 Michael Iatrou 指出这点。
```

{% endhint %}

**注记**

{% hint style="info" %}
在本书中，变量类型标注（typing）是指指定变量类型并限制其属性。例如一个变量被 `declared` 或是 `typed` 命令声明为整型，则该变量不再适用于各种 [字符串操作]()。

```bash
declare -i intvar

intvar=23
echo "$intvar"   # 23
intvar=stringval
echo "$intvar"   # 0
```

{% endhint %}

#### 9.2.2 `declare` 的另类用法

`declare` 命令可以帮助用户识别变量、[环境变量]() 或是其他信息，与 [数组]() 搭配效果更佳。

```bash
bash$ declare | grep HOME
HOME=/home/bozo


bash$ zzy=68
bash$ declare | grep zzy
zzy=68


bash$ Colors=([0]="purple" [1]="reddish-orange" [2]="light green")
bash$ echo ${Colors[@]}
purple reddish-orange light green
bash$ declare | grep Colors
Colors=([0]="purple" [1]="reddish-orange" [2]="light green")
```

### 9.3 `$RANDOM`：生成随机数

> 任何试图通过确定性方法生成随机数的行为都是在犯罪。
>
> —— 约翰·冯·诺伊曼

`$RANDOM` 是 Bash 中用来生成 0 至 32767 之间随机整数的一个内置 [函数]()（而非常量）。其**不应**被用于生成密钥。

样例 9-11. 生成随机数

```bash
#!/bin/bash

# $RANDOM 每一次调用都会返回一个随机的不同的整数。
# 随机数的标称范围为 0 - 32767（16位有符号整型）。

MAXCOUNT=10
count=1

echo
echo "$MAXCOUNT random numbers:"
echo "-----------------"
while [ "$count" -le $MAXCOUNT ]      # 生成 10 ($MAXCOUNT) 个随机整数。
do
  number=$RANDOM
  echo $number
  let "count += 1"  # 增加计数。
done
echo "-----------------"

# 如果你需要一个小于指定上界的随机数，可以使用 'modulo' 操作符。
# 该操作符可以返回除法后的余数。

RANGE=500

echo

number=$RANDOM
let "number %= $RANGE"
#           ^^
echo "Random number less than $RANGE --- $number"

echo



#  如果你需要生成的随机数大于一个指定的下界，
#+ 可以增加一步判断，判别并丢弃所有小于下界的数。

FLOOR=200

number=0   # 初始化
while [ "$number" -le $FLOOR ]
do
  number=$RANDOM
done
echo "Random number greater than $FLOOR --- $number"
echo

   # 现在来看一种可以代替上面循环的更简单的方式，也就是
   #       let "number = $RANDOM + $FLOOR"
   # 该方式可以不使用 while 循环，效率更高。
   # 但是，该方法可能会产生一些问题，是什么呢？



# 通过结合上面的两种方法，可以获得一个特定范围内的随机数。
number=0   # 初始化
while [ "$number" -le $FLOOR ]
do
  number=$RANDOM
  let "number %= $RANGE"  # 将 $number 缩小至 $RANGE 的范围内。
done
echo "Random number between $FLOOR and $RANGE --- $number"
echo



# 生成二元选择值，即真(true)或假(false)。
BINARY=2
T=1
number=$RANDOM

let "number %= $BINARY"
#  如果使用    let "number >>= 14"    可以获得更优的随机分布
#+ （除了最低位，其余二进制位都右移）。
if [ "$number" -eq $T ]
then
  echo "TRUE"
else
  echo "FALSE"
fi

echo


# 扔一个骰子。
SPOTS=6   # 模 6 的余数范围为 0 - 5。
          # 然后加 1 就可以得到期望的范围 1 - 6。
          # 感谢 Paulo Marcel Coelho Aragao 简化了代码。
die1=0
die2=0
# 如果设置 SPOTS=7 就可以不用加 1 得到值。这是不是一种更好的方法，为什么？

# 为了保证公平，独立的投每一个骰子。

    let "die1 = $RANDOM % $SPOTS + 1" # 投第一个骰子。
    let "die2 = $RANDOM % $SPOTS + 1" # 投第二个骰子。
    #  哪一种运算符有更高的优先级，
    #+ 取余(%)还是加法(+)？


let "throw = $die1 + $die2"
echo "Throw of the dice = $throw"
echo


exit 0
```

样例 9-12. 从牌组中随机选牌

```bash
#!/bin/bash
# pick-card.sh

# 该样例演示了如何从数组中随机选择元素。


# 随机选择任意一张牌。

Suites="Clubs
Diamonds
Hearts
Spades"

Denominations="2
3
4
5
6
7
8
9
10
Jack
Queen
King
Ace"

# 注意一个变量占了多行。


suite=($Suites)                # 读入数组变量。
denomination=($Denominations)

num_suites=${#suite[*]}        # 数组中的元素数量。
num_denominations=${#denomination[*]}

echo -n "${denomination[$((RANDOM%num_denominations))]} of "
echo ${suite[$((RANDOM%num_suites))]}


# $bozo sh pick-cards.sh
# Jack of Clubs


# 感谢 jipe 指出可以用 $RANDOM 随机选牌。
exit 0
```

Example 9-13. 模拟布朗运动

```bash
#!/bin/bash
# brownian.sh
# 作者：Mendel Cooper
# 发布日期：10/26/07
# 开源协议：GPL3

#  ----------------------------------------------------------------
#  该脚本模拟了布朗运动。
#+ 布朗运动是指微小粒子受到流体粒子随机碰撞，
#+ 而在流体中做的无规则随机运动。
#+ 也就是俗称的“醉汉走路”。

#  布朗运动也可以被视作是一个简化的高尔顿板。
#+ 高尔顿板是一个有着交错排列的钉子的倾斜板子，
#+ 每次可以从中向下滚动一堆石子。
#+ 在板子底端是一排槽位，
#+ 石子最后会落在槽位中。
#  把它想象成一个简单的弹珠游戏就可以了。
#  当运行这个脚本之后，
#+ 你就会发现大部分的石子都聚集在中间的槽位里。
#+ 这与预期的二项分布相符。
#  作为模拟高尔顿板的程序，
#+ 脚本忽略了许多参数，
#+ 例如板子的倾斜角度、石子滚动的摩擦系数、
#+ 冲击角度以及钉子的弹性系数等等。
#  忽略的这些参数能够在多大程度上影响模拟的精度？
#  -------------------------------------------------------------

PASSES=500            #  粒子作用数 / 石子数。
ROWS=10               #  碰撞数 / 每一排钉子的数量。
RANGE=3               #  $RANDOM 的输出范围为 0 - 2。
POS=0                 #  滚落左侧或是右侧。
RANDOM=$$             #  将脚本的进程 ID 作为
                      #+ 生成随机数的种子。

declare -a Slots      # 用于储存落入每一个槽位的石子数量。
NUMSLOTS=21           # 底部槽位的数量。


Initialize_Slots () { # 初始化数组。
for i in $( seq $NUMSLOTS )
do
  Slots[$i]=0
done

echo                  # 在正式模拟开始之前先输出空行。
  }


Show_Slots () {
echo; echo
echo -n " "
for i in $( seq $NUMSLOTS )   # 更精致地输出数组中的所有元素。
do
  printf "%3d" ${Slots[$i]}   # 每个结果都占三个字符的宽度。
done

echo # 槽位：
echo " |__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|"
echo "                                ||"
echo #  需要注意的是，如果任意一个槽位中石子的数量超过 99，
     #+ 将会打乱整个程序的显示效果。
     #  如果只运行 500 次通常可以避免这个问题。
  }


Move () {              # 将一个单位左移、右移或保持原地不动。
  Move=$RANDOM         # $RANDOM 到底有多随机？让我们看看...
  let "Move %= RANGE"  # 标准化至范围 0 - 2。
  case "$Move" in
    0 ) ;;                   # 什么也不做，也就是原地不动。
    1 ) ((POS--));;          # 左移。
    2 ) ((POS++));;          # 右移。
    * ) echo -n "Error ";;   # 出现异常！（应该永远不会发生）
  esac
  }


Play () {                    # 模拟单次运行（内部循环）。
i=0
while [ "$i" -lt "$ROWS" ]   # 每一排钉子经过且仅经过一次石子。
do
  Move
  ((i++));
done

SHIFT=11                     # 为什么是 11 而不是 10？
let "POS += $SHIFT"          # 将原点移到中间。
(( Slots[$POS]++ ))          # 调试：echo $POS

# echo -n "$POS "

  }


Run () {                     # 外部循环。
p=0
while [ "$p" -lt "$PASSES ]
do
  Play
  (( p++ ))
  POS=0                      # 重置为 0。为什么要这么做？
done
  }


# --------------
# main ()
Initialize_Slots
Run
Show_Slots
# --------------

exit $?

#  练习：
#  ---------
#  1) 将结果显示为一张直方图，
#+    或者是一张散点图。
#  2) 修改脚本，使用 /dev/urandom 提到 $RANDOM。
#     这会使脚本更加的随机化么？
#  3) 当每一个石子落下的时候，
#+    尝试添加一些动画效果。
```

Jipe 提供了一些生成指定范围内随机数的方法。

```bash
#  生成范围为 6 到 30 的随机数。
   rnumber=$((RANDOM%25+6))

#  生成范围为 6 到 30 的随机数，
#+ 并且该随机数能被 3 整除。
   rnumber=$(((RANDOM%30/3+1)*3))

#  需要注意这种方法并不是在所有情况下都能起效。
#  会在 $RANDOM%30 为 0 时失效。

#  Frank Wang 建议可以换用下面的方法：
   rnumber=$(( RANDOM%27/3*3+6 ))
```

Bill Gradwohl 提出了一种改良后的仅适用于正数的公式。

```bash
rnumber=$(((RANDOM%(max-min+divisibleBy))/divisibleBy*divisibleBy+min))
```

Bill 在这还给出了一个生成指定范围内随机数的通用函数。

样例 9-14. 指定范围随机数

```bash
#!/bin/bash
# random-between.sh
# 生成指定范围内的随机数。
# 本书作者在 Bill Gradwhol 所提供的脚本的基础上作了些细微修改。
# Anthony Le Clezio 修正了 187 行和 189 行。
# 本书被授权使用该脚本。


randomBetween() {
   #  生成一个范围在 $min 和 $max 之间，
   #+ 并且能被 $divisibleBy 整除的
   #+ 随机正数或负数。
   #  返回的随机数遵循合理的随机分布。
   
   #  Bill Gradwohl - Oct 1, 2003
   
   syntax() {
   # 嵌套函数。
      echo
      echo    "Syntax: randomBetween [min] [max] [multiple]"
      echo
      echo -n "Expects up to 3 passed parameters, "
      echo    "but all are completely optional."
      echo    "min is the minimum value"
      echo    "max is the maximum value"
      echo -n "multiple specifies that the answer must be "
      echo     "a multiple of this value."
      echo    "    i.e. answer must be evenly divisible by this number."
      echo
      echo    "If any value is missing, defaults area supplied as: 0 32767 1"
      echo -n "Successful completion returns 0, "
      echo      "unsuccessful completion returns"
      echo    "function syntax and 1."
      echo -n "The answer is returned in the global variable "
      echo    "randomBetweenAnswer"
      echo -n "Negative values for any passed parameter are "
      echo    "handled correctly."
   }
   
   local min=${1:-0}
   local max=${2:-32767}
   local divisibleBy=${3:-1}
   # 考虑到没有给函数传参的情况，给变量设置默认值。
   
   local x
   local spread
   
   # 确保 divisibleBy 的值为正数。
   [ ${divisibleBy} -lt 0 ] && divisibleBy=$((0-divisibleBy))
   
   # 合规校验。
   if [ $# -gt 3 -o ${divisibleBy} -eq 0 -o  ${min} -eq ${max} ]; then
      syntax
      return 1
   fi
   
   # 检查 min 和 max 的值是否颠倒。
   if [ ${min} -gt ${max} ]; then
      # 交换它们。
      x=${min}
      min=${max}
      max=${x}
   fi
   
   #  如果 min 值本身不能被 $divisibleBy 整除，
   #+ 则将其修正到范围内。
   if [ $((min/divisibleBy*divisibleBy)) -ne ${min} ]; then
      if [ ${min} -lt 0 ]; then
         min=$((min/divisibleBy*divisibleBy))
      else
         min=$((((min/divisibleBy)+1)*divisibleBy))
      fi
   fi
   
   #  如果 max 值本身不能被 $divisibleBy 整除，
   #+ 则将其修正到范围内。
   if [ $((max/divisibleBy*divisibleBy)) -ne ${max} ]; then
      if [ ${max} -lt 0 ]; then
         max=$((((max/divisibleBy)-1)*divisibleBy))
      else
         max=$((max/divisibleBy*divisibleBy))
      fi
   fi

   #  ---------------------------------------------------------------------
   #  接下来开始真正的内容。
   
   #  需要注意的是，为了得到端点间合理的随机分布，
   #+ 随机数的取值范围应是 0 至 abs(max-min)+divisibleBy，
   #+ 而不是简单的 abs(max-min)+1。
   
   #  少量的增长将会带来端点间
   #+ 合理的随机分布。
   
   #  将公式修改为使用 abs(max-min)+1 仍然可以得到正确的答案，
   #+ 但是获得的这些随机数的随机性是有缺陷的，
   #+ 因为这种情况下返回的端点值 ($min 和 $max) 的次数远少于
   #+ 使用正确公式时所返回的次数。
   #  ---------------------------------------------------------------------

   spread=$((max-min))
   #  Omair Eshkenazi 指出在这里没有必要进行校验，
   #+ 因为 max 和 min 的值已经被交换了。
   [ ${spread} -lt 0 ] && spread=$((0-spread))
   let spread+=divisibleBy
   randomBetweenAnswer=$(((RANDOM%spread)/divisibleBy*divisibleBy+min))
   
   return 0
   
   #  但是 Paulo Marcel Coelho Aragao 指出
   #+ 当 $max 和 $min 不能被 $divisibleBy 整除时，
   #+ 该公式就会失效。
   #
   #  他建议替换为下面的公式：
   #    rnumber = $(((RANDOM%(max-min+1)+min)/divisibleBy*divisibleBy))
   
}

# 接下来测试函数。
min=-14
max=20
divisibleBy=3


#  循环执行足够多次数的函数，生成包含这些随机数的数组，
#+ 然后校验数组中是否包含了端点范围内的每一个数字。

declare -a answer
minimum=${min}
maximum=${max}
   if [ $((minimum/divisibleBy*divisibleBy)) -ne ${minimum} ]; then
      if [ ${minimum} -lt 0 ]; then
         minimum=$((minimum/divisibleBy*divisibleBy))
      else
         minimum=$((((minimum/divisibleBy)+1)*divisibleBy))
      fi
   fi
   
   
   #  如果 max 值本身不能被 $divisibleBy 整除，
   #+ 则将其修正到范围内。
   
   if [ $((maximum/divisibleBy*divisibleBy)) -ne ${maximum} ]; then
      if [ ${maximum} -lt 0 ]; then
         maximum=$((((maximum/divisibleBy)-1)*divisibleBy))
      else
         maximum=$((maximum/divisibleBy*divisibleBy))
      fi
   fi


#  需要保证数组的下标只能为正数，
#+ 因此这里需要通过位移来保证
#+ 结果为正。

disp=$((0-minimum))
for ((i=${minimum}; i<=${maximum}; i+=divisibleBy)); do
   answer[i+disp]=0
done


# 现在开始循环执行函数以获得大量的随机数。
loopIt=1000   #  脚本的作者建议使用 100000，
              #+ 但是这会花费大量的时间。
              
for ((i=0; i<${loopIt}; i++)); do

   #  注意，我们在这里颠倒了 min 和 max 的值，
   #+ 为的是校验函数在这种情况下是否能正常执行。
   
   randomBetween ${max} ${min} ${divisibleBy}
   
   # 如果获得了非预期的答案，则报错。
   [ ${randomBetweenAnswer} -lt ${min} -o ${randomBetweenAnswer} -gt ${max} ] \
   && echo MIN or MAX error - ${randomBetweenAnswer}!
   [ $((randomBetweenAnswer%${divisibleBy})) -ne 0 ] \
   && echo DIVISIBLE BY error - ${randomBetweenAnswer}!
   
   # 保存统计结果。
   answer[randomBetweenAnswer+disp]=$((answer[randomBetweenAnswer+disp]+1))
done



# 校验最终结果。

for ((i=${minimum}; i<=${maximum}; i+=divisibleBy)); do
   [ ${answer[i+disp]} -eq 0 ] \
   && echo "We never got an answer of $i." \
   || echo "${i} occurred ${answer[i+disp]} times."
done

exit 0
```

那么 `$RANDOM` 到底有多随机？最好的测试方法就是写一个脚本跟踪由 `$RANDOM` 生成的随机数的分布。接下来让我们多投几次由 `$RANDOM` 做的骰子...

样例 9-15. 用 `RANDOM` 投骰子

```bash
#!/bin/bash
# RANDOM 有多随机？

RANDOM=$$       # 用脚本的进程 ID 重置随机数生成器种子。

PIPS=6          # 骰子有 6 个点。
MAXTHORWS=600   # 如果你没有更好消磨时间的办法，就增加这个值。
                # 投骰子的次数。

ones=0          #  必须初始化计数器的值为 0，
twos=0          #+ 因为未初始化的变量的值为 null 而非 0。
threes=0
fours=0
fives=0
sixes=0

print_result ()
{
echo
echo "ones =   $ones"
echo "twos =   $twos"
echo "threes = $threes"
echo "fours =  $fours"
echo "fives =  $fives"
echo "sixes =  $sixes"
echo
}

update_count()
{
case "$1" in
  0) ((ones++));;   # 因为骰子没有 0 点，所以这个其实对应的是 1 点。
  1) ((twos++));;   # 这个对应 2 点。
  2) ((threes++));; # 以此类推。
  3) ((fours++));;
  4) ((fives++));;
  5) ((sixes++));;
esac
}

echo


while [ "$throw" -lt "$MAXTHROWS" ]
do
  let "die1 = RANDOM % $PIPS"
  update_count $die1
  let "throw += 1"
done

print_result

exit $?

#  假设 RANDOM 是真随机，那么计数结果应该均匀分布。
#  当 $MAXTHROWS 的值为 600 时，每一个计数器的值都应该在 100 左右，
#+ 上下浮动大约 20。
#
#  记住 RANDOM 是一个 ***伪随机*** 生成器，
#+ 并且也不是其中最优秀的那一个。

#  随机化是一个很深奥且复杂的话题。
#  足够长的“随机”序列可能会出现一些
#+ 混乱或其他非随机化的表现。

# 练习（简单）：
# ---------------
# 重写脚本，修改为投掷硬币 1000 次。
# 显示为正面 "HEADS" 和背面 "TAILS"。
```

从上一个样例中我们可以发现，在每次调用 `RANDOM` 生成器时，最好利用重置生成器种子。在 `RANDOM` 生成器中使用相同的种子会生成相同序列的随机数。[^2]（与 C 语言中的 `random()` 函数的行为一致）

样例 9-16. 重置 `RANDOM` 种子

```bash
#!/bin/bash
# seeding-random.sh: 设置 RANDOM 变量的种子。
# 版本号 1.1, 发布日期 09 Feb 2013

MAXCOUNT=25       # 生成随机数的个数。
SEED=

random_numbers ()
{
local count=0
local number

while [ "$count" -lt "$MAXCOUNT" ]
do
  number=$RANDOM
  echo -n "$number "
  let "count++"
done
}

echo; echo

SEED=1
RANDOM=$SEED      # 设置变量 RANDOM 会为随机数生成器设置种子。
echo "Random seed = $SEED"
random_numbers

RANDOM=$SEED      # 同样的种子 ...
echo; echo "Again, with same random seed ..."
echo "Random seed = $SEED"
random_numbers    # ... 生成了同样的数字序列。
                  #
                  # 在什么情况下重复一个随机化序列会有用？
                  
echo; echo

SEED=2
RANDOM=$SEED      # 用不同的种子再试一次 ...
echo "Random seed = $SEED"
random_numbers    # ... 生成了不同的数字序列。

echo; echo

# RANDOM=$$  利用脚本的进程 ID 设置 RANDOM 的种子。
# 同样也可以利用 'time' 或是 'date' 命令设置 RANDOM 的种子。

# 更花哨一点的 ...
SEED=$(head -1 /dev/urandom | od -N 1 | awk '{ print $2 }'| sed s/^0*//)
#  从 /dev/urandom （系统的伪随机设备文件）中
#+ 获取伪随机输出，
#+ 然后通过 "od" 转换为可打印八进制字符行，
#+ 然后 "awk" 命令会检索出一个数字作为种子，
#+ 最后用 "sed" 命令删除数字前面所有的前置 0。
RANDOM=$SEED
echo "Random seed = $SEED"
random_numbers

echo; echo

exit 0
```

{% hint style="info" %}

伪设备文件 `/dev/urandom` 提供了比 `$RANDOM` 变量更随机化的伪随机数。命令 `dd if=/dev/urandom of=targetfile bs=1 count=XXX` 将会创建一个包含均匀分布的伪随机数的文件。但是想要在脚本中将这些随机数赋值给变量需要做一些变通，比如使用命令 [`od`]() 进行过滤（参照上面的样例以及 [样例 16-14]() 和 [样例 A-36]()）或者使用管道导入命令 [md5sum]() 中（参照 [样例 36-16]()）。

当然也有其他在脚本中生成伪随机数的方法。比如 `Awk` 命令就提供了这样一种非常简易的方法。

样例 9-17. 使用 [`awk`]() 命令生成伪随机数

```bash
#!/bin/bash
#  random2.sh: 返回大小在 0 - 1 内，
#+ 精度为小数点后 6 位的伪随机数。例如：0.822725
#  使用 awk rand() 函数。

AWKSCRIPT=' { srand(); print rand() } '
#           传递给 awk 的命令或参数
# 注意 srand() 重置了 awk 的随机数生成种子。


echo -n "Random number between 0 and 1 = "

echo | awk "$AWKSCRIPT"
# 如果省略 'echo' 将会发生什么？

exit 0


# 练习：
# ---------

# 1) 使用循环结构，输出 10 个不同的随机数。
#      （提示：你必须在每次循环中使用 srand() 函数重置种子以获得不同的随机数种子。
#+       如果你省略了这一步会发生什么？）

# 2) 利用整型乘数作为随机数的缩放因子，
#+   生成大小在 10 到 100 之间的随机数。

# 3) 内容与练习 #2 相同，只是这次生成随机整数。
```

同样，命令 [`date`]() 可以用于 [生成整型随机数序列]()。

{% endhint %}

**注记**

{% hint style="info" %}
真正的“随机性”，就其存在而言，只存在于一些类似放射性衰变这样还未被完全理解的自然现象中。计算机只能模拟这样的随机性，因此计算机生成的“随机数”序列被称作伪随机数。
{% endhint %}

{% hint style="info" %}
计算机用于生成伪随机数的种子可以被视作一个标识标签。例如，你可以将用种子 23 生成的随机数序列视作第23号序列。

伪随机数序列的一个属性是该序列在开始重复之前的周期长度。一个好的伪随机数生成器能够生成周期非常长的序列。
{% endhint %}

## 10 变量处理

### 10.1 字符串处理

Bash 支持的字符串操作数量达到了一个惊人的数目。但可惜的是，这些操作工具缺乏一个统一的核心。他们中的一些是[参数代换](http://tldp.org/LDP/abs/html/parameter-substitution.html#PARAMSUBREF)的子集，另外一些则是 UNIX 下 [`expr`](http://tldp.org/LDP/abs/html/moreadv.html#EXPRREF) 函数的子集。这将会导致语法前后不一致或者功能上出现重叠，更不用说那些可能导致的混乱了。

#### 10.1.1 字符串长度

`${#string}`

`expr length $string`

上面两个表达式等价于C语言中的 `strlen()` 函数。

`expr "$string" : '.*'`

```bash
stringZ=abcABC123ABCabc

echo ${#stringZ}                 # 15
echo `expr length $stringz`      # 15
echo `expr "$stringZ" : '.*'`    # 15
```

样例 10-1. 在文本的段落之间插入空行

```bash
#!/bin/bash
# paragraph-space.sh
# 版本 2.1，发布日期 2012年7月29日

# 在无空行的文本文件的段落之间插入空行。
# 像这样使用: $0 <FILENAME

MINLEN=60        # 可以试试修改这个值。它用来做判断。
#  假设一行的字符数小于 $MINLEN，并且以句点结束段落。
#+ 结尾部分有练习！

while read line  # 当文件有许多行的时候
do
  echo "$line"   # 输出行本身。
  
  len=${#line}
  if [[ "$len" -lt "$MINLEN" && "$line" =~ [*{\.}]$ ]]
# if [[ "$len" -lt "$MINLEN" && "$line" =~ \[*\.\] ]]
# 新版Bash将不能正常运行前一个版本的脚本。Ouch！
# 感谢 Halim Srama 指出这点，并且给出了修正版本。
    then echo    #  在该行以句点结束时，
  fi             #+ 增加一行空行。
done

exit

# 练习：
# -----
#  1) 该脚本通常会在文件的最后插入一个空行。
#+    尝试解决这个问题。
#  2) 在第17行仅仅考虑到了以句点作为句子终止的情况。
#+    修改以满足其他的终止符，例如 ?, ! 和 "。
```

#### 10.1.2 起始部分字符串匹配长度

`expr match "$string" '$substring'`

其中，`$substring` 是一个[正则表达式](http://tldp.org/LDP/abs/html/regexp.html#REGEXREF)。

`expr "$string" : '$substring'`

其中，`$substring` 是一个正则表达式。

```bash
stringZ=abcABC123ABCabc
#       |------|
#       12345678

echo `expr match "$stringZ" 'abc[A-Z]*.2'`   # 8
echo `expr "$stringZ" : 'abc[A-Z]*.2'`       # 8
```

#### 10.1.3 索引

`expr index $string $substring`

返回在 `$string` 中第一个出现的 `$substring` 字符所在的位置。

```bash
stringZ=abcABC123ABCabc
#       123456 ...
echo `expr index "$stringZ" C12`             # 6
                                             # C 的位置。
echo `expr index "$stringZ" 1c`              # 3
# 'c' (第三号位) 较 '1' 出现的更早。
```

几乎等价于C语言中的 `strchr()`。

#### 10.1.4 截取字符串（字符串分片）

`${string:position}`

在 `$string` 中截取自 `$position` 起的字符串。

如果参数 `$string` 是 "*" 或者 "@"，那么将会截取自 `$position` 起的[位置参数](http://tldp.org/LDP/abs/html/internalvariables.html#POSPARAMREF)。

`${string:position:length}`

在 `$string` 中截取自 `$position` 起，长度为 `$length` 的字符串。

```bash
stringZ=abcABC123ABCabc
#       0123456789.....
#       索引位置从0开始。

echo ${stringZ:0}                            # abcABC123ABCabc
echo ${stringZ:1}                            # bcABC123ABCabc
echo ${stringZ:7}                            # 23ABCabc

echo ${stringz:7:3}                          # 23A
                                             # 三个字符的子字符串。
                                             
                                             

# 从右至左进行截取可行么？

echo ${stringZ:-4}                           # abcABC123ABCabc
# ${parameter:-default} 将会得到整个字符串。
# 但是……

echo ${stringZ:(-4)}                         # Cabc
echo ${stringZ: -4}                          # Cabc
# 现在可以了。
# 括号或者增加空格都可以"转义"位置参数。

# 感谢 Dan Jacobson 指出这些。
```

其中，参数 `position` 与 `length` 可以传入一个变量而不一定需要传入常量。

样例 10-2. 产生一个8个字符的随机字符串

```bash
#!/bin/bash
# rand-string.sh
# 产生一个8个字符的随机字符串。

if [ -n "$1" ]  #  如果在命令行中已经传入了参数，
then            #+ 那么就以它作为起始字符串。
  str0="$1"
else            #  否则，就将脚本的进程标识符PID作为起始字符串。
  str0="$$"
fi

POS=2  # 从字符串的第二位开始。
LEN=8  # 截取八个字符。

str1=$( echo "$str0" | md5sum | md5sum )
#                      ^^^^^^   ^^^^^^
# 将字符串通过管道计算两次 md5 来进行两次混淆。

randstring="${str1:$POS:$LEN}"
#                  ^^^^ ^^^^
# 允许传入参数

echo "$randstring"

exit $?

# bozo$ ./rand-string.sh my-password
# 1bdd88c4

# 不过不建议将其作为一种能够抵抗黑客的生成密码的方法。
```

如果参数 `$string` 是 "*" 或者 "@"，那么将会截取自 `$position` 起，最大个数为 `$length` 的位置参数。

```bash
echo ${*:2}          # 输出第二个及之后的所有位置参数。
echo ${@:2}          # 同上。

echo ${*:2:3}        # 从第二个位置参数起，输出三个位置参数。 
```

`expr substr $string $position $length`

在 `$string` 中截取自 `$position` 起，长度为 `$length` 的字符串。

```bash
stringZ=abcABC123ABCabc
#       123456789......
#       索引位置从1开始。

echo `expr substr $stringZ 1 2`              # ab
echo `expr substr $stringZ 4 3`              # ABC
```

`expr match "$string" '\($substring\)'`

在 `$string` 中截取自 `$position` 起的字符串，其中 `$substring` 是[正则表达式](http://tldp.org/LDP/abs/html/regexp.html#REGEXREF)。

`expr "$string" : '\($substring\)'`

在 `$string` 中截取自 `$position` 起的字符串，其中 `$substring` 是正则表达式。

```bash
stringZ=abcABC123ABCabc
#       =======

echo `expr match "$stringZ" '\(.[b-c]*[A-Z]..[0-9]\)'`   # abcABC1
echo `expr "$stringZ" : '\(.[b-c]*[A-Z]..[0-9]\)'`       # abcABC1
echo `expr "$stringZ" : '\(.......\)'`                   # abcABC1
# 上面所有的形式都给出了相同的结果。
```

`expr match "$string" '.*\($substring\)'`

从 `$string` 结尾部分截取 `$substring` 字符串，其中 `$substring` 是正则表达式。

`expr "$string" : '.*\($substring\)'`

从 `$string` 结尾部分截取 `$substring` 字符串，其中 `$substring` 是正则表达式。

```bash
stringZ=abcABC123ABCabc
#                ======

echo `expr match "$stringZ" '.*\([A-C][A-C][A-C][a-c]*\)'`    # ABCabc
echo `expr "$stringZ" : '.*\(......\)'`                       # ABCabc
```

#### 10.1.5 删除子串

`${string#substring}`

删除从 `$string` 起始部分起，匹配到的最短的 `$substring`。

`${string##substring}`

删除从 `$string` 起始部分起，匹配到的最长的 `$substring`。

```bash
stringZ=abcABC123ABCabc
#       |----|          最长
#       |----------|    最短

echo ${stringZ#a*C}      # 123ABCabc
# 删除 'a' 与 'c' 之间最短的匹配。

echo ${stringZ##a*C}     # abc
# 删除 'a' 与 'c' 之间最长的匹配。



# 你可以使用变量代替 substring。

X='a*C'

echo ${stringZ#$X}      # 123ABCabc
echo ${stringZ##$X}     # abc
                        # 同上。
```

`${string%substring}`

删除从 `$string` 结尾部分起，匹配到的最短的 `$substring`。

例如：

```bash
# 将当前目录下所有后缀名为 "TXT" 的文件改为 "txt" 后缀。
# 例如 "file1.TXT" 改为 "file1.txt"。

SUFF=TXT
suff=txt

for i in $(ls *.$SUFF)
do
  mv -f $i $(i%.$SUFF).$suff
  #  除了从变量 $i 右侧匹配到的最短的字符串之外，
  #+ 其他一切都保持不变。
done ### 如果需要，循环可以压缩成一行的形式。

# 感谢 Rory Winston。
```

`${string%%substring}`

删除从 `$string` 结尾部分起，匹配到的最长的 `$substring`。

```bash
stringZ=abcABC123ABCabc
#                    ||     最短
#        |------------|     最长

echo ${stringZ%b*c}      # abcABC123ABCa
# 从结尾处删除 'b' 与 'c' 之间最短的匹配。

echo ${stringZ%%b*c}     # a
# 从结尾处删除 'b' 与 'c' 之间最长的匹配。
```

这个操作对生成文件名非常有帮助。

样例 10-3. 改变图像文件的格式及文件名

```bash
#!/bin/bash
#  cvt.sh:
#  将目录下所有的 MacPaint 文件转换为 "pbm" 格式。

#  使用由 Brian Henderson (bryanh@giraffe-data.com) 维护的
#+ "netpbm" 包下的 "macptobpm" 二进制工具。
#  Netpbm 是大多数 Linux 发行版的标准组成部分。

OPERATION=macptopbm
SUFFIX=pbm          # 新的文件名后缀。

if [ -n "$1" ]
then
  directory=$1      # 如果已经通过脚本参数传入了目录名的情况……
else
  directory=$PWD    # 否则就使用当前工作目录。
fi

#  假设目标目录下的所有 MacPaint 图像文件都拥有
#+ ".mac" 的文件后缀名。

for file in $directory/*    # 文件名匹配。
do
  filename=${file%.*c}      #  从文件名中删除 ".mac" 后缀
                            #+ ('.*c' 匹配 '.' 与 'c' 之间的
                            #  所有字符，包括其本身)。
  $OPERATION $file > "$filename.$SUFFIX"
                            # 将转换结果重定向到新的文件。
  rm -f $file               # 在转换后删除原文件。
  echo "$filename.$SUFFIX"  # 将记录输出到 stdout 中。
done

exit 0

# 练习：
# -----
# 这个脚本会将当前工作目录下的所有文件进行转换。
# 修改脚本，使得它仅转换 ".mac" 后缀的文件。



# *** 还可以使用另外一种方法。 *** #

#!/bin/bash
# 将图像批处理转换成不同的格式。
# 假设已经安装了 imagemagick。（在大部分 Linux 发行版中都有）

INFMT=png   # 可以是 tif, jpg, gif 等等。
OUTFMT=pdf  # 可以是 tif, jpg, gif, pdf 等等。

for pic in *"$INFMT"
do
  p2=$(ls "$pic" | sed -e s/\.$INFMT//)
  # echo $p2
  convert "$pic" $p2.$OUTFMT
done

exit $?
```

样例 10-4. 将流音频格式转换成 ogg 格式

```bash
#!/bin/bash
# ra2ogg.sh: 将流音频文件 (*.ra) 转换成 ogg 格式。

# 使用 "mplayer" 媒体播放器程序：
#      http://www.mplayerhq.hu/homepage
# 使用 "ogg" 库与 "oggenc"：
#      http://www.xiph.org/
#
# 脚本同时需要安装一些解码器，例如 sipr.so 等等一些。
# 这些解码器可以在 compat-libstdc++ 包中找到。


OFILEPREF=${1%%ra}      # 删除 "ra" 后缀。
OFILESUFF=wav           # wav 文件后缀。
OUTFILE="$OFILEPREF""$OFILESUFF"
E_NOARGS=85

if [ -z "$1" ]          # 必须指定一个文件进行转换。
then
  echo "Usage: `basename $0` [filename]"
  exit $E_NOAGRS
fi


######################################################
mplayer "$1" -ao pcm:file=$OUTFILE
oggenc "$OUTFILE"  # 由 oggenc 自动加上正确的文件后缀名。
######################################################

rm "$OUTFILE"      # 立即删除 *.wav 文件。
                   # 如果你仍需保留原文件，注释掉上面这一行即可。
                   
exit $?

#  注意：
#  -----
#  在网站上，点击一个 *.ram 的流媒体音频文件
#+ 通常只会下载到 *.ra 音频文件的 URL。
#  你可以使用 "wget" 或者类似的工具下载 *.ra 文件本身。


#  练习：
#  -----
#  这个脚本仅仅转换 *.ra 文件。
#  修改脚本增加适应性，使其可以转换 *.ram 或其他文件格式。
#
#  如果你非常有热情，你可以扩展这个脚本使其
#+ 可以自动下载并且转换流媒体音频文件。
#  给定一个 URL，自动下载流媒体音频文件 (使用 "wget")，
#+ 然后转换它。
```

下面是使用字符串截取结构对 [`getopt`](http://tldp.org/LDP/abs/html/extmisc.html#GETOPTY) 的一个简单模拟。

样例 10-5. 模拟 `getopt`

```bash
#!/bin/bash
# getopt-simple.sh
# 作者: Chris Morgan
# 允许在高级脚本编程指南中使用。


getopt_simple()
{
    echo "getopt_simple()"
    echo "Parameters are '$*'"
    until [ -z "$1" ]
    do
      echo "Processing parameter of: '$1'"
      if [ ${1:0:1} = '/' ]
      then
          tmp=${1:1}               # 删除开头的 '/'
          parameter=${tmp%%=*}     # 取出名称。
          value=${tmp##*=}         # 取出值。
          echo "Parameter: '$parameter', value: '$value'"
          eval $parameter=$value
      fi
      shift
    done
}

# 将所有参数传递给 getopt_simple()。
getopt_simple $*

echo "test is '$test'"
echo "test2 is '$test2'"

exit 0  # 可以查看该脚本的修改版 UseGetOpt.sh。

---

sh getopt_example.sh /test=value1 /test2=value2

Parameters are '/test=value1 /test2=value2'
Processing parameter of: '/test=value1'
Parameter: 'test', value: 'value1'
Processing parameter of: '/test2=value2'
Parameter: 'test2', value: 'value2'
test is 'value1'
test2 is 'value2'
```

#### 10.1.6 子串替换

`${string/substring/replacement}`

替换匹配到的第一个 `$substring` 为 `$replacement`。

`${string//substring/replacement}`

替换匹配到的所有 `$substring` 为 `$replacement`。

```bash
stringZ=abcABC123ABCabc

echo ${stringZ/abc/xyz}       # xyzABC123ABCabc
                              # 将匹配到的第一个 'abc' 替换为 'xyz'。
                              
echo ${stringZ//abc/xyz}      # xyzABC123ABCxyz
                              # 将匹配到的所有 'abc' 替换为 'xyz'。
                              
echo  ---------------
echo "$stringZ"               # abcABC123ABCabc
echo  ---------------
                              # 字符串本身并不会被修改！
                              
# 匹配以及替换的字符串可以是参数么？
match=abc
repl=000
echo ${stringZ/$match/$repl}  # 000ABC123ABCabc
#              ^      ^         ^^^
echo ${stringZ//$match/$repl} # 000ABC123ABC000
# Yes!          ^      ^        ^^^         ^^^

echo

# 如果没有给定 $replacement 字符串会怎样？
echo ${stringZ/abc}           # ABC123ABCabc
echo ${stringZ//abc}          # ABC123ABC
# 仅仅是将其删除而已。
```

`${string/#substring/replacement}`

替换 `$string` 中最前端匹配到的 `$substring` 为 `$replacement`。

`${string/%substring/replacement}`

替换 `$string` 中最末端匹配到的 `$substring` 为 `$replacement`。

```bash
stringZ=abcABC123ABCabc

echo ${stringZ/#abc/XYZ}          # XYZABC123ABCabc
                                  # 将前端的 'abc' 替换为 'XYZ'
                                  
echo ${stringZ/%abc/XYZ}          # abcABC123ABCXYZ
                                  # 将末端的 'abc' 替换为 'XYZ'
```

####  10.1.7 使用 `awk` 处理字符串

在 Bash 脚本中可以调用字符串处理工具 `awk` 来替换内置的字符串处理操作。

样例 10-6. 使用另一种方式来截取和定位子字符串

```bash
#!/bin/bash
# substring-extraction.sh

String=23skidoo1
#      012345678    Bash
#      123456789    awk
# 注意不同字符串索引系统：
# Bash 中第一个字符的位置为0。
# Awk 中第一个字符的位置为1。

echo ${String:2:4} # 从第3位开始（0-1-2），4个字符的长度
                                         # skid

# Awk 中与 ${string:pos:length} 等价的是 substr(string,pos,length)。
echo | awk '
{ print substr("'"${String}"'",3,4)      # skid
}
'
#  将空的 "echo" 通过管道传递给 awk 作为一个模拟输入，
#+ 这样就不需要提供一个文件名来操作 awk 了。

echo "----"

# 同样的：

echo | awk '
{ print index("'"${String}"'", "skid")      # 3
}                                           # （skid 从第3位开始）
'   # 这里使用 awk 等价于 "expr index"。

exit 0
```

### 10.2 参数替换

参数替换用来处理或扩展变量。

`${parameter}`

等同于 `$parameter`，是变量 parameter 的值。在一些特定的环境下，只允许使用不易混淆的 `${parameter}` 形式。

可以用于连接变量与字符串。

```bash
your_id=${USER}-on-${HOSTNAME}
echo "$your_id"
# 
echo "Old \$PATH = $PATH"
PATH=${PATH}:/opt/bin  # 在脚本执行过程中临时在 $PATH 中加入 /opt/bin。
echo "New \$PATH = $PATH"
```

`${parameter-default}, ${parameter:-default}`

在没有设置变量的情况下使用缺省值。

```bash
var1=1
var2=2
# 没有设置 var3。

echo ${var1-$var2}   # 1
echo ${var3-$var2}   # 2
#           ^          注意前面的 $ 前缀。



echo ${username-`whoami`}
# 如果变量 $username 没有被设置，输出 `whoami` 的结果。
```

> ![note](images/note-1583310494799.gif) `${parameter-default}` 与 `${parameter:-default}` 的作用几乎相同，唯一不同的情况就是当变量 parameter 已经被声明但值为空时。

```bash
#!/bin/bash
# param-sub.sh

# 无论变量的值是否为空，其是否已被声明决定了缺省设置的触发。

username0=
echo "username0 has been declared, but is set to null."
echo "username0 = ${username0-`whoami`}"
# 将不会输出 `whoami` 的结果。

echo

echo username1 has not been declared.
echo "username1 = ${username1-`whoami`}"
# 将会输出 `whoami` 的结果。

username2=
echo "username2 has been declared, but is set to null."
echo "username2 = ${username2:-`whoami`}"
#                            ^
# 因为这里是 :- 而不是 -，所以将会输出 `whoami` 的结果。
# 与上面的 username0 比较。


# 

# 再来一次：

variable=
# 变量已被声明，但其值为空。

echo "${varibale-0}"    # 没有输出。
echo "${variable:-1}"   # 1
#               ^

unser variable

echo "${variable-2}"    # 2
echo "${variable:-3}"   # 3

exit 0
```

当传入的命令行参数的数量不足时，可以使用这种缺省参数结构。

```bash
DEFAULT_FILENAME=generic.data
filename=${1:-$DEFAULT_FILENAME}
# 如果没有其他特殊情况，下面的代码块将会操作文件 "generic.data"。
# 代码块开始
# ...
# ...
# ...
# 代码块结束



# 摘自样例 "hanoi2.bash"：
DISKS=${1:-E_NOPARAM}   # 必须指定碟子的个数。
#  将 $DISKS 设置为传入的第一个命令行参数，
#+ 如果没有传入第一个参数，则设置为 $E_NOPARAM。
```

可以查看 [样例 3-4](http://tldp.org/LDP/abs/html/special-chars.html#EX58)，[样例 31-2](http://tldp.org/LDP/abs/html/zeros.html#EX73) 和 [样例 A-6](http://tldp.org/LDP/abs/html/contributed-scripts.html#COLLATZ)。

可以同 [使用与链设置缺省命令行参数](http://tldp.org/LDP/abs/html/list-cons.html#ANDDEFAULT) 做比较。

`${parameter=default}, ${parameter:=default}`

在没有设置变量的情况下，将其设置为缺省值。

两种形式的作用几乎相同，唯一不同的情况与上面类似，就是当变量 parameter 已经被声明但值为空时。[^1]

```bash
echo ${var=abc}   # abc
echo ${vat=xyz}   # abc
# $var 已经在第一条语句中被赋值为 abc，因此第二条语句将不会改变它的值。
```

`${parameter+alt_value}, ${parameter:+alt_value}`

如果变量已被设置，使用 alt_value，否则使用空值。

两种形式的作用几乎相同，唯一不同的情况就是当变量 parameter 已经被声明但值为空时，看下面的例子。

```bash
echo "###### \${parameter+alt_value} ########"
echo

a=${param1+xyz}
echo "a = $a"      # a =

param2=
a=${param2+xyz}
echo "a = $a"      # a = xyz

param3=123
a=${param3+xyz}
echo "a = $a"      # a = xyz

echo
echo "###### \${parameter:+alt_value} ########"
echo

a=${param4:+xyz}
echo "a = $a"      # a =

param5=
a=${param5:+xyz}
echo "a = $a"      # a =
# 不同于 a=${param5+xyz}

param6=123
a=${param6:+xyz}
echo "a = $a"      # a = xyz
```

`${parameter?err_msg}, ${parameter:?err_msg}`

如果变量已被设置，那么使用原值，否则输出 err_msg 并且终止脚本，返回 [错误码](http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF) 1。

两种形式的作用几乎相同，唯一不同的情况与上面类似，就是当变量 parameter 已经被声明但值为空时。

样例 10-7. 如何使用变量替换和错误信息

```bash
#!/bin/bash

# 检查系统环境变量。
# 这是一种良好的预防性维护措施。
# 如果控制台用户的名称 $USER 没有被设置，那么主机将不能够识别用户。

: ${HOSTNAME?} ${USER?} ${HOME?} ${MAIL?}
  echo
  echo "Name of the machine is $HOSTNAME."
  echo "You are $USER."
  echo "Your home directory is $HOME."
  echo "Your mail INBOX is located in $MAIL."
  echo
  echo "If you are reading this message,"
  echo "critcial environmental variables have been set."
  echo
  echo
  
# ------------------------------------------------------

# ${variablename?} 结构统一可以检查脚本中的变量是否被设置。

ThisVariable=Value-of-ThisVariable
# 顺带一提，这个字符串的值可以被设置成名称中不可以使用的禁用字符。
: ${ThisVariable?}
echo "Value of ThisVariable is $ThisVariable."

echo; echo


: ${ZZXy23AB?"ZZXy23AB has not been set."}
# 因为 ZZXy23AB 没有被设置，所以脚本会终止同时显示错误消息。

# 你可以指定错误消息。
# : ${variablename?"ERROR MESSAGE"}


# 与这些结果相同:  dummy_variable=${ZZXy23AB?}
#                 dummy_variable=${ZZXy23AB?"ZZXy23AB has not been set."}
#
#                 echo ${ZZXy23AB?} >/dev/null

# 将上面这些检查变量是否被设置的方法同 "set -u" 作比较。



echo "You will not see this message, because script already terminated."

HERE=0
exit $HERE   # 将不会从这里退出。

#  事实上，这个脚本将会返回退出码（echo $?）1。
```

样例 10-8. 参数替换与 "usage" 消息

```bash
#!/bin/bash
# usage-message.sh

: ${1?"Usage: $0 ARGUMENT"}
# 如果命令行参数缺失，脚本将会在这里结束，并且返回下面的错误信息。
#    usage-message.sh: 1: Usage: usage-message.sh ARGUMENT

echo "These two lines echo only if command-line parameter given."
echo "command-line parameter = \"$1\""

exit 0  # 仅当命令行参数存在是才会从这里退出。

# 在传入和未传入命令行参数的情况下查看退出状态。
# 如果传入了命令行参数，那么 "$?" 的结果是0。
# 如果没有，那么 "$?" 的结果是1。
```

参数替换用来处理或扩展变量。下面的表达式是对 `expr` 处理字符串的操作的补足（查看样例 16-9）。这些特殊的表达式通常养来解析文件的路径名。

#### 10.2.1 变量长度 / 删除子串

`${#var}`

字符串的长度（`$var` 中字符的个数）。对任意 [数组](http://tldp.org/LDP/abs/html/arrays.html#ARRAYREF) array，`${#array}` 返回数组中第一个元素的长度。

> ![note](http://tldp.org/LDP/abs/images/note.gif) 以下情况例外：
>
> * `${#*}` 和 `${#@}` 返回位置参数的个数。
> * 任意数组 array，`${#array[*]}` 和 `${#array[@]}` 返回数组中元素的个数。

样例 10-9. 变量长度

```bash
#!/bin/bash
# length.sh

E_NO_ARGS=65

if [ $# -eq 0 ]  # 脚本必须传入参数。
then
  echo "Please invoke this script with one or more command-line arguments."
  exit $E_NO_ARGS
fi

var01=abcdEFGH28ij
echo "var01 = ${var01}"
echo "Length of var01 = ${#var01}"
# 现在我们尝试加入空格。
var02="abcd EFGH28ij"
echo "var02 = ${var02}"
echo "Length of var02 = ${#var02}"

echo "Number of command-line arguments passed to script = ${#@}"
echo "Number of command-line arguments passed to script = ${#*}"

exit 0
```

`${var#Pattern}, ${var##Pattern}`

`${var#Pattern}` 删除 `$var` 前缀部分匹配到的最短长度的 `$Pattern`。

`${var##Pattern}` 删除 `$var` 前缀部分匹配到的最长长度的 `$Pattern`。

摘自 [样例 A-7](http://tldp.org/LDP/abs/html/contributed-scripts.html#DAYSBETWEEN) 的例子：

```bash
# 函数摘自样例 "day-between.sh"。
# 删除传入的参数中的前缀0。

strip_leading_zero () #  删除传入参数中可能存在的
{                     #+ 前缀0。
  return=${1#0}       #  "1" 代表 "$1"，即传入的参数。
}                     #  从 "$1" 中删除 "0"。
```

下面是由 Manfred Schwarb 提供的上述函数的改进版本：

```bash
strip_leading_zero2 () # 删除前缀0，
{                      # 否则 Bash 会将其解释为8进制数。
  shopt -s extglob     # 启用扩展通配特性。
  local val=${1##+(0)} # 使用本地变量，匹配前缀中所有的0。
  shopt -u extglob     # 禁用扩展通配特性。
  _strip_leading_zero2=${var:-0}
                       # 如果输入的为0，那么返回 0 而不是 ""。
```

另外一个样例：

```bash
echo `basename $PWD`        # 当前工作目录的目录名。
echo "${PWD##*/}"           # 当前工作目录的目录名。
echo
echo `basename $0`          # 脚本名。
echo $0                     # 脚本名。
echo "${0##*/}"             # 脚本名。
echo
filename=test.data
echo "${filename##*.}"      # data
                            # 文件扩展名。
```

`${var%Pattern}, ${var%%Pattern}`

`${var%Pattern}` 删除 `$var` 后缀部分匹配到的最短长度的 `$Pattern`。

`${var%%Pattern}` 删除 `$var` 后缀部分匹配到的最长长度的 `$Pattern`。

在 Bash 的 [第二个版本](http://tldp.org/LDP/abs/html/bashver2.html#BASH2REF) 中增加了一些额外的选择。

样例 10-10. 参数替换中的模式匹配

```bash
#!/bin/bash
# patt-matching.sh

# 使用 # ## % %% 参数替换操作符进行模式匹配

var1=abcd12345abc6789
pattern1=a*c  # 通配符 * 可以匹配 a 与 c 之间的任意字符

echo
echo "var1 = $var1"           # abcd12345abc6789
echo "var1 = ${var1}"         # abcd12345abc6789
                              # （另一种形式）
echo "Number of characters in ${var1} = ${#var1}"
echo

echo "pattern1 = $pattern1"   # a*c  (匹配 'a' 与 'c' 之间的一切)
echo "--------------"
echo '${var1#$pattern1}  =' "${var1#$pattern1}"    #         d12345abc6789
# 匹配到首部最短的3个字符                                   abcd12345abc6789
#             ^                                           |-|
echo '${var1##$pattern1} =' "${var1##$pattern1}"   #                  6789
# 匹配到首部最长的12个字符                                  abcd12345abc6789
#             ^                                           |----------|

echo; echo; echo

pattern2=b*9            # 匹配 'b' 与 '9' 之间的任意字符
echo "var1 = $var1"     # 仍旧是 abcd12345abc6789
echo
echo "pattern2 = $pattern2"
echo "--------------"
echo '${var1%pattern2}  =' "${var1%$pattern2}"     #     abcd12345a
# 匹配到尾部最短的6个字符                                  abcd12345abc6789
#             ^                                                    |----|
echo '${var1%%pattern2} =' "${var1%%$pattern2}"    #     a
# 匹配到尾部最长的12个字符                                 abcd12345abc6789
#             ^                                           |-------------|

# 牢记 # 与 ## 是从字符串左侧开始，
#      % 与 %% 是从右侧开始。

echo

exit 0
```

样例 10-11. 更改文件扩展名：

```bash
#!/bin/bash
# rfe.sh: 更改文件扩展名。
#
#         rfe old_extension new_extension
#
# 如：
# 将当前目录下所有 *.gif 文件重命名为 *.jpg，
#         rfe gif jpg


E_BADARGS=65

case $# in
  0|1)             # 竖线 | 在这里表示逻辑或关系。
  echo "Usage: `basename $0` old_file_suffix new_file_suffix"
  exit $E_BADARGS  # 如果只有0个或1个参数，那么退出脚本。
  ;;
esac


for filename in *.$1
# 遍历以第一个参数作为后缀名的文件列表。
do
  mv $filename ${filename%$1}$2
  # 删除文件后缀名，增加第二个参数作为后缀名。
done

exit 0
```

#### 10.2.2 变量扩展 / 替换子串

下面这些结构采用自 ksh。

`${var:pos}`

扩展为从偏移量 pos 处截取的变量 var。

`${var:pos:len}`

扩展为从偏移量 pos 处截取变量 var 最大长度为 len 的字符串。

`${var/Pattern/Replacement}`

替换 var 中第一个匹配到的 Pattern 为 Replacement。

如果 Replacement 被省略，那么匹配到的第一个 Pattern 将被替换为空，即删除。

`${var//Pattern/Replacement}`

全局替换。替换 var 中所有匹配到的 Pattern 为 Replacement。

跟上面一样，如果 Replacement 被省略，那么匹配到的所有 Pattern 将被替换为空，即删除。

样例 10-12. 使用模式匹配解析任意字符串

```bash
#!/bin/bash

var1=abcd-1234-defg
echo "var1 = $var1"

t=${var1#*-*}
echo "var1 (with everything, up to and including first - stripped out) = $t"
#  t=${var1#*-} 效果相同，
#+ 因为 # 只匹配最短的字符串，
#+ 并且 * 可以任意匹配，其中也包括空字符串。
# （感谢 Stephane Chazelas 指出这一点。）

t=${var##*-*}
echo "If var1 contains a \"-\", returns empty string...   var1 = $t"


t=${var1%*-*}
echo "var1 (with everything from the last - on stripped out) = $t"

echo

# -------------------------------------------
path_name=/home/bozo/ideas/thoughts/for.today
# -------------------------------------------
echo "path_name = $path_name"
t=${path_name##/*/}
echo "path_name, stripped of prefixes = $t"
# 在这里与 t=`basename $path_name` 效果相同。
#  t=${path_name%/}; t=${t##*/}  是更加通用的方法，
#+ 但有时仍旧也会出现问题。
#  如果 $path_name 以换行结束，那么 `basename $path_name` 将会失效，
#+ 但是上面这种表达式却可以。
# （感谢 S.C.）

t=${path_name%/*.*}
# 同 t=`dirname $path_name` 效果相同。
echo "path_name, stripped of suffixes = $t"
# 在一些情况下会失效，比如 "../", "/foo////", # "foo/", "/"。
#  在删除后缀时，尤其是当文件名没有后缀，目录名却有后缀时，
#+ 事情会变的非常复杂。
# （感谢 S.C.）

echo

t=${path_name:11}
echo "$path_name, with first 11 chars stripped off = $t"
t=${path_name:11:5}
echo "$path_name, with first 11 chars stripped off, length 5 = $t"

echo

t=${path_name/bozo/clown}
echo "$path_name with \"bozo\" replaced by \"clown\" = $t"
t=${path_name/today/}
echo "$path_name with \"today\" deleted = $t"
t=${path_name//o/O}
echo "$path_name with all o's capitalized = $t"
t=${path_name//o/}
echo "$path_name with all o's deleted = $t"

exit 0
```

`${var/#Pattern/Replacement}`

替换 var 前缀部分匹配到的 Pattern 为 Replacement。

`${var/%Pattern/Replacement}`

替换 var 后缀部分匹配到的 Pattern 为 Replacement。

样例 10-13. 在字符串首部或尾部进行模式匹配

```bash
#!/bin/bash
# var-match.sh:
# 演示在字符串首部或尾部进行模式替换。

v0=abc1234zip1234abc    # 初始值。
echo "v0 = $v0"         # abc1234zip1234abc
echo

# 在字符串首部进行匹配
v1=${v0/#abc/ABCDEF}    # abc1234zip123abc
                        # |-|
echo "v1 = $v1"         # ABCDEF1234zip1234abc
                        # |----|
                        
# 在字符串尾部进行匹配
v2=${v0/%abc/ABCDEF}    # abc1234zip123abc
                        #              |-|
echo "v2 = $v2"         # abc1234zip1234ABCDEF
                        #               |----|
                        
echo

#  --------------------------------------------
#  必须在字符串的最开始或者最末尾的地方进行匹配，
#+ 否则将不会发生替换。
#  --------------------------------------------
v3=${v0/#123/000}       # 虽然匹配到了，但是不在最开始的地方。
echo "v3 = $v3"         # abc1234zip1234abc
                        # 没有替换。
v4=${v0/%123/000}       # 虽然匹配到了，但是不在最末尾的地方。
echo "v4 = $v4"         # abc1234zip1234abc
                        # 没有替换。

exit 0
```

`${!varprefix*}, ${!varprefix@}`

匹配先前声明过所有以 varprefix 作为变量名前缀的变量。

```bash
# 这是带 * 或 @ 的间接引用的一种变换形式。
# 在 Bash 2.04 版本中加入了这个特性。

xyz23=whatever
xyz23=

a=${!xyz*}         #  扩展为声明变量中以 "xyz"
# ^ ^   ^           + 开头变量名。
echo "a = $a"      #  a = xyz23 xyz24
a=${!xyz@}         #  同上。
echo "a = $a"      #  a = xyz23 xyz24

echo "---"

abc23=something_else
b=${!abc*}
echo "b = $b"      #  b = abc23
c=${!b}            #  这是我们熟悉的间接引用的形式。
echo $c            #  something_else
```

## 11 循环与分支

> 奥赛罗夫人，您为什么把这句话说了又说呢？
>
> —— 《奥赛罗》，莎士比亚

对代码块的处理是结构化和构建 shell 脚本的关键。循环与分支结构恰好提供了这样一种对代码块处理的工具。

### 11.1 循环

循环是当循环控制条件为真时，一系列命令迭代执行的代码块。

#### 11.1.1 `for arg in [list]`

这是 shell 中最基本的循环结构，它与C语言形式的循环有着明显的不同。

```bash
for arg in [list]
do
  command(s)...
done
```

> ![note](images/note-1583394862122.gif) 在循环的过程中，`arg` 会从 `list` 中连续获得每一个变量的值。

```bash
for arg in "$var1" "$var2" "$var3" ... "$varN"
# 第一次循环中，arg = $var1
# 第二次循环中，arg = $var2
# 第三次循环中，arg = $var3
# ...
# 第 N 次循环中，arg = $varN
>
# 为了防止可能的字符分割问题，[list] 中的参数都需要被引用。
```

参数 list 中允许含有 [通配符](http://tldp.org/LDP/abs/html/special-chars.html#ASTERISKREF)。

如果 `do` 和 `for` 写在同一行时，需要在 list 之后加上一个分号。

`for arg in [list] ; do`

样例 11-1. 简单的 for 循环

```bash
#!/bin/bash
# 列出太阳系的所有行星。

for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto
do
  echo $planet  # 每一行输出一个行星。
done

echo; echo

for planet in "Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
    # 所有的行星都输出在一行上。
    # 整个 'list' 被包裹在引号中时是作为一个单一的变量。
    # 为什么？因为空格也是变量的一部分。
do
  echo $planet
done

echo; echo "Whoops! Pluto is no longer a planet!"

exit 0
```

[list] 中的每一个元素中都可能含有多个参数。这在处理参数组中非常有用。在这种情况下，使用 [`set`](http://tldp.org/LDP/abs/html/internal.html#SETREF) 命令（查看 [样例 15-16](http://tldp.org/LDP/abs/html/internal.html#EX34)）强制解析 [list] 中的每一个元素，并将元素的每一个部分分配给位置参数。

样例 11-2. `for` 循环 [list] 中的每一个变量有两个参数的情况

```bash
#!/bin/bash
# 让行星再躺次枪。

# 将每个行星与其到太阳的距离放在一起。

for planet in "Mercury 36" "Venus 67" "Earth 93" "Mars 142" "Jupiter 483"
do
  set -- $planet  #  解析变量 "planet"
                  #+ 并将其每个部分赋值给位置参数。
  # "--" 防止一些极端情况，比如 $planet 为空或者以破折号开头。
  
  # 因为位置参数会被覆盖掉，因此需要先保存原先的位置参数。
  # 你可以使用数组来保存
  #         original_params=("$@")
  
  echo "$1		$2,000,000 miles from the sum"
  #-------两个制表符---将后面的一系列 0 连到参数 $2 上。
done

# （感谢 S.C. 做出的额外注释。）

exit 0
```

一个单一变量也可以成为 `for` 循环中的 [list]。

样例 11-3. 文件信息：查看一个单一变量中含有的文件列表的文件信息

```bash
#!/bin/bash
# fileinfo.sh

FILES="/usr/sbin/accept
/usr/sbin/pwck
/usr/sbin/chroot
/usr/bin/fakefile
/sbin/badblocks
/sbin/ypbind"     # 你可能会感兴趣的一系列文件。
                  # 包含一个不存在的文件，/usr/bin/fakefile。
                  
echo

for file in $FILES
do

  if [ ! -e "$file" ]       # 检查文件是否存在。
  then
    echo "$file does not exist."; echo
    continue                # 继续判断下一个文件。
  fi
  
  ls -l $file | awk '{ print $8 "         file size: " $5 }'  # 输出其中的两个域。
  whatis `basename $file`   # 文件信息。
  # 脚本正常运行需要注意提前设置好 whatis 的数据。
  # 使用 root 权限运行 /usr/bin/makewhatis 可以完成。
  echo
done

exit 0
```

`for` 循环中的 [list] 可以是一个参数。

样例 11-4. 操作含有一系列文件的参数

```bash
#!/bin/bash

filename="*txt"

for file in $filename
do
 echo "Contents of $file"
 echo "---"
 cat "$file"
 echo
done
```

如果在匹配文件扩展名的 `for` 循环中的 [list] 含有通配符（* 和 ?），那么将会进行文件名扩展。

样例 11-5. 在 `for` 循环中操作文件

```bash
#!/bin/bash
# list-glob.sh: 通过文件名扩展在 for 循环中产生 [list]。
# 通配 = 文件名扩展。

echo

for file in *
#           ^  Bash 在检测到通配表达式时，
#+             会进行文件名扩展。
do
  ls -l "$file"  # 列出 $PWD（当前工作目录）下的所有文件。
  #  回忆一下，通配符 "*" 会匹配所有的文件名，
  #+ 但是，在文件名扩展中，他将不会匹配以点开头的文件。
  
  #  如果没有匹配到文件，那么它将会扩展为它自身。
  #  为了防止出现这种情况，需要设置 nullglob 选项。
  #+    (shopt -s nullglob)。
  #  感谢 S.C.
done

echo; echo

for file in [jx]*
do
  rm -f $file    # 删除当前目录下所有以 "j" 或 "x" 开头的文件。
  echo "Removed file \"$file\"".
done

echo

exit 0
```

如果在 `for` 循环中省略 `in [list]` 部分，那么循环将会遍历位置参数（`$@`）。[样例 A-15](http://tldp.org/LDP/abs/html/contributed-scripts.html#PRIMES) 中使用到了这一点。也可以查看 [样例 15-17](http://tldp.org/LDP/abs/html/internal.html#REVPOSPARAMS)。

样例 11-6. 缺少 `in [list]` 的 `for` 循环

```bash
#!/bin/bash

# 尝试在带参数和不带参数两种情况下调用这个脚本，观察发生了什么。

for a
do
 echo -n "$a "
done

#  缺失 'in list' 的情况下，循环会遍历 '$@'
#+（命令行参数列表，包括空格）。

echo

exit 0
```

可以在 `for` 循环中使用 [命令代换](http://tldp.org/LDP/abs/html/commandsub.html#COMMANDSUBREF) 生成 [list]。查看 [样例 16-54](http://tldp.org/LDP/abs/html/extmisc.html#EX53)，[样例 11-11](http://tldp.org/LDP/abs/html/loops1.html#SYMLINKS) 和 [样例 16-48](http://tldp.org/LDP/abs/html/mathc.html#BASE)。

样例 11-7. 在 `for` 循环中使用命令代换生成 [list]

```bash
#!/bin/bash
# for-loopcmd.sh: 带命令代换所生成 [list] 的 for 循环

NUMBERS="9 7 3 8 37.53"

for number in `echo $NUMBERS`  # for number in 9 7 3 8 37.53
do
  echo -n "$number "
done

echo
exit 0
```

下面是使用命令代换生成 [list] 的更加复杂的例子。

样例 11-8. 一种替代 `grep` 搜索二进制文件的方法

```bash
#!/bin/bash
# bin-grep.sh: 在二进制文件中定位匹配的字符串。

# 一种替代 `grep` 搜索二进制文件的方法
# 与 "grep -a" 的效果类似

E_BADARGS=65
E_NOFILE=66

if [ $# -ne 2 ]
then
  echo "Usage: `basename $0` search_string filename"
  exit $E_BADARGS
fi

if [ ! -f "$2" ]
then
  echo "File \"$2\" does not exist."
  exit $E_NOFILE
fi


IFS=$'\012'       # 按照 Anton Filippov 的意见应该是
                  # IFS="\n"
for word in $( strings "$2" | grep "$1" )
# "strings" 命令列出二进制文件中的所有字符串。
# 将结果通过管道输出到 "grep" 中，检查是不是匹配的字符串。
do
  echo $word
done

# 就像 S.C. 指出的那样，第 23-30 行可以换成下面的形式：
#    strings "$2" | grep "$1" | tr -s "$IFS" '[\n*]'


# 尝试运行脚本 "./bin-grep.sh mem /bin/ls"

exit 0
```

下面的例子同样展示了如何使用命令代换生成 [list]。

样例 11-9. 列出系统中的所有用户

```bash
#!/bin/bash
# userlist.sh

PASSWORD_FILE=/etc/passwd
n=1           # 用户数量

for name in $(awk 'BEGIN{fs=":"}{print $1}' < "$PASSWORD_FILE" )
# 分隔符 = :              ^^^^^^
# 输出第一个域                    ^^^^^^^^
# 读取密码文件 /etc/passwd                    ^^^^^^^^^^^^^^^^^
do
  echo "USER #$n = $name"
  let "n += 1"
done


# USER #1 = root
# USER #2 = bin
# USER #3 = daemon
# ...
# USER #33 = bozo

exit $?

# 讨论：
# -----
# 一个普通用户是如何读取 /etc/passwd 文件的？
# 提示：检查 /etc/passwd 的文件权限。
# 这算不算是一个安全漏洞？为什么？
```

另外一个关于 [list] 的例子也来自于命令代换。

样例 11-10. 检查目录中所有二进制文件的原作者

```bash
#!/bin/bash
# findstring.sh
# 在指定目录的二进制文件中寻找指定的字符串。

directory=/usr/bin
fstring="Free Software Foundation"  # 查看哪些文件来自于 FSF。

for file in $( find $directory -type f -name '*' | sort )
do
  strings -f $file | grep "$fstring" | sed -e "s%$driectory%%"
  #  在 "sed" 表达式中，你需要替换掉 "/" 分隔符，
  #+ 因为 "/" 是一个会被过滤的字符。
  #  如果不做替换，将会产生一个错误。（你可以尝试一下。）
done

exit $?

# 简单的练习：
# ----------
# 修改脚本，使其可以从命令行参数中获取 $directory 和 $fstring。
```

最后一个关于 [list] 和命令代换的例子，但这个例子中的命令是一个[函数](http://tldp.org/LDP/abs/html/functions.html#FUNCTIONREF)。

```bash
generate_list ()
{
  echo "one two three"
}

for word in $(generate_list)  # "word" 获得函数执行的结果。
do
  echo "$word"
done

# one
# two
# three
```

`for` 循环的结果可以通过管道导向至一个或多个命令中。

样例 11-11. 列出目录中的所有符号链接。

```bash
#!/bin/bash
# symlinks.sh: 列出目录中的所有符号链接。

directory=${1-`pwd`}
# 如果没有特别指定，缺省目录为当前工作目录。
# 等价于下面的代码块。
# ---------------------------------------------------
# ARGS=1                 # 只有一个命令行参数。
#
# if [ $# -ne "$ARGS" ]  # 如果不是只有一个参数的情况下
# then
#   directory=`pwd`      # 设为当前工作目录。
# else
#   directory=$1
# fi
# ---------------------------------------------------

echo "symbolic links in directory \"$directory\""

for file in "$( find $directory -type 1 )"   # -type 1 = 符号链接
do
  echo "$file"
done | sort                                  # 否则文件顺序会是乱序。
#  严格的来说这里并不需要使用循环，
#+ 因为 "find" 命令的输出结果已经被扩展成一个单一字符串了。
#  然而，为了方便大家理解，我们使用了循环的方式。

#  Dominik 'Aeneas' Schnitzer 指出，
#+ 不引用 $( find $directory -type 1 ) 的话，
#  脚本将在文件名包含空格时阻塞。

exit 0


# --------------------------------------------------------
# Jean Helou 提供了另外一种方法：

echo "symbolic links in directory \"$directory\""
# 备份当前的内部字段分隔符。谨慎永远没有坏处。
OLDIFS=$IFS
IFS=:

for file in $(find $directory -type 1 -printf "%p$IFS")
do     #                              ^^^^^^^^^^^^^^^^
       echo "$file"
       done|sort

# James "Mike" Conley 建议将 Helou 的代码修改为：

OLDIFS=$IFS
IFS='' # 空的内部字段分隔符意味着将不会分隔任何字符串
for file in $( find $directory -type 1 )
do
  echo $file
  done | sort
  
#  上面的代码可以在目录名包含冒号（前一个允许包含空格）
#+ 的情况下仍旧正常工作。
```

只需要对上一个样例做一些小小的改动，就可以把在标准输出 `stdout` 中的循环 [重定向](http://tldp.org/LDP/abs/html/io-redirection.html#IOREDIRREF) 到文件中。

样例 11-12. 将目录中的所有符号链接保存到文件中。

```bash
#!/bin/bash
# symlinks.sh: 列出目录中的所有符号链接。

OUTFILE=symlinks.list

directory=${1-`pwd`}
# 如果没有特别指定，缺省目录为当前工作目录。


echo "symbolic links in directory \"$directory\"" > "$OUTFILE"
echo "---------------------------" >> "$OUTFILE"

for file in "$( find $directory -type 1 )"    # -type 1 = 符号链接
do
  echo "$file"
done | sort >> "$OUTFILE"                     # 将 stdout 的循环结果
#           ^^^^^^^^^^^^^                       重定向到文件。

# echo "Output file = $OUTFILE"

exit $?
```

还有另外一种看起来非常像C语言中循环那样的语法。你需要使用到 [双圆括号](http://tldp.org/LDP/abs/html/dblparens.html#DBLPARENSREF) 语法。

样例 11-13. C语言风格的循环

```bash
#!/bin/bash
# 用多种方式数到10。

echo

# 基础版
for a in 1 2 3 4 5 6 7 8 9 10
do
  echo -n "$a "
done

echo; echo

# +==========================================+

# 使用 "seq"
for a in `seq 10`
do
  echo -n "$a "
done

echo; echo

# +==========================================+

# 使用大括号扩展语法
# Bash 3+ 版本有效。
for a in {1..10}
do
  echo -n "$a "
done

echo; echo

# +==========================================+

# 现在用类似C语言的语法再实现一次。

LIMIT=10

for ((a=1; a <= LIMIT ; a++))  # 双圆括号语法，不带 $ 的 LIMIT
do
  echo -n "$a "
done                           # 从 ksh93 中学习到的特性。

echo; echo

# +==========================================+

# 我们现在使用C语言中的逗号运算符来使得两个变量同时增加。

for ((a=1, b=1; a <= LIMIT ; a++, b++))
do  # 逗号连接操作。
  echo -n "$a-$b "
done

echo; echo

exit 0
```

还可以查看 [样例 27-16](http://tldp.org/LDP/abs/html/arrays.html#QFUNCTION)，[样例 27-17](http://tldp.org/LDP/abs/html/arrays.html#TWODIM) 和 [样例 A-6](http://tldp.org/LDP/abs/html/contributed-scripts.html#COLLATZ)。

\---

接下来，我们将展示在真实环境中应用的循环。

样例 11-14. 在批处理模式下使用 `efax`

```bash
#!/bin/bash
# 传真（必须提前安装了 'efax' 模块）。

EXPECTED_ARGS=2
E_BADARGS=85
MODEM_PORT="/dev/ttyS2"   # 你的电脑可能会不一样。
#                ^^^^^       PCMCIA 调制解调卡缺省端口。

if [ $# -ne $EXPECTED_ARGS ]
# 检查是不是传入了适当数量的命令行参数。
then
   echo "Usage: `basename $0` phone# text-file"
   exit $E_BADARGS
fi


if [ ! -f "$2" ]
then
  echo "File $2 is not a text file."
  #     File 不是一个正常文件或者文件不存在。
  exit $E_BADARGS
fi


fax make $2              # 根据文本文件创建传真格式文件。

for file in $(ls $2.0*)  # 连接转换后的文件。
                         # 在参数列表中使用通配符（文件名通配）。
do
  fil="$fil $file"
done

efax -d "$MODEM_PORT"  -t "T$1" $fil   # 最后使用 efax。
# 如果上面一行执行失败，尝试添加 -o1。


#  S.C. 指出，上面的 for 循环可以被压缩为
#     efax -d /dev/ttyS2 -o1 -t "T$1" $2.0*
#+ 但是这并不是一个好主意。

exit $?   # efax 同时也会将诊断信息传递给标准输出。
```

> ![note](http://tldp.org/LDP/abs/images/note.gif) [关键字](http://tldp.org/LDP/abs/html/internal.html#KEYWORDREF) `do` 和 `done` 圈定了 for 循环代码块的范围。但是在一些特殊的情况下，也可以被 [大括号](http://tldp.org/LDP/abs/html/special-chars.html#CODEBLOCKREF) 取代。

```bash
for((n=1; n<=10; n++))
# 没有 do！
{
  echo -n "* $n *"
}
# 没有 done！
>
>
# 输出：
# * 1 ** 2 ** 3 ** 4 ** 5 ** 6 ** 7 ** 8 ** 9 ** 10 *
# 并且 echo $? 返回 0，因此 Bash 并不认为这是一个错误。
>
>
echo
>
>
#  但是注意在典型的 for 循环 for n in [list] ... 中，
#+ 需要在结尾加一个分号。
>
for n in 1 2 3
{  echo -n "$n "; }
#               ^
>
>
# 感谢 Yongye 指出这一点。
```

#### 11.1.2 while 循环

`while` 循环结构会在循环顶部检测循环条件，若循环条件为真（ [退出状态](http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF) 为0）则循环持续进行。与 [`for` 循环](http://tldp.org/LDP/abs/html/loops1.html#FORLOOPREF1) 不同的是，`while` 循环是在不知道循环次数的情况下使用的。

```bash
while [ condition ]
do
  command(s)...
done
```

在 `while` 循环结构中，你不仅可以使用像 `if/test` 中那样的 [括号结构](http://tldp.org/LDP/abs/html/testconstructs.html#TESTCONSTRUCTS1)，也可以使用用途更广泛的 [双括号结构](http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS)（`while [[ condition ]]`）。

就像在 `for` 循环中那样，将 `do` 和循环条件放在同一行时需要加一个分号。

`while [ condition ] ; do`

在 `while` 循环中，括号结构 [并不是必须存在的](http://tldp.org/LDP/abs/html/loops1.html#WHILENOBRACKETS)。比如说 [`getopts` 结构](http://tldp.org/LDP/abs/html/internal.html#GETOPTSX)。

样例 11-15. 简单的 `while` 循环

```bash
#!/bin/bash

var0=0
LIMIT=10

while [ "$var0" -lt "$LIMIT" ]
#      ^                    ^
# 必须有空格，因为这是测试结构
do
  echo -n "$var0 "        # -n 不会另起一行
  #             ^           空格用来分开输出的数字。
  
  var0=`expr $var0 + 1`   # var0=$(($var0+1))  效果相同。
                          # var0=$((var0 + 1)) 效果相同。
                          # let "var0 += 1"    效果相同。
done                      # 还有许多其他的方法也可以达到相同的效果。

echo

exit 0
```

样例 11-16. 另一个例子

```bash
#!/bin/bash

echo
                               # 等价于：
while [ "$var1" != "end" ]     # while test "$var1" != "end"
do
  echo "Input variable #1 (end to exit) "
  read var1                    # 不是 'read $var1' （为什么？）。
  echo "variable #1 = $var1"   # 因为存在 "#"，所以需要使用引号。
  # 如果输入的是 "end"，也将会在这里输出。
  # 在结束本轮循环之前都不会再测试循环条件了。
  echo
done

exit 0
```

一个 `while` 循环可以有多个测试条件，但只有最后的那一个条件决定了循环是否终止。这是一种你需要注意到的不同于其他循环的语法。

样例 11-17. 多条件 `while` 循环

```bash
#!/bin/bash

var1=unset
previous=$var1

while echo "previous-variable = $previous"
      echo
      previous=$var1
      [ "$var1" != end ] # 记录下 $var1 之前的值。
      # 在 while 循环中有4个条件，但只有最后的那个控制循环。
      # 最后一个条件的退出状态才会被记录。
do
echo "Input variable #1 (end to exit) "
  read var1
  echo "variable #1 = $var1"
done

# 猜猜这是怎样实现的。
# 这是一个很小的技巧。

exit 0
```

就像 `for` 循环一样， `while` 循环也可以使用双圆括号结构写得像C语言那样（也可以查看[样例 8-5](http://tldp.org/LDP/abs/html/dblparens.html#CVARS)）。

样例 11-18. C语言风格的 `while` 循环

```bash
#!/bin/bash
# wh-loopc.sh: 在 "while" 循环中计数到10。

LIMIT=10                 # 循环10次。
a=1

while [ "$a" -le $LIMIT ]
do
  echo -n "$a "
  let "a+=1"
done                     # 没什么好奇怪的吧。

echo; echo

# +==============================================+

# 现在我们用C语言风格再写一次。

((a = 1))      # a=1
# 双圆括号结构允许像C语言一样在赋值语句中使用空格。

while (( a <= LIMIT ))   #  双圆括号结构，
do                       #+ 并且没有使用 "$"。
  echo -n "$a "
  ((a += 1))             # let "a+=1"
  # 是的，就是这样。
  # 双圆括号结构允许像C语言一样自增一个变量。
done

echo

# 这可以让C和Java程序猿感觉更加舒服。

exit 0
```

在测试部分，`while` 循环可以调用 [函数](http://tldp.org/LDP/abs/html/functions.html#FUNCTIONREF)。

```bash
t=0

condition ()
{
  ((t++))
  
  if [ $t -lt 5 ]
  then
    return 0  # true 真
  else
    return 1  # false 假
  fi
}

while condition
#     ^^^^^^^^^
#     调用函数循环四次。
do
  echo "Still going: t = $t"
done

# Still going: t = 1
# Still going: t = 2
# Still going: t = 3
# Still going: t = 4
```

> 和 [if 测试](http://tldp.org/LDP/abs/html/testconstructs.html#IFGREPREF) 结构一样，`while` 循环也可以省略括号。

```bash
while condition
do
  command(s) ...
done
```

在 `while` 循环中结合 [`read`](http://tldp.org/LDP/abs/html/internal.html#READREF) 命令，我们就得到了一个非常易于使用的 [`while read`](http://tldp.org/LDP/abs/html/internal.html#WHILEREADREF) 结构。它可以用来读取和解析文件。

```bash
cat $filename |    # 从文件获得输入。
while read line    # 只要还有可以读入的行，循环就继续。
do
  ...
done

# ==================== 摘自样例脚本 "sd.sh" =================== #

  while read value   # 一次读入一个数据。
  do
    rt=$(echo "scale=$SC; $rt + $value" | bc)
    (( ct++ ))
  done
  
  am=$(echo "scale=$SC; $rt / $ct" | bc)
  
  echo $am; return $ct   # 这个功能“返回”了2个值。
  # 注意：这个技巧在 $ct > 255 的情况下会失效。
  # 如果要操作更大的数字，注释掉上面的 "return $ct" 就可以了。
} <"$datafile"   # 传入数据文件。
```

> ![note](http://tldp.org/LDP/abs/images/note.gif) 在 `while` 循环后面可以通过 < 将标准输入 [重定位到文件](http://tldp.org/LDP/abs/html/redircb.html#REDIRREF) 中。
> `while` 循环同样可以 [通过管道](http://tldp.org/LDP/abs/html/internal.html#READPIPEREF) 传入标准输入中。

#### 11.1.3 until

与 `while` 循环相反，`until` 循环测试其顶部的循环条件，直到其中的条件为真时停止。

```bash
until [ condition-is-true ]
do
  commands(s)...
done
```

注意到，跟其他的一些编程语言不同，`until` 循环的测试条件在循环顶部。

就像在 `for` 循环中那样，将 `do` 和循环条件放在同一行时需要加一个分号。

`until[ condition-is-true ] ; do`

样例 11-19. `until` 循环

```bash
#!/bin/bash

END_CONDITION=end

until [ "$var1" = "$END_CONDITION" ]
# 在循环顶部测试条件。
do
  echo "Input variable #1 "
  echo "($END_CONDITION to exit)"
  read var1
  echo "variable #1 = $var1"
  echo
done

#                ---                   #

#  就像 "for" 和 "while" 循环一样，
#+ "until" 循环也可以写的像C语言一样。

LIMIT=10
var=0

until (( var > LIMIT ))
do  # ^^ ^     ^     ^^   没有方括号，没有 $ 前缀。
  echo -n "$var "
  (( var++ ))
done    # 0 1 2 3 4 5 6 7 8 9 10


exit 0
```

如何在 `for`，`while` 和 `until` 之间做出选择？我们知道在C语言中，在已知循环次数的情况下更加倾向于使用 `for` 循环。但是在Bash中情况可能更加复杂一些。Bash中的 `for` 循环相比起其他语言来说，结构更加松散，使用更加灵活。因此使用你认为最简单的就好。

### 11.2 嵌套循环

嵌套循环，顾名思义就是在循环里面还有循环。外层循环会不断的触发内层循环直到外层循环结束。当然，你仍然可以使用 `break` 可以终止外层或内层的循环。

样例 11-20. 嵌套循环

```bash
#!/bin/bash
# nested-loop.sh: 嵌套 "for" 循环。

outer=1             # 设置外层循环计数器。

# 外层循环。
for a in 1 2 3 4 5 
do
  echo "Pass $outer in outer loop."
  echo "---------------------"
  inner=1           # 重设内层循环计数器。
  
  # =====================================
  # 内层循环。
  for b in 1 2 3 4 5
  do
    echo "Pass $inner in inner loop."
    let "inner+=1"  # 增加内层循环计数器。
  done
  # 内层循环结束。
  # =====================================
  
  let "outer+=1"    # 增加外层循环计数器。
  echo              # 在每次外层循环输出中加入空行。
done
# 外层循环结束。

exit 0
```

查看 [样例 27-11](http://tldp.org/LDP/abs/html/arrays.html#BUBBLE) 详细了解嵌套 [while 循环](http://tldp.org/LDP/abs/html/loops1.html#WHILELOOPREF)。查看 [样例 27-13](http://tldp.org/LDP/abs/html/arrays.html#EX68) 详细了解嵌套 [until 循环](http://tldp.org/LDP/abs/html/loops1.html#UNTILLOOPREF)。

### 11.3 循环控制

> Tournez cent tours, tournez mille tours,
>
> Tournez souvent et tournez toujours . . .
>
> ——保尔·魏尔伦，《木马》

本节介绍两个会影响循环行为的命令。

#### 11.3.1 break, continue

`break` 和 `continue` 命令[^1]的作用和在其他编程语言中的作用一样。`break` 用来中止（跳出）循环，而 `continue` 则是略过未执行的循环部分，直接进行下一次循环。

样例 11-21. 循环中 `break` 与 `continue` 的作用

```bash
#!/bin/bash

LIMIT=19  # 循环上界

echo
echo "Printing Numbers 1 through 20 (but not 3 and 11)."

a=0

while [ $a -le "$LIMIT" ]
do
 a=$(($a+1))
 
 if [ "$a" -eq 3 ] || [ "$a" -eq 11 ]  # 除了 3 和 11。
 then
   continue      # 略过本次循环的剩余部分。
 fi
 
 echo -n "$a "   # 当 a 等于 3 和 11 时，将不会执行这条语句。
done

# 思考：
# 为什么循环不会输出到20？

echo; echo

echo Printing Numbers 1 through 20, but something happens after 2.

##################################################################

# 用 'break' 代替了 'continue'。

a=0

while [ "$a" -le "$LIMIT" ]
do
 a=$(($a+1))
 
 if [ "$a" -gt 2 ]
 then
   break  # 中止循环。
 fi
 
 echo -n "$a"
done

echo; echo; echo

exit 0
```

`break` 命令接受一个参数。普通的 `break` 命令仅仅跳出其所在的那层循环，而 `break N` 命令则可以跳出其上 N 层的循环。

样例 11-22. 跳出多层循环

```bash
#!/bin/bash
# break-levels.sh: 跳出循环.

# "break N" 跳出 N 层循环。

for outerloop in 1 2 3 4 5
do
  echo -n "Group $outerloop:   "

  # ------------------------------------------
  for innerloop in 1 2 3 4 5
  do
    echo -n "$innerloop "
    
    if [ "$innerloop" -eq 3 ]
    then
      break  # 尝试一下 break 2 看看会发生什么。
             # （它同时中止了内层和外层循环。）
    fi
  done
  # ------------------------------------------

  echo
done

echo

exit 0
```

与 `break` 类似，`continue` 也接受一个参数。普通的 `continue` 命令仅仅影响其所在的那层循环，而 `continue N` 命令则可以影响其上 N 层的循环。

样例 11-23. `continue` 影响外层循环

```bash
#!/bin/bash
# "continue N" 命令可以影响其上 N 层循环。

for outer in I II III IV V           # 外层循环
do
  echo; echo -n "Group $outer: "
  
  # --------------------------------------------------------------------
  for inner in 1 2 3 4 5 6 7 8 9 10  # 内层循环
  do
  
    if [[ "$inner" -eq 7 && "$outer" = "III" ]]
    then
      continue 2  # 影响两层循环，包括“外层循环”。
                  # 将其替换为普通的 "continue"，那么只会影响内层循环。
    fi
    
    echo -n "$inner "  # 7 8 9 10 将不会出现在 "Group III."中。
  done
  # --------------------------------------------------------------------

done

echo; echo

# 思考：
# 想一个 "continue N" 在脚本中的实际应用情况。

exit 0
```

样例 11-24. 真实环境中的 `continue N`

```bash
# Albert Reiner 举出了一个如何使用 "continue N" 的例子：
# ---------------------------------------------------

#  如果我有许多任务需要运行，并且运行所需要的数据都以文件的形
#+ 式存在文件夹中。现在有多台设备可以访问这个文件夹，我想将任
#+ 务分配给这些不同的设备来完成。
#  那么我通常会在每台设备上执行下面的代码：

while true:
do
  for n in .iso.*
  do
    [ "$n" = ".iso.opts" ] && continue
    beta=${n#.iso.}
    [ -r .Iso.$beta ] && continue
    [ -r .lock.$beta ] && sleep 10 && continue
    lockfile -r0 .lock.$beta || continue
    echo -n "$beta: " `date`
    run-isotherm $beta
    date
    ls -alF .Iso.$beta
    [ -r .Iso.$beta ] && rm -rf .lock.$beta
    continue 2
  done
  break
done

exit 0

# 这个脚本中出现的 sleep N 只针对这个脚本，通常的形式是：

while true
do
  for job in {pattern}
  do
    {job already done or running} && continue
    {mark job as running, do job, mark job as done}
    continue 2
  done
  break        # 或者使用类似 `sleep 600` 这样的语句来防止脚本结束。
done

#  这样做可以保证脚本只会在没有任务时（包括在运行过程中添加的任务）
#+ 才会停止。合理使用文件锁保证多台设备可以无重复的并行执行任务（这
#+ 在我的设备上通常会消耗好几个小时，所以我想避免重复计算）。并且，
#+ 因为每次总是从头开始搜索文件，因此可以通过文件名决定执行的先后
#+ 顺序。当然，你可以不使用 'continue 2' 来完成这些，但是你必须
#+ 添加代码去检测某项任务是否完成（以此判断是否可以执行下一项任务或
#+ 终止、休眠一段时间再执行下一项任务）。
```

> ![caution](images/caution-1583395096706.gif) `continue N` 结构不易理解并且可能在一些情况下有歧义，因此不建议使用。

### 11.4 测试与分支

`case` 和 `select` 结构并不属于循环结构，因为它们并没有反复执行代码块。但是和循环结构相似的是，它们会根据代码块顶部或尾部的条件控制程序流。

下面介绍两种在代码块中控制程序流的方法：

#### 11.4.1 `case (in)` / `esac`

在 shell 脚本中，`case` 模拟了 C/C++ 语言中的 `switch`，可以根据条件跳转到其中一个分支。其相当于简写版的 `if/then/else` 语句。很适合用来创建菜单选项哟！

```bash
case "$variable" in
  "$condition1" )
    command...
  ;;
  "$condition2" )
    command...
  ;;
esac
```

> ![note](images/note-1583395183884.gif)
>
> - 对变量进行引用不是必须的，因为在这里不会进行字符分割。
>
> - 条件测试语句必须以右括号 ) 结束。[^1]
>
> - 每一段代码块都必须以双分号 ;; 结束。
>
> - 如果测试条件为真，其对应的代码块将被执行，而后整个 `case` 代码段结束执行。
>
> - `case` 代码段必须以 `esac` 结束（倒着拼写case）。

样例 11-25. 如何使用 `case`

```bash
#!/bin/bash
# 测试字符的种类。

echo; echo "Hit a key, then hit return."
read Keypress

case "$Keypress" in
  [[:lower:]]   ) echo "Lowercase letter";;
  [[:upper:]]   ) echo "Uppercase letter";;
  [0-9]         ) echo "Digit";;
  *             ) echo "Punctuation, whitespace, or other";;
esac      #  字符范围可以用[方括号]表示，也可以用 POSIX 形式的[[双方括号]]表示。

# 在这个例子的第一个版本中，用来测试是小写还是大写字符使用的是 [a-z] 和 [A-Z]。
# 这在一些特定的语言环境和 Linux 发行版中不起效。
# POSIX 形式具有更好的兼容性。
# 感谢 Frank Wang 指出这一点。

# 练习：
# -----
# 这个脚本接受一个单字符然后结束。
# 修改脚本，使得其可以循环接受输入，并且检测键入的每一个字符，直到键入 "X" 为止。
# 提示：将所有东西包在 "while" 中。

exit 0
```

样例 11-26. 使用 `case` 创建菜单

```bash
#!/bin/bash

# 简易的通讯录数据库

clear # 清屏。

echo "          Contact List"
echo "          ------- ----"
echo "Choose one of the following persons:" 
echo
echo "[E]vans, Roland"
echo "[J]ones, Mildred"
echo "[S]mith, Julie"
echo "[Z]ane, Morris"
echo

read person

case "$person" in
# 注意变量是被引用的。

  "E" | "e" )
  # 同时接受大小写的输入。
  echo
  echo "Roland Evans"
  echo "4321 Flash Dr."
  echo "Hardscrabble, CO 80753"
  echo "(303) 734-9874"
  echo "(303) 734-9892 fax"
  echo "revans@zzy.net"
  echo "Business partner & old friend"
  ;;
  # 注意用双分号结束这一个选项。

  "J" | "j" )
  echo
  echo "Mildred Jones"
  echo "249 E. 7th St., Apt. 19"
  echo "New York, NY 10009"
  echo "(212) 533-2814"
  echo "(212) 533-9972 fax"
  echo "milliej@loisaida.com"
  echo "Ex-girlfriend"
  echo "Birthday: Feb. 11"
  ;;
  
  # Smith 和 Zane 的信息稍后添加。

  *         )
  # 缺省设置。
  # 空输入（直接键入回车）也是执行这一部分。
  echo
  echo "Not yet in database."
  ;;
  
esac

echo

# 练习：
# -----
# 修改脚本，使得其可以循环接受多次输入而不是只显示一个地址后终止脚本。

exit 0
```

你可以用 `case` 来检测命令行参数。

```bash
#!/bin/bash

case "$1" in
  "") echo "Usage: ${0##*/} <filename>"; exit $E_PARAM;;
                      # 没有命令行参数，或者第一个参数为空。
                      # 注意 ${0##*/} 是参数替换 ${var##pattern} 的一种形式。
                      # 最后的结果是 $0.
  
  -*) FILENAME=./$1;; #  如果传入的参数以短横线开头，那么将其替换为 ./$1
                      #+ 以避免后续的命令将其解释为一个选项。
  
  * ) FILENAME=$1;;   # 否则赋值为 $1。
esac                  
```

下面是一个更加直观的处理命令行参数的例子：

```bash
#!/bin/bash

while [ $# -gt 0 ]; do    # 遍历完所有参数
  case "$1" in
    -d|--debug)
              # 检测是否是 "-d" 或者 "--debug"。
              DEBUG=1
              ;;
    -c|--conf)
              CONFFILE="$2"
              shift
              if [ ! -f $CONFFILE ]; then
                echo "Error: Supplied file doesn't exist!"
                exit $E_CONFFILE     # 找不到文件。
              fi
              ;;
  esac
  shift       # 检测下一个参数
done

# 摘自 Stefano Falsetto 的 "Log2Rot" 脚本中 "rottlog" 包的一部分。
# 已授权使用。
```

样例 11-27. 使用命令替换生成 `case` 变量

```bash
#!/bin/bash
# case-cmd.sh: 使用命令替换生成 "case" 变量。

case $( arch ) in   # $( arch ) 返回设备架构。
                    # 等价于 'uname -m"。
  i386 ) echo "80386-based machine";;
  i486 ) echo "80486-based machine";;
  i586 ) echo "Pentium-based machine";;
  i686 ) echo "Pentium2+-based machine";;
  *    ) echo "Other type of machine";;
esac

exit 0  
```

`case` 还可以用来做字符串模式匹配。

样例 11-28. 简单的字符串匹配

```bash
#!/bin/bash
# match-string.sh: 使用 'case' 结构进行简单的字符串匹配。

match_string ()
{ # 字符串精确匹配。
  MATCH=0
  E_NOMATCH=90
  PARAMS=2     # 需要2个参数。
  E_BAD_PARAMS=91
  
  [ $# -eq $PARAMS ] || return $E_BAD_PARAMS
  
  case "$1" in
    "$2") return $MATCH;;
    *   ) return $E_NOMATCH;;
  esac
  
}


a=one
b=two
c=three
d=two

match_string $a     # 参数个数不够
echo $?             # 91

match_string $a $b  # 匹配不到
echo $?             # 90

match_string $a $d  # 匹配成功
echo $?             # 0


exit 0
```

样例 11-29. 检查输入

```bash
#!/bin/bash
# isaplpha.sh: 使用 "case" 结构检查输入。

SUCCESS=0
FAILURE=1   #  以前是FAILURE=-1,
            #+ 但现在 Bash 不允许返回负值。

isalpha ()  # 测试字符串的第一个字符是否是字母。
{
if [ -z "$1" ]                # 检测是否传入参数。
then
  return $FAILURE
fi

case "$1" in
  [a-zA-Z]*) return $SUCCESS;;  # 是否以字母形式开始？
  *        ) return $FAILURE;;
esac
}             # 可以与 C 语言中的函数 "isalpha ()" 作比较。


isalpha2 ()   # 测试整个字符串是否都是字母。
{
  [ $# -eq 1 ] || return $FAILURE
  
  case $1 in
  *[!a-zA-Z]*|"") return $FAILURE;;
               *) return $SUCCESS;;
  esac
}

isdigit ()    # 测试整个字符串是否都是数字。
{             # 换句话说，也就是测试是否是一个整型变量。
  [ $# -eq 1 ] || return $FAILURE
  
  case $1 in
    *[!0-9]*|"") return $FAILURE;;
              *) return $SUCCESS;;
  esac
}



check_var ()  # 包装后的 isalpha ()。
{
if isalpha "$@"
then
  echo "\"$*\" begins with an alpha character."
  if isalpha2 "$@"
  then        # 其实没必要检查第一个字符是不是字母。
    echo "\"$*\" contains only alpha characters."
  else
    echo "\"$*\" contains at least one non-alpha character."
  fi
else
  echo "\"$*\" begins with a non-alpha character."
              # 如果没有传入参数同样同样返回“存在非字母”。
fi
  
echo
  
}

digit_check ()  # 包装后的 isdigit ()。
{
if isdigit "$@"
then
  echo "\"$*\" contains only digits [0 - 9]."
else
  echo "\"$*\" has at least one non-digit character."
fi
  
echo
  
}


a=23skidoo
b=H3llo
c=-What?
d=What?
e=$(echo $b)   # 命令替换。
f=AbcDef
g=27234
h=27a34
i=27.34

check_var $a
check_var $b
check_var $c
check_var $d
check_var $e
check_var $f
check_var     # 如果不传入参数会发送什么？
#
digit_check $g
digit_check $h
digit_check $i


exit 0        # S.C. 改进了本脚本。

# 练习：
# -----
# 写一个函数 'isfloat ()' 来检测输入值是否是浮点数。
# 提示：可以参考函数 'isdigit ()'，在其中加入检测合法的小数点即可。
```

#### 11.4.2 `select`

`select` 结构是学习自 Korn Shell。其同样可以用来构建菜单。

```bash
select variable [in list]
do
 command...
 break
done
```

而效果则是终端会提示用户输入列表中的一个选项。注意，`select` 默认使用提示字串3（Prompt String 3，`$PS3`, 即#?），但同样可以被修改。

样例 11-30. 使用 `select` 创建菜单

```bash
#!/bin/bash

PS3='Choose your favorite vegetable: ' # 设置提示字串。
                                       # 否则默认为 #?。

echo

select vegetable in "beans" "carrots" "potatoes" "onions" "rutabagas"
do
  echo
  echo "Your favorite veggie is $vegetable."
  echo "Yuck!"
  echo
  break  # 如果没有 'break' 会发生什么？
done

exit

# 练习:
# -----
# 修改脚本，使得其可以接受其他输入而不是 "select" 语句中所指定的。
# 例如，如果用户输入 "peas,"，那么脚本会通知用户 "Sorry. That is not on the menu."
```

如果 *in list* 被省略，那么 `select` 将会使用传入脚本的命令行参数（`$@`）或者传入函数的参数作为 *list*。

可以与 `for variable [in list]` 中 *in list* 被省略的情况做比较。

样例 11-31. 在函数中使用 `select` 创建菜单

```bash
#!/bin/bash

PS3='Choose your favorite vegetable: '

echo

choice_of()
{
select vegetable
# [in list] 被省略，因此 'select' 将会使用传入函数的参数作为 list。
do
  echo
  echo "Your favorite veggie is $vegetable."
  echo "Yuck!"
  echo
  break
done
}

choice_of beans rice carrorts radishes rutabaga spinach
#         $1    $2   $3      $4       $5       $6
#         传入了函数 choice_of()

exit 0
```

还可以参照 [样例37-3](http://tldp.org/LDP/abs/html/bashver2.html#RESISTOR)。

## 12命令替换

命令替换重新指定一个[^1]或多个命令的输出。其实就是将命令的输出导到另外一个地方[^2]。

命令替换的通常形式是（`` `...` ``），即用反引号引用命令。

```bash
script_name=`basename $0`
echo "The name of this script is $scirpt_name."
```

命令的输出可以作为另一个命令的参数，也可以赋值给一个变量。甚至在 [`for`](http://tldp.org/LDP/abs/html/loops1.html#FORLOOPREF1) 循环中可以用输出产生参数表。

```bash
rm `cat filename`   # "filename" 中包含了一系列需要被删除的文件名。
#
# S.C. 指出这样写可能会导致出现 "arg list too long" 的错误。
# 更好的写法应该是 xargs rm -- < filename
# （ -- 可以在 "filename" 文件名以 "-" 为开头时仍旧正常执行 ）

textfile_listing=`ls *.txt`
# 变量中包含了当前工作目录下所有的名为 *.txt 的文件。
echo $textfile_listing

textfile_listing2=$(ls *.txt)   # 命令替换的另一种形式。
echo $textfile_listing2
# 结果相同。

# 这样将一系列文件名赋值给一个单一字符串可能会出现换行。
#
# 而更加安全的方式是将这一系列文件存入数组。
#      shopt -s nullglob    # 设置后，如果没有匹配到文件，那么变量会被赋值为空。
#      textfile_listing=( *.txt )
#
# 感谢 S.C.
```

> ![note](images/note-1583395282531.gif) 命令替换本质上是调用了一个 [子进程](http://tldp.org/LDP/abs/html/subshells.html#SUBSHELLSREF) 来执行。

> ![caution](images/caution-1583395282545.gif) 命令替换有可能会出现 [字符分割](http://tldp.org/LDP/abs/html/quotingvar.html#WSPLITREF) 的情况。

> ```bash
> COMMAND `echo a b`     # 2个参数：a和b
> 
> COMMAND "`echo a b`"   # 1个参数："a b"
> 
> COMMAND `echo`         # 没有参数
> 
> COMMAND "`echo`"       # 一个空参数
> 
> 
> # 感谢 S.C.
> ```

> 但即使不存在字符分割的情况，使用命令替换也会出现丢失尾部换行符的情况。

> ```bash
> # cd "`pwd`"  # 你是不是认为这条语句在任何情况下都不会出现错误？
> # 但事实却不是这样的。
> 
> mkdir 'dir with trailing newline
> '
> 
> cd 'dir with trailing newline
> '
> 
> cd "`pwd`"  # Bash 会出现如下错误提示：
> # bash: cd: /tmp/file with trailing newline: No such file or directory
> 
> cd "$PWD"   # 这样写是对的。
> 
> 
> 
> 
> 
> old_tty_setting=$(stty -g)   # 保存旧的设置。
> echo "Hit a key "
> stty -icanon -echo           # 禁用终端的 canonical 模式。
>                           # 同时禁用 echo。
> key=$(dd bs=1 count=1 2> /dev/null)   # 使用 'dd' 获得键值。
> stty "$old_tty_setting"      # 恢复旧的设置。
> echo "You hit ${#key} key."  # ${#variable} 表示 $variable 中的字符个数。
> #
> # 除了按下回车键外，其余情况都会输出 "You hit 1 key."
> # 按下回车键会输出 "You hit 0 key."
> # 因为唯一的换行符在命令替换中被丢失了。
> 
> # 这段代码摘自 Stéphane Chazelas。
> ```

> ![caution](http://tldp.org/LDP/abs/images/caution.gif) 使用 `echo` 输出未被引用的命令代换的变量时会删掉尾部的换行。这可能会导致非常不好的情况出现。

> ```bash
> dir_listing=`ls -l`
> echo $dir_listing     # 未被引用
> 
> # 你希望会出现按行显示出文件列表。
> 
> # 但是，你却看到了：
> # total 3 -rw-rw-r-- 1 bozo bozo 30 May 13 17:15 1.txt -rw-rw-r-- 1 bozo
> # bozo 51 May 15 20:57 t2.sh -rwxr-xr-x 1 bozo bozo 217 Mar 5 21:13 wi.sh
> 
> # 所有换行都消失了。
> 
> 
> echo "$dir_listing"   # 被引用
> # -rw-rw-r--    1 bozo       30 May 13 17:15 1.txt
> # -rw-rw-r--    1 bozo       51 May 15 20:57 t2.sh
> # -rwxr-xr-x    1 bozo      217 Mar  5 21:13 wi.sh
> ```

你甚至可以使用 [重定向](http://tldp.org/LDP/abs/html/io-redirection.html#IOREDIRREF) 或者 [`cat`](http://tldp.org/LDP/abs/html/basic.html#CATREF) 命令把一个文件的内容通过命令代换赋值给一个变量。

```bash
variable1=`<file1`      # 将 "file1" 的内容赋值给 variable1。
variable2=`cat file2`   # 将 "file2" 的内容赋值给 variable2。
                        # 使用 cat 命令会开一个新进程，因此执行速度会比重定向慢。

# 需要注意的是，这些变量中可能包含一些空格或者控制字符。

# 无需显示的赋值给一个变量。
echo "` <$0`"           # 输出脚本自身。
```

```bash
#  摘录自系统文件 /etc/rc.d/rc.sysinit
#+ （Red Hat Linux 发行版）


if [ -f /fsckoptions ]; then
        fsckoptions=`cat /fsckoptions`
...
fi
#
#
if [ -e "/proc/ide/${disk[$device]}/media" ] ; then
             hdmedia=`cat /proc/ide/${disk[$device]}/media`
...
fi
#
#
if [ ! -n "`uname -r | grep -- "-"`" ]; then
       ktag="`cat /proc/version`"
...
fi
#
#
if [ $usb = "1" ]; then
    sleep 5
    mouseoutput=`cat /proc/bus/usb/devices 2>/dev/null|grep -E "^I.*Cls=03.*Prot=02"`
    kbdoutput=`cat /proc/bus/usb/devices 2>/dev/null|grep -E "^I.*Cls=03.*Prot=01"`
...
fi
```

> ![caution](http://tldp.org/LDP/abs/images/caution.gif) 尽量不要将一大段文字赋值给一个变量，除非你有足够的理由。也绝不要将一个二进制文件的内容赋值给一个变量。

> 样例 12-1. 蠢蠢的脚本
>
> ```bash
> #!/bin/bash
> # stupid-script-tricks.sh: 不要在自己的电脑上尝试。
> # 摘自 "Stupid Script Tricks" 卷一。
> 
> exit 99  ### 如果你有胆，就注释掉这行。:)
> 
> dangerous_variable=`cat /boot/vmlinuz`   # 压缩的 Linux 内核。
> 
> echo "string-length of \$dangerous_variable = ${#dangerous_variable}"
> # $dangerous_variable 的长度为 794151
> # （更新版本的内核可能更大。）
> # 与 'wc -c /boot/vmlinuz' 的结果不同。
> 
> # echo "$dangerous_variable"
> # 不要作死。否则脚本会挂起。
> 
> 
> 
> # 将二进制文件的内容赋值给一个变量没有任何意义。
> 
> exit 0
> ```

> 尽管脚本会挂起，但并不会出现缓存溢出的情况。而这正是像 Bash 这样的解释型语言相比起编译型语言能够提供更多保护的一个例子。

命令替换允许将 [循环](http://tldp.org/LDP/abs/html/loops1.html#FORLOOPREF1) 的输出结果赋值给一个变量。这其中的关键在于循环内部的 [`echo`](http://tldp.org/LDP/abs/html/internal.html#ECHOREF) 命令。

样例 12-2. 将循环的输出结果赋值给变量

```bash
#!/bin/bash
# csubloop.sh: 将循环的输出结果赋值给变量。

variable1=`for i in 1 2 3 4 5
do
  echo -n "$i"                 #  在这里，'echo' 命令非常关键。
done`

echo "variable1 = $variable1"  # variable1 = 12345


i=0
variable2=`while [ "$i" -lt 10 ]
do
  echo -n "$i"                 # 很关键的 'echo'。
  let "i += 1"                 # i 自增。
done`

echo "variable2 = $variable2"  # variable2 = 0123456789

# 这个例子表明可以在变量声明时嵌入循环。

exit 0
```

> 命令替换能够让 Bash 做更多的事情。而这仅仅需要在书写程序或者脚本时将结果输出到标准输出 `stdout` 中，然后将这些输出结果赋值给变量即可。
>
> ```c
> #include <stdio.h>
> 
> /*  "Hello, world." C program  */
> 
> int main()
> {
> printf( "Hello, world.\n" );
> return (0);
> }
> ```
>
> ```
> bash$ gcc -0 hello hello.c
> ```
>
> ```bash
> #!/bin/bash
> # hello.sh
> 
> greeting=`./hello`
> echo $greeting
> ```
>
> ```
> bash$ sh hello.sh
> Hello, world.
> ```



> ![note](http://tldp.org/LDP/abs/images/note.gif) 在命令替换中，你可以使用 `$(...)` 来替代反引号。
>
> ```bash
> output=$(sed -n /"$1"/p $file)   # 摘自 "grp.sh"。
> 
> # 将文本文件的内容赋值给一个变量。
> File_contents1=$(cat $file1)
> File_contents2=$(<$file2)        # 这么做也是可以的。
> ```
>
> `$(...)` 和反引号在处理双反斜杠上有所不同。
>
> ```
> bash$ echo `echo \\`
> 
> 
> bash$ echo $(echo \\)
> \
> ```
>
> `$(...)` 允许嵌套。[^3]
>
> ```bash
> word_count=$( wc -w $(echo * | awk '{print $8}') )
> ```
>
> 样例 12-3. 寻找变位词（anagram）
>
> ```bash
> #!/bin/bash
> # agram2.sh
> # 嵌套命令替换的例子。
> 
> # 其中使用了作者写的工具包 "yawl" 中的 "anagram" 工具。
> # http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz
> # http://bash.deta.in/yawl-0.3.2.tar.gz
> 
> E_NOARGS=86
> E_BADARG=87
> MINLEN=7
> 
> if [ -z "$1" ]
> then
> echo "Usage $0 LETTERSET"
> exit $E_NOARGS         # 脚本需要命令行参数。
> elif [ ${#1} -lt $MINLEN ]
> then
> echo "Argument must have at least $MINLEN letters."
> exit $E_BADARG
> fi
> 
> 
> 
> FILTER='.......'         # 至少需要7个字符。
> #       1234567
> Anagrams=( $(echo $(anagram $1 | grep $FILTER) ) )
> #          $(     $(        嵌套命令集        ) )
> #        (              赋值给数组                )
> 
> echo
> echo "${#Anagrams[*]}  7+ letter anagrams found"
> echo
> echo ${Anagrams[0]}      # 第一个变位词。
> echo ${Anagrams[1]}      # 第二个变位词。
>                       # 以此类推。
> 
> # echo "${Anagrams[*]}"  # 将所有变位词在一行里面输出。
> 
> # 可以配合后面的数组章节来理解上面的代码。
> 
> # 建议同时查看另一个寻找变位词的脚本 agram.sh。
> 
> exit $?
> ```

以下是包含命令替换的样例：

1. [样例 11-8](http://tldp.org/LDP/abs/html/loops1.html#BINGREP)
2. [样例 11-27](http://tldp.org/LDP/abs/html/testbranch.html#CASECMD)
3. [样例 9-16](http://tldp.org/LDP/abs/html/randomvar.html#SEEDINGRANDOM)
4. [样例 16-3](http://tldp.org/LDP/abs/html/moreadv.html#EX57)
5. [样例 16-22](http://tldp.org/LDP/abs/html/textproc.html#LOWERCASE)
6. [样例 16-17](http://tldp.org/LDP/abs/html/textproc.html#GRP)
7. [样例 16-54](http://tldp.org/LDP/abs/html/extmisc.html#EX53)
8. [样例 11-14](http://tldp.org/LDP/abs/html/loops1.html#EX24)
9. [样例 11-11](http://tldp.org/LDP/abs/html/loops1.html#SYMLINKS)
10. [样例 16-32](http://tldp.org/LDP/abs/html/filearchiv.html#STRIPC)
11. [样例 20-8](http://tldp.org/LDP/abs/html/redircb.html#REDIR4)
12. [样例 A-16](http://tldp.org/LDP/abs/html/contributed-scripts.html#TREE)
13. [样例 29-3](http://tldp.org/LDP/abs/html/procref1.html#PIDID)
14. [样例 16-47](http://tldp.org/LDP/abs/html/mathc.html#MONTHLYPMT)
15. [样例 16-48](http://tldp.org/LDP/abs/html/mathc.html#BASE)
16. [样例 16-49](http://tldp.org/LDP/abs/html/mathc.html#ALTBC)

## 13 算术扩展

算术扩展为脚本中的（整数）算术操作提供了强有力的工具。你可以使用反引号、双圆括号或者 `let` 将字符串转换为数学表达式。

### 13.1 差异比较

使用 [反引号](http://tldp.org/LDP/abs/html/commandsub.html#BACKQUOTESREF) 的算术扩展（通常与 [`expr`](http://tldp.org/LDP/abs/html/moreadv.html#EXPRREF) 一起使用）

```bash
z=`expr $z + 3`         # 'expr' 命令执行了算术扩展。
```

使用 [双圆括号](http://tldp.org/LDP/abs/html/dblparens.html) 或 [`let`](http://tldp.org/LDP/abs/html/internal.html#LETREF) 的算术扩展。

事实上，在算术扩展中，反引号已经被双圆括号 `((...))` 和 `$((...))` 以及 [`let`](http://tldp.org/LDP/abs/html/internal.html#LETREF) 所取代。

```bash
z=$(($z+3))
z=$((z+3))                     # 同样正确。
                               # 在双圆括号内，参数引用形式可用可不用。
                                            
# $((EXPRESSION)) 是算术扩展。  # 不要与命令替换混淆。



# 双圆括号不是只能用作赋值算术结果。

  n=0
  echo "n = $n"                # n = 0

  (( n += 1 ))                 # 自增。
# (( $n += 1 )) 是错误用法！
  echo "n = $n"                # n = 1


let z=z+3
let "z += 3"  # 引号允许在赋值表达式中使用空格。
              # 'let' 事实上执行的算术运算而非算术扩展。
```

以下是包含算术扩展的样例：

1. [样例 16-9](http://tldp.org/LDP/abs/html/moreadv.html#EX45)
2. [样例 11-15](http://tldp.org/LDP/abs/html/loops1.html#EX25)
3. [样例 27-1](http://tldp.org/LDP/abs/html/arrays.html#EX66)
4. [样例 27-11](http://tldp.org/LDP/abs/html/arrays.html#BUBBLE)
5. [样例 A-16](http://tldp.org/LDP/abs/html/contributed-scripts.html#TREE)

# 第四部分 命令

# 第五部分 高级话题

## 18 正则表示式

为了充分利用shell脚本，您需要熟练掌握正则表达式。有一些在脚本中常用的特定的命令和工具，例如grep、expr、sed和awk，这些命令会解释和使用正则表达式。版本三的bash实现了它独特的正则匹配符：=~。

### 18.1 正则表达式简介

正则表达式是一系列的字符串。这些包含超过其字面含义的字符串被称之为元字符。例如，一个符号前面的引用符代表一个人的言语能力，或者按照上面的说法，代表着meta-meaning[[1]](http://tldp.org/LDP/abs/html/x17129.html#FTN.AEN17134)。正则表达式是一组字符串和（或者）一组匹配（特定的）模式的元字符。

一个正则表达式包含下面的一个或多个选项：

- 一组字符串。这是仅仅表示字面意思的字符串。最简单形式的正则表达式仅仅包含一组字符串。
- 一个锚字符。锚节点指定了正则表达式在一行文本中的匹配位置。例如，^和$就是锚字符。
- 修饰符。修饰符扩展或者限定（修改）了正则表达式在文本中的匹配范围。修饰符包括星号、方括号和反斜线。

正则表达式的主要用在文本搜索和字符串操作。一个正则表达式匹配单个字符或者一组字符 -- 一系列的字符或者字符串的一部分。

- 星号 * 匹配前面的子表达式任意次，包括0次

  "1133*"匹配"11"加一个或多个"3"：113，1133，1133333，及以后

- 点号 . 匹配任意字符，除了新的一行[[2]](http://tldp.org/LDP/abs/html/x17129.html#AEN17189)

  "13."匹配"13"加至少一个字符（包括空格）：1133，11333，但不是13（缺少额外的字符）  
  参见例子[16-18](http://tldp.org/LDP/abs/html/textproc.html#CWSOLVER)，展示单字符匹配

- 脱字符 ^ 匹配行的起始位置，但有时候会根据上下文环境匹配其相反的意义（译者注：例如[^a]匹配任意一个非a的字符）

- 美元符 $ 匹配行的结束位置

  "XXX$"匹配行尾处的"XXX"  
  "^$"匹配空行

- 方括号 [...] 匹配所包含的任意一个字符

  "[xyz]"匹配x、y或z中的任意一个字符  
  "[c-n]"匹配c到n之间的任意一个字符  
  "[B-Pk-y]"匹配B到P和k到y之间任意一个字符  
  "[a-z0-9]"匹配任意一个小写字符和任意一个数字  
  "[^b-d]"匹配任意一个不在b到d之间的字符。这是一个很好的例子，展示了"^"的匹配了正则表达式的反义（类似在其他环境下的"!"符号所起的作用）  
  组合一连串的用方括号括起来的字符能匹配非常多的词组模式。"[Yy][Ee][Ss]"匹配yes、Yes、YES、yEs等等。"[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]"匹配任何一个社会保险号

- 反斜线 \ 转义一个特殊字符，意味着这个字符被解释为字面意义（因此不再包含特殊意思）

  "\$"表示回它的字面意义"$"，而不是它原本在正则表达式中代表行尾的意义。同样，"\\"表示字面意义"\"

- 转义后的尖括号 \<..\> 代表词组的边界

  尖括号必须进行转义，否则它们就代表其字面意义  
  "\<the\>"匹配词组"the"，而不是词组"them," "there," "other,"等等

```shell
bash$ cat textfile
This is line 1, of which there is only one instance.
 This is the only instance of line 2.
 This is line 3, another line.
 This is line 4.


bash$ grep 'the' textfile
This is line 1, of which there is only one instance.
 This is the only instance of line 2.
 This is line 3, another line.


bash$ grep '\<the\>' textfile
This is the only instance of line 2.
```

唯一判断一个特定的正则表达式是否有效的方法就是测试它。

```shell
测试文件: tstfile                          # No match.
                                            # No match.
运行 grep "1133*"  tstfile                  # Match.
                                            # No match.
                                            # No match.
This line contains the number 113.          # Match.
This line contains the number 13.           # No match.
This line contains the number 133.          # No match.
This line contains the number 1133.         # Match.
This line contains the number 113312.       # Match.
This line contains the number 1112.         # No match.
This line contains the number 113312312.    # Match.
This line contains no numbers at all.       # No match.
```

```shell
bash$ grep "1133*" tstfile
Run   grep "1133*"  on this file.           # Match.
 This line contains the number 113.          # Match.
 This line contains the number 1133.         # Match.
 This line contains the number 113312.       # Match.
 This line contains the number 113312312.    # Match.
```


注解

[[1]](http://tldp.org/LDP/abs/html/x17129.html#FTN.AEN17134) 元意义指的是一个词组或者表达式在更高层次的抽象上的意义。例如，正则表达式的字面意思就是所有人接受其用法的普通表达式。元意义则完全不同，正如在本章最终讨论的那样。
[[2]](http://tldp.org/LDP/abs/html/x17129.html#AEN17189)
Since sed, awk, and grep process single lines, there will usually not be a newline to match. In those cases where there is a newline in a multiple line expression, the dot will match the newline.

```shell
#!/bin/bash

sed -e 'N;s/.*/[&]/' << EOF   # Here Document
line1
line2
EOF
# OUTPUT:
# [line1
# line2]



echo

awk '{ $0=$1 "\n" $2; if (/line.1/) {print}}' << EOF
line 1
line 2
EOF
# OUTPUT:
# line
# 1


# Thanks, S.C.

exit 0
```

## 19 嵌入文档

<blockquote class="blockquote-center">Here and now, boys.
&emsp;&emsp;&emsp;&emsp;--Aldous Huxley, Island</blockquote>


嵌入文档是一段有特殊作用的代码块，它用 [I/O 重定向](http://tldp.org/LDP/abs/html/io-redirection.html#IOREDIRREF) 在交互程序和交互命令中传递和反馈一个命令列表，例如 [ftp](http://tldp.org/LDP/abs/html/communications.html#FTPREF)，[cat](http://tldp.org/LDP/abs/html/basic.html#CATREF) 或者是 ex 文本编辑器

```
COMMAND <<InputComesFromHERE
...
...
...
InputComesFromHERE
```


嵌入文档用限定符作为命令列表的边界，在限定符前需要一个指定的标识符 `<<`，这会将一个程序或命令的标准输入(stdin)进行重定向，它类似 `交互程序 < 命令文件` 的方式，其中命令文件内容如下

```
command #1
command #2
...
```

嵌入文档的格式大致如下

```
interactive-program <<LimitString
command #1
command #2
...
LimitString
```

限定符的选择必须保证特殊以确保不会和命令列表里的内容发生混淆。

注意嵌入文档有时候用作非交互的工具和命令有着非常好的效果，例如 [wall](http://tldp.org/LDP/abs/html/system.html#WALLREF)

样例 19-1. broadcast: 给每个登陆者发送信息

```
#!/bin/bash

wall <<zzz23EndOfMessagezzz23
E-mail your noontime orders for pizza to the system administrator.
    (Add an extra dollar for anchovy or mushroom topping.)
# 额外的信息文本.
# 注意: 'wall' 会打印注释行.
zzz23EndOfMessagezzz23

# 更有效的做法是通过
#         wall < 信息文本
#  然而, 在脚本里嵌入信息模板不乏是一种迅速而又随性的解决方式.

exit
```

样例: 19-2. dummyfile：创建一个有两行内容的虚拟文件

```
#!/bin/bash

# 非交互的使用 `vi` 编辑文件.
# 仿照 'sed'.

E_BADARGS=85

if [ -z "$1" ]
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi

TARGETFILE=$1

# 插入两行到文件中保存
#--------Begin here document-----------#
vi $TARGETFILE <<x23LimitStringx23
i
This is line 1 of the example file.
This is line 2 of the example file.
^[
ZZ
x23LimitStringx23
#----------End here document-----------#

#  注意 "^" 对 "[" 进行了转义 
#+ 这段起到了和键盘上按下 Control-V <Esc> 相同的效果.

#  Bram Moolenaar 指出这种情况下 'vim' 可能无法正常工作
#+ 因为在与终端交互的过程中可能会出现问题.

exit
```

上述脚本实现了 `ex` 的功能, 而不是 `vi`. 嵌入文档包含了 `ex` 足够通用的命令列表来形成自有的类别, 所以又称之为 `ex` 脚本.

```
#!/bin/bash
#  替换所有的以 ".txt" 后缀结尾的文件的 "Smith" 为 "Jones"

ORIGINAL=Smith
REPLACEMENT=Jones

for word in $(fgrep -l $ORIGINAL *.txt)
do
  # -------------------------------------
  ex $word <<EOF
  :%s/$ORIGINAL/$REPLACEMENT/g
  :wq
EOF
  # :%s is the "ex" substitution command.
  # :wq is write-and-quit.
  # -------------------------------------
done
```

类似的 `ex 脚本` 是 `cat 脚本`.

样例 19-3. 使用 `cat` 的多行信息

```
#!/bin/bash

#  'echo' 可以输出单行信息,
#+  但是如果是输出消息块就有点问题了.
#   'cat' 嵌入文档却能解决这个局限.

cat <<End-of-message
-------------------------------------
This is line 1 of the message.
This is line 2 of the message.
This is line 3 of the message.
This is line 4 of the message.
This is the last line of the message.
-------------------------------------
End-of-message

#  替换上述嵌入文档内的 7 行文本
#+   cat > $Newfile <<End-of-message
#+       ^^^^^^^^^^
#+ 将输出追加到 $Newfile, 而不是标准输出.

exit 0


#--------------------------------------------
# 由于上面的 "exit 0"，下面的代码将不会生效.

# S.C. points out that the following also works.
echo "-------------------------------------
This is line 1 of the message.
This is line 2 of the message.
This is line 3 of the message.
This is line 4 of the message.
This is the last line of the message.
-------------------------------------"
# 然而, 文本可能不包括双引号除非出现了字符串逃逸.
```

`-` 的作用是标记了一个嵌入文档限制符 (<<-LimitString) ，它能抑制输出的行首的 `tab` (非空格). 这在脚本可读性方面可能非常有用.

样例 19-4. 抑制 tab 的多行信息

```
#!/bin/bash
# 和之前的样例一样, 但...

#  嵌入文档内的 '-' ，也就是 <<-
#+ 抑制了文档行首的 'tab',
#+ 但 *不是* 空格.

cat <<-ENDOFMESSAGE
	This is line 1 of the message.
	This is line 2 of the message.
	This is line 3 of the message.
	This is line 4 of the message.
	This is the last line of the message.
ENDOFMESSAGE
# 脚本的输出将左对齐.
# 行首的 tab 将不会输出.

# 上面 5 行的 "信息" 以 tab 开始, 不是空格.
# 空格不会受影响 <<- .

# 注意这个选项对 *内嵌的* tab 没有影响.

exit 0
```

嵌入文档支持参数和命令替换. 因此可以向嵌入文档传递不同的参数,变向的改其输出.

样例 19-5. 可替换参数的嵌入文档

```
#!/bin/bash
# 另一个使用参数替换的 'cat' 嵌入文档.

# 试一试没有命令行参数,   ./scriptname
# 试一试一个命令行参数,   ./scriptname Mortimer
# 试试用一两个单词引用命令行参数,
#                           ./scriptname "Mortimer Jones"

CMDLINEPARAM=1     #  Expect at least command-line parameter.

if [ $# -ge $CMDLINEPARAM ]
then
  NAME=$1          #  If more than one command-line param,
                   #+ then just take the first.
else
  NAME="John Doe"  #  Default, if no command-line parameter.
fi  

RESPONDENT="the author of this fine script"  
  

cat <<Endofmessage

Hello, there, $NAME.
Greetings to you, $NAME, from $RESPONDENT.

# 这个注释在输出时显示 (为什么?).

Endofmessage

# 注意输出了空行.
# 所以可以这样注释.

exit
```

这个包含参数替换的嵌入文档是相当有用的

样例 19-6. 上传文件对到 `Sunsite` 入口目录

```
#!/bin/bash
# upload.sh

#  上传文件对 (Filename.lsm, Filename.tar.gz)
#+ 到 Sunsite/UNC (ibiblio.org) 的入口目录.
#  Filename.tar.gz 是个 tarball.
#  Filename.lsm is 是个描述文件.
#  Sunsite 需要 "lsm" 文件, 否则将会退回给发送者


E_ARGERROR=85

if [ -z "$1" ]
then
  echo "Usage: `basename $0` Filename-to-upload"
  exit $E_ARGERROR
fi  


Filename=`basename $1`           # Strips pathname out of file name.

Server="ibiblio.org"
Directory="/incoming/Linux"
#  脚本里不需要硬编码,
#+ 但最好可以替换命令行参数.

Password="your.e-mail.address"   # Change above to suit.

ftp -n $Server <<End-Of-Session
# -n 禁用自动登录

user anonymous "$Password"       #  If this doesn't work, then try:
                                 #  quote user anonymous "$Password"
binary
bell                             # Ring 'bell' after each file transfer.
cd $Directory
put "$Filename.lsm"
put "$Filename.tar.gz"
bye
End-Of-Session

exit 0
```

在嵌入文档头部引用或转义"限制符"来禁用参数替换.原因是 `引用/转义` 限定符能有效的[转义](http://tldp.org/LDP/abs/html/escapingsection.html#ESCP)  "$", "`", 和 "\" 这些[特殊符号](http://tldp.org/LDP/abs/html/special-chars.html#SCHARLIST), 使他们维持字面上的意思. (感谢 Allen Halsey 指出这点.)

样例 19-7. 禁用参数替换

```
#!/bin/bash
#  A 'cat' here-document, but with parameter substitution disabled.

NAME="John Doe"
RESPONDENT="the author of this fine script"  

cat <<'Endofmessage'

Hello, there, $NAME.
Greetings to you, $NAME, from $RESPONDENT.

Endofmessage

#   当'限制符'引用或转义时不会有参数替换.
#   下面的嵌入文档也有同样的效果
#   cat <<"Endofmessage"
#   cat <<\Endofmessage



#   同样的:

cat <<"SpecialCharTest"

Directory listing would follow
if limit string were not quoted.
`ls -l`

Arithmetic expansion would take place
if limit string were not quoted.
$((5 + 3))

A a single backslash would echo
if limit string were not quoted.
\\

SpecialCharTest


exit
```

生成脚本或者程序代码时可以用禁用参数的方式来输出文本.

样例 19-8. 生成其他脚本的脚本

```
#!/bin/bash
# generate-script.sh
# Based on an idea by Albert Reiner.

OUTFILE=generated.sh         # Name of the file to generate.


# -----------------------------------------------------------
# '嵌入文档涵盖了生成脚本的主体部分.
(
cat <<'EOF'
#!/bin/bash

echo "This is a generated shell script."
#  注意我们现在在一个子 shell 内,
#+ 我们不能访问 "外部" 脚本变量.

echo "Generated file will be named: $OUTFILE"
#  上面这行并不能按照预期的正常工作
#+ 因为参数扩展已被禁用.
#  相反的, 结果是文字输出.

a=7
b=3

let "c = $a * $b"
echo "c = $c"

exit 0
EOF
) > $OUTFILE
# -----------------------------------------------------------

#  在上述的嵌入文档内引用'限制符'防止变量扩展

if [ -f "$OUTFILE" ]
then
  chmod 755 $OUTFILE
  # 生成可执行文件.
else
  echo "Problem in creating file: \"$OUTFILE\""
fi

#  这个方法适用于生成 C, Perl, Python, Makefiles 等等

exit 0
```

可以从嵌入文档的输出设置一个变量的值. 这实际上是种灵活的 [命令替换](http://tldp.org/LDP/abs/html/commandsub.html#COMMANDSUBREF).

```
variable=$(cat <<SETVAR
This variable
runs over multiple lines.
SETVAR
)

echo "$variable"
```

同样的脚本里嵌入文档可以作为函数的输入.

样例 19-9. 嵌入文档和函数

```
#!/bin/bash
# here-function.sh

GetPersonalData ()
{
  read firstname
  read lastname
  read address
  read city 
  read state 
  read zipcode
} # 可以肯定的是这应该是个交互式的函数, 但 . . .


# 作为函数的输入.
GetPersonalData <<RECORD001
Bozo
Bozeman
2726 Nondescript Dr.
Bozeman
MT
21226
RECORD001


echo
echo "$firstname $lastname"
echo "$address"
echo "$city, $state $zipcode"
echo

exit 0
```

可以这样使用: 作为一个虚构的命令接受嵌入文档的输出. 这样实际上就创建了一个 "匿名" 嵌入文档.

样例 19-10. "匿名" 嵌入文档

```
#!/bin/bash

: <<TESTVARIABLES
${HOSTNAME?}${USER?}${MAIL?}  # Print error message if one of the variables not set.
TESTVARIABLES

exit $?
```

- 上面技巧的一种变体允许 "可添加注释" 的代码块.

样例 19-11. 可添加注释的代码块

```
#!/bin/bash
# commentblock.sh

: <<COMMENTBLOCK
echo "This line will not echo."
这些注释没有 "#" 前缀.
则是另一种没有 "#" 前缀的注释方法.

&*@!!++=
上面这行不会产生报错信息,
因为 bash 解释器会忽略它.

COMMENTBLOCK

echo "Exit value of above \"COMMENTBLOCK\" is $?."   # 0
# 没有错误输出.
echo

#  上面的技巧经常用于工作代码的注释用作排错目的
#  这省去了在每一行开头加上 "#" 前缀,
#+ 然后调试完不得不删除每行的前缀的重复工作.
#  注意我们用了 ":", 在这之上，是可选的.

echo "Just before commented-out code block."
#  下面这个在双破折号之间的代码不会被执行.
#  ===================================================================
: <<DEBUGXXX
for file in *
do
 cat "$file"
done
DEBUGXXX
#  ===================================================================
echo "Just after commented-out code block."

exit 0



######################################################################
#  注意, 然而, 如果将变量中包含一个注释的代码块将会引发问题
#  例如:


#/!/bin/bash

  : <<COMMENTBLOCK
  echo "This line will not echo."
  &*@!!++=
  ${foo_bar_bazz?}
  $(rm -rf /tmp/foobar/)
  $(touch my_build_directory/cups/Makefile)
COMMENTBLOCK


$ sh commented-bad.sh
commented-bad.sh: line 3: foo_bar_bazz: parameter null or not set

# 有效的补救办法就是在 49 行的位置加上单引号，变为 'COMMENTBLOCK'.

  : <<'COMMENTBLOCK'

# 感谢 Kurt Pfeifle 指出这一点.
```

- 另一个漂亮的方法使得"自文档化"的脚本成为可能


样例 19-12. 自文档化的脚本

```
#!/bin/bash
# self-document.sh: self-documenting script
# Modification of "colm.sh".

DOC_REQUEST=70

if [ "$1" = "-h"  -o "$1" = "--help" ]     # 请求帮助.
then
  echo; echo "Usage: $0 [directory-name]"; echo
  sed --silent -e '/DOCUMENTATIONXX$/,/^DOCUMENTATIONXX$/p' "$0" |
  sed -e '/DOCUMENTATIONXX$/d'; exit $DOC_REQUEST; fi


: <<DOCUMENTATIONXX
List the statistics of a specified directory in tabular format.
---------------------------------------------------------------
The command-line parameter gives the directory to be listed.
If no directory specified or directory specified cannot be read,
then list the current working directory.

DOCUMENTATIONXX

if [ -z "$1" -o ! -r "$1" ]
then
  directory=.
else
  directory="$1"
fi  

echo "Listing of "$directory":"; echo
(printf "PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n" \
; ls -l "$directory" | sed 1d) | column -t

exit 0
```

使用 [cat script](http://tldp.org/LDP/abs/html/here-docs.html#CATSCRIPTREF) 是另一种可行的方法.

```
DOC_REQUEST=70

if [ "$1" = "-h"  -o "$1" = "--help" ]     # Request help.
then                                       # Use a "cat script" . . .
  cat <<DOCUMENTATIONXX
List the statistics of a specified directory in tabular format.
---------------------------------------------------------------
The command-line parameter gives the directory to be listed.
If no directory specified or directory specified cannot be read,
then list the current working directory.

DOCUMENTATIONXX
exit $DOC_REQUEST
fi
```

> 另请参阅 [样例 A-28](http://tldp.org/LDP/abs/html/contributed-scripts.html#ISSPAMMER2), [样例 A-40](http://tldp.org/LDP/abs/html/contributed-scripts.html#PETALS), [样例 A-41](http://tldp.org/LDP/abs/html/contributed-scripts.html#QKY), and [样例 A-42](http://tldp.org/LDP/abs/html/contributed-scripts.html#NIM) 更多样例请阅读脚本附带的注释文档.


- 嵌入文档创建了临时文件, 但这些文件在打开且不可被其他程序访问后删除.

```
bash$ bash -c 'lsof -a -p $$ -d0' << EOF
> EOF
lsof    1213 bozo    0r   REG    3,5    0 30386 /tmp/t1213-0-sh (deleted)
```

- 某些工具在嵌入文档内部并不能正常运行.

- 在嵌入文档的最后关闭限定符必须在起始的第一个字符的位置开始.行首不能是空格. 限制符后尾随空格同样会导致意想不到的行为.空格可以防止限制符被当做其他用途. [[1]](http://tldp.org/LDP/abs/html/here-docs.html#FTN.AEN17822)

```
#!/bin/bash

echo "----------------------------------------------------------------------"

cat <<LimitString
echo "This is line 1 of the message inside the here document."
echo "This is line 2 of the message inside the here document."
echo "This is the final line of the message inside the here document."
     LimitString
#^^^^限制符的缩进. 出错! 这个脚本将不会如期运行.

echo "----------------------------------------------------------------------"

#  这些评论在嵌入文档范围外并不能输出

echo "Outside the here document."

exit 0

echo "This line had better not echo."  # 紧跟着个 'exit' 命令.
```

- 有些人非常聪明的使用了一个单引号(!)做为限制符. 但这并不是个好主意

```
# 这个可以运行.
cat <<!
Hello!
! Three more exclamations !!!
!


# 但是 . . .
cat <<!
Hello!
Single exclamation point follows!
!
!
# Crashes with an error message.


# 然而, 下面这样也能运行.
cat <<EOF
Hello!
Single exclamation point follows!
!
EOF
# 使用多字符限制符更为安全.
```

为嵌入文档设置这些任务有些复杂, 可以考虑使用 `expect`, 一种专门用来和程序进行交互的脚本语言。

**Notes:**
&emsp;&emsp;除此之外, Dennis Benzinger 指出,  [使用 <<- 抑制 tab.](http://tldp.org/LDP/abs/html/here-docs.html#LIMITSTRDASH)

## 20 I/O 重定向

有三个默认打开的文件[[1]](http://tldp.org/LDP/abs/html/io-redirection.html#FTN.AEN17884), `stdin`(标准输入，键盘),`stdout`(标准输出， 屏幕)和 `stderr`(标准错误，屏幕上输出的错误信息)。这些和任何其他打开的文件都可以被重定向。重定向仅仅意味着捕获输出文件，命令，脚本，甚至是一个脚本的代码块([样例 3-1](http://tldp.org/LDP/abs/html/special-chars.html#EX8))和([样例 3-2](http://tldp.org/LDP/abs/html/special-chars.html#EX8)) 作为另一个文件，命令，程序或脚本的输入。

每个打开的文件都有特定的文件描述符。[[2]](http://tldp.org/LDP/abs/html/io-redirection.html#FTN.AEN17894),而 `stdin`，`stdout`，`stderr` 的文件描述符分别为 0,1,2。当然了，还有附件的文件描述符 3 - 9。有时候为`stdin`，`stdout`，`stderr`临时性的复制链接分配这些附加的文件描述符会非常有用.[[3]](http://tldp.org/LDP/abs/html/io-redirection.html#FTN.AEN17906)。这简化了复杂重定向和重组后的恢复(见[样例 20-1](http://tldp.org/LDP/abs/html/x17974.html#REDIR1))

```
   COMMAND_OUTPUT >
      # 重定向标准输出到一个文件.
      # 如果文件不存在则创建，否则覆盖.

      ls -lR > dir-tree.list
      # 创建了一个包含目录树列表的文件.

   : > filename
      # ">" 清空了文件.
      # 如果文件不存在，则创建了个空文件 (效果类似 'touch').
      # ":" 是个虚拟占位符, 不会有输出.

   > filename    
      # ">" 清空了文件.
      # 如果文件不存在，则创建了个空文件 (效果类似 'touch').
      # (结果和上述的 ": >" 一样， 但在某些 shell 环境中不能正常运行.)

   COMMAND_OUTPUT >>
      # 重定向标准输出到一个文件.
      # 如果文件不存在则创建，否则新内容在文件末尾追加.


      # 单行重定向命令 (只作用于本身所在的那行):
      # --------------------------------------------------------------------

   1>filename
      # 以覆盖的方式将 标准错误 重定向到文件 "filename."
   1>>filename
      # 以追加的方式将 标准输出 重定向到文件 "filename."
   2>filename
      # 以覆盖的方式将 标准错误 重定向到文件 "filename."
   2>>filename
      # 以追加的方式将 标准错误 重定向到文件 "filename."
   &>filename
      # 以覆盖的方式将 标准错误 和 标准输出 同时重定向到文件 "filename."
      # 在 bash 4 中才有这个新功能.

   M>N
     # "M" 是个文件描述符, 如果不明确指定，默认为 1.
     # "N" 是个文件名.
     # 文件描述符 "M" 重定向到文件 "N."
   M>&N
     # "M" 是个文件描述符, 如果不设置默认为 1.
     # "N" 是另一个文件描述符.

      #==============================================================================

      # 重定向 标准输出，一次一行.
      LOGFILE=script.log

      echo "This statement is sent to the log file, \"$LOGFILE\"." 1>$LOGFILE
      echo "This statement is appended to \"$LOGFILE\"." 1>>$LOGFILE
      echo "This statement is also appended to \"$LOGFILE\"." 1>>$LOGFILE
      echo "This statement is echoed to stdout, and will not appear in \"$LOGFILE\"."
      # 这些重定向命令在每行结束后自动"重置".



      # 重定向 标准错误，一次一行.
      ERRORFILE=script.errors

      bad_command1 2>$ERRORFILE       #  Error message sent to $ERRORFILE.
      bad_command2 2>>$ERRORFILE      #  Error message appended to $ERRORFILE.
      bad_command3                    #  Error message echoed to stderr,
                                      #+ and does not appear in $ERRORFILE.
      # 这些重定向命令每行结束后会自动“重置”.
	#=======================================================================
```

```
   2>&1
      # 重定向 标准错误 到 标准输出.
      # 错误信息发送到标准输出相同的位置.
        >>filename 2>&1
            bad_command >>filename 2>&1
            # 同时将 标准输出 和 标准错误 追加到文件 "filename" 中 ...
        2>&1 | [command(s)]
            bad_command 2>&1 | awk '{print $5}'   # found
            # 通过管道传递 标准错误.
            # bash 4 中可以将 "2>&1 |" 缩写为 "|&".

   i>&j
      # 重定向文件描述符 i 到 j.
      # 文件描述符 i 指向的文件输出将会重定向到文件描述符 j 指向的文件

   >&j
      # 默认的标准输出 (stdout) 重定向到 j.
      # 所有的标准输出将会重定向到 j 指向的文件.
```

```
   0< FILENAME
    < FILENAME
      # 从文件接收输入.
      # 类似功能命令是 ">", 经常会组合使用.
      #
      # grep search-word <filename


   [j]<>filename
      #  打开并读写文件 "filename" ,
      #+ 并且分配文件描述符 "j".
      #  如果 "filename" 不存在则创建.
      #  如果文件描述符 "j" 未指定, 默认分配文件描述符 0, 标准输入.
      #
      #  这是一个写指定文件位置的应用程序. 
      echo 1234567890 > File    # 写字符串到 "File".
      exec 3<> File             # 打开并分配文件描述符 3 给 "File" .
      read -n 4 <&3             # 读取 4 字符.
      echo -n . >&3             # 写一个小数点.
      exec 3>&-                 # 关闭文件描述符 3.
      cat File                  # ==> 1234.67890
      #  随机访问.



   |
      # 管道.
      # 一般是命令和进程的链接工具.
      # 类似 ">", 但更一般.
      # 在连接命令，脚本，文件和程序方面非常有用.
      cat *.txt | sort | uniq > result-file
      # 所有 .txt 文件输出进行排序并且删除复制行,
      # 最终保存结果到 "result-file".
```

可以用单个命令行表示输入和输出的多个重定向或管道.

```
command < input-file > output-file
# 或者等价:
< input-file command > output-file   # 尽管这不标准.

command1 | command2 | command3 > output-file
```

更多详情见[样例 16-31](http://tldp.org/LDP/abs/html/filearchiv.html#DERPM) and [样例 A-14](http://tldp.org/LDP/abs/html/contributed-scripts.html#FIFO).

多个输出流可以重定向到一个文件.

```
ls -yz >> command.log 2>&1
#  捕获不合法选项 "yz" 的结果到文件 "command.log."
#  因为 标准错误输出 被重定向到了文件,
#+ 任何错误信息都会在这.

#  注意, 然而, 接下来的这个案例并 "不能" 同样的结果.
ls -yz 2>&1 >> command.log
#  输出一条错误信息，但是不会写入到文件.
#  恰恰的, 命令输出(这个例子里为空)写入到文件, 但错误信息只会在 标准输出 输出.

#  如果同时重定向 标准输出 和 标准错误输出,
#+ 命令的顺序不同会导致不同.
```

关闭文件描述符

```
n<&-
	关闭输入文件描述符 n.

0<&-, <&-
	关闭标准输入.

n>&-
	关闭输出文件描述符 n.

1>&-, >&-
	关闭标准输出.
```

子进程能继承文件描述符.这就是管道符能工作的原因.通过关闭文件描述符来防止继承 .

```
# 只重定向到 标准错误 到管道.

exec 3>&1                              # 保存当前 标准输出 "值".

ls -l 2>&1 >&3 3>&- | grep bad 3>&-    # 关闭 'grep' 文件描述符 3 (但不是 'ls').
#              ^^^^   ^^^^
exec 3>&-                              # 现在关闭它.

# 感谢, S.C.
```

更多关于 I/O 重定向详情见 [Appendix F](http://tldp.org/LDP/abs/html/ioredirintro.html).

**注意**

[[1]](http://tldp.org/LDP/abs/html/io-redirection.html#AEN17884)	 在 UNIX 和 Linux 中, 数据流和周边外设([device files](http://tldp.org/LDP/abs/html/devref1.html#DEVFILEREF)) 都被看做文件.

[[2]](http://tldp.org/LDP/abs/html/io-redirection.html#AEN17894)	 `文件描述符` 仅仅是操作系统分配的一个可追踪的打开的文件号. 可以认为是一个简化的文件指针. 类似于 C 语言的 `文件句柄`.

[[3]](http://tldp.org/LDP/abs/html/io-redirection.html#AEN17906)	当 bash 创建一个子进程的时候使用 `文件描述符 5` 会有问题. 例如 [exec](http://tldp.org/LDP/abs/html/internal.html#EXECREF), 子进程继承了文件描述符 5 (详情见 Chet Ramey's 归档的 e-mail, [SUBJECT: RE: File descriptor 5 is held open](https://groups.google.com/forum/#!topic/gnu.bash.bug/E5Vdqv3tO1w)). 最好将这个文件描述符单独规避.

### 20.1 使用 exec

一个 `exec < filename` 命令重定向了 `标准输入` 到一个文件。自此所有 `标准输入` 都来自该文件而不是默认来源(通常是键盘输入)。在使用 [sed](http://tldp.org/LDP/abs/html/sedawk.html#SEDREF) 和 [awk](http://tldp.org/LDP/abs/html/awk.html#AWKREF) 时候这种方式可以逐行读文件并逐行解析。

样例 20-1. 使用 `exec` 重定向 标准输入

```
#!/bin/bash
# 使用 'exec' 重定向 标准输入 .


exec 6<&0          # 链接文件描述符 #6 到标准输入.
                   # .

exec < data-file   # 标准输入被文件 "data-file" 替换

read a1            # 读取文件 "data-file" 首行.
read a2            # 读取文件 "data-file" 第二行

echo
echo "Following lines read from file."
echo "-------------------------------"
echo $a1
echo $a2

echo; echo; echo

exec 0<&6 6<&-
#  现在在之前保存的位置将从文件描述符 #6 将 标准输出 恢复.
#+ 且关闭文件描述符 #6 ( 6<&- ) 让其他程序正常使用.
#
# <&6 6<&-    also works.

echo -n "Enter data  "
read b1  # 现在按预期的，从正常的标准输入 "read".
echo "Input read from stdin."
echo "----------------------"
echo "b1 = $b1"

echo

exit 0
```

同理, `exec >filename` 重定向 标准输出 到指定文件. 他将所有的命令输出通常是 标准输出 重定向到指定的位置.

`exec N > filename` 影响整个脚本或当前 shell。[PID](http://tldp.org/LDP/abs/html/special-chars.html#PROCESSIDREF) 从重定向脚本或 shell 的那时候已经发生了改变. 然而 `N > filename` 影响的就是新派生的进程，而不是整个脚本或 shell。

样例 20-2. 使用 exec 重定向标准输出

```
#!/bin/bash
# reassign-stdout.sh

LOGFILE=logfile.txt

exec 6>&1           # 链接文件描述符 #6 到标准输出.
                    # 保存标准输出.

exec > $LOGFILE     # 标准输出被文件 "logfile.txt" 替换.

# ----------------------------------------------------------- #
# 所有在这个块里的命令的输出都会发送到文件 $LOGFILE.

echo -n "Logfile: "
date
echo "-------------------------------------"
echo

echo "Output of \"ls -al\" command"
echo
ls -al
echo; echo
echo "Output of \"df\" command"
echo
df

# ----------------------------------------------------------- #

exec 1>&6 6>&-      # 关闭文件描述符 #6 恢复 标准输出.

echo
echo "== stdout now restored to default == "
echo
ls -al
echo

exit 0
```

样例 20-3. 用 exec 在一个脚本里同时重定向 标准输入 和 标准输出

```
#!/bin/bash
# upperconv.sh
# 转化指定的输入文件成大写.

E_FILE_ACCESS=70
E_WRONG_ARGS=71

if [ ! -r "$1" ]     # 指定的输入文件是否可读?
then
  echo "Can't read from input file!"
  echo "Usage: $0 input-file output-file"
  exit $E_FILE_ACCESS
fi                   #  同样的错误退出
                     #+ 等同如果输入文件 ($1) 未指定 (为什么?).

if [ -z "$2" ]
then
  echo "Need to specify output file."
  echo "Usage: $0 input-file output-file"
  exit $E_WRONG_ARGS
fi


exec 4<&0
exec < $1            # 将从输入文件读取.

exec 7>&1
exec > $2            # 将写入输出文件.
                     # 假定输出文件可写 (增加检测?).

# -----------------------------------------------
    cat - | tr a-z A-Z   # 转化大写.
#   ^^^^^                # 读取标准输入.
#           ^^^^^^^^^^   # 写到标准输出.
# 然而标准输入和标准输出都会被重定向.
# 注意 'cat' 可能会被遗漏.
# -----------------------------------------------

exec 1>&7 7>&-       # 恢复标准输出.
exec 0<&4 4<&-       # 恢复标准输入.

# 恢复后, 下面这行会预期从标准输出打印.
echo "File \"$1\" written to \"$2\" as uppercase conversion."

exit 0
```

I/O 重定向是种明智的规避 [inaccessible variables within a subshell](http://tldp.org/LDP/abs/html/subshells.html#PARVIS) 问题的方法.

样例 20-4. 规避子 shell

```
#!/bin/bash
# avoid-subshell.sh
# Matthew Walker 的建议.

Lines=0

echo

cat myfile.txt | while read line;
                 do {
                   echo $line
                   (( Lines++ ));  #  递增变量的值趋近外层循环
                                   #  使用子 shell 会有问题.
                 }
                 done

echo "Number of lines read = $Lines"     # 0
                                         # 报错!

echo "------------------------"


exec 3<> myfile.txt
while read line <&3
do {
  echo "$line"
  (( Lines++ ));                   #  递增变量的值趋近外层循环.
                                   #  没有子 shell，就不会有问题.
}
done
exec 3>&-

echo "Number of lines read = $Lines"     # 8

echo

exit 0

# 下面的行并不在脚本里.

$ cat myfile.txt

Line 1.
Line 2.
Line 3.
Line 4.
Line 5.
Line 6.
Line 7.
Line 8.
```

### 20.2 重定向代码块

有如 [while](http://tldp.org/LDP/abs/html/loops1.html#WHILELOOPREF), [until](http://tldp.org/LDP/abs/html/loops1.html#FORLOOPREF1), 和 [for](http://tldp.org/LDP/abs/html/loops1.html#UNTILLOOPREF) 循环, 甚至 [if/then](http://tldp.org/LDP/abs/html/tests.html#IFTHEN) 也可以重定向 标准输入 测试代码块. 甚至连一个函数都可以用这个方法进行重定向 (见 [样例 24-11](http://tldp.org/LDP/abs/html/complexfunct.html#REALNAME)).  代码块的末尾部分的 "<" 就是用来完成这个的.

样例 20-5. while 循环的重定向

```
#!/bin/bash
# redir2.sh

if [ -z "$1" ]
then
  Filename=names.data       # 如果不指定文件名的默认值.
else
  Filename=$1
fi  
#+ Filename=${1:-names.data}
#  can replace the above test (parameter substitution).

count=0

echo

while [ "$name" != Smith ]  # 为什么变量 "$name" 加引号?
do
  read name                 # 从 $Filename 读取值, 而不是 标准输入.
  echo $name
  let "count += 1"
done <"$Filename"           # 重定向标准输入到文件 $Filename. 
#    ^^^^^^^^^^^^

echo; echo "$count names read"; echo

exit 0

#  注意在一些老的脚本语言中,
#+ 循环的重定向会跑在子 shell 的环境中.
#  因此, $count 返回 0, 在循环外已经初始化过值.
#  Bash 和 ksh *只要可能* 会避免启动子 shell ,
#+ 所以这个脚本作为样例运行成功.
#  (感谢 Heiner Steven 指出这点.)

#  然而 . . .
#  Bash 有时候 *能* 在 "只读的 while" 循环启动子进程 ,
#+ 不同于 "while" 循环的重定向.

abc=hi
echo -e "1\n2\n3" | while read l
     do abc="$l"
        echo $abc
     done
echo $abc

#  感谢, Bruno de Oliveira Schneider 上面的演示代码.
#  也感谢 Brian Onn 纠正了注释的错误.
```

样例 20-6. 另一种形式的 while 循环重定向

```
#!/bin/bash

# 这是之前的另一种形式的脚本.

#  Heiner Steven 提议在重定向循环时候运行在子 shell 可以作为一个变通方案
#+ 因此直到循环终止时循环内部的变量不需要保证他们的值


if [ -z "$1" ]
then
  Filename=names.data     # 如果不指定文件名的默认值.
else
  Filename=$1
fi  


exec 3<&0                 # 保存标准输入到文件描述符 3.
exec 0<"$Filename"        # 重定向标准输入.

count=0
echo


while [ "$name" != Smith ]
do
  read name               # 从重定向的标准输入($Filename)读取值.
  echo $name
  let "count += 1"
done                      #  从 $Filename 循环读
                          #+ 因为第 20 行.

#  这个脚本的早期版本在 "while" 循环 done <"$Filename" 终止
#  练习:
#  为什么这个没必要?


exec 0<&3                 # 恢复早前的标准输入.
exec 3<&-                 # 关闭临时的文件描述符 3.

echo; echo "$count names read"; echo

exit 0
```

样例 20-7. until 循环的重定向

```
#!/bin/bash
# 同先前的脚本一样, 不过用的是 "until" 循环.

if [ -z "$1" ]
then
  Filename=names.data         # 如果不指定文件的默认值.
else
  Filename=$1
fi  

# while [ "$name" != Smith ]
until [ "$name" = Smith ]     # 变  !=  为 =.
do
  read name                   # 从 $Filename 读取值, 而不是标准输入.
  echo $name
done <"$Filename"             # 重定向标准输入到文件 "$Filename". 
#    ^^^^^^^^^^^^

# 和之前的 "while" 循环样例相同的结果.

exit 0
```

样例 20-8. for 循环的重定向

```
#!/bin/bash

if [ -z "$1" ]
then
  Filename=names.data          # 如果不指定文件的默认值.
else
  Filename=$1
fi  

line_count=`wc $Filename | awk '{ print $1 }'`
#           目标文件的行数.
#
#  非常作和不完善, 然而这只是证明 "for" 循环中的重定向标准输入是可行的
#+ 如果你足够聪明的话.
#
# 简介的做法是     line_count=$(wc -l < "$Filename")


for name in `seq $line_count`  # 回忆下 "seq" 可以输入数组序列.
# while [ "$name" != Smith ]   --   比 "while" 循环更复杂的循环   --
do
  read name                    # 从 $Filename 读取值, 而不是标准输入.
  echo $name
  if [ "$name" = Smith ]       # 这需要所有这些额外的设置.
  then
    break
  fi  
done <"$Filename"              # 重定向标准输入到文件 "$Filename". 
#    ^^^^^^^^^^^^

exit 0
```

我们可以修改先前的样例也可以重定向循环的输出.

样例 20-9. for 循环的重定向 (同时重定向标准输入和标准输出)

```
#!/bin/bash

if [ -z "$1" ]
then
  Filename=names.data          # 如果不指定文件的默认值.
else
  Filename=$1
fi  

Savefile=$Filename.new         # 报错的结果的文件名.
FinalName=Jonah                # 停止 "read" 的终止字符.

line_count=`wc $Filename | awk '{ print $1 }'`  # 目标文件行数.


for name in `seq $line_count`
do
  read name
  echo "$name"
  if [ "$name" = "$FinalName" ]
  then
    break
  fi  
done < "$Filename" > "$Savefile"     # 重定向标准输入到文件 $Filename,
#    ^^^^^^^^^^^^^^^^^^^^^^^^^^^       并且报错结果到备份文件.

exit 0
```


样例 20-10. if/then test的重定向

```
#!/bin/bash

if [ -z "$1" ]
then
  Filename=names.data   # 如果不指定文件的默认值.
else
  Filename=$1
fi  

TRUE=1

if [ "$TRUE" ]          # if true    和   if :   都可以工作.
then
 read name
 echo $name
fi <"$Filename"
#  ^^^^^^^^^^^^

# 只读取文件的首行.
# "if/then" test 除非嵌入在循环内部否则没办法迭代.

exit 0
```

样例 20-11. 上述样例的数据文件 names.data

```
Aristotle
Arrhenius
Belisarius
Capablanca
Dickens
Euler
Goethe
Hegel
Jonah
Laplace
Maroczy
Purcell
Schmidt
Schopenhauer
Semmelweiss
Smith
Steinmetz
Tukhashevsky
Turing
Venn
Warshawski
Znosko-Borowski

#+ 这是 "redir2.sh", "redir3.sh", "redir4.sh", "redir4a.sh", "redir5.sh" 的数据文件.
```

代码块的标准输出的重定向影响了保存到文件的输出. 见样例 [样例 3-2](http://tldp.org/LDP/abs/html/special-chars.html#RPMCHECK).

[嵌入文档](http://tldp.org/LDP/abs/html/here-docs.html#HEREDOCREF) 是种特别的重定向代码块的方法. 既然如此,它使得在 while 循环的标准输入里传入嵌入文档的输出变得可能.

```
# 这个样例来自 Albert Siersema
# 得到了使用许可 (感谢!).

function doesOutput()
 # 当然这也是个外部命令.
 # 这里用函数进行演示会更好一点.
{
  ls -al *.jpg | awk '{print $5,$9}'
}


nr=0          #  我们希望在 'while' 循环里可以操作这些
totalSize=0   #+ 并且在 'while' 循环结束时看到改变.

while read fileSize fileName ; do
  echo "$fileName is $fileSize bytes"
  let nr++
  totalSize=$((totalSize+fileSize))   # Or: "let totalSize+=fileSize"
done<<EOF
$(doesOutput)
EOF

echo "$nr files totaling $totalSize bytes"
```

### 20.3 应用程序

使用 I/O 重定向可以同时解析和固定命令输出的片段(see [样例 15-7](http://tldp.org/LDP/abs/html/internal.html#READREDIR)). 这也使得可以生成报告和日志文件.

样例 20-12. 日志记录事件

```
#!/bin/bash
# logevents.sh
# 作者: Stephane Chazelas.
# 用于 ABS 许可指南.

# 事件记录到文件.
# 必须 root 身份执行 (可以写入 /var/log).

ROOT_UID=0     # 只有 $UID 为 0 的用户具有 root 权限.
E_NOTROOT=67   # 非 root 会报错.


if [ "$UID" -ne "$ROOT_UID" ]
then
  echo "Must be root to run this script."
  exit $E_NOTROOT
fi  


FD_DEBUG1=3
FD_DEBUG2=4
FD_DEBUG3=5

# === 取消下面两行注释来激活脚本. ===
# LOG_EVENTS=1
# LOG_VARS=1


log()  # 时间和日期写入日志文件.
{
echo "$(date)  $*" >&7     # *追加* 日期到文件.
#     ^^^^^^^  命令替换
                           # 见下文.
}



case $LOG_LEVEL in
 1) exec 3>&2         4> /dev/null 5> /dev/null;;
 2) exec 3>&2         4>&2         5> /dev/null;;
 3) exec 3>&2         4>&2         5>&2;;
 *) exec 3> /dev/null 4> /dev/null 5> /dev/null;;
esac

FD_LOGVARS=6
if [[ $LOG_VARS ]]
then exec 6>> /var/log/vars.log
else exec 6> /dev/null                     # 清空输出.
fi

FD_LOGEVENTS=7
if [[ $LOG_EVENTS ]]
then
  # exec 7 >(exec gawk '{print strftime(), $0}' >> /var/log/event.log)
  # 上述行在最近高于 bash 2.04 版本会失败，为什么?
  exec 7>> /var/log/event.log              # 追加到 "event.log".
  log                                      # 写入时间和日期.
else exec 7> /dev/null                     # 清空输出.
fi

echo "DEBUG3: beginning" >&${FD_DEBUG3}

ls -l >&5 2>&4                             # 命令1 >&5 2>&4

echo "Done"                                # 命令2 

echo "sending mail" >&${FD_LOGEVENTS}
# 输出信息 "sending mail" 到文件描述符 #7.


exit 0
```

## 21 子shell

运行一个shell脚本会启动一个新的进程，即*子shell*。

**定义**： 一个*子shell*是由一个shell（或*shell脚本*）触发的[子进程](http://tldp.org/LDP/abs/html/othertypesv.html#CHILDREF2)。

一个子shell是命令处理器（-- 在终端或者*xtrem*窗口给出提示符的*shell*）的一个独立的例子。正如你的命令在命令行提示符处被理解执行一样，一个脚本[批处理](http://tldp.org/LDP/abs/html/timedate.html#BATCHPROCREF)一组命令。每一个shell脚本运行实际上是[父](http://tldp.org/LDP/abs/html/internal.html#FORKREF)shell的一个支线进程（*子进程*）。

一个shell脚本可以自己启动多个子进程。这些子进程使得脚本进行并行处理，实际上是多个支线任务同事进行。

```bash
#!/bin/bash
# subshell-test.sh

(
# 在圆括号内，因此是一个子shell . . .
while [ 1 ]   # 无限循环.
do
  echo "Subshell running . . ."
done
)

#  脚本会永远运行，或者至少直到由Ctl-C终止。

exit $?  # 脚本结束 （但是永远无法到达这里）。



现在，运行这个脚本：
sh subshell-test.sh

另外，在脚本运行的同时， 从另一个xterm运行：
ps -ef | grep subshell-test.sh

UID       PID   PPID  C STIME TTY      TIME     CMD
500       2698  2502  0 14:26 pts/4    00:00:00 sh subshell-test.sh
500       2699  2698 21 14:26 pts/4    00:00:24 sh subshell-test.sh

          ^^^^

分析：
PID 2698, 脚本, 启动 PID 2699, 子shell.

注释: “UID ...”这一列可以通过“grep”命令筛去，但是由于说明的目的而显示在这里。
```

一般来说，脚本的一个[外部命令](http://tldp.org/LDP/abs/html/external.html#EXTERNALREF)会使得子进程产生[分叉](http://tldp.org/LDP/abs/html/internal.html#FORKREF)，[^1] 但是一个Bash内建命令不会如此。

**在圆括号内的命令列**

(命令1; 命令1; 命令3; ...)

    放在圆括号内的一列命令作为子shell运行。

子shell的变量*不能*被这个子shell内代码区块之外的部分看见。这些变量不能被[父进程](http://tldp.org/LDP/abs/html/internal.html#FORKREF)中调用，也不能被启动次子shell的shell调用。这些变量实际上是*子进程*的[局部变量](http://tldp.org/LDP/abs/html/localvar.html#LOCALREF)。

**例21-1.子shell的变量范围**

```bash
#!/bin/bash
# subshell.sh

echo

echo "We are outside the subshell."
echo "Subshell level OUTSIDE subshell = $BASH_SUBSHELL"
# Bash, 版本3，增加新变量                 $BASH_SUBSHELL 。
echo; echo

outer_variable=Outer
global_variable=
#  定义全局变量来”存储“子shell变量值。

(
echo "We are inside the subshell."
echo "Subshell level INSIDE subshell = $BASH_SUBSHELL"
inner_variable=Inner

echo "From inside subshell, \"inner_variable\" = $inner_variable"
echo "From inside subshell, \"outer\" = $outer_variable"

global_variable="$inner_variable"   #  这会允许”输出“ 一个子shell变量吗？
)

echo; echo
echo "We are outside the subshell."
echo "Subshell level OUTSIDE subshell = $BASH_SUBSHELL"
echo

if [ -z "$inner_variable" ]
then
  echo "inner_variable undefined in main body of shell"
else
  echo "inner_variable defined in main body of shell"
fi

echo "From main body of shell, \"inner_variable\" = $inner_variable"
#  $inner_variable 会显示为空白 （未初始化） 
#+ 因为定义在子shell的变量是“局部变量”。
#  有办法改正这一点吗？
echo "global_variable = "$global_variable""  # 为什么这不行？

echo

# =======================================================================

# 另外 ...

echo "-----------------"; echo

var=41                                                 # 全局变量。

( let "var+=1"; echo "\$var INSIDE subshell = $var" )  # 42

echo "\$var OUTSIDE subshell = $var"                   # 41
# 子shell内的变量操作，即使是对全局变量，不影响变量在子shell外的值！


exit 0

#  问题：
#  --------
#  一旦执行一个子shell，
#+ 是否有办法再次进入这个子shell以便修改或调用子shell的变量？ 
```

同样参看 [$BASHPID](http://tldp.org/LDP/abs/html/internalvariables.html#BASHPIDREF) 和 [例34-2](http://tldp.org/LDP/abs/html/gotchas.html#SUBPIT)。

**定义**： 变量的*范围*是指其有意义的上下文内容，在此变量*值*可以被引用。比如说，[局部变量](http://tldp.org/LDP/abs/html/localvar.html#LOCALREF1)的范围只在函数、代码区块或子shell内的相应定义范围内，而*全局*变量的范围则是其出现的整个脚本区域。

内部变量 [\$BASH_SUBSHELL](http://tldp.org/LDP/abs/html/internalvariables.html#BASHSUBSHELLREF) 指出一个子shell的嵌套层级时，而变量 [\$SHLVL](http://tldp.org/LDP/abs/html/internalvariables.html#SHLVLREF) 指示在子shell内*不变*的层级。

```bash
echo " \$BASH_SUBSHELL outside subshell       = $BASH_SUBSHELL"           # 0
  ( echo " \$BASH_SUBSHELL inside subshell        = $BASH_SUBSHELL" )     # 1
  ( ( echo " \$BASH_SUBSHELL inside nested subshell = $BASH_SUBSHELL" ) ) # 2
# ^ ^                          ***  嵌套   ***                        ^ ^

echo

echo " \$SHLVL outside subshell = $SHLVL"       # 3
( echo " \$SHLVL inside subshell  = $SHLVL" )   # 3 (不变！)
```

子shell内的路径改变不会带入到父shell中。

**例21-2. 列出用户信息**

```bash
#!/bin/bash
# allprofs.sh: 打印所有用户信息.

# 此脚本作者 Heiner Steven，由文件作者修改。

FILE=.bashrc  #  包含用户信息的文件是".profile"的原始脚本。

for home in `awk -F: '{print $6}' /etc/passwd`
do
  [ -d "$home" ] || continue    # 如果没有home目录，到下一个。
  [ -r "$home" ] || continue    # 如果没有读取权限，到下一个。
  (cd $home; [ -e $FILE ] && less $FILE)
done

# 脚本终止时， 不需要使用命令'cd'回到初始目录，因为'cd $home'只在子shell发生。

exit 0
```

一个子shell可以用来为一个命令组设定一个“特定环境”。

```bash
命令1
命令2
命令3
(
  IFS=:
  PATH=/bin
  unset TERMINFO
  set -C
  shift 5
  命令4
  命令5
  exit 3 # 只退出子shell！
)
# 父shell不受影响， 且环境保留。
命令6
命令7
```

从这里可以看出，命令 [exit](http://tldp.org/LDP/abs/html/internal.html#EXITREF) 只终止正在运行的子shell，并不终止父shell或脚本。

这样的“特定环境”的一个应用是检查一个变量是否被定义。

```bash
if (set -u; : $variable) 2> /dev/null
then
  echo "Variable is set."
fi     #  变量已在当前脚本被设定， 
       #+ 或者变量是一个Bash内部变量，
       #+ 或者变量在环境变量中（在export命令后）。

# 也可以写成  [[ ${variable-x} != x || ${variable-y} != y ]]
# 或者       [[ ${variable-x} != x$variable ]]
# 或者       [[ ${variable+x} = x ]]
# 或者       [[ ${variable-x} != x ]]
```

另一个应用是检查一个锁定文件。

```bash
if (set -C; : > lock_file) 2> /dev/null
then
  :   # lock_file不存在：没有用户运行此脚本
else
  echo "Another user is already running that script."
exit 65
fi

#  代码段作者 Stéphane Chazelas,
#+ 修改者 Paulo Marcel Coelho Aragao。
```

+

多个进程可以在不同子shell内并行执行。这样就可以将一个复杂的任务分解成多个子部分同时处理。

**例21-3. 在子shell中运行并行进程**

```bash
	(cat list1 list2 list3 | sort | uniq > list123) &
	(cat list4 list5 list6 | sort | uniq > list456) &
	# 同时合并和排列两组列表。
	# 在后台运行以确保并行执行。
	#
	# 同样效果如下
	#   cat list1 list2 list3 | sort | uniq > list123 &
	#   cat list4 list5 list6 | sort | uniq > list456 &
	
	wait   # 在子shell结束前不执行之后命令。
	
	diff list123 list456
```

向子shell的I/O重定向使用管道算符"|"，正如 ls -al | (命令)

在花括号间的代码块不会启动一个子shell。

{ 命令1； 命令2； 命令3； ...命令N； }

```bash
var1=23
echo "$var1"   # 23

{ var1=76; }
echo "$var1"   # 76
```

Notes

[^1] 和 [exec](http://tldp.org/LDP/abs/html/internal.html#EXECREF) 命令一起触发的外部命令（通常）不会分叉一个子进程 / 子shell

## 22 限制模式的Shell

**限制模式下被禁用的命令**

* 在限制模式下运行一个脚本或部分脚本将禁用一些命令，尽管这些命令在正常模式下是可用的。这是个安全措施，可以限制脚本用户的权限，减少运行脚本可能带来的损害。

被禁用的命令和功能：

* 使用 _cd_ 来改变工作目录。
* 修改 _$PATH_, _$SHELL_, *$BASH_ENV* 或 _$ENV_ 等[环境变量](http://tldp.org/LDP/abs/html/othertypesv.html#ENVREF)
* 读取或修改 _$SHELLOPTS_，shell环境选项。
* 输出重定向。
* 调用包含 / 的命令。
* 调用 [exec](http://tldp.org/LDP/abs/html/internal.html#EXECREF) 来替代shell进程。
* 其他各种会造成混乱或颠覆脚本用途的命令。
* 在脚本中跳出限制模式。

例 22-1. 在限制模式运行脚本

```
#!/bin/bash

#  在脚本开头用"#!/bin/bash -r"
#+ 可以让整个脚本在限制模式运行。

echo

echo "改变目录。"
cd /usr/local
echo "现在是在 `pwd`"
echo "回到家目录。"
cd
echo "现在是在 `pwd`"
echo

# 到此为止一切都是正常的，非限制模式。

set -r
# set --restricted 效果相同。
echo "==> 现在是限制模式 <=="

echo
echo

echo "在限制模式试图改变目录。"
cd ..
echo "依旧在 `pwd`"

echo
echo

echo "\$SHELL = $SHELL"
echo "试图在限制模式改变Shell 。"
SHELL="/bin/ash"
echo
echo "\$SHELL= $SHELL"

echo
echo

echo "试图在限制模式重定向输出内容。"
ls -l /usr/bin > bin.files
ls -l bin.files    # 尝试列出试图创建的文件。

echo

exit 0

```

## 23 进程替换

用[管道](http://tldp.org/LDP/abs/html/special-chars.html#PIPEREF) 将一个命令的 ```标准输出``` 输送到另一个命令的 ```标准输入``` 是个强大的技术。但是如果你需要用管道输送_多个_命令的 ```标准输出``` 怎么办？这时候 _进程替换_ 就派上用场了。

 _进程替换_ 把一个（或多个）[进程](http://tldp.org/LDP/abs/html/special-chars.html#PROCESSREF) 的输出送到另一个进程的 ```标准输入```。

**样板**
命令列表要用括号括起来

 ```
>(command_list)
<(command_list)
 ```

进程替换使用 ```/dev/fd/<n>``` 文件发送括号内进程的结果到另一个进程。[1]

<img src="http://tldp.org/LDP/abs/images/caution.gif">"<"或">"与括号之间没有空格，加上空格或报错。

```
bash$ echo >(true)
/dev/fd/63

bash$ echo <(true)
/dev/fd/63

bash$ echo >(true) <(true)
/dev/fd/63 /dev/fd/62

bash$ wc <(cat /usr/share/dict/linux.words)
 483523  483523 4992010 /dev/fd/63

bash$ grep script /usr/share/dict/linux.words | wc
    262     262    3601

bash$ wc <(grep script /usr/share/dict/linux.words)
    262     262    3601 /dev/fd/63
```

<img src="http://tldp.org/LDP/abs/images/note.gif">Bash用两个文件描述符创建管道，```--fIn 和 fOut--``` 。[true](http://tldp.org/LDP/abs/html/internal.html#TRUEREF) 的```标准输入```连接 fOut(dup2(fOut, 0))，然后Bash 传递一个 ```/dev/fd/fIn``` 参数给 **echo** 。在不使用 ```/dev/fd/<n>``` 的系统里，Bash可以用临时文件（感谢 S.C. 指出这点）。

进程替换可以比较两个不同命令的输出，或者同一个命令使用不同选项的输出。

```
bash$ comm <(ls -l) <(ls -al)
total 12
-rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
-rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
-rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh
        total 20
        drwxrwxrwx    2 bozo bozo     4096 Mar 10 18:10 .
        drwx------   72 bozo bozo     4096 Mar 10 17:58 ..
        -rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
        -rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
        -rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh
```

进程替换可以比较两个目录的内容——来检查哪些文件在这个目录而不在那个目录。

```
diff <(ls $first_directory) <(ls $second_directory)
```

进程替换的一些其他用法：

```
read -a list < <( od -Ad -w24 -t u2 /dev/urandom )
#  从 /dev/urandom 读取一个随机数列表
#+ 用 "od" 处理
#+ 输送到 "read" 的标准输入. . .
#  来自 "insertion-sort.bash" 示例脚本。
#  致谢：JuanJo Ciarlante。
```

```
PORT=6881   # bittorrent（BT端口）

#  扫描端口，确保没有恶意行为
netcat -l $PORT | tee>(md5sum ->mydata-orig.md5) |
gzip | tee>(md5sum - | sed 's/-$/mydata.lz2/'>mydata-gz.md5)>mydata.gz

#  检查解压缩结果：
  gzip -d<mydata.gz | md5sum -c mydata-orig.md5)
#  对原件的MD5校验用来检查标准输入，并且探测压缩当中出现的问题。

#  Bill Davidsen 贡献了这个例子
#+ （ABS指南作者做了轻微修改）。
```

```
cat <(ls -l)
# 等价于	ls -l | cat

sort -k 9 <(ls -l /bin) <(ls -l /usr/bin) <(ls -l /usr/X11R6/bin)
#  列出 3 个主要 'bin' 目录的文件，按照文件名排序。
#  注意，有三个（数一下）单独的命令输送给了 'sort'。

diff <(command1) <(command2)    # 比较命令输出结果的不同之处。

tar cf >(bzip2 -c > file.tar.bz2) $directory_name

#  调用 "tar cf /dev/fd/?? $directory_name"，然后 "bzip2 -c > file.tar.bz2"。
#
#  因为 /dev/fd/<n> 系统特性
#  不需要在两个命令之间使用管道符
#
#  这个可以模拟
#
bzip2 -c < pipe > file.tar.bz2&
tar cf pipe $directory_name
rm pipe
#	或者
exec 3>&1
tar cf /dev/fd/4 $directory_name 4>&1 >&3 3>&- | bzip2 -c > file.tar.bz2 3>&-
exec 3>&-

# 致谢：Stéphane Chazelas
```

在子shell中 [echo 命令用管道输送给 while-read 循环](http://tldp.org/LDP/abs/html/gotchas.html#BADREAD0)时会出现问题，下面是避免的方法：

**例23-1 不用 fork 的代码块重定向。**

```
#!/bin/bash

#  wr-ps.bash: 使用进程替换的 while-read 循环。

#  示例由 Tomas Pospisek 贡献。
# （ABS指南作者做了大量改动。）

echo

echo "random input" | while read i
do
  global=3D": Not available outside the loop."
  # ... 因为在子 shell 中运行。
done

echo "\$global (从子进程之外) = $global"
# $global (从子进程之外) =

echo; echo "--"; echo

while read i
do
  echo $i
  global=3D": Available outside the loop."
  # ... 因为没有在子 shell 中运行。
done < <( echo "random input" )
#    ^ ^

echo "\$global (使用进程替换) = $global"
#  随机输入
#  $global (使用进程替换)= 3D: Available outside the loop.


echo; echo "##########"; echo



# 同样道理 . . .

declare -a inloop
index=0
cat $0 | while read line
do
  inloop[$index]="$line"
  ((index++))
  # 在子 shell 中运行，所以 ...
done
echo "OUTPUT = "
echo ${inloop[*]}           # ... 什么也没有显示。


echo; echo "--"; echo


declare -a outloop
index=0
while read line
do
  outloop[$index]="$line"
  ((index++))
  # 没有在子 shell 中运行，所以 ...
done < <( cat $0 )
echo "OUTPUT = "
echo ${outloop[*]}          # ... 整个脚本的结果显示出来。

exit $?
```

下面是个类似的例子。

**例 23-2. 重定向进程替换的输出到一个循环内**

```
#!/bin/bash
# psub.bash
#  受 Diego Molina 启发（感谢！）。

declare -a array0
while read
do
  array0[${#array0[@]}]="$REPLY"
done < <( sed -e 's/bash/CRASH-BANG!/' $0 | grep bin | awk '{print $1}' )
#  由进程替换来设置'read'默认变量（$REPLY）。
#+ 然后将变量复制到一个数组。

echo "${array0[@]}"

exit $?

# ====================================== #
# 运行结果：
bash psub.bash

#!/bin/CRASH-BANG! done #!/bin/CRASH-BANG!
```

一个读者发来一个有趣的进程替换例子，如下：

```
# SuSE 发行版中提取的脚本片段：

# --------------------------------------------------------------#
while read  des what mask iface; do
# 一些命令 ...
done < <(route -n)  
#    ^ ^  第一个 < 是重定向，第二个是进程替换。

#  为了测试，我们让它来做点儿事情。
while read  des what mask iface; do
  echo $des $what $mask $iface
done < <(route -n)  

# 输出内容:
# Kernel IP routing table
# Destination Gateway Genmask Flags Metric Ref Use Iface
# 127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo
# --------------------------------------------------------------#

#  正如 Stéphane Chazelas 指出的,
#+ 一个更容易理解的等价代码如下：
route -n |
  while read des what mask iface; do   # 通过管道输出设置的变量
    echo $des $what $mask $iface
  done  #  这段代码的结果更上面的相同。
        #  但是，Ulrich Gayer 指出 . . .
        #+ 这段简化版等价代码在 while 循环里用了子 shell，
        #+ 因此当管道终止时变量都消失了。

# --------------------------------------------------------------#

#  然而，Filip Moritz 说上面的两个例子有一个微妙的区别，
#+ 见下面的代码

(
route -n | while read x; do ((y++)); done
echo $y # $y is still unset

while read x; do ((y++)); done < <(route -n)
echo $y # $y has the number of lines of output of route -n
)

#  更通俗地说（译者注：原文本行少了注释符）
(
: | x=x
# 似乎启动了子 shell ，就像
: | ( x=x )
# 而
x=x < <(:)
# 并没有。
)
#  这个方法在解析 csv 和类似格式时很有用。
#  也就是在效果上，原始 SuSE 系统的代码片段就是做这个用的。
```

注解 [1]
这个与命名管道（使用临时文件）的效果相同，而且事实上，进程替换也曾经用过命名管道。

## 24 函数

和其它“真正”的编程语言一样，Bash也有函数，尽管它在实现方面有一些限制。一个函数就是一个子程序，实现一系列操作的[代码块](http://tldp.org/LDP/abs/html/special-chars.html#CODEBLOCKREF)，执行一个特定任务的“黑盒子”。有重复代码的地方，当一个过程只需要轻微修改任务就会重复执行的时候，那么你就需要考虑使用函数了。

```
function function_name {
command...
}
```

或者

```
function_name () { 
command...
}
```

第二种形式可能会更受C程序员的喜爱（并且它更具有[可移植性](http://tldp.org/LDP/abs/html/portabilityissues.html)）。
在C语言里面，函数的圆括号可以出现在第二行。

```
function_name () {
command...
}
```

![extra](images/note-1583396939237.gif) 一个函数可能被“压缩”到一个单独行里。

```
￼fun () { echo "This is a function"; echo; } 
#                                 ^     ^
```

然而，在这种情况下，函数里的最后一个命令必须跟有一个分号。

```
fun () { echo "This is a function"; echo } # Error! 
#                                       ^
fun2 () { echo "Even a single-command function? Yes!"; } 
#                                                    ^
```

只需要引用函数名字就可以调用或者触发函数。一个函数调用相当于一个命令。

例子 24-1. 简单的函数

```
#!/bin/bash
# ex59.sh: 练习函数(简单的).

JUST_A_SECOND=1

funky ()
{ # 这是一个简单的函数
    echo "This is a funky function."
    echo "Now exiting funky function."
} # 函数必须在调用前声明.


fun ()
{   # 一个稍微复杂点的函数.
    i=0
    REPEATS=30

    echo
    echo "And now the fun really begins."
    echo

    sleep $JUST_A_SECOND    # Hey, 等一秒钟!
    while [ $i -lt $REPEATS ]
    do
        echo "----------FUNCTIONS---------->"
        echo "<------------ARE-------------"
        echo "<------------FUN------------>"
        echo
        let "i+=1"
    done
}

# 现在，调用这些函数.

funky
fun

exit $?
```

函数定义必须在第一次函数调用之前。没有声明函数的方法，比如像C语言中一样。

```
f1
# 将会产生一个错误消息，因为“f1”函数还没有定义。

declare -f f1      # 这样也不会有帮助。
f1                 # 仍然会产生一个错误消息。

# 然而...


f1 () {
    echo "Calling function \"f2\" from within function \"f1\"."
    f2 
}

f2 () {
    echo "Function \"f2\"."
}

f1  #  在此之前，事实上函数“f2”是没有被调用的，
    #+ 尽管在它定义之前被引用了。
    #  这是可以的。
    # 感谢, S.C.
```

![extra](http://tldp.org/LDP/abs/images/note.gif)  函数不能为空！

```
#!/bin/bash
# empty-functionn.sh

empty () 
{
}

exit 0  # 这里将不会退出!


# $ sh empty-function.sh
# empty-function.sh: line 6: syntax error near unexpected token `}'
# empty-function.sh: line 6: `}'

# $ echo $? 
# 2

# 请注意，只包含注释的函数也是空函数。

func () 
{
    # 注释 1.
    # 注释 2.
    # 这仍然是一个空函数。
    # 感谢, Mark Bova将这一点指出来。
}
# 结果会出现和上面一样的错误信息。

# 然而 ...

not_quite_empty ()
{
    illegal_command
} #  一个包含这个函数的脚本将不会出错
    #+ 只要这个函数没有被调用。
not_empty ()
{
    :
} # 包含一个 : (空命令符），这样是可以的。

# 感谢, Dominick Geyer 和 Thiemo Kellner.
```

甚至，把一个函数嵌套在另外一个函数里也是可行的，尽管这并没有什么用。

```
f1 () 
{
    f2 () # 嵌套函数
    {
        echo "Function \"f2\", inside \"f1\"."
    }
}

f2  #  将会产生一个错误消息。
    #  即使有一个前置的 "declare -f f2" 也不会有什么作用。

echo

f1  #  不会做任何事情，因为调用“f1”的时候，并不会自动调用“f2”。
    #  现在，调用“f2”是可以的，
    #+ 因为通过调用“f1”，它的定义现在已是可见的。

    # 感谢, S.C.
```

函数定义可能出现在不太可能出现的地方，甚至出现在本应该是命令出现的地方。

```
ls -l | foo() { echo "foo"; }  # 可行的，尽管没有什么作用。


if [ "$USER" = bozo ]
then
    bozo_greet ()   # 函数定义嵌套在if/then的结构体中。
    {
        echo "Hello, Bozo."
    }
fi

bozo_greet        # 只有Bozo用户工作，其它用户会得到一个错误消息。


# 在某些场景中，像下面这些东西可能会很有用。
NO_EXIT=1   # 将会激活下面的函数定义。

[[ $NO_EXIT -eq 1 ]] && exit() { true; }     # 函数定义出现在“与列表”中。
# 如果 $NO_EXIT 等于 1, 定义 "exit ()".
# 通过把exit函数别名为“true”，这样把内置的exit命令给禁用了。

exit  # 调用 "exit ()" 函数, 而不是内置的 "exit" 命令。


# 或者，类似地:
filename=file1

[ -f "$filename" ] &&
foo () { rm -f "$filename"; echo "File "$filename" deleted."; } ||
foo () { echo "File "$filename" not found."; touch bar; }

foo

# 感谢, S.C. 和 Christopher Head
```

函数名字可以呈现各种奇怪的形式。

```
_(){ for i in {1..10}; do echo -n "$FUNCNAME"; done; echo; }
# ^^^         函数名字和圆括号之间没有空格。
#             这并不会总是会正常工作。为什么呢？

# 现在，我们来调用函数。
_         # __________
#           ^^^^^^^^^^   10 个下划线（10 倍的函数名字）！
# 一个“假”的下划线也是一个可以接受的函数名字。

# 事实上，一个分号也是一个可以接受的函数名字。

:(){ echo ":"; }; :

# 这有什么作用呢？
# 这是一个狡诈的方式去混淆脚本中的代码。
```

也可以参见 [Example A-56](http://tldp.org/LDP/abs/html/contributed-scripts.html#GRONSFELD)

小提示：当一个函数的不同版本出现在一个脚本中，会发生什么事情呢？

```
#  正如Yan Chen 指出的那样,
#  当一个函数被多次定义的时候，
#  最后一个函数是被调用的那个。
#  然而这并不是特别有用。

func () 
{
    echo "First version of func ()."
}

func () 
{
    echo "Second version of func ()."
}

func   # 调用的是第二个 func () 函数版本。

exit $?

#  甚至，可能用函数去覆盖
#+ 或者占用系统命令。
#  当然，这并不是可取的。
```

## 25 别名

Bash `别名` 本质上不外乎是键盘上的快捷键，缩写呢是避免输入很长的命令串的一种手段.举个例子, 在 [~/.bashrc](http://tldp.org/LDP/abs/html/sample-bashrc.html) 文件中包含别名 `lm="ls -l | more`, 而后每个命令行输入的 lm [[1]](http://tldp.org/LDP/abs/html/aliases.html#FTN.AEN18669) 将会自动被替换成 `ls -l | more`. 这可以节省大量的命令行输入和避免记住复杂的命令和选项. 设定别名 `rm="rm -i"` (交互的删除模式) 防止无意的删除重要文件，也许可以少些悲痛.

脚本中别名作用十分有限. 如果别名可以有一些 C 预处理器的功能会更好, 例如宏扩展, 但不幸的是 bash 别名中没有扩展参数. [[2]](http://tldp.org/LDP/abs/html/aliases.html#FTN.AEN18676) 另外, 脚本在 "复合结构" 中并不能扩展自身的别名，例如 [if/then](http://tldp.org/LDP/abs/html/tests.html#IFTHEN), 循环和函数. 另一个限制是，别名不能递归扩展. 基本上是我们无论怎么喜欢用别名都不如函数 [function](http://tldp.org/LDP/abs/html/functions.html#FUNCTIONREF) 来的更有效.

样例 25-1. 脚本中的别名

```
#!/bin/bash
# alias.sh

shopt -s expand_aliases
# 必须设置此选项, 否则脚本不能别名扩展.


# 首先来点好玩的东西.
alias Jesse_James='echo "\"Alias Jesse James\" was a 1959 comedy starring Bob Hope."'
Jesse_James

echo; echo; echo;

alias ll="ls -l"
# 可以任意使用单引号 (') 或双引号 (") 把别名括起来.

echo "Trying aliased \"ll\":"
ll /usr/X11R6/bin/mk*   #* 别名可以运行.

echo

directory=/usr/X11R6/bin/
prefix=mk*  # See if wild card causes problems.
echo "Variables \"directory\" + \"prefix\" = $directory$prefix"
echo

alias lll="ls -l $directory$prefix"

echo "Trying aliased \"lll\":"
lll         # 所有 /usr/X11R6/bin 文件清单以 mk 开始.
# 别名可以处理连续的变量 -- 包含 wild card -- o.k.




TRUE=1

echo

if [ TRUE ]
then
  alias rr="ls -l"
  echo "Trying aliased \"rr\" within if/then statement:"
  rr /usr/X11R6/bin/mk*   #* 结果报错!
  # 别名在复合的表达式中并没有生效.
  echo "However, previously expanded alias still recognized:"
  ll /usr/X11R6/bin/mk*
fi  

echo

count=0
while [ $count -lt 3 ]
do
  alias rrr="ls -l"
  echo "Trying aliased \"rrr\" within \"while\" loop:"
  rrr /usr/X11R6/bin/mk*   #* 这里的别名也没生效.
                           #  alias.sh: 行 57: rrr: 命令未找到
  let count+=1
done 

echo; echo

alias xyz='cat $0'   # 列出了自身.
                     # 注意强引.
xyz
#  这看起来能工作,
#+ 尽管 bash 文档不介意这么做.
#
#  然而, Steve Jacobson 指出,
#+ "$0" 参数的扩展在上面的别名申明后立刻生效.

exit 0
```

取消别名的命令删除之前设置的别名.

样例 25-2. unalias: 设置和取消一个别名

```
#!/bin/bash
# unalias.sh

shopt -s expand_aliases  # 开启别名扩展.

alias llm='ls -al | more'
llm

echo

unalias llm              # 取消别名.
llm
# 'llm' 不再被识别后的报错信息.

exit 0
bash$ ./unalias.sh
total 6
drwxrwxr-x    2 bozo     bozo         3072 Feb  6 14:04 .
drwxr-xr-x   40 bozo     bozo         2048 Feb  6 14:04 ..
-rwxr-xr-x    1 bozo     bozo          199 Feb  6 14:04 unalias.sh

./unalias.sh: llm: 命令未找到
```

**注意**

[[1]](http://tldp.org/LDP/abs/html/aliases.html#AEN18669)	... 作为命令行的第一个词. 显然别名只在命令的开始有意义.
[[2]](http://tldp.org/LDP/abs/html/aliases.html#AEN18676)	然而, 别名可用来扩展位置参数.

## 26 列表结构

_and 列表_ 和 _or 列表_ 结构提供了连续执行若干命令的方法，可以有效地替换复杂的嵌套 [if/then](http://tldp.org/LDP/abs/html/testconstructs.html#TESTCONSTRUCTS1) ，甚至 [case](http://tldp.org/LDP/abs/html/testbranch.html#CASEESAC1) 语句。

链接多个命令

**and 列表**

``` command-1 && command-2 && command-3 && ... command-n ```

只要前一个命令返回 _true_（即 0），每一个命令就依次执行。当第一个 _false_（即 非0）返回时，命令链条即终止（第一个返回 _false_ 的命令是最后一个执行的）。

在[YongYe](https://github.com/yongye)早期版本的[俄罗斯方块游戏](http://bash.deta.in/Tetris_Game.sh)脚本里，一个有趣的双条件 _and 列表_ 用法：

```
equation()

{  # core algorithm used for doubling and halving the coordinates
   [[ ${cdx} ]] && ((y=cy+(ccy-cdy)${2}2))
   eval ${1}+=\"${x} ${y} \"
}
```

**例 26-1. 使用 _and 列表_ 来测试命令行参数**

```
#!/bin/bash
# and list

if [ ! -z "$1" ] && echo "Argument #1 = $1" && [ ! -z "$2" ] && \
#                ^^                         ^^               ^^
echo "Argument #2 = $2"
then
  echo "At least 2 arguments passed to script."
  # 链条内的所有命令都返回 true。
else
  echo "Fewer than 2 arguments passed to script."
  # 链条内至少有一个命令返回 false。
fi  
# 注意： "if [ ! -z $1 ]" 是好用的，但是宣传与之等同的
#   "if [ -n $1 ]" 并不好用。
#  不过，用引号就能解决问题，
#   "if [ -n "$1" ]" 好用（译者注：原文本行内第一个引号位置错了）。
#           ^  ^    小心!
# 被测试的变量放在引号内总是最好的选择。


# 下面的代码功能一样，用的是“纯粹”的 if/then 语句。
if [ ! -z "$1" ]
then
  echo "Argument #1 = $1"
fi
if [ ! -z "$2" ]
then
  echo "Argument #2 = $2"
  echo "At least 2 arguments passed to script."
else
  echo "Fewer than 2 arguments passed to script."
fi
# 比起用“and 列表”要更长、更笨重。


exit $?
```

**例 26-2. 使用 _and 列表_ 来测试命令行参数2**

```
#!/bin/bash

ARGS=1        # 预期的参数数量。
E_BADARGS=85  # 参数数量错误时返回的值。

test $# -ne $ARGS && \
#    ^^^^^^^^^^^^ 条件 #1
echo "Usage: `basename $0` $ARGS argument(s)" && exit $E_BADARGS
#                                             ^^
#  如果条件 #1 结果为 true (传递给脚本的参数数量错误),
#+ 那么执行本行剩余的命令，脚本终止。

# 下面的代码行只有在上面的测试失败时才执行。
echo "Correct number of arguments passed to this script."

exit 0

#  如果要检查退出值，脚本终止后运行 "echo $?"。
```

当然，_and 列表_ 也可以给变量设置默认值。

```
arg1=$@ && [ -z "$arg1" ] && arg1=DEFAULT

              # 如果有命令行参数，则把参数值赋给 $arg1 。
              # 但是... 如果没有参数，则使用DEFAULT给 $arg1 赋值。
```

**or 列表**

```
command-1 || command-2 || command-3 || ... command-n
```

只要前一个命令返回_false_，每一个命令就依次执行。当第一个_true_ 返回时，命令链条即终止（第一个返回_true_ 的命令是最后一个执行的）。很明显它与“and 列表”相反。

例 26-3. _or 列表_ 与 _and 列表_ 结合使用

```
#!/bin/bash

#  delete.sh, 不那么巧妙的文件删除工具。
#  用法： delete 文件名

E_BADARGS=85

if [ -z "$1" ]
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS  # No arg? Bail out.
else  
  file=$1          # Set filename.
fi  


[ ! -f "$file" ] && echo "File \"$file\" not found. \
Cowardly refusing to delete a nonexistent file."
# AND 列表，如果文件不存在则显示出错信息。
# 注意，echo 消息内容分成了两行，中间通过转义符（\）连接。

[ ! -f "$file" ] || (rm -f $file; echo "File \"$file\" deleted.")
# OR 列表，删除存在的文件。

# 注意上面的逻辑颠倒。 Note logic inversion above.
# “AND 列表” 在得到 true 时执行, “OR 列表”在得到 false 时执行。

exit $?
```

<img src="http://tldp.org/LDP/abs/images/caution.gif"> 如果 _or 列表_ 第一个命令返回 true，它**会**执行。

```
# ==> 下面的代码段来自 /etc/rc.d/init.d/single
#+==> 作者 Miquel van Smoorenburg
#+==> 说明了 "and" 和 "or" 列表。
# ==> 带箭头的注释是本文作者添加的。

[ -x /usr/bin/clear ] && /usr/bin/clear
  # ==> 如果 /usr/bin/clear 存在, 则调用它。
  # ==> 调用命令之前检查它是否存在，
  #+==> 可以避免出错消息和其他怪异的结果。

  # ==> . . .

#  If they want to run something in single user mode, might as well run it...
for i in /etc/rc1.d/S[0-9][0-9]* ; do
        # 检查脚本是否存在。
        [ -x "$i" ] || continue
  # ==> 如果对应的文件在 $PWD 里*没有*找到，
  #+==> 则跳回到循环顶端“继续运行”。

        # 丢弃备份文件和 rpm 生成的文件。
        case "$1" in
                *.rpmsave|*.rpmorig|*.rpmnew|*~|*.orig)
                        continue;;
        esac
        [ "$i" = "/etc/rc1.d/S00single" ] && continue
  # ==> 设置脚本名，但先不要执行
        $i start
done

  # ==> . . .
```

<img src="http://tldp.org/LDP/abs/images/important.gif">
_and 列表_ 或 _or 列表_ 的[退出状态](http://tldp.org/LDP/abs/html/exit-status.html#EXITSTATUSREF)就是最后一个执行的命令的退出状态。

聪明地结合 _and 列表_ 和 _or 列表_ 是可能的，但是程序逻辑会很容易地变得令人费解，需要密切注意[操作符优先规则](http://tldp.org/LDP/abs/html/opprecedence.html#OPPRECEDENCE1)，而且，会带来大量的调试工作。

```
false && true || echo false         # false

# 下面的代码结果相同
( false && true ) || echo false     # false
# 但这个就不同了
false && ( true || echo false )     # (什么都不显示)

#  注意语句是从左到右组合和解释的。

#  通常情况下最好避免这种复杂性。

#  感谢, S.C.
```

[例 A-7](http://tldp.org/LDP/abs/html/contributed-scripts.html#DAYSBETWEEN) 和 [例 7-4](http://tldp.org/LDP/abs/html/fto.html#BROKENLINK) 解释了用 _and 列表_ / _or 列表_ 来测试变量。

## 27 数组

新版本的Bash支持一维数组。 数组元素可以使用符号**variable[xx]** 来初始化。另外，脚本可以使用**declare -a variable**语句来制定一个数组。 如果想引用一个数组元素（也就是取值），可以使用大括号，访问形式为 ${element[xx]} 。

例子 27-1. 简单的数组使用 

```
#!/bin/bash

area[11]=23
area[13]=37
area[51]=UFOs

#  数组成员不一定非得是相邻或连续的。

#  数组的部分成员可以不被初始化。
#  数组中允许空缺元素。
#  实际上，保存着稀疏数据的数组（“稀疏数组”） 
#+ 在电子表格处理软件中是非常有用的。

echo -n "area[11] = "
echo ${area[11]}    #  需要{大括号}。

echo -n "area[13] = "
echo ${area[13]}

echo "Contents of area[51] are ${area[51]}."

# 没被初始化的数组成员打印为空值（null变量）。
echo -n "area[43] = "
echo ${area[43]}
echo "(area[43] unassigned)"

echo

# 两个数组元素的和被赋值给另一个数组元素。
area[5]=`expr ${area[11]} + ${area[13]}`
echo "area[5] = area[11] + area[13]"
echo -n "area[5] = "
echo ${area[5]}

area[6]=`expr ${area[11]} + ${area[51]}`
echo "area[6] = area[11] + area[51]"
echo -n "area[6] = "
echo ${area[6]}
# 这里会失败，是因为不允许整数与字符串相加。

echo; echo; echo

# -----------------------------------------------------------------
# 另一个数组, "area2".

# 另一种给数组变量赋值的方法...
# array_name=( XXX YYY ZZZ ... )

area2=( zero one two three four )

echo -n "area2[0] = "
echo ${area2[0]}
# 啊哈，从0开始计算数组下标（也就是，数组的第一个元素为[0],而不是[1]).

echo -n "area2[1] = "
echo ${area2[1]}    # [1] 是数组的第二个元素。
# -----------------------------------------------------------------

echo; echo; echo

# -----------------------------------------------
# 第三个数组， "area3".
# 另外一种给数组元素赋值的方法...
# array_name=([xx]=XXX [yy]=YYY ...)

area3=([17]=seventeen [24]=twenty-four)

echo -n "area3[17] = "
echo ${area3[17]}

echo -n "area3[24] = "
echo ${area3[24]}
# -----------------------------------------------

exit 0
```

我们可以看出，初始化整数的一个简单的方法是 array=( element1 element2 ... elementN ) 。

```
base64_charset=( {A..Z} {a..z} {0..9} + / = )
#  使用扩展的一对范围 Using extended brace expansion
#+ 去初始化数组的元素。to initialize the elements of the array.
# 从 vladz's "base64.sh" 脚本中摘录过来。
#+ 在"Contributed Scripts" 附录中可以看到.
```

Bash允许把变量当成数据来操作，即使这个变量没有明确地被声明为数组。

```
string=abcABC123ABCabc
echo ${string[@]}   # abcABC123ABCabc
echo ${string[*]}   # abcABC123ABCabc
echo ${string[0]}   # abcABC123ABCabc
echo ${string[1]}   # 没有输出！
                    # 为什么?
echo ${#string[@]}  # 1
                    # 数组中只有一个元素。
                    # 就是这个字符串本身。

# 感谢你, Michael Zick, 指出这一点.
```

类似的示范可以参考 [Bash变量是无类型的](../part2/04_3_bash_variables_are_untyped.md) 。

例子 27-2. 格式化一首诗

```
#!/bin/bash
# poem.sh: 将本书作者非常喜欢的一首诗，漂亮的打印出来。

# 诗的行数 (单节).
Line[1]="I do not know which to prefer,"
Line[2]="The beauty of inflections"
Line[3]="Or the beauty of innuendoes,"
Line[4]="The blackbird whistling"
Line[5]="Or just after."
# 注意 引用允许嵌入的空格。

# 出处.
Attrib[1]=" Wallace Stevens"
Attrib[2]="\"Thirteen Ways of Looking at a Blackbird\""
# 这首诗已经是公共版权了 (版权已经过期了).

echo

tput bold   # 粗体打印.

for index in 1 2 3 4 5    # 5行.
do
    printf "     %s\n" "${Line[index]}"
done

for index in 1 2          # 出处为2行。
do
    printf "        %s\n" "${Attrib[index]}"
done

tput sgr0       # 重置终端。Reset terminal.
                # 查看 'tput' 文档.
echo

exit 0

# 练习:
# --------
# 修改这个脚本，使其能够从一个文本数据文件中提取出一首诗的内容，然后将其漂亮的打印出来。
```

数组元素有它们独特的语法，甚至标准Bash命令和操作符，都有特殊的选项用以配合数组操作。

例子 27-3. 多种数组操作 

```
#!/bin/bash
# array-ops.sh: 更多有趣的数组用法.

array=( zero one two three four five )
# 数组元素 0   1   2    3     4    5

echo ${array[0]}        #  0
echo ${array:0}         #  0
                        #  第一个元素的参数扩展,
                        #+ 从位置0(#0)开始（即第一个字符）.
echo ${array:1}         #  ero
                        #  第一个元素的参数扩扎，
                        #+ 从位置1（#1）开始（即第二个字符）。

echo "--------------"

echo ${#array[0]}       #  4
                        # 第一个数组元素的长度。
echo ${#array}          #4
                        # 第一个数组元素的长度。
                        #  (另一种表示形式)

echo ${#array[1]}       # 3
                        # 第二个数组元素的长度。
                        #  Bash中的数组是从0开始索引的。

echo ${#array[*]}       # 6
                        # 数组中的元素个数。
echo ${#array[@]}       # 6
                        # 数组中的元素个数.
echo "--------------"

array2=( [0]="first element" [1]="second element" [3]="fourth element" )
#            ^     ^       ^     ^      ^       ^     ^      ^       ^
# 引用允许嵌入的空格,在每个单独的数组元素中。

echo ${array2[0]}       # 第一个元素
echo ${array2[1]}       # 第二个元素
echo ${array2[2]}       #
                        # 因为并没有被初始化，所以此值为null。
echo ${array2[3]}       # 第四个元素.
echo ${#array2[0]}      # 13    (第一个元素的长度)
echo ${#array2[*]}      # 3     (数组中元素的个数)

exit
```

大部分标准[字符串操作](../part3/10_1_manipulating_strings.md) 都可以用于数组中。

例子27-4. 用于数组的字符串操作

```
#!/bin/bash
# array-strops.sh: 用于数组的字符串操作。

# 本脚本由Michael Zick 所编写.
# 通过了授权在本书中使用。
# 修复: 05 May 08, 04 Aug 08.

#  一般来说，任何类似于 ${name ... }(这种形式)的字符串操作
#+ 都能够应用于数组中的所有字符串元素，
#+ 比如说${name[@] ... } 或者 ${name[*] ...} 这两种形式。 

arrayZ=( one two three four five five )

echo

# 提取尾部的子串。
echo ${arrayZ[@]:0}     # one two three four five five
#                ^       所有元素 

echo ${arrayZ[@]:1} 	# two three four five five
#                ^		element[0]后边的所有元素.

echo ${arrayZ[@]:1:2} 	# two three
#                  ^	只提取element[0]后边的两个元素.

echo "---------"


# 子串删除 

# 从字符串的开头删除最短的匹配。

echo ${arrayZ[@]#f*r}   # one two three five five
#               ^       # 匹配将应用于数组的所有元素。 
                        # 匹配到了"four",并且将它删除。 

# 从字符串的开头删除最长的匹配
echo ${arrayZ[@]##t*e}  # one two four five five
#               ^^      # 匹配将应用于数组的所有元素
                        # 匹配到了 "three" ,并且将它删除。

# 从字符串的结尾删除最短的匹配
echo ${arrayZ[@]%h*e}   # one two t four five five
#               ^       # 匹配将应用于数组的所有元素
                        # 匹配到了 "hree" ,并且将它删除。
					
# 从字符串的结尾删除最长的匹配
echo ${arrayZ[@]%%t*e}  # one two four five five
#               ^^      # 匹配将应用于数组的所有元素
                        # 匹配到了 "three" ,并且将它删除。
						
echo "----------------------"

# 子串替换

# 第一个匹配到的子串将会被替换。
echo ${arrayZ[@]/fiv/XYZ}   # one two three four XYZe XYZe
#               ^           # 匹配将应用于数组的所有元素

# 所有匹配到的子串将会被替换。
echo ${arrayZ[@]//iv/YY}    # one two three four fYYe fYYe
                            # 匹配将应用于数组的所有元素

# 删除所有的匹配子串
# 如果没有指定替换字符串的话，那就意味着'删除'...
echo ${arrayZ[@]//fi/}      # one two three four ve ve
#               ^^          # 匹配将应用于数组的所有元素

# 替换字符串前端子串
echo ${arrayZ[@]/#fi/XY}    # one two three four XYve XYve
#                ^          # 匹配将应用于数组的所有元素

# 替换字符串后端子串
echo ${arrayZ[@]/%ve/ZZ}	# one two three four fiZZ fiZZ
#                ^			# 匹配将应用于数组的所有元素

echo ${arrayZ[@]/%o/XX}		# one twXX three four five five
#                ^			# 为什么?

echo "-----------------------------"

replacement() {
    echo -n "!!!"
}

echo ${arrayZ[@]/%e/$(replacement)}
#                ^  ^^^^^^^^^^^^^^
# on!!! two thre!!! four fiv!!! fiv!!!
# replacement()的标准输出就是那个替代字符串.
# Q.E.D: 替换动作实际上是一个‘赋值’。

echo "------------------------------------"

#  使用"for-each"之前:
echo ${arrayZ[@]//*/$(replacement optional_arguments)}
#                ^^ ^^^^^^^^^^^^^
# !!! !!! !!! !!! !!! !!!

#  现在，如果Bash只将匹配到的字符串
#+ 传递给被调用的函数...

echo

exit 0

#  在将处理后的结果发送到大工具之前，比如-- Perl, Python, 或者其它工具
#  回忆一下:
#    $( ... ) 是命令替换。
#    一个函数作为子进程运行。
#    一个函数将结果输出到stdout。
#    赋值，结合"echo"和命令替换，
#+   可以读取函数的stdout.
#    使用name[@]表示法指定了一个 "for-each"
#+   操作。
#  Bash比你想象的更加强力.

```

[命令替换](../part3/12_command_substitution.md) 可以构造数组的独立元素。

例子 27-5. 将脚本中的内容赋值给数组

```
#!/bin/bash
# script-array.sh: 将脚本中的内容赋值给数组。 
# 这个脚本的灵感来自于 Chris Martii 的邮件 (感谢!).

script_contents=( $(cat "$0") )  # 将这个脚本的内容($0） 
                                 #+ 赋值给数组
for element in $(seq 0 $((${#script_contents[@]} - 1)))
  do                #  ${#script_contents[@]}
                    #+ 表示数组元素的个数
                    #
                    #  问题:
                    #  为什么必须使用seq 0 ?
                    #  用seq 1来试一下.
  echo -n "${script_contents[$element]}"
                    # 在同一行上显示脚本中每个域的内容。
# echo -n "${script_contents[element]}" also works because of ${ ... }.
  echo -n " -- "    # 使用 " -- " 作为域分隔符。
done
echo

exit 0
# 练习:
# --------
#  修改这个脚本，
#+ 让这个脚本能够按照它原本的格式输出，
#+ 连同空格，换行，等等。
```

在数组环境中，某些Bash [内建命令](../part4/15_internal_commands_and_builtins.md) 的含义可能会有些轻微的改变。比如，[unset](http://tldp.org/LDP/abs/html/internal.html#UNSETREF) 命令可以删除数组元素，甚至能够删除整个数组。

例子 27-6. 一些数组的专有特性

```
#!/bin/bash

declare -a colors
#  脚本中所有的后续命令都会把
#+ "colors" 当做数组 

echo "Enter your favorite colors (separated from each other by a space)."

read -a colors    # 至少需要键入3种颜色，以便于后边的演示。
#  'read'命令的特殊选项 ,
#+ 允许给数组元素赋值。

echo

element_count=${#colors[@]}
# 提取数组元素个数的特殊语法
#     用element_count=${#colors[*]} 也可以。
#
#  "@" 变量允许在引用中存在单次分割，
#+ (依靠空白字符来分割变量).
#
#  这就好像"$@" 和 "$*"
#+ 在位置参数中所表现出来的行为一样。

index=0

while [ "$index" -lt "$element_count" ]
do    # 列出数组中的所有元素
  echo ${colors[$index]}
  #    ${colors[index]} 也可以工作，因为它${ ... }之中.
  let "index = $index + 1"
  # Or:
  #    ((index++))
done
# 每个数组元素被列为单独的一行
# 如果没有这种要求的话，可以使用echo -n "${colors[$index]} "
#
# 也可以使用“for”循环来做:
#   for i in "${colors[@]}"
#   do
#     echo "$i"
#   done
# (Thanks, S.C.)

echo

# 再次列出数组中的所有元素，不过这次的做法更为优雅。
  echo ${colors[@]}          # echo ${colors[*]} 也可以工作.

echo

# "unset"命令既可以删除数组数据，也可以删除整个数组。
unset colors[1]			# 删除数组的第2个元素。
						# 作用等同于colors[1]=
echo  ${colors[@]}		# 再次列出数组内容，第2个元素没了。

unset colors			# 删除整个数组。
						#  unset colors[*] 以及
						#+ unset colors[@] 都可以.
echo; echo -n "Colors gone."
echo ${colors[@]}		# 再次列出数组内容，内容为空。
exit 0
```

正如我们在前面的例子中所看到的，**${array_name[@]}**  或者  **${array_name[\*]}**  都与数组中的所有元素相关。同样的，为了计算数组的元素个数，可以使用 **${array_name[@]}**  或者  **${array_name[\*]}**  。 **${#array_name}**  是数组第一个元素的长度，也就是  **${array_name[0]}**  的长度（字符个数）。

例子 27-7. 空数组与包含空元素的数组 

```
#!/bin/bash
# empty-array.sh

#  感谢Stephane Chazelas制作这个例子的原始版本。 
#+ 同时感谢Michael Zick 和 Omair Eshkenazi 对这个例子所作的扩展。
#  以及感谢Nathan Coulter 作的声明和感谢。

# 空数组与包含有空元素的数组，这两个概念不同。
  
array0=( first second third )
array1=( '' )		# "array1" 包含一个空元素.
array2=( )			# 没有元素. . . "array2"为空 
array3=()			# 这个数组呢?

echo
ListArray()
{
	echo
	echo "Elements in array0:  ${array0[@]}"
	echo "Elements in array1:  ${array1[@]}"
	echo "Elements in array2:  ${array2[@]}"
	echo "Elements in array3:  ${array3[@]}"
	echo
	echo "Length of first element in array0 = ${#array0}"
	echo "Length of first element in array1 = ${#array1}"
	echo "Length of first element in array2 = ${#array2}"
	echo "Length of first element in array3 = ${#array3}"
	echo
	echo "Number of elements in array0 = ${#array0[*]}"  # 3
	echo "Number of elements in array1 = ${#array1[*]}"  # 1  (Surprise!)
	echo "Number of elements in array2 = ${#array2[*]}"  # 0
	echo "Number of elements in array3 = ${#array3[*]}"  # 0
}

# ===================================================================

ListArray

# 尝试扩展这些数组。

# 添加一个元素到这个数组。
array0=( "${array0[@]}" "new1" )
array1=( "${array1[@]}" "new1" )
array2=( "${array2[@]}" "new1" )
array3=( "${array3[@]}" "new1" )

ListArray

# 或者
array0[${#array0[*]}]="new2"
array1[${#array1[*]}]="new2"
array2[${#array2[*]}]="new2"
array3[${#array3[*]}]="new2"

ListArray

# 如果你按照上边的方法对数组进行扩展的话，数组比较像‘栈’
# 上边的操作就是‘压栈’
# ‘栈’的高度为：
height=${#array2[@]}
echo
echo "Stack height for array2 = $height"

# '出栈’就是：
unset array2[${#array2[@]}-1]   # 数组从0开始索引 
height=${#array2[@]}            #+ 这就意味着数组的第一个下标是0
echo
echo "POP"
echo "New stack height for array2 = $height"

ListArray

# 只列出数组array0的第二个和第三个元素。
from=1              # 从0开始索引。
to=2
array3=( ${array0[@]:1:2} )
echo
echo "Elements in array3:  ${array3[@]}"

# 处理方式就像是字符串（字符数组）。
# 试试其他的“字符串”形式。

# 替换:
array4=( ${array0[@]/second/2nd} )
echo
echo "Elements in array4:  ${array4[@]}"

# 替换掉所有匹配通配符的字符串
array5=( ${array0[@]//new?/old} )
echo
echo "Elements in array5:  ${array5[@]}"

# 当你觉得对此有把握的时候...
array6=( ${array0[@]#*new} )
echo # This one might surprise you.
echo "Elements in array6:  ${array6[@]}"

array7=( ${array0[@]#new1} )
echo # 数组array6之后就没有惊奇了。
echo "Elements in array7:  ${array7[@]}"

# 看起来非常像...
array8=( ${array0[@]/new1/} )
echo
echo "Elements in array8:  ${array8[@]}"

# 所以，让我们怎么形容呢？

#  对数组var[@]中的每个元素The string operations are performed on
#+ 进行连续的字符串操作。each of the elements in var[@] in succession.
#  因此：Bash支持支持字符串向量操作，
#  如果结果是长度为0的字符串
#+ 元素会在结果赋值中消失不见。
#  然而，如果扩展在引用中，那个空元素会仍然存在。

#  Michael Zick:   问题--这些字符串是强引用还是弱引用？ 
#  Nathan Coulter:  没有像弱引用的东西
#!    真正发生的事情是
#!+   匹配的格式发生在
#!+   [word]的所有其它扩展之后
#!+   比如像${parameter#word}.

zap='new*'
array9=( ${array0[@]/$zap/} )
echo
echo "Number of elements in array9:  ${#array9[@]}"
array9=( "${array0[@]/$zap/}" )
echo "Elements in array9:  ${array9[@]}"
# 此时，空元素仍然存在
echo "Number of elements in array9:  ${#array9[@]}"

# 当你还在认为你身在Kansas州时...
array10=( ${array0[@]#$zap} )
echo
echo "Elements in array10:  ${array10[@]}"
# 但是，如果被引用的话，*号将不会被解释。
array10=( ${array0[@]#"$zap"} )
echo
echo "Elements in array10:  ${array10[@]}"
# 可能，我们仍然在Kansas...
# (上面的代码块Nathan Coulter所修改.)

#  比较 array7 和array10.
#  比较array8 和array9.

#  重申: 所有所谓弱引用的东西
#  Nathan Coulter 这样解释:
#  word在${parameter#word}中的匹配格式在
#+ 参数扩展之后和引用移除之前已经完成了。
#  在通常情况下，格式匹配在引用移除之后完成。

exit
```

**${array_name[@]}** 和 **${array_name[\*]}** 的关系非常类似于 [$@ 和$*](http://tldp.org/LDP/abs/html/internalvariables.html#APPREF)。这种数组用法非常广泛。

```
# 复制一个数组
array2=( "${array1[@]}" )
# 或者
array2="${array1[@]}"
#
# 然而，如果在“缺项”数组中使用的话，将会失败 
#+ 也就是说数组中存在空洞（中间的某个元素没赋值），
#+ 这个问题由Jochen DeSmet 指出.
# ------------------------------------------
  array1[0]=0
# array1[1] not assigned
  array1[2]=2
  array2=( "${array1[@]}" )       # 拷贝它？
echo ${array2[0]}      # 0
echo ${array2[2]}      # (null), 应该是 2
# ------------------------------------------
# 添加一个元素到数组。
array=( "${array[@]}" "new element" )
# 或者
array[${#array[*]}]="new element"
# 感谢, S.C.
```

![info](images/tip-1583397056177.gif) **array=( element1 element2 ... elementN )** 初始化操作，如果有[命令替换](../part3/12_command_substitution.md)的帮助，就可以将一个文本文件的内容加载到数组。

```
#!/bin/bash
filename=sample_file
#            cat sample_file
#
# 			1  a  b  c
# 			2  d  e  fg

declare -a array1

array1=( `cat "$filename"`)		#  将$filename的内容
#         把文件内容展示到输出	#+ 加载到数组array1.
#
#  array1=( `cat "$filename" | tr '\n' ' '`)
#                           把文件中的换行替换为空格 
# 其实这样做是没必要的，因为Bash在做单词分割的时候， 
#+将会把换行转换为空格。

echo ${array1[@]}            # 打印数组
#                              1 a b c 2 d e fg
#
#  文件中每个被空白符分割的“单词”
#+ 都被保存到数组的一个元素中。

element_count=${#array1[*]}
echo $element_count          # 8
```

出色的技巧使得数组的操作技术又多了一种。

例子 27-8. 初始化数组

```
#! /bin/bash
# array-assign.bash

# 数组操作是Bash所特有的，
#+ 所以才使用".bash" 作为脚本扩展名

# Copyright (c) Michael S. Zick, 2003, All rights reserved.
# License: Unrestricted reuse in any form, for any purpose.
# Version: $ID$
#
# 说明与注释由 William Park所添加.

#  基于 Stephane Chazelas所提供的例子
#+ 它是在ABS中的较早版本。

# 'times' 命令的输出格式:
# User CPU <space> System CPU
# User CPU of dead children <space> System CPU of dead children

#  Bash有两种方法， 
#+ 可以将一个数组的所有元素都赋值给一个新的数组变量。
#  这两个方法都会丢弃数组中的“空引用“（null值）元素
#+ 在2.04和以后的Bash版本中。
#  另一种给数组赋值的方法将会被添加到新版本的Bash中，
#+ 这种方法采用[subscript]=value 形式，来维护数组下标与元素值之间的关系。 

#  可以使用内部命令来构造一个大数组，
#+ 当然，构造一个包含上千元素数组的其它方法
#+ 也能很好的完成任务

declare -a bigOne=( /dev/* )  # /dev下的所有文件 . . .
echo
echo 'Conditions: Unquoted, default IFS, All-Elements-Of'
echo "Number of elements in array is ${#bigOne[@]}"

# set -vx

echo
echo '- - testing: =( ${array[@]} ) - -'
times
declare -a bigTwo=( ${bigOne[@]} )
# 注意括号:    ^              ^
times
echo

echo '- - testing: =${array[@]} - -'
times
declare -a bigThree=${bigOne[@]}
# 这次没用括号。
times
#  通过比较，可以发现第二种格式的赋值更快一些，
#+ 正如 Stephane Chazelas指出的那样
#
#  William Park 解释:
#+ bigTwo数组是作为一个单个字符串被赋值的(因为括号)
#+ 而BigThree数组，则是一个元素一个元素进行的赋值。
#  所以，实质上是:
#                   bigTwo=( [0]="..." [1]="..." [2]="..." ... )
#                   bigThree=( [0]="... ... ..." )
#
#  通过这样确认:  echo ${bigTwo[0]}
#                   echo ${bigThree[0]}
#  在本书的例子中，我还是会继续使用第一种形式， 
#+ 因为，我认为这种形式更有利于将问题阐述清楚。

#  在我所使用的例子中，在其中复用的部分，
#+ 还是使用了第二种形式，那是因为这种形式更快。

# MSZ: 很抱歉早先的疏忽。

#  注意:
#  ----
#  32和44的"declare -a" 语句其实不是必需的， 
#+ 因为Array=(...)形式
#+ 只能用于数组
#  然而，如果省略这些声明的话，
#+ 会导致脚本后边的相关操作变慢。
#  试试看，会发生什么.

exit 0
```

![extra](images/note-1583397056183.gif) 在数组声明的时候添加一个额外的**declare -a**语句，能够加速后续的数组操作速度。

例子 27-9. 拷贝和连接数组

```
#! /bin/bash
# CopyArray.sh
#
# 这个脚本由Michael Zick所编写.
# 这里已经通过作者的授权

#  如何“通过名字传值&通过名字返回”
#+ 或者“建立自己的赋值语句”。

CpArray_Mac() {
	# 建立赋值命令
	echo -n 'eval '
    echo -n "$2"                    # 目的名字
    echo -n '=( ${'
    echo -n "$1"                    # 源名字
    echo -n '[@]} )'

# 上边这些语句会构成一条命令。
# 这仅仅是形式上的问题。
}

declare -f CopyArray
CopyArray=CpArray_Mac

Hype() {
# "Pointer"函数
# 状态产生器
# 需要连接的数组名为$1.
# (把这个数组与字符串"Really Rocks"结合起来，形成一个新数组.)
# 并将结果从数组$2中返回.

    local -a TMP
    local -a hype=( Really Rocks )
    $($CopyArray $1 TMP)
    TMP=( ${TMP[@]} ${hype[@]} )
    $($CopyArray TMP $2)
}

declare -a before=( Advanced Bash Scripting )
declare -a after

echo "Array Before = ${before[@]}"

Hype before after

echo "Array After = ${after[@]}"

# 连接的太多了?

echo "What ${after[@]:3:2}?"
declare -a modest=( ${after[@]:2:1} ${after[@]:3:2} )
#                    ---- 子串提取 ----

echo "Array Modest = ${modest[@]}"

# 'before' 发生了什么变化 ?

echo "Array Before = ${before[@]}"

exit 0
```

例子27-10. 关于串联数组的更多信息

```
#! /bin/bash
# array-append.bash

# Copyright (c) Michael S. Zick, 2003, All rights reserved.
# License: Unrestricted reuse in any form, for any purpose.
# Version: $ID$
#
#  在格式上，由M.C做了一些修改.

# 数组操作是Bash特有的属性。
# 传统的UNIX /bin/sh 缺乏类似的功能。

#  将这个脚本的输出通过管道传递给'more'，
#+ 这样做的目的是放止输出的内容超过终端能够显示的范围，
#  或者，重定向输出到文件中。

declare -a array1=( zero1 one1 two1 )
# 依次使用下标
declare -a array2=( [0]=zero2 [2]=two2 [3]=three2 )
# 数组中存在空缺的元素-- [1] 未定义

echo
echo '- Confirm that the array is really subscript sparse. -'
echo "Number of elements: 4"        # 为了演示，这里作了硬编码
for (( i = 0 ; i < 4 ; i++ ))
do
    echo "Element [$i]: ${array2[$i]}"
done
# 也可以参考一个更通用的例子， basics-reviewed.bash.


declare -a dest

# 将两个数组合并到第3个数组中。
echo
echo 'Conditions: Unquoted, default IFS, All-Elements-Of operator'
echo '- Undefined elements not present, subscripts not maintained. -'
# # 那些未定义的元素不会出现；组合时会丢弃这些元素。

dest=( ${array1[@]} ${array2[@]} )
# dest=${array1[@]}${array2[@]} 		# 奇怪的结果，可能是个bug。

# 现在，打印结果。
echo
echo '- - Testing Array Append - -'
cnt=${#dest[@]}

echo "Number of elements: $cnt"
for (( i = 0 ; i < cnt ; i++ ))
do
    echo "Element [$i]: ${dest[$i]}"
done

# 将数组赋值给一个数组中的元素（两次）
dest[0]=${array1[@]}
dest[1]=${array2[@]}

# 打印结果
echo
echo '- - Testing modified array - -'
cnt=${#dest[@]}

echo "Number of elements: $cnt"
for (( i = 0 ; i < cnt ; i++ ))
do
echo "Element [$i]: ${dest[$i]}"
done

# 检查第二个元素的修改状况.
echo
echo '- - Reassign and list second element - -'

declare -a subArray=${dest[1]}
cnt=${#subArray[@]}

echo "Number of elements: $cnt"
for (( i = 0 ; i < cnt ; i++ ))
do
    echo "Element [$i]: ${subArray[$i]}"
done

# 如果你使用'=${ ... }'形式
#+ 将一个数组赋值到另一个数组的一个元素中,
#+ 那么这个数组的所有元素都会被转换为一个字符串,
#+ 这个字符串中的每个数组元素都以空格进行分隔(其实是IFS的第一个字符).

# 如果原来数组中的所有元素都不包含空白符 . . .
# 如果原来的数组下标都是连续的 . . .
# 那么我们就可以将原来的数组进行恢复.

# 从修改过的第二个元素中, 将原来的数组恢复出来.
echo
echo '- - Listing restored element - -'

declare -a subArray=( ${dest[1]} )
cnt=${#subArray[@]}

echo "Number of elements: $cnt"
for (( i = 0 ; i < cnt ; i++ ))
do
    echo "Element [$i]: ${subArray[$i]}"
done

echo '- - Do not depend on this behavior. - -'
echo '- - This behavior is subject to change - -'
echo '- - in versions of Bash newer than version 2.05b - -'

# MSZ: 抱歉，之前混淆了一些要点。

exit 0
```

------

有了数组, 我们就可以在脚本中实现一些比较熟悉的算法. 这么做, 到底是不是一个好主意, 我们在这里不做讨论, 还是留给读者决定吧.

例子 27-11. 冒泡排序

```
#!/bin/bash
# bubble.sh: 一种排序方式, 冒泡排序.

# 回忆一下冒泡排序的算法. 我们在这里要实现它...

# 依靠连续的比较数组元素进行排序,
#+ 比较两个相邻元素, 如果顺序不对, 就交换这两个元素的位置.
# 当第一轮比较结束之后, 最"重"的元素就会被移动到最底部.
# 当第二轮比较结束之后, 第二"重"的元素就会被移动到次底部的位置.
# 依此类推.
# 这意味着每轮比较不需要比较之前已经"沉淀"好的数据.
# 因此你会注意到后边的数据在打印的时候会快一些.


exchange() {
  # 交换数组中的两个元素.
  local temp=${Countries[$1]} #  临时保存
                              #+ 要交换的那个元素 
  Countries[$1]=${Countries[$2]}
  Countries[$2]=$temp
  
  return 
}

declare -a Countries  #  声明数组,
                      #+ 此处是可选的, 因为数组在下面被初始化
#  我们是否可以使用转义符(\)
#+ 来将数组元素的值放在不同的行上?
#  可以.

Countries=(Netherlands Ukraine Zaire Turkey Russia Yemen Syria \
Brazil Argentina Nicaragua Japan Mexico Venezuela Greece England \
Israel Peru Canada Oman Denmark Wales France Kenya \
Xanadu Qatar Liechtenstein Hungary)

# "Xanadu" 虚拟出来的世外桃源.
#+ Kubla Khan做了个愉快的决定


clear                      # 开始之前的清屏动作

echo "0: ${Countries[*]}"  # 从索引0开始列出整个数组.

number_of_elements=${#Countries[@]}
let "comparisons = $number_of_elements - 1"

count=1 # Pass number.

while [ "$comparisons" -gt 0 ]          # 开始外部循环
do

  index=0  # 在每轮循环开始之前，重置索引。

  while [ "$index" -lt "$comparisons" ] # 开始内部循环。
  do
    if [ ${Countries[$index]} \> ${Countries[`expr $index + 1`]} ]
	# 如果原来的排序次序不对...
	# 回想一下, 在单括号中,
	#+ \>是ASCII码的比较操作符.

	# if [[ ${Countries[$index]} > ${Countries[`expr $index + 1`]} ]]
	#+ 这样也行.
    then
      exchange $index `expr $index + 1`  # 交换
    fi
    let "index += 1"  #或者, index+=1 在Bash 3.1之后的版本才能这么用.
  done # 内部循环结束

  # ----------------------------------------------------------------------
# Paulo Marcel Coelho Aragao 建议我们可以使用更简单的for循环
#
# for (( last = $number_of_elements - 1 ; last > 0 ; last-- ))
##                     Fix by C.Y. Hunt          ^   (Thanks!)
# do
#     for (( i = 0 ; i < last ; i++ ))
#     do
#		[[ "${Countries[$i]}" > "${Countries[$((i+1))]}" ]] \
#    		&& exchange $i $((i+1))
#     done
# done
# ----------------------------------------------------------------------


let "comparisons -= 1" #  因为最"重"的元素到了底部,
                       #+ 所以每轮我们可以少做一次比较。

echo
echo "$count: ${Countries[@]}"  # 每轮结束后, 都打印一次数组.
echo
let "count += 1"                # 增加传递计数.

done                            # 外部循环结束
                                # 至此, 全部完成.
exit 0
```

----

我们可以在数组中嵌套数组么？

```
#!/bin/bash
# "嵌套" 数组.

#  Michael Zick 提供了这个用例。
#+ William Park做了一些修正和说明.

AnArray=( $(ls --inode --ignore-backups --almost-all \
        --directory --full-time --color=none --time=status \
        --sort=time -l ${PWD} ) )  # Commands and options.

# 空格是有意义的 . . . 并且不要在上边用引号引用任何东西.

SubArray=( ${AnArray[@]:11:1}  ${AnArray[@]:6:5} )
#  这个数组有六个元素:
#+     SubArray=( [0]=${AnArray[11]} [1]=${AnArray[6]} [2]=${AnArray[7]}
#      [3]=${AnArray[8]} [4]=${AnArray[9]} [5]=${AnArray[10]} )
#
#  Bash数组是字符串(char *)类型
#+ 的(循环)链表
#  因此, 这不是真正意义上的嵌套数组,
#+ 只不过功能很相似而已.

echo "Current directory and date of last status change:"
echo "${SubArray[@]}"

exit 0
```

---

如果将“嵌套数组”与[间接引用](http://tldp.org/LDP/abs/html/bashver2.html#VARREFNEW) 组合起来使用的话，将会产生一些非常有趣的用法。

例子 27-12. 嵌套数组与间接引用

```
#!/bin/bash
# embedded-arrays.sh
# 嵌套数组和间接引用.

# 本脚本由Dennis Leeuw 编写.
# 经过授权, 在本书中使用.
# 本书作者做了少许修改.

ARRAY1=(
        VAR1_1=value11
        VAR1_2=value12
        VAR1_3=value13
)

ARRAY2=(
        VARIABLE="test"
        STRING="VAR1=value1 VAR2=value2 VAR3=value3"
        ARRAY21=${ARRAY1[*]}
)       # 将ARRAY1嵌套到这个数组中.

function print () {
        OLD_IFS="$IFS"
        IFS=$'\n'       #  这么做是为了每行
                        #+ 只打印一个数组元素.
        TEST1="ARRAY2[*]"
        local ${!TEST1} # 删除这一行, 看看会发生什么?
        #  间接引用.
        #  这使得$TEST1
        #+ 只能够在函数内被访问.

        #  让我们看看还能干点什么.

        echo
        echo "\$TEST1 = $TEST1"       #  仅仅是变量名字.
        echo; echo
        echo "{\$TEST1} = ${!TEST1}"  #  变量内容.
                                      #  这就是
                                      #+ 间接引用的作用.
        echo
        echo "-------------------------------------------"; echo
        echo

        # 打印变量
        echo "Variable VARIABLE: $VARIABLE"

        # 打印一个字符串元素
        IFS="$OLD_IFS"
        TEST2="STRING[*]"
        local ${!TEST2}      # 间接引用(同上).
        echo "String element VAR2: $VAR2 from STRING"

        # Print an array element
        TEST2="ARRAY21[*]"
		local ${!TEST2}      # 间接引用(同上).
		echo "Array element VAR1_1: $VAR1_1 from ARRAY21"
}

print
echo

exit 0

# 脚本作者注,
#+ "你可以很容易的将其扩展成一个能创建hash 的Bash 脚本."
# (难) 留给读者的练习: 实现它.
```

---

数组使得埃拉托色尼素数筛子有了shell版本的实现. 当然, 如果你需要的是追求效率的应用, 那么就 应该使用编译行语言来实现, 比如C语言. 因为脚本运行的太慢了.

例子 27-13. 埃拉托色尼素数筛子

```
#!/bin/bash
# sieve.sh (ex68.sh)

# 埃拉托色尼素数筛子
# 找素数的经典算法.

# 在同等数值的范围内,
#+ 这个脚本运行的速度比C版本慢的多.

LOWER_LIMIT=1       # 从1开始.
UPPER_LIMIT=1000    # 到1000.
# (如果你时间很多的话 . . . 你可以将这个数值调的很高.)

PRIME=1
NON_PRIME=0

let SPLIT=UPPER_LIMIT/2
# 优化:
# 只需要测试中间到最大的值,为什么?

declare -a Primes
# Primes[] 是个数组.


initialize ()
{
	# 初始化数组.
	i=$LOWER_LIMIT
	until [ "$i" -gt "$UPPER_LIMIT" ]
	do
	  Primes[i]=$PRIME
	  let "i += 1"
	done
	#  假定所有数组成员都是需要检查的(素数)
	#+ 直到检查完成.
}

print_primes ()
{
	# 打印出所有数组Primes[]中被标记为素数的元素.
	
	i=$LOWER_LIMIT

	until [ "$i" -gt "$UPPER_LIMIT" ]
	do
	  if [ "${Primes[i]}" -eq "$PRIME" ]
	  then
		printf "%8d" $i
		# 每个数字打印前先打印8个空格, 在偶数列才打印.
	  fi

	  let "i += 1"

	done
}

sift () # 查出非素数.
{
	let i=$LOWER_LIMIT+1
	# 我们从2开始.

	until [ "$i" -gt "$UPPER_LIMIT" ]
	do

	if [ "${Primes[i]}" -eq "$PRIME" ]
	# 不要处理已经过滤过的数字(被标识为非素数).
	then
	  t=$i

	  while [ "$t" -le "$UPPER_LIMIT" ]
	  do
		let "t += $i "
		Primes[t]=$NON_PRIME
		# 标识为非素数.
	  done 
	fi
	 
	let "i += 1"
	done
}

# ==============================================
# main ()
# 继续调用函数.
initialize
sift
print_primes
# 这里就是被称为结构化编程的东西.
# ==============================================
echo

exit 0

# -------------------------------------------------------- #
# 因为前面的'exit'语句, 所以后边的代码不会运行

#  下边的代码, 是由Stephane Chazelas 所编写的埃拉托色尼素数筛子的改进版本,
#+ 这个版本可以运行的快一些.

# 必须在命令行上指定参数(这个参数就是: 寻找素数的限制范围)

UPPER_LIMIT=$1                  # 来自于命令行.
let SPLIT=UPPER_LIMIT/2         # 从中间值到最大值.

Primes=( '' $(seq $UPPER_LIMIT) )

i=1
until (( ( i += 1 ) > SPLIT ))  # 仅需要从中间值检查.
do
  if [[ -n ${Primes[i]} ]]
  then
    t=$i
    until (( ( t += i ) > UPPER_LIMIT ))
    do
      Primes[t]=
    done
  fi 
done
echo ${Primes[*]}

exit $?
```

例子 27-14. 埃拉托色尼素数筛子，优化版

```
#!/bin/bash
# 优化过的埃拉托色尼素数筛子
# 脚本由Jared Martin编写, ABS Guide 的作者作了少许修改.
# 在ABS Guide 中经过了许可而使用(感谢!).

# 基于Advanced Bash Scripting Guide中的脚本.
# http://tldp.org/LDP/abs/html/arrays.html#PRIMES0 (ex68.sh).

# http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf (引用)
# Check results against http://primes.utm.edu/lists/small/1000.txt

# Necessary but not sufficient would be, e.g.,
#     (($(sieve 7919 | wc -w) == 1000)) && echo "7919 is the 1000th prime"

UPPER_LIMIT=${1:?"Need an upper limit of primes to search."}

Primes=( '' $(seq ${UPPER_LIMIT}) )

typeset -i i t
Primes[i=1]='' # 1不是素数 
until (( ( i += 1 ) > (${UPPER_LIMIT}/i) ))  # 只需要ith-way 检查.
  do                                         # 为什么?
    if ((${Primes[t=i*(i-1), i]}))
    # 很少见， 但是很有指导意义, 在下标中使用算术扩展。
	then
      until (( ( t += i ) > ${UPPER_LIMIT} ))
        do Primes[t]=; done
    fi
  done

# echo ${Primes[*]}
echo   # 改回原来的脚本，为了漂亮的打印(80-col. 展示).
printf "%8d" ${Primes[*]}
echo; echo

exit $?
```

上边的这个例子是基于数组的素数产生器, 还有不使用数组的素数产生器[例子A-15](http://tldp.org/LDP/abs/html/contributed-scripts.html#PRIMES) 和[例子 16-46](http://tldp.org/LDP/abs/html/mathc.html#PRIMES2)，让我们来比较一番.

-----

数组可以进行一定程度上的扩展, 这样就可以模拟一些Bash原本不支持的数据结构.

例子 27-15. 模拟一个压入栈

```
#!/bin/bash
# stack.sh: 模拟压入栈

# 类似于CPU 栈, 压入栈依次保存数据项, 
#+ 但是取数据时, 却反序进行, 后进先出.

BP=100		#  栈数组的基址指针.
			#  从元素100 开始.

SP=$BP		#  栈指针.
			#  将其初始化为栈"基址"(栈底)

Data=		#  当前栈的数据内容.
			#  必须定义为全局变量,
			#+ 因为函数所能够返回的整数存在范围限制.

			# 100	基址				<-- Base Pointer
			#  99	第一个数据元素
			#  98	第二个数据元素
			# ...	更多数据
			#		最后一个数据元素	<-- Stack pointer

declare -a stack

push()		# 压栈
{
	if [ -z "$1" ]		# 没有可压入的数据项?
	then
		return 
	fi

	let "SP -= 1"		# 更新栈指针.
	stack[$SP]=$1
	return 
}

pop()	 #从栈中弹出数据项. 
{ 
	Data=						# 清空保存数据项的中间变量

	if [ "$SP" -eq "$BP" ]		# 栈空?
	then
		return 
	fi						# 这使得SP不会超过100,
							#+ 例如, 这可以防止堆栈失控.


	Data=${stack[$SP]}
	let "SP += 1"			# 更新栈指针
	return
}

status_report()			# 打印当前状态
{
	echo "-------------------------------------"
	echo "REPORT"
	echo "Stack Pointer = $SP"
	echo "Just popped \""$Data"\" off the stack."
	echo "-------------------------------------"
	echo
}


# =======================================================
# 现在, 来点乐子.

echo

# 看你是否能从空栈里弹出数据项来.
pop
status_report

echo

push garbage
pop
status_report			# 压入Garbage, 弹出garbage.

value1=23;			push $value1
value2=skidoo;		push $value2
value3=LAST;		push $value3

pop					# LAST
status_report
pop					# skidoo
status_report
pop					# 23
status_report		# 后进，先出!

# 注意: 栈指针在压栈时减,
#+ 在弹出时加.

echo

exit 0


# =======================================================
#
# 练习：
#
# 1) 修改"push()"函数，
# 	+ 使其调用一次就能够压入多个数据项。

# 2) 修改"pop()"函数,
#	+ 使其调用一次就能弹出多个数据项.

# 3) 给那些有临界操作的函数添加出错检查.
#	 说明白一些, 就是让这些函数返回错误码, 
#	+ 返回的错误码依赖于操作是否成功完成, 
#	+ 如果没有成功完成, 那么就需要启动合适的处理动作.

# 4) 以这个脚本为基础,
#	+ 编写一个用栈实现的四则运算计算器.
```

----

如果想对数组"下标"做一些比较诡异的操作, 可能需要使用中间变量. 对于那些有这种需求的项目来说, 还是应该考虑使用功能更加强大的编程语言, 比如Perl或C。

例子 27-16. 复杂的数组应用: 探索一个神秘的数学序列

```
!/bin/bash

# Douglas Hofstadter 的声名狼藉的序列"Q-series":

# Q(1) = Q(2) = 1
# Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), 当 n>2时

#  这是一个令人感到陌生的, 没有规律的"乱序"整数序列
#+ 并且行为不可预测
#  序列的头20项, 如下所示:
#  1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12

#  请参考相关书籍, Hofstadter的, "_Goedel, Escher, Bach: An Eternal Golden Braid_",
#+ 第137页.


LIMIT=100     # 需要计算的数列长度.
LINEWIDTH=20  # 每行打印的个数.

Q[1]=1        # 数列的头两项都为1.
Q[2]=1

echo
echo "Q-series [$LIMIT terms]:"
echo -n "${Q[1]} "             # 输出数列头两项.
echo -n "${Q[2]} "

for ((n=3; n <= $LIMIT; n++))  # C风格的循环条件.
do   # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]]  for n>2
#    需要将表达式拆开, 分步计算,
#+   因为Bash 不能够很好的处理复杂数组的算术运算.

	let "n1 = $n - 1"        # n-1
	let "n2 = $n - 2"        # n-2

	t0=`expr $n - ${Q[n1]}`  # n - Q[n-1]
	t1=`expr $n - ${Q[n2]}`  # n - Q[n-2]

	T0=${Q[t0]}			# Q[n - Q[n-1]]
	T1=${Q[t1]}			# Q[n - Q[n-2]]


	Q[n]=`expr $T0 + $T1`	# Q[n - Q[n-1]] + Q[n - Q[n-2]]
	echo -n "${Q[n]} "

	if [ `expr $n % $LINEWIDTH` -eq 0 ]		# 格式化输出
	then   #      ^ 取模操作
		echo # 把每行都拆为20个数字的小块.
	fi

done

echo

exit 0

# 这是Q-series的一个迭代实现.
# 更直接明了的实现是使用递归, 请读者作为练习完成.
# 警告: 使用递归的方法来计算这个数列的话, 会花费非常长的时间.
#+ C/C++ 将会计算的快一些。
```

----

Bash仅仅支持一维数组, 但是我们可以使用一个小手段, 这样就可以模拟多维数组了.

例子 27-17. 模拟一个二维数组，并使它倾斜

```
#!/bin/bash
# twodim.sh: 模拟一个二维数组.

# 一维数组由单行组成.
# 二维数组由连续的多行组成.

Rows=5
Columns=5
# 5 X 5 的数组.

declare -a alpha		# char alpha [Rows] [Columns];
						# 没必要声明. 为什么?

load_alpha ()
{
	local rc=0
	local index

	for i in A B C D E F G H I J K L M N O P Q R S T U V W X Y
	do     # 你可以随你的心意, 使用任意符号.
	  local row=`expr $rc / $Columns`
	  local column=`expr $rc % $Rows`
	  let "index = $row * $Rows + $column"
	  alpha[$index]=$i
	# alpha[$row][$column]
	  let "rc += 1"
	done
	# 更简单的方法:
	#+   declare -a alpha=( A B C D E F G H I J K L M N O P Q R S T U V W X Y )
	#+ 但是如果写的话, 就缺乏二维数组的"风味"了.
}

print_alpha ()
{
	local row=0
	local index
	echo
	while [ "$row" -lt "$Rows" ]   #  以"行序为主"进行打印:
	do                             #+ 行号不变(外层循环),							
								   #+ 列号进行增长.
	  local column=0

	  echo -n "       "            #  按照行方向打印"正方形"数组.

	  while [ "$column" -lt "$Columns" ]
	  do
		let "index = $row * $Rows + $column"
		echo -n "${alpha[index]} "  # alpha[$row][$column]
		let "column += 1"
	  done

	  let "row += 1"
	  echo
	done
	# 更简单的等价写法为:
	#     echo ${alpha[*]} | xargs -n $Columns
	echo 
}

filter ()     # 过滤掉负的数组下标.
{

	echo -n "  "  # 产生倾斜.
				  # 解释一下, 这是怎么做到的.
	if [[ "$1" -ge 0 &&  "$1" -lt "$Rows" && "$2" -ge 0 && "$2" -lt "$Columns" ]]
	then
		let "index = $1 * $Rows + $2"
		# 现在, 按照旋转方向进行打印.
		echo -n " ${alpha[index]}"
		#           alpha[$row][$column]
	fi 

}

rotate ()  #  将数组旋转45度 --
{          #+ 从左下角进行"平衡".
	local row
	local column

	for (( row = Rows; row > -Rows; row-- ))
	  do       # 反向步进数组, 为什么?
	  
	  for (( column = 0; column < Columns; column++ ))
	  do

		if [ "$row" -ge 0 ]
		then
		  let "t1 = $column - $row"
		  let "t2 = $column"
		else
		  let "t1 = $column"
		  let "t2 = $column + $row"
		fi
		filter $t1 $t2			# 将负的数组下标过滤出来.
								# 如果你不做这一步, 将会怎样?
	  done
	  echo; echo

	done

#  数组旋转的灵感来源于Herbert Mayer 所著的
#+ "Advanced C Programming on the IBM PC"的例子(第143-146页)
#+ (参见参考书目).
#  由此可见, C语言能够做到的好多事情,
#+ 用shell 脚本一样能够做到.
}


#--------------- 现在, 让我们开始吧. ------------#
load_alpha			# 加载数组
print_alpha			# 打印数组.
rotate				# 逆时钟旋转45度打印.
#-----------------------------------------------------#

exit 0

# 这有点做作, 不是那么优雅.

# 练习:
# -----
#  1) 重新实现数组加载和打印函数,
#     让其更直观, 可读性更强. 
#
#  2) 详细地描述旋转函数的原理.
#     提示: 思考一下倒序索引数组的实现.
#
#  3) 重写这个脚本, 扩展它, 让不仅仅能够支持非正方形的数组.
#     比如6 X 4的数组.
#     尝试一下, 在数组旋转时, 做到最小"失真".
```

二维数组本质上其实就是一个一维数组, 只不过是添加了行和列的寻址方式, 来引用和操作数组的元素而已.

这里有一个精心制作的模拟二维数组的例子, 请参考[例子 A-10](http://tldp.org/LDP/abs/html/contributed-scripts.html#LIFESLOW).

-----

还有更多使用数组的有趣的脚本，请参考：

* [例子 12-3](http://tldp.org/LDP/abs/html/commandsub.html#AGRAM2)
* [例子 16-46](http://tldp.org/LDP/abs/html/mathc.html#PRIMES2)
* [例子 A-22](http://tldp.org/LDP/abs/html/contributed-scripts.html#HASHEX2)
* [例子 A-44](http://tldp.org/LDP/abs/html/contributed-scripts.html#HOMEWORK)
* [例子 A-41](http://tldp.org/LDP/abs/html/contributed-scripts.html#QKY)
* [例子 A-42](http://tldp.org/LDP/abs/html/contributed-scripts.html#NIM)